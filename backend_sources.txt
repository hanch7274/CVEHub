============================================================
File: /home/CVEHub/backend/app/auth/router.py
------------------------------------------------------------
"""
사용자 인증 및 관리 통합 API 라우터
"""
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from typing import List, Callable, Any, Awaitable
from beanie import PydanticObjectId
import functools

# 변경: 모델과 스키마 임포트 경로 수정
from .models import User, Token, UserResponse, RefreshTokenRequest, LogoutRequest, UserCreate, UserUpdate
# 변경: 통합된 service 파일에서 의존성 함수들 가져오기
from .service import UserService, get_current_user
from ..core.dependencies import get_user_service
import logging
import traceback

# 라우터 및 로거 초기화
router = APIRouter()
logger = logging.getLogger(__name__)

# ----- 에러 핸들링 데코레이터 -----

def auth_api_error_handler(func: Callable[..., Awaitable[Any]]) -> Callable[..., Awaitable[Any]]:
    """인증 API 예외 처리 데코레이터
    
    모든 인증 관련 엔드포인트의 공통 예외 처리 로직을 중앙화합니다.
    """
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except HTTPException:
            # FastAPI HTTP 예외는 그대로 전달
            raise
        except ValueError as val_exc:
            # 검증 오류 (400 Bad Request)
            endpoint = func.__name__
            logger.warning(f"{endpoint} 중 검증 오류 발생: {str(val_exc)}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(val_exc)
            )
        except Exception as e:
            # 일반 예외는 서버 오류로 처리
            endpoint = func.__name__
            logger.error(f"Error in {endpoint}: {str(e)}")
            logger.error(traceback.format_exc())
            
            # 인증 관련 엔드포인트인 경우 인증 헤더 추가
            headers = {}
            if endpoint in ["login_for_access_token", "refresh_access_token"]:
                headers["WWW-Authenticate"] = "Bearer"
                
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"{endpoint} 중 오류가 발생했습니다: {str(e)}",
                headers=headers
            )
    
    return wrapper

# ----- 인증 관련 API 엔드포인트 -----

@router.post("/token", response_model=Token)
@auth_api_error_handler
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    user_service: UserService = Depends(get_user_service)
):
    """
    로그인 및 토큰 발급
    
    - **username**: 사용자 이메일 (OAuth2 규약에 따라 username으로 받습니다)
    - **password**: 사용자 비밀번호
    """
    logger.info(f"로그인 시도: {form_data.username}")
    
    # 사용자 인증 및 토큰 발급
    token = await user_service.authenticate_user(form_data.username, form_data.password)
    if not token:
        logger.warning(f"로그인 실패: {form_data.username}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="이메일 또는 비밀번호가 올바르지 않습니다",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    logger.info(f"로그인 성공: {form_data.username}")
    return token

@router.post("/refresh", response_model=Token)
@auth_api_error_handler
async def refresh_access_token(
    refresh_request: RefreshTokenRequest,
    user_service: UserService = Depends(get_user_service)
):
    """
    토큰 갱신
    
    - **refresh_token**: 리프레시 토큰
    """
    logger.info("토큰 갱신 요청")
    logger.debug(f"리프레시 토큰: {refresh_request.refresh_token[:10]}...")
    
    # 리프레시 토큰 검증
    user = await user_service.verify_refresh_token(refresh_request.refresh_token)
    if not user:
        logger.warning("유효하지 않은 리프레시 토큰")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="유효하지 않은 리프레시 토큰입니다",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 기존 리프레시 토큰 무효화
    await user_service.revoke_refresh_token(refresh_request.refresh_token)
    
    # 새로운 액세스 토큰 생성
    access_token = user_service._create_access_token(
        data={
            "sub": user.id,
            "email": user.email
        }
    )
    
    # 새로운 리프레시 토큰 생성
    new_refresh_token, _ = await user_service._create_refresh_token(user.id)
    
    logger.info(f"토큰 갱신 성공: {user.email}")
    
    return Token(
        access_token=access_token,
        refresh_token=new_refresh_token,
        token_type="bearer",
        user=user
    )

@router.post("/logout")
@auth_api_error_handler
async def logout(
    logout_request: LogoutRequest,
    user_service: UserService = Depends(get_user_service)
):
    """
    로그아웃
    
    - **refresh_token**: 무효화할 리프레시 토큰
    """
    logger.info("로그아웃 요청")
    
    success = await user_service.revoke_refresh_token(logout_request.refresh_token)
    if success:
        logger.info("로그아웃 성공")
        return {"message": "성공적으로 로그아웃되었습니다"}
    else:
        logger.warning("로그아웃 실패: 토큰을 찾을 수 없음")
        return {"message": "로그아웃 처리되었습니다"}

# ----- 사용자 관리 API 엔드포인트 -----

@router.post("/signup", response_model=Token)
@auth_api_error_handler
async def signup_user(
    user_data: UserCreate,
    user_service: UserService = Depends(get_user_service)
):
    """
    새로운 사용자를 등록하고 자동으로 로그인합니다.
    
    - **user_data**: 사용자 등록 정보
    """
    logger.info(f"사용자 등록 요청: {user_data.username}, {user_data.email}")
    
    # 사용자 생성
    user = await user_service.create_user(user_data)
    if not user:
        logger.error("사용자 생성 실패")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="사용자 생성에 실패했습니다"
        )
    
    # 액세스 토큰 생성
    access_token = user_service._create_access_token(
        data={
            "sub": user.id,
            "email": user.email
        }
    )
    
    # 리프레시 토큰 생성
    refresh_token, _ = await user_service._create_refresh_token(user.id)
    
    logger.info(f"사용자 등록 성공: {user.username}, {user.email}")
    
    return Token(
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer",
        user=user
    )

@router.get("/me", response_model=UserResponse)
@auth_api_error_handler
async def get_current_user_info(current_user: User = Depends(get_current_user)):
    """
    현재 인증된 사용자의 정보를 반환합니다.
    """
    logger.info(f"현재 사용자 정보 요청: {current_user.username}")
    
    return UserResponse(
        id=str(current_user.id),
        username=current_user.username,
        email=current_user.email,
        is_admin=current_user.is_admin,
        is_active=current_user.is_active,
        created_at=current_user.created_at,
        last_modified_at=current_user.last_modified_at
    )

@router.patch("/me")
@auth_api_error_handler
async def update_current_user(
    user_data: UserUpdate,
    current_user: User = Depends(get_current_user),
    user_service: UserService = Depends(get_user_service)
):
    """현재 로그인한 사용자의 정보를 수정합니다."""
    logger.info(f"사용자 {current_user.username} 정보 수정 요청")
    user = await user_service.update_user(current_user.id, user_data)
    if not user:
        logger.error(f"사용자 {current_user.username} 정보 수정 실패: 사용자를 찾을 수 없음")
        raise HTTPException(status_code=404, detail="사용자를 찾을 수 없습니다.")
    logger.info(f"사용자 {current_user.username} 정보 수정 성공")
    return user

@router.delete("/me")
@auth_api_error_handler
async def delete_current_user(
    current_user: User = Depends(get_current_user),
    user_service: UserService = Depends(get_user_service)
):
    """현재 로그인한 사용자의 계정을 삭제합니다."""
    logger.info(f"사용자 {current_user.username} 계정 삭제 요청")
    success = await user_service.delete_user(current_user.id)
    if not success:
        logger.error(f"사용자 {current_user.username} 계정 삭제 실패: 사용자를 찾을 수 없음")
        raise HTTPException(status_code=404, detail="사용자를 찾을 수 없습니다.")
    logger.info(f"사용자 {current_user.username} 계정 삭제 성공")
    return {"message": "사용자 계정이 삭제되었습니다."}

@router.get("/search", response_model=List[dict])
@auth_api_error_handler
async def search_users(
    query: str = "",
    current_user: User = Depends(get_current_user)
):
    """사용자 검색 API - 멘션 자동완성을 위해 사용됩니다."""
    logger.info("=== 사용자 검색 API 호출 ===")
    logger.info(f"검색어: {query}")
    logger.info(f"현재 사용자: {current_user.username}")
    
    # 쿼리에서 @ 기호 제거
    clean_query = query.replace("@", "").strip()
    logger.info(f"정제된 검색어: {clean_query}")
    
    # 빈 쿼리이거나 '@'만 입력된 경우 모든 사용자 반환
    if not clean_query:
        users = await User.find(
            {"username": {"$ne": current_user.username}}
        ).sort("username").limit(10).to_list()
    else:
        users = await User.find(
            {
                "username": {
                    "$regex": f"^{clean_query}", 
                    "$options": "i",
                    "$ne": current_user.username
                }
            }
        ).sort("username").limit(10).to_list()
    
    logger.info(f"검색 결과: {len(users)}명의 사용자 찾음")
    result = [
        {
            "username": user.username,
            "displayName": user.username
        } 
        for user in users
    ]
    logger.debug(f"반환할 사용자 목록: {result}")
    return result

@router.get("/", response_model=List[dict])
@auth_api_error_handler
async def get_users(current_user: User = Depends(get_current_user)):
    """등록된 모든 사용자 목록을 반환합니다."""
    logger.info("=== 전체 사용자 목록 조회 API 호출 ===")
    logger.info(f"요청 사용자: {current_user.username}")
    
    # beanie를 사용하여 모든 사용자 조회
    users = await User.find_all().to_list()
    user_list = [{"username": user.username, "email": user.email} for user in users]
    
    logger.info(f"총 {len(user_list)}명의 사용자 조회됨")
    return user_list


============================================================
File: /home/CVEHub/backend/app/auth/models.py
------------------------------------------------------------
"""
사용자 인증 관련 모델 정의
"""
from typing import Optional, Dict, Any
from pydantic import Field, EmailStr
from beanie import PydanticObjectId
from datetime import datetime
from zoneinfo import ZoneInfo

from app.common.models.base_models import BaseSchema, TimestampMixin, UserBaseMixin, BaseDocument


# Pydantic 모델: API 요청/응답용 스키마
class UserBase(UserBaseMixin, BaseSchema):
    """사용자 기본 모델"""
    pass


class UserCreate(UserBase):
    """사용자 생성 요청 모델"""
    password: str

    class Config:
        json_schema_extra = {
            "example": {
                "username": "johndoe",
                "email": "johndoe@example.com",
                "password": "password123",
                "is_active": True,
                "is_admin": False
            }
        }


class UserUpdate(BaseSchema):
    """사용자 정보 수정 요청 모델"""
    email: Optional[EmailStr] = None
    full_name: Optional[str] = None
    is_active: Optional[bool] = None
    is_admin: Optional[bool] = None
    password: Optional[str] = None

    class Config:
        json_schema_extra = {
            "example": {
                "email": "johndoe-updated@example.com",
                "full_name": "John Doe Updated",
                "is_active": True,
                "is_admin": False,
                "password": "newpassword123"
            }
        }


class UserResponse(UserBase, TimestampMixin):
    """사용자 정보 응답 모델"""
    id: str
    full_name: Optional[str] = None

    class Config:
        json_schema_extra = {
            "example": {
                "id": "507f1f77bcf86cd799439011",
                "username": "johndoe",
                "email": "johndoe@example.com",
                "full_name": "John Doe",
                "is_active": True,
                "is_admin": False,
                "created_at": "2023-01-01T00:00:00Z",
                "last_modified_at": "2023-01-01T00:00:00Z"
            }
        }


class UserInDB(UserBase):
    """데이터베이스 사용자 모델 (내부용)"""
    id: str
    hashed_password: str
    full_name: Optional[str] = None
    created_at: datetime
    last_modified_at: datetime


class UserSearchResponse(BaseSchema):
    """사용자 검색 응답 모델"""
    username: str
    displayName: str

    class Config:
        json_schema_extra = {
            "example": {
                "username": "johndoe",
                "displayName": "John Doe"
            }
        }


# 인증 관련 모델
class TokenData(BaseSchema):
    """토큰 데이터 모델"""
    sub: Optional[str] = None
    email: Optional[str] = None
    token_type: Optional[str] = None
    exp: Optional[int] = None


class Token(BaseSchema):
    """토큰 응답 모델"""
    access_token: str
    refresh_token: str
    token_type: str
    user: UserResponse

    class Config:
        json_schema_extra = {
            "example": {
                "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                "token_type": "bearer",
                "user": {
                    "id": "507f1f77bcf86cd799439011",
                    "username": "johndoe",
                    "email": "johndoe@example.com",
                    "is_active": True,
                    "is_admin": False
                }
            }
        }


class RefreshTokenRequest(BaseSchema):
    """리프레시 토큰 요청 모델"""
    refresh_token: str

    class Config:
        json_schema_extra = {
            "example": {
                "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
            }
        }


class LoginRequest(BaseSchema):
    """로그인 요청 모델"""
    username: str
    password: str

    class Config:
        json_schema_extra = {
            "example": {
                "username": "johndoe@example.com",
                "password": "password123"
            }
        }


class LogoutRequest(BaseSchema):
    """로그아웃 요청 모델"""
    refresh_token: str

    class Config:
        json_schema_extra = {
            "example": {
                "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
            }
        }


# Beanie Document 모델: 데이터베이스용 모델
class User(BaseDocument):
    """사용자 문서 모델"""
    username: str
    email: EmailStr
    hashed_password: str
    full_name: Optional[str] = None
    is_active: bool = True
    is_admin: bool = False
    
    class Settings:
        name = "users"
        indexes = [
            "username",
            "email",
        ]

    @property
    def is_authenticated(self) -> bool:
        """사용자 인증 여부"""
        return True if self.is_active else False

    def to_dict(self) -> Dict[str, Any]:
        """User 객체를 dictionary로 변환"""
        return {
            "id": str(self.id),
            "username": self.username,
            "email": self.email,
            "full_name": self.full_name,
            "is_active": self.is_active,
            "is_admin": self.is_admin,
            "created_at": self.created_at,
            "last_modified_at": self.last_modified_at
        }


class RefreshToken(BaseDocument):
    """리프레시 토큰 문서 모델"""
    user_id: PydanticObjectId
    token: str
    expires_at: datetime
    is_revoked: bool = False
    
    class Settings:
        name = "refresh_tokens"
        indexes = [
            "user_id",
            "token",
            "expires_at"
        ]


============================================================
File: /home/CVEHub/backend/app/auth/service.py
------------------------------------------------------------
# service.py

import logging
import json
import secrets
import traceback
from typing import Optional, List, Dict, Any, Tuple
from datetime import datetime, timedelta

from beanie import PydanticObjectId
from bson import ObjectId
from passlib.context import CryptContext
from jose import jwt, JWTError
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer

# Local imports (경로는 실제 프로젝트 구조에 맞게 조정하세요)
from .models import User, RefreshToken, TokenData, UserCreate, UserUpdate, UserResponse, Token

from ..core.config import get_settings


# --- FastAPI 의존성 관련 설정 ---
# tokenUrl은 실제 API 엔드포인트 경로에 맞게 수정해야 합니다.
# 예: "api/v1/auth/token" 또는 "/auth/token" 등
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/token") 
settings = get_settings()
logger = logging.getLogger(__name__)

class UserService:
    """사용자 및 인증 관련 서비스"""

    def __init__(self, socket_manager=None):
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        self.settings = get_settings() # settings는 전역 변수로도 접근 가능하지만, 명시적으로 주입
        self.logger = logging.getLogger(__name__) # logger는 전역 변수로도 접근 가능
        self._socket_manager = socket_manager

    # --- Password Handling ---
    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """비밀번호 검증"""
        return self.pwd_context.verify(plain_password, hashed_password)

    def get_password_hash(self, password: str) -> str:
        """비밀번호 해싱"""
        return self.pwd_context.hash(password)

    # --- Authentication ---
    async def authenticate_user(self, email: str, password: str) -> Optional[Token]:
        """사용자 인증 (이메일 기반) 및 토큰 발급"""
        self.logger.info(f"사용자 인증 시도: {email}")
        try:
            user = await User.find_one({"email": email})
            if not user:
                self.logger.warning(f"인증 실패: 사용자 없음 - {email}")
                return None

            if not self.verify_password(password, user.hashed_password):
                self.logger.warning(f"인증 실패: 잘못된 비밀번호 - {email}")
                return None

            if not user.is_active:
                self.logger.warning(f"인증 실패: 비활성화된 계정 - {email}")
                # 필요시 명시적 에러 처리 또는 None 반환 유지
                # raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
                return None

            # 액세스 토큰 생성
            access_token = self._create_access_token(
                data={"sub": str(user.id), "email": user.email}
            )

            # 리프레시 토큰 생성 및 저장
            refresh_token, _ = await self._create_refresh_token(str(user.id))

            user_response = self._map_user_to_response(user)

            self.logger.info(f"사용자 인증 성공: {email}")

            return Token(
                access_token=access_token,
                refresh_token=refresh_token,
                token_type="bearer",
                user=user_response
            )
        except Exception as e:
            self.logger.error(f"사용자 인증 중 오류 발생: {str(e)}")
            raise # 에러를 다시 발생시켜 상위 핸들러가 처리하도록 함

    # --- User CRUD ---
    async def create_user(self, user_data: UserCreate) -> Optional[UserResponse]:
        """새로운 사용자 생성"""
        self.logger.info(f"새 사용자 생성 시도: {user_data.username}, {user_data.email}")
        try:
            if await User.find_one({"username": user_data.username}):
                self.logger.warning(f"사용자 생성 실패: 이미 존재하는 사용자명 - {user_data.username}")
                raise ValueError("Username already registered")

            if await User.find_one({"email": user_data.email}):
                self.logger.warning(f"사용자 생성 실패: 이미 존재하는 이메일 - {user_data.email}")
                raise ValueError("Email already registered")

            hashed_password = self.get_password_hash(user_data.password)
            now = datetime.utcnow()

            new_user = User(
                username=user_data.username,
                email=user_data.email,
                hashed_password=hashed_password,
                is_admin=getattr(user_data, 'is_admin', False),
                is_active=True, # 기본값 활성
                created_at=now,
                last_modified_at=now
            )
            await new_user.save()
            self.logger.info(f"새 사용자 생성 성공: {new_user.username}, {new_user.email}")

            return self._map_user_to_response(new_user)
        except ValueError as ve: # 중복 에러는 그대로 전달
             raise ve
        except Exception as e:
            self.logger.error(f"사용자 생성 중 오류 발생: {str(e)}")
            raise # 다른 에러는 다시 발생

    async def get_user_by_id(self, user_id: str) -> Optional[UserResponse]:
        """사용자 ID로 사용자 조회"""
        self.logger.debug(f"ID로 사용자 조회: {user_id}")
        try:
            user = await User.get(user_id) # Beanie의 get 메서드 활용
            if user:
                 self.logger.debug(f"사용자 조회 성공 (ID): {user_id}")
                 return self._map_user_to_response(user)
            else:
                 self.logger.info(f"사용자 조회 실패: 사용자 없음 (ID) - {user_id}")
                 return None
        except Exception as e:
            # ObjectId 변환 오류 등 처리
            if "Argument is not a valid ObjectId" in str(e):
                 self.logger.warning(f"잘못된 사용자 ID 형식: {user_id}")
                 return None
            self.logger.error(f"ID로 사용자 조회 중 오류: {str(e)}")
            raise

    async def get_user_by_username(self, username: str) -> Optional[UserResponse]:
        """사용자명으로 사용자 조회"""
        self.logger.info(f"사용자명으로 사용자 조회: {username}")
        try:
            user = await User.find_one({"username": username})
            if user:
                self.logger.info(f"사용자 조회 성공 (Username): {username}")
                return self._map_user_to_response(user)
            else:
                self.logger.info(f"사용자 조회 실패: 사용자 없음 (Username) - {username}")
                return None
        except Exception as e:
            self.logger.error(f"사용자명으로 조회 중 오류 발생: {str(e)}")
            raise

    async def get_user_by_email(self, email: str) -> Optional[UserResponse]:
        """이메일로 사용자 조회"""
        self.logger.info(f"이메일로 사용자 조회: {email}")
        try:
            user = await User.find_one({"email": email})
            if user:
                 self.logger.info(f"사용자 조회 성공 (Email): {email}")
                 return self._map_user_to_response(user)
            else:
                 self.logger.info(f"사용자 조회 실패: 사용자 없음 (Email) - {email}")
                 return None
        except Exception as e:
            self.logger.error(f"이메일로 조회 중 오류 발생: {str(e)}")
            raise

    async def update_user(self, user_id: str, user_data: UserUpdate) -> Optional[UserResponse]:
        """사용자 정보 수정"""
        self.logger.info(f"사용자 정보 수정 시도: {user_id}")
        self.logger.debug(f"수정 데이터: {json.dumps(user_data.dict(exclude_unset=True))}")
        try:
            user = await User.get(user_id)
            if not user:
                self.logger.warning(f"사용자 정보 수정 실패: 사용자 없음 - {user_id}")
                return None

            update_data = user_data.dict(exclude_unset=True)

            # 사용자명 또는 이메일 변경 시 중복 확인
            if "username" in update_data and update_data["username"] != user.username:
                 if await User.find_one({"username": update_data["username"], "_id": {"$ne": user.id}}):
                     raise ValueError("Username already registered by another user")
            if "email" in update_data and update_data["email"] != user.email:
                 if await User.find_one({"email": update_data["email"], "_id": {"$ne": user.id}}):
                     raise ValueError("Email already registered by another user")

            if "password" in update_data:
                update_data["hashed_password"] = self.get_password_hash(update_data.pop("password"))

            update_data["last_modified_at"] = datetime.utcnow()

            await user.update({"$set": update_data})

            # 업데이트된 사용자 정보 다시 로드 (update 후 user 객체가 자동으로 갱신되지 않을 수 있음)
            updated_user = await User.get(user_id)
            self.logger.info(f"사용자 정보 수정 성공: {user_id}")
            return self._map_user_to_response(updated_user)

        except ValueError as ve: # 중복 에러는 그대로 전달
             raise ve
        except Exception as e:
            self.logger.error(f"사용자 정보 수정 중 오류 발생: {str(e)}")
            raise

    async def delete_user(self, user_id: str) -> bool:
        """사용자 삭제"""
        self.logger.info(f"사용자 삭제 시도: {user_id}")
        try:
            user = await User.get(user_id)
            if not user:
                self.logger.warning(f"사용자 삭제 실패: 사용자 없음 - {user_id}")
                return False

            # 연결된 리프레시 토큰 삭제
            await RefreshToken.find({"user_id": PydanticObjectId(user_id)}).delete()
            # 사용자 삭제
            await user.delete()

            self.logger.info(f"사용자 삭제 성공: {user_id}")
            return True
        except Exception as e:
            self.logger.error(f"사용자 삭제 중 오류 발생: {str(e)}")
            raise

    async def search_users(self, query: str, current_user_id: str, limit: int = 10) -> List[Dict[str, str]]:
        """사용자 검색 (자동완성용)"""
        self.logger.info(f"사용자 검색: {query}")
        try:
            clean_query = query.replace("@", "").strip()
            self.logger.debug(f"정리된 쿼리: {clean_query}")

            # 현재 사용자는 제외
            filter_query = {"_id": {"$ne": PydanticObjectId(current_user_id)}}

            if clean_query:
                # 사용자명 또는 이메일 시작 부분 일치 (대소문자 구분 없음)
                 filter_query["$or"] = [
                     {"username": {"$regex": f"^{clean_query}", "$options": "i"}},
                     {"email": {"$regex": f"^{clean_query}", "$options": "i"}}
                 ]
            # else: 빈 쿼리면 모든 사용자 (현재 사용자 제외)

            users = await User.find(filter_query).sort("username").limit(limit).to_list()
            self.logger.info(f"검색 결과: {len(users)}명의 사용자 발견")

            result = [{"username": user.username, "displayName": user.username} for user in users]
            return result
        except Exception as e:
            self.logger.error(f"사용자 검색 중 오류 발생: {str(e)}")
            raise

    async def get_all_users(self) -> List[UserResponse]:
        """모든 사용자 목록 조회"""
        self.logger.info("모든 사용자 목록 조회")
        try:
            users = await User.find_all().to_list()
            self.logger.info(f"조회된 사용자 수: {len(users)}")
            return [self._map_user_to_response(user) for user in users]
        except Exception as e:
            self.logger.error(f"사용자 목록 조회 중 오류 발생: {str(e)}")
            raise

    # --- Token Handling (Internal) ---
    def _create_access_token(self, data: dict, expires_delta: Optional[timedelta] = None) -> str:
        """액세스 토큰 생성"""
        to_encode = data.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=self.settings.ACCESS_TOKEN_EXPIRE_MINUTES)

        to_encode.update({
            "exp": expire,
            "type": "access" # 토큰 타입 명시
        })
        encoded_jwt = jwt.encode(
            to_encode, self.settings.SECRET_KEY, algorithm=self.settings.ALGORITHM
        )
        return encoded_jwt

    async def _create_refresh_token(self, user_id: str) -> tuple[str, datetime]:
        """리프레시 토큰 생성 및 저장"""
        self.logger.debug(f"리프레시 토큰 생성: 사용자 ID {user_id}")
        expires_at = datetime.utcnow() + self.settings.REFRESH_TOKEN_EXPIRE_DELTA
        token = secrets.token_urlsafe(32)

        refresh_token_doc = RefreshToken(
            user_id=PydanticObjectId(user_id),
            token=token,
            expires_at=expires_at,
            is_revoked=False, # 기본값 false
            created_at=datetime.utcnow()
        )
        await refresh_token_doc.insert()
        self.logger.debug(f"리프레시 토큰 생성 완료: {token[:10]}... (만료: {expires_at})")
        return token, expires_at

    async def verify_refresh_token(self, token: str) -> Optional[UserResponse]:
        """리프레시 토큰 검증 및 사용자 정보 반환"""
        self.logger.debug(f"리프레시 토큰 검증: {token[:10]}...")
        try:
            refresh_token_doc = await RefreshToken.find_one({
                "token": token,
                "is_revoked": False,
                "expires_at": {"$gt": datetime.utcnow()}
            })

            if not refresh_token_doc:
                self.logger.warning("유효하지 않은 리프레시 토큰 또는 만료/폐기됨")
                return None

            user = await User.get(refresh_token_doc.user_id)
            if not user or not user.is_active:
                self.logger.warning(f"토큰에 해당하는 사용자 없음 또는 비활성: {refresh_token_doc.user_id}")
                # 토큰 유출 가능성? 해당 토큰 폐기 고려
                # await self.revoke_refresh_token(token) # 필요시 주석 해제
                return None

            self.logger.debug(f"리프레시 토큰 검증 성공: 사용자 {user.email}")
            return self._map_user_to_response(user)
        except Exception as e:
            self.logger.error(f"리프레시 토큰 검증 중 오류 발생: {str(e)}")
            raise

    async def revoke_refresh_token(self, token: str) -> bool:
        """리프레시 토큰 무효화"""
        self.logger.debug(f"리프레시 토큰 무효화 시도: {token[:10]}...")
        try:
            refresh_token_doc = await RefreshToken.find_one({"token": token})
            if not refresh_token_doc:
                self.logger.warning("무효화할 토큰을 찾을 수 없음")
                return False

            if refresh_token_doc.is_revoked:
                self.logger.debug("이미 무효화된 토큰")
                return True # 이미 처리됨

            refresh_token_doc.is_revoked = True
            refresh_token_doc.last_modified_at = datetime.utcnow() # 수정 시간 기록
            await refresh_token_doc.save()

            self.logger.debug("리프레시 토큰 무효화 성공")
            return True
        except Exception as e:
            self.logger.error(f"리프레시 토큰 무효화 중 오류 발생: {str(e)}")
            raise

    # --- Socket.IO Related ---
    async def get_user_by_session_id(self, sid: str) -> Optional[UserResponse]:
        """Socket.IO 세션 ID로 사용자 조회"""
        if self._socketio_manager is None:
            self.logger.error("socketio_manager가 설정되지 않았습니다.")
            return None
            
        self.logger.debug(f"Socket.IO 세션 ID로 사용자 조회: {sid}")
        try:
            user_id = self._socketio_manager.sid_to_user.get(sid)
            if not user_id:
                self.logger.info(f"Socket.IO 세션 ID({sid})에 해당하는 사용자 ID 없음")
                return None

            self.logger.debug(f"Socket.IO 세션 {sid}에 해당하는 사용자 ID 발견: {user_id}")
            # get_user_by_id 재사용
            return await self.get_user_by_id(user_id)

        except Exception as e:
            self.logger.error(f"Socket.IO 세션 ID로 사용자 조회 중 오류: {str(e)}")
            self.logger.error(traceback.format_exc())
            return None  # 오류 발생 시 None 반환

    # --- Helper Methods ---
    def _map_user_to_response(self, user: User) -> UserResponse:
        """User 모델 객체를 UserResponse 스키마로 변환"""
        return UserResponse(
            id=str(user.id),
            username=user.username,
            email=user.email,
            is_admin=user.is_admin,
            is_active=user.is_active,
            created_at=user.created_at,
            last_modified_at=user.last_modified_at
        )

    async def decode_access_token(self, token: str) -> Optional[TokenData]:
        """액세스 토큰 검증 및 페이로드 반환 (내부 및 외부 사용 가능)"""
        try:
            payload = jwt.decode(
                token,
                self.settings.SECRET_KEY,
                algorithms=[self.settings.ALGORITHM]
            )
            # 토큰 타입 확인 (선택 사항이지만 권장)
            token_type = payload.get("type")
            if token_type != "access":
                 self.logger.warning(f"잘못된 토큰 타입 수신: {token_type}")
                 return None

            email: Optional[str] = payload.get("email")
            user_id: Optional[str] = payload.get("sub") # 'sub' 클레임 사용

            if email is None or user_id is None:
                 self.logger.error("토큰에 필수 클레임(email, sub) 부족")
                 return None

            # 추가 검증: payload의 user_id와 email이 실제 DB와 일치하는지 등 (선택 사항)

            return TokenData(email=email, user_id=user_id) # 필요시 TokenData 스키마 확장

        except JWTError as e:
            self.logger.error(f"액세스 토큰 디코드 오류: {str(e)}")
            return None
        except Exception as e:
             self.logger.error(f"액세스 토큰 처리 중 예상치 못한 오류: {str(e)}")
             return None


# --- FastAPI Dependency Functions ---

# UserService 인스턴스 생성 (싱글톤처럼 사용하거나 요청마다 생성할 수 있음)
# FastAPI의 Depends를 활용하여 주입하는 것이 더 일반적이나, 여기서는 간단하게 전역 인스턴스 사용
user_service_instance = UserService()

async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    """현재 인증된 사용자 조회 (FastAPI 의존성)"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    token_data = await user_service_instance.decode_access_token(token)
    if not token_data or not token_data.email:
        logger.warning(f"토큰 검증 실패 또는 이메일 정보 없음: {token[:10]}...")
        raise credentials_exception

    # TokenData에 user_id도 포함하여 바로 ID로 조회하도록 개선 가능
    # user = await User.get(token_data.user_id)
    user = await User.find_one({"email": token_data.email}) # decode에서 email만 반환 시

    if user is None:
        logger.error(f"토큰의 이메일에 해당하는 사용자를 찾을 수 없음: {token_data.email}")
        raise credentials_exception

    if not user.is_active:
        logger.warning(f"비활성화된 사용자에 대한 접근 시도: {user.email}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")

    logger.debug(f"현재 사용자 확인됨: {user.email}")
    return user # FastAPI 경로 함수에서는 User 모델 직접 사용 가능

async def get_current_admin_user(current_user: User = Depends(get_current_user)) -> User:
    """현재 인증된 사용자가 관리자인지 확인 (FastAPI 의존성)"""
    if not current_user.is_admin:
        logger.warning(f"관리자 권한 없는 접근 시도: {current_user.email}")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="The user doesn't have enough privileges"
        )
    logger.debug(f"관리자 사용자 확인됨: {current_user.email}")
    return current_user

# --- Standalone Verification (Optional) ---

async def verify_token(token: str) -> Optional[User]:
    """
    토큰(액세스)을 검증하고 해당 사용자 모델 반환 (FastAPI 의존성 없이 사용 가능)
    주로 WebSocket 등 HTTP 요청 컨텍스트 외부에서 사용될 수 있음
    """
    logger.debug(f"Standalone 토큰 검증 시도: {token[:10]}...")
    token_data = await user_service_instance.decode_access_token(token)

    if not token_data or not token_data.email:
         logger.warning("Standalone 토큰 검증 실패 또는 이메일 정보 없음")
         return None

    # User 모델 조회
    user = await User.find_one({"email": token_data.email})

    if user is None:
         logger.error(f"Standalone 검증: 이메일에 해당하는 사용자 없음 - {token_data.email}")
         return None

    if not user.is_active:
         logger.warning(f"Standalone 검증: 비활성화된 사용자 - {user.email}")
         return None # 비활성 사용자는 인증 실패로 간주

    logger.debug(f"Standalone 토큰 검증 성공: 사용자 {user.email}")
    return user


============================================================
File: /home/CVEHub/backend/app/common/utils/datetime_utils.py
------------------------------------------------------------
from datetime import datetime
from zoneinfo import ZoneInfo
from typing import List, Dict, Any, Optional, Union

def get_utc_now() -> datetime:
    """
    현재 UTC 시간을 datetime 객체로 반환합니다.
    백엔드의 모든 시간 관련 작업에 이 함수를 사용해야 합니다.
    
    Returns:
        datetime: 현재 UTC 시간 (tzinfo=UTC)
    """
    return datetime.now(ZoneInfo("UTC"))

def get_kst_now() -> datetime:
    """
    현재 KST(한국 표준시) 시간을 datetime 객체로 반환합니다.
    
    Returns:
        datetime: 현재 KST 시간 (tzinfo=Asia/Seoul)
    """
    now_utc = get_utc_now()
    return now_utc.astimezone(ZoneInfo("Asia/Seoul"))

def format_datetime(dt: datetime, timezone: Optional[str] = "Asia/Seoul", 
                   format_str: Optional[str] = "%Y-%m-%d %H:%M:%S") -> str:
    """
    datetime 객체를 지정된 타임존의 포맷팅된 문자열로 변환합니다.
    사용자 인터페이스에 표시되는 시간에 사용됩니다.
    
    Args:
        dt (datetime): 변환할 datetime 객체
        timezone (str, optional): 변환할 타임존. 기본값은 "Asia/Seoul"(KST)
        format_str (str, optional): 날짜/시간 포맷 문자열. 기본값은 "%Y-%m-%d %H:%M:%S"
    
    Returns:
        str: 지정된 포맷의 문자열
    """
    if dt is None:
        return ""
    
    # UTC 시간을 지정된 타임존으로 변환
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=ZoneInfo("UTC"))
    
    local_dt = dt.astimezone(ZoneInfo(timezone))
    return local_dt.strftime(format_str)

# 이전 버전과의 호환성을 위해 get_current_time 함수 유지
def get_current_time() -> datetime:
    """
    이전 버전과의 호환성을 위한 함수
    현재 UTC 시간을 반환합니다.
    
    Returns:
        datetime: 현재 UTC 시간
    """
    return get_utc_now()

def serialize_datetime(dt: datetime) -> str:
    """
    datetime 객체를 ISO 8601 형식의 문자열로 직렬화합니다.
    모든 API 응답에서 이 함수를 사용하여 일관성을 유지합니다.
    
    Args:
        dt (datetime): 변환할 datetime 객체
        
    Returns:
        str: ISO 8601 형식의 문자열 (예: "2025-03-28T06:34:01.123Z")
    """
    if dt is None:
        return None
        
    # UTC 시간으로 변환
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=ZoneInfo("UTC"))
    else:
        dt = dt.astimezone(ZoneInfo("UTC"))
        
    # ISO 8601 형식으로 직렬화
    return dt.isoformat().replace('+00:00', 'Z')

def normalize_datetime_fields(data: Dict[str, Any], 
                             fields: List[str] = ["created_at", "last_modified_at"]) -> Dict[str, Any]:
    """
    딕셔너리의 날짜 필드를 정규화합니다.
    
    Args:
        data: 처리할 딕셔너리 데이터
        fields: 날짜 필드 이름 목록. 기본값은 ["created_at", "last_modified_at"]
    
    Returns:
        Dict[str, Any]: 정규화된 날짜 필드가 포함된 딕셔너리
    """
    if not data:
        return data
    
    result = data.copy()
    current_time = get_utc_now()
    
    for field in fields:
        # 필드가 없거나 None인 경우 현재 시간으로 설정
        if field not in result or result[field] is None:
            result[field] = current_time
        # 문자열인 경우 datetime 객체로 변환 (이미 datetime이면 그대로 유지)
        elif isinstance(result[field], str):
            try:
                # ISO 형식 문자열을 datetime으로 파싱
                result[field] = datetime.fromisoformat(result[field])
            except ValueError:
                # 파싱 실패 시 현재 시간 사용
                result[field] = current_time
        
        # 시간대 정보가 없는 경우 UTC로 설정
        if isinstance(result[field], datetime) and result[field].tzinfo is None:
            result[field] = result[field].replace(tzinfo=ZoneInfo("UTC"))
    
    return result



============================================================
File: /home/CVEHub/backend/app/common/utils/change_detection.py
------------------------------------------------------------
"""
객체 변경 사항 감지 유틸리티
"""
from typing import List, Dict, Any, Optional, Union
from datetime import datetime

from app.common.models.base_models import ChangeLogBase

def detect_object_changes(old_obj: Any, new_obj: Any, ignore_fields: Optional[List[str]] = None) -> List[ChangeLogBase]:
    """
    두 객체 간의 변경 사항을 감지하고 ChangeLogBase 목록을 반환합니다.
    
    Args:
        old_obj: 변경 전 객체
        new_obj: 변경 후 객체
        ignore_fields: 무시할 필드 목록 (기본값: ["last_modified_at", "last_modified_by"])
        
    Returns:
        변경 사항 목록
    """
    if ignore_fields is None:
        ignore_fields = ["last_modified_at", "last_modified_by"]
        
    changes = []
    
    # Pydantic 모델이나 Document 객체 처리
    if hasattr(old_obj, 'dict') and hasattr(new_obj, 'dict'):
        old_dict = old_obj.dict()
        new_dict = new_obj.dict()
    else:
        old_dict = old_obj if isinstance(old_obj, dict) else {}
        new_dict = new_obj if isinstance(new_obj, dict) else {}
    
    # 필드 이름 매핑 (한글명 또는 사용자 친화적 이름)
    field_name_mapping = {
        "title": "제목",
        "description": "설명",
        "status": "상태",
        "assigned_to": "담당자",
        "severity": "심각도",
        "pocs": "PoC",
        "snort_rules": "Snort 규칙",
        "references": "참조 문서",
        "username": "사용자명",
        "email": "이메일",
        "is_active": "활성 상태",
        "is_admin": "관리자 여부",
        "full_name": "이름",
        "comment": "댓글",
        # 필요한 필드 추가
    }
    
    # 모든 키 수집
    all_keys = set(old_dict.keys()) | set(new_dict.keys())
    
    current_user = "system"  # 실제 구현에서는 현재 인증된 사용자 정보를 가져와야 함
    
    # 각 키에 대해 변경 사항 확인
    for key in all_keys:
        if key in ignore_fields:
            continue
            
        # 필드 한글명 가져오기
        field_display = field_name_mapping.get(key, key)
        
        if key not in old_dict and key in new_dict:
            # 새로 추가된 필드
            changes.append(ChangeLogBase(
                field=key,
                action="add",
                user=current_user,
                new_value=new_dict[key],
                summary=f"{field_display} 추가됨"
            ))
        elif key in old_dict and key not in new_dict:
            # 삭제된 필드
            changes.append(ChangeLogBase(
                field=key,
                action="delete",
                user=current_user,
                old_value=old_dict[key],
                summary=f"{field_display} 삭제됨"
            ))
        elif key in old_dict and key in new_dict and old_dict[key] != new_dict[key]:
            # 컬렉션 타입 필드 특별 처리
            if isinstance(old_dict[key], list) and isinstance(new_dict[key], list):
                collection_changes = detect_collection_changes(old_dict[key], new_dict[key])
                if collection_changes["added"] or collection_changes["removed"] or collection_changes["modified"]:
                    summary = f"{field_display} "
                    details = []
                    
                    if collection_changes["added"]:
                        details.append(f"{len(collection_changes['added'])}개 추가")
                    if collection_changes["removed"]:
                        details.append(f"{len(collection_changes['removed'])}개 삭제")
                    if collection_changes["modified"]:
                        details.append(f"{len(collection_changes['modified'])}개 수정")
                        
                    summary += ", ".join(details)
                    
                    changes.append(ChangeLogBase(
                        field=key,
                        action="edit",
                        user=current_user,
                        old_value=old_dict[key],
                        new_value=new_dict[key],
                        summary=summary
                    ))
            else:
                # 일반 필드 변경
                old_value = old_dict[key]
                new_value = new_dict[key]
                
                # 간단한 값 표시를 위한 처리
                old_display = str(old_value)[:100] if old_value is not None else "없음"
                new_display = str(new_value)[:100] if new_value is not None else "없음"
                
                if len(old_display) == 100:
                    old_display += "..."
                if len(new_display) == 100:
                    new_display += "..."
                
                changes.append(ChangeLogBase(
                    field=key,
                    action="edit",
                    user=current_user,
                    old_value=old_value,
                    new_value=new_value,
                    summary=f"{field_display} 변경: '{old_display}' → '{new_display}'"
                ))
    
    return changes


def detect_collection_changes(old_collection: List, new_collection: List, id_field: str = "id") -> Dict[str, Any]:
    """
    컬렉션 타입(리스트)의 변경 사항을 감지합니다.
    
    Args:
        old_collection: 변경 전 컬렉션
        new_collection: 변경 후 컬렉션
        id_field: 객체 식별을 위한 ID 필드명
        
    Returns:
        추가, 삭제, 수정된 항목 목록을 포함하는 사전
    """
    if not old_collection:
        old_collection = []
    if not new_collection:
        new_collection = []
        
    # ID 기준으로 항목 인덱싱
    old_items = {}
    new_items = {}
    
    for i, item in enumerate(old_collection):
        item_id = item.get(id_field, i) if isinstance(item, dict) else i
        old_items[item_id] = item
        
    for i, item in enumerate(new_collection):
        item_id = item.get(id_field, i) if isinstance(item, dict) else i
        new_items[item_id] = item
    
    # 변경 사항 계산
    added_ids = set(new_items.keys()) - set(old_items.keys())
    removed_ids = set(old_items.keys()) - set(new_items.keys())
    common_ids = set(old_items.keys()) & set(new_items.keys())
    
    # 수정된 항목 찾기
    modified_ids = [id for id in common_ids if old_items[id] != new_items[id]]
    
    return {
        "added": [new_items[id] for id in added_ids],
        "removed": [old_items[id] for id in removed_ids],
        "modified": [(old_items[id], new_items[id]) for id in modified_ids]
    }


============================================================
File: /home/CVEHub/backend/app/common/utils/init.py
------------------------------------------------------------
"""
공통 유틸리티 패키지
"""
from app.common.utils.change_detection import detect_object_changes, detect_collection_changes

__all__ = [
    'detect_object_changes',
    'detect_collection_changes'
]


============================================================
File: /home/CVEHub/backend/app/common/repositories/base.py
------------------------------------------------------------
from typing import Generic, TypeVar, Optional, List, Type
from beanie import Document
from pydantic import BaseModel
from app.database import get_database

ModelType = TypeVar("ModelType", bound=Document)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)

class BaseRepository(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
    def __init__(self, model: Type[ModelType]):
        self.model = model
        self.db = get_database()

    async def get(self, id: str) -> Optional[ModelType]:
        """ID로 단일 문서를 조회합니다."""
        return await self.model.get(id)

    async def get_by_field(self, field: str, value: any) -> Optional[ModelType]:
        """특정 필드 값으로 단일 문서를 조회합니다."""
        return await self.model.find_one({field: value})

    async def get_all(self, skip: int = 0, limit: int = 10) -> List[ModelType]:
        """모든 객체를 조회합니다."""
        return await self.model.find().skip(skip).limit(limit).to_list()

    async def create(self, data):
        """새로운 객체를 생성합니다."""
        # Pydantic 모델인 경우 dict()를 호출하고, dictionary인 경우 그대로 사용
        if hasattr(data, 'dict'):
            data = data.dict()
        obj = self.model(**data)
        await obj.insert()
        return obj

    async def update(self, obj):
        """객체를 업데이트합니다."""
        await obj.save()
        return obj

    async def delete(self, id: str) -> bool:
        """객체를 삭제합니다."""
        obj = await self.get(id)
        if obj:
            await obj.delete()
            return True
        return False

    async def count(self, filter_query=None) -> int:
        """객체의 수를 반환합니다."""
        if filter_query:
            return await self.model.find(filter_query).count()
        return await self.model.find().count()

    async def update_one(self, filter_query: dict, update_data: dict) -> Optional[ModelType]:
        """필터 조건에 맞는 단일 문서를 업데이트합니다."""
        result = await self.model.find_one(filter_query)
        if result:
            # $set 연산자가 있는 경우와 없는 경우를 모두 처리
            if "$set" in update_data:
                await result.update(update_data)
            else:
                await result.update({"$set": update_data})
            return result
        return None 


============================================================
File: /home/CVEHub/backend/app/common/models/init.py
------------------------------------------------------------
"""
공통 모델 패키지
"""
from app.common.models.base_models import (
    BaseSchema,
    TimestampMixin, 
    UserBaseMixin,
    BaseDocument,
    PaginatedResponse,
    APIResponse,
    ChangeLogBase
)

__all__ = [
    'BaseSchema',
    'TimestampMixin',
    'UserBaseMixin',
    'BaseDocument',
    'PaginatedResponse',
    'APIResponse',
    'ChangeLogBase'
]


============================================================
File: /home/CVEHub/backend/app/common/models/base_models.py
------------------------------------------------------------
"""
애플리케이션 전체에서 공유하는 기본 모델 정의
"""
from typing import Optional, List, Dict, Any, TypeVar, Generic
from pydantic import BaseModel, EmailStr, Field
from datetime import datetime
from zoneinfo import ZoneInfo
from beanie import Document, PydanticObjectId

# 타입 변수 정의
T = TypeVar('T')

class BaseSchema(BaseModel):
    """모든 스키마의 기본이 되는 모델"""
    
    class Config:
        """Pydantic 설정"""
        from_attributes = True


class TimestampMixin(BaseModel):
    """생성 및 수정 시간 필드를 포함하는 믹스인"""
    created_at: Optional[datetime] = None
    last_modified_at: Optional[datetime] = None

    class Config:
        json_encoders = {
            datetime: lambda v: v.replace(tzinfo=ZoneInfo("UTC")).isoformat().replace('+00:00', 'Z') if v else None
        }


class UserBaseMixin(BaseModel):
    """사용자 기본 정보를 포함하는 믹스인"""
    username: str
    email: EmailStr
    is_active: bool = True
    is_admin: bool = False


class BaseDocument(Document):
    """모든 Document의 기본이 되는 모델"""
    created_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    last_modified_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    
    class Config:
        json_encoders = {
            # MongoDB에서 가져온 시간을 그대로 유지하면서 UTC로 표시
            datetime: lambda v: v.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + 'Z' if v else None,
            PydanticObjectId: str
        }


class PaginatedResponse(BaseSchema, Generic[T]):
    """페이지네이션된 응답의 표준 형식"""
    items: List[T]
    total: int
    page: int = 1
    limit: int = 10


class APIResponse(BaseSchema, Generic[T]):
    """표준 API 응답 형식"""
    success: bool = True
    message: Optional[str] = None
    data: Optional[T] = None


class ChangeLogBase(BaseSchema):
    """변경 로그 기본 클래스"""
    field: str
    action: str
    user: str
    timestamp: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    old_value: Optional[Any] = None
    new_value: Optional[Any] = None


============================================================
File: /home/CVEHub/backend/app/main.py
------------------------------------------------------------
"""메인 애플리케이션"""
from fastapi import FastAPI, Request, status, WebSocket
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from datetime import datetime
import json
import logging
import traceback
import sys
from beanie import init_beanie
from motor.motor_asyncio import AsyncIOMotorClient
import os
from zoneinfo import ZoneInfo

from app.core.config import get_settings
from app.socketio.router import router as socketio_router
from app.core.exceptions import CVEHubException
from app.core.error_handlers import (
    cvehub_exception_handler,
    validation_exception_handler,
    general_exception_handler,
    request_validation_exception_handler,
    http_exception_handler
)
from pydantic import ValidationError
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException
from fastapi.websockets import WebSocketDisconnect, WebSocketState
from app.system.models import SystemConfig
from .database import init_db, get_database
from app.cve.models import CVEModel, CreateCVERequest, PatchCVERequest
from app.api import api_router  # 새 위치에서 임포트
from app.core.scheduler import CrawlerScheduler

# 설정 초기화
settings = get_settings()
app = FastAPI()
app.include_router(api_router)

# 로깅 포맷터에 KST 시간대 적용
class KSTFormatter(logging.Formatter):
    def converter(self, timestamp):
        # 명시적으로 KST 시간대 사용
        dt = datetime.fromtimestamp(timestamp, ZoneInfo("Asia/Seoul"))
        return dt
        
    def formatTime(self, record, datefmt=None):
        dt = self.converter(record.created)
        if datefmt:
            return dt.strftime(datefmt)
        return dt.strftime("%Y-%m-%d %H:%M:%S %z")

# 루트 로거 설정
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',  
    handlers=[logging.StreamHandler(sys.stdout)]
)

# 모든 로거에 KST 포맷터 적용
kst_formatter = KSTFormatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
for handler in logging.root.handlers:
    handler.setFormatter(kst_formatter)

# 애플리케이션 로거 설정
logger = logging.getLogger(__name__)

app = FastAPI(
    title=settings.PROJECT_NAME,
    description="CVE 관리 및 모니터링을 위한 API",
    version=settings.VERSION,
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json"
)

# CORS 설정
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,  # config.py의 설정 사용
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 미들웨어 설정
@app.middleware("http")
async def logging_middleware(request: Request, call_next):
    """모든 요청과 응답을 로깅하는 미들웨어"""
    print(f"\n=== Request ===")
    print(f"Method: {request.method}")
    print(f"URL: {request.url}")
    
    try:
        response = await call_next(request)
        print(f"\n=== Response ===")
        print(f"Status: {response.status_code}")
        return response
    except Exception as e:
        print(f"\n=== Error ===")
        print(f"Error type: {type(e)}")
        print(f"Error message: {str(e)}")
        print(f"Traceback: {traceback.format_exc()}")
        return JSONResponse(
            status_code=500,
            content={"detail": "Internal server error"}
        )

@app.middleware("http")
async def catch_exceptions_middleware(request: Request, call_next):
    try:
        return await call_next(request)
    except Exception as e:
        logging.error(f"Exception occurred: {e}")
        logging.error(traceback.format_exc())
        return JSONResponse(
            status_code=500,
            content={"detail": str(e)}
        )

# 예외 처리기 등록
app.add_exception_handler(CVEHubException, cvehub_exception_handler)
app.add_exception_handler(ValidationError, validation_exception_handler)
app.add_exception_handler(Exception, general_exception_handler)
app.add_exception_handler(RequestValidationError, request_validation_exception_handler)
app.add_exception_handler(HTTPException, http_exception_handler)

# API 라우터 등록
app.include_router(api_router)
app.include_router(socketio_router)

# 애플리케이션 시작 시 KST 타임존 설정
os.environ['TZ'] = 'Asia/Seoul'

@app.on_event("startup")
async def startup_event():
    """애플리케이션 시작 시 실행되는 이벤트"""
    try:
        # 데이터베이스 초기화 (database.py의 함수 사용)
        await init_db()
        logger.info("Database initialized successfully")
        
        # 데이터베이스 연결 테스트
        db = get_database()
        await db.client.admin.command('ping')
        logger.info("Successfully connected to MongoDB")
        
        # SocketManager 초기화 - 명시적으로 UserService 주입
        from .core.dependencies import initialize_socket_manager, get_user_service
        user_service = get_user_service()
        socket_manager = initialize_socket_manager()
        logger.info("SocketManager initialized successfully")
        
        # Socket.IO 앱 생성 및 마운트 - CORS 설정 명시적 적용
        import socketio
        from .core.config import get_settings
        settings = get_settings()
        
        # 로그에 CORS 설정 출력
        logger.info(f"Socket.IO CORS 설정: {settings.CORS_ORIGINS}")
        
        # Socket.IO 앱 생성 및 마운트 - 명시적 경로 설정
        sio_app = socketio.ASGIApp(socket_manager.sio)
        socket_io_path = "/socket.io"
        app.mount(socket_io_path, sio_app)
        logger.info(f"Socket.IO app mounted successfully at path: {socket_io_path}")
        
        # 마운트된 경로 확인 로깅 
        logger.info(f"Socket.IO 연결 URL: http://localhost:8000{socket_io_path}")
        logger.info(f"Socket.IO WebSocket URL: ws://localhost:8000{socket_io_path}")
        
        # CVE 컬렉션 데이터 수 확인
        cve_count = await CVEModel.find().count()
        logger.info(f"Total CVEs in database: {cve_count}")
        
        # 스케줄러 초기화 및 시작
        scheduler = CrawlerScheduler()
        # 데이터베이스 초기화가 아닌 스케줄러 상태 초기화만 수행
        await scheduler.init_scheduler_state()
        scheduler.start()
        
    except Exception as e:
        logger.error(f"Failed to initialize database: {e}")
        logger.error(traceback.format_exc())
        raise

@app.get("/")
async def root():
    """API 루트 엔드포인트"""
    return {
        "message": "Welcome to CVEHub API",
        "version": "1.0.0",
        "docs_url": "/docs",
        "redoc_url": "/redoc"
    }

# 커스텀 JSON 인코더 클래스 정의
class CustomJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime):
            # UTC 시간대 정보를 명시적으로 추가하여 ISO 포맷으로 반환
            if obj.tzinfo is None:
                obj = obj.replace(tzinfo=ZoneInfo("UTC"))
            # 항상 Z로 끝나는 ISO 형식으로 통일 (밀리초 포함)
            iso_format = obj.isoformat().replace('+00:00', 'Z')
            # 디버깅 로그 추가
            print(f"CustomJSONEncoder: datetime 변환 - 원본: {obj}, 변환결과: {iso_format}")
            return iso_format
        return super().default(obj)

# FastAPI의 JSONResponse에 커스텀 인코더 적용
class CustomJSONResponse(JSONResponse):
    def render(self, content) -> bytes:
        return json.dumps(
            content,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(",", ":"),
            cls=CustomJSONEncoder
        ).encode("utf-8")

# 기본 JSONResponse를 커스텀 JSONResponse로 교체
app.router.default_response_class = CustomJSONResponse



============================================================
File: /home/CVEHub/backend/app/api.py
------------------------------------------------------------
"""라우터 모듈 패키지"""

from fastapi import APIRouter
from app.auth.router import router as auth_router
from app.cve.router import router as cve_router
from app.comment.router import router as comment_router
from app.notification.router import router as notification_router
from app.crawler.router import router as crawler_router
from app.cache.router import router as cache_router
from app.activity.router import router as activity_router

api_router = APIRouter()

# 인증 관련 라우터
api_router.include_router(auth_router, prefix="/auth", tags=["auth"])

# CVE 관련 라우터
api_router.include_router(cve_router, prefix="/cves", tags=["cves"])

# 댓글 관련 라우터
api_router.include_router(comment_router, prefix="/cves", tags=["comments"])

# 알림 관련 라우터
api_router.include_router(notification_router, prefix="/notifications", tags=["notifications"])

# 크롤러 관련 라우터
api_router.include_router(crawler_router, prefix="/crawler", tags=["crawler"])

# 캐시 관련 라우터
api_router.include_router(cache_router, prefix="/cache", tags=["cache"])

# 활동 관련 라우터
api_router.include_router(activity_router, prefix="", tags=["activities"])


============================================================
File: /home/CVEHub/backend/app/activity/router.py
------------------------------------------------------------
"""
사용자 활동 라우터
"""
from typing import Dict, Any, Optional
from fastapi import APIRouter, Depends, Query, HTTPException
from app.activity.service import ActivityService
from app.activity.models import ActivityListResponse
from app.auth.service import get_current_user
import functools
import logging

router = APIRouter(
    prefix="/activities",
    tags=["activities"]
)

logger = logging.getLogger(__name__)

def activity_api_error_handler(func):
    """활동 API 엔드포인트 예외 처리 데코레이터"""
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            result = await func(*args, **kwargs)
            if result is None:
                # 서비스에서 오류가 발생하여 None이 반환된 경우
                logger.error(f"{func.__name__} 실행 중 서비스 계층에서 오류가 발생했습니다.")
                raise HTTPException(
                    status_code=500, 
                    detail=f"{func.__name__} 실행 중 서비스 계층에서 오류가 발생했습니다."
                )
            return result
        except HTTPException:
            # FastAPI HTTP 예외는 그대로 전달
            raise
        except ValueError as val_err:
            # 값 검증 오류
            logger.warning(f"값 검증 오류 in {func.__name__}: {str(val_err)}")
            raise HTTPException(status_code=400, detail=str(val_err))
        except Exception as e:
            # 일반 예외는 서버 오류로 처리
            logger.error(f"Error in {func.__name__}: {str(e)}")
            raise HTTPException(
                status_code=500, 
                detail=f"{func.__name__} 중 오류 발생: {str(e)}"
            )
    return wrapper

@router.get("/me", response_model=ActivityListResponse)
@activity_api_error_handler
async def get_my_activities(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    current_user: Dict[str, Any] = Depends(get_current_user)
):
    """
    현재 로그인한 사용자의 활동 내역을 조회합니다.
    """
    activity_service = ActivityService()
    return await activity_service.get_activities_by_username(
        username=current_user["username"],
        page=page,
        limit=limit
    )

@router.get("/users/{username}", response_model=ActivityListResponse)
@activity_api_error_handler
async def get_user_activities(
    username: str,
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    current_user: Dict[str, Any] = Depends(get_current_user)
):
    """
    특정 사용자의 활동 내역을 조회합니다.
    """
    activity_service = ActivityService()
    return await activity_service.get_activities_by_username(
        username=username,
        page=page,
        limit=limit
    )

@router.get("/targets/{target_type}/{target_id}", response_model=ActivityListResponse)
@activity_api_error_handler
async def get_target_activities(
    target_type: str,
    target_id: str,
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    current_user: Dict[str, Any] = Depends(get_current_user)
):
    """
    대상 객체(CVE, PoC 등)의 활동 내역을 조회합니다.
    """
    activity_service = ActivityService()
    return await activity_service.get_activities_by_target(
        target_type=target_type,
        target_id=target_id,
        page=page,
        limit=limit
    )

@router.get("/", response_model=ActivityListResponse)
@activity_api_error_handler
async def get_all_activities(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    username: Optional[str] = None,
    target_type: Optional[str] = None,
    action: Optional[str] = None,
    current_user: Dict[str, Any] = Depends(get_current_user)
):
    """
    모든 활동 내역을 조회합니다. 필터링도 가능합니다.
    """
    activity_service = ActivityService()
    
    filter_data = {}
    if username:
        filter_data["username"] = username
    if target_type:
        filter_data["target_type"] = target_type
    if action:
        filter_data["action"] = action
    
    return await activity_service.get_all_activities(
        filter_data=filter_data,
        page=page,
        limit=limit
    )



============================================================
File: /home/CVEHub/backend/app/activity/repository.py
------------------------------------------------------------
"""
사용자 활동 레포지토리
"""
from typing import List, Dict, Any, Optional
from datetime import datetime
from pymongo import DESCENDING
from .models import UserActivity, ActivityAction, ActivityTargetType

class ActivityRepository:
    """사용자 활동 저장소 클래스"""
    
    def _convert_activities_for_response(self, activities: List[UserActivity]) -> List[Dict[str, Any]]:
        """MongoDB 객체를 API 응답에 맞게 변환합니다."""
        items_with_id = []
        for activity in activities:
            activity_dict = activity.dict()
            # MongoDB _id를 id 필드로 복사
            activity_dict["id"] = str(activity_dict.get("_id"))
            items_with_id.append(activity_dict)
        return items_with_id

    async def create_activity(self, activity_data: Dict[str, Any]) -> UserActivity:
        """
        사용자 활동을 생성합니다.
        
        Args:
            activity_data: 활동 데이터
            
        Returns:
            새 활동 객체
        """
        activity = UserActivity(**activity_data)
        await activity.create()
        return activity

    async def get_activities_by_username(self, 
                                         username: str, 
                                         page: int = 1, 
                                         limit: int = 10) -> Dict[str, Any]:
        """
        사용자명으로 활동 목록을 조회합니다.
        
        Args:
            username: 조회할 사용자명
            page: 페이지 번호
            limit: 페이지당 항목 수
            
        Returns:
            총 개수와 활동 목록
        """
        skip = (page - 1) * limit
        
        # 사용자명으로 조회
        query = {"username": username}
        
        # 활동 개수 조회
        total = await UserActivity.find(query).count()
        
        # 활동 목록 조회
        activities = await UserActivity.find(query)\
            .sort([("timestamp", DESCENDING)])\
            .skip(skip)\
            .limit(limit)\
            .to_list()
        
        return {
            "total": total,
            "items": self._convert_activities_for_response(activities),
            "page": page,
            "limit": limit
        }

    async def get_activities_by_target(self, 
                                       target_type: str, 
                                       target_id: str, 
                                       page: int = 1, 
                                       limit: int = 10) -> Dict[str, Any]:
        """
        대상 유형과 ID로 활동 목록을 조회합니다.
        
        Args:
            target_type: 대상 유형 (cve, poc 등)
            target_id: 대상 ID (CVE ID 등)
            page: 페이지 번호
            limit: 페이지당 항목 수
            
        Returns:
            총 개수와 활동 목록
        """
        skip = (page - 1) * limit
        
        # 대상 유형과 ID로 조회
        query = {
            "target_type": target_type,
            "target_id": target_id
        }
        
        # 활동 개수 조회
        total = await UserActivity.find(query).count()
        
        # 활동 목록 조회
        activities = await UserActivity.find(query)\
            .sort([("timestamp", DESCENDING)])\
            .skip(skip)\
            .limit(limit)\
            .to_list()
        
        return {
            "total": total,
            "items": self._convert_activities_for_response(activities),
            "page": page,
            "limit": limit
        }

    async def get_all_activities(self, 
                                filter_data: Optional[Dict[str, Any]] = None, 
                                page: int = 1, 
                                limit: int = 10) -> Dict[str, Any]:
        """
        모든 또는 필터링된 활동 목록을 조회합니다.
        
        Args:
            filter_data: 필터링할 데이터 (특정 대상 유형, 활동 유형 등)
            page: 페이지 번호
            limit: 페이지당 항목 수
            
        Returns:
            총 개수와 활동 목록
        """
        skip = (page - 1) * limit
        
        # 쿼리 구성
        query = {}
        
        if filter_data:
            # 대상 유형 필터 - OR 조건 처리
            if "target_type" in filter_data:
                if isinstance(filter_data["target_type"], ActivityTargetType):
                    query["target_type"] = filter_data["target_type"].value
                elif isinstance(filter_data["target_type"], str) and "," in filter_data["target_type"]:
                    # 쉼표로 구분된 문자열을 배열로 분할하여 $in 연산자 사용(OR 조건)
                    target_type_list = [target_type.strip() for target_type in filter_data["target_type"].split(",")]
                    query["target_type"] = {"$in": target_type_list}
                else:
                    query["target_type"] = filter_data["target_type"]
            
            # 동작 필터 - OR 조건 처리
            if "action" in filter_data:
                if isinstance(filter_data["action"], ActivityAction):
                    query["action"] = filter_data["action"].value
                elif isinstance(filter_data["action"], str) and "," in filter_data["action"]:
                    # 쉼표로 구분된 문자열을 배열로 분할하여 $in 연산자 사용(OR 조건)
                    action_list = [action.strip() for action in filter_data["action"].split(",")]
                    query["action"] = {"$in": action_list}
                else:
                    query["action"] = filter_data["action"]
            
            # 대상 ID 필터
            if "target_id" in filter_data:
                query["target_id"] = filter_data["target_id"]
            
            # 사용자명 필터
            if "username" in filter_data:
                query["username"] = filter_data["username"]
            
            # 날짜 범위 필터
            if "start_date" in filter_data or "end_date" in filter_data:
                date_query = {}
                
                if "start_date" in filter_data:
                    date_query["$gte"] = filter_data["start_date"]
                
                if "end_date" in filter_data:
                    date_query["$lte"] = filter_data["end_date"]
                
                if date_query:
                    query["timestamp"] = date_query
        
        # 활동 개수 조회
        total = await UserActivity.find(query).count()
        
        # 활동 목록 조회
        activities = await UserActivity.find(query)\
            .sort([("timestamp", DESCENDING)])\
            .skip(skip)\
            .limit(limit)\
            .to_list()
        
        return {
            "total": total,
            "items": self._convert_activities_for_response(activities),
            "page": page,
            "limit": limit
        }

    async def delete_activity(self, activity_id: str) -> bool:
        """
        활동을 ID로 삭제합니다.
        
        Args:
            activity_id: 삭제할 활동 ID
            
        Returns:
            성공 여부
        """
        activity = await UserActivity.get(activity_id)
        if activity:
            await activity.delete()
            return True
        return False



============================================================
File: /home/CVEHub/backend/app/activity/models.py
------------------------------------------------------------
"""
사용자 활동 모델 정의
"""
from typing import List, Optional, Dict, Any, Literal
from datetime import datetime
from beanie import Document
from pydantic import BaseModel, Field
from zoneinfo import ZoneInfo
from bson import ObjectId

from ..cve.models import ChangeItem

class ActivityAction(str):
    """활동 동작 유형"""
    CREATE = "create"  # 생성
    UPDATE = "update"  # 업데이트
    DELETE = "delete"  # 삭제
    ADD = "add"       # 추가
    ASSIGN = "assign"  # 할당
    LOGIN = "login"    # 로그인
    LOGOUT = "logout"  # 로그아웃

class ActivityTargetType(str):
    """활동 대상 유형"""
    CVE = "cve"              # CVE
    POC = "poc"              # PoC
    SNORT_RULE = "snort_rule"  # Snort 규칙
    REFERENCE = "reference"    # 참조 문서
    COMMENT = "comment"        # 댓글
    USER = "user"              # 사용자
    SYSTEM = "system"          # 시스템

class UserActivity(Document):
    """사용자 활동 모델"""
    username: str = Field(..., description="활동을 수행한 사용자명")
    timestamp: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    action: str = Field(..., description="수행한 동작")
    target_type: str = Field(..., description="대상 유형")
    target_id: str = Field(..., description="대상 ID (CVE ID, 댓글 ID 등)")
    target_title: Optional[str] = Field(None, description="대상 제목 또는 요약 (검색 및 표시 용도)")
    changes: List[ChangeItem] = Field(default_factory=list, description="변경 사항 목록 (모든 변경 내역 및 컨텍스트 정보 포함)")

    class Settings:
        name = "user_activities"
        use_state_management = True
        indexes = [
            "username",  # 사용자명 인덱스
            "target_type",  # 대상 유형 인덱스
            "target_id",  # 대상 ID 인덱스
            "action",     # 동작 유형 인덱스
            [("timestamp", -1)],  # 타임스탬프 내림차순 인덱스
            [("username", 1), ("timestamp", -1)],  # 사용자 + 타임스탬프 복합 인덱스
            [("target_type", 1), ("target_id", 1), ("timestamp", -1)],  # 대상 유형 + ID + 타임스탬프 인덱스
            [("target_type", 1), ("action", 1), ("timestamp", -1)]  # 대상 유형 + 동작 + 타임스탬프 인덱스
        ]

class ActivityResponse(BaseModel):
    """사용자 활동 응답 모델"""
    id: str
    username: str
    timestamp: datetime
    action: str
    target_type: str
    target_id: str
    target_title: Optional[str]
    changes: List[ChangeItem]

    class Config:
        orm_mode = True
        allow_population_by_field_name = True
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

class ActivityListResponse(BaseModel):
    """활동 목록 응답 모델"""
    total: int
    items: List[ActivityResponse]
    page: int = 1
    limit: int = 10



============================================================
File: /home/CVEHub/backend/app/activity/service.py
------------------------------------------------------------
"""
사용자 활동 서비스
"""
from typing import List, Dict, Any, Optional, Callable, Awaitable, TypeVar, ParamSpec, cast
from datetime import datetime
from zoneinfo import ZoneInfo
import logging
import traceback
import functools
import inspect
from .repository import ActivityRepository
from .models import UserActivity, ActivityAction, ActivityTargetType
from ..cve.models import ChangeItem
from ..common.utils.change_detection import detect_object_changes

logger = logging.getLogger(__name__)

# 제네릭 타입 정의
T = TypeVar('T')
P = ParamSpec('P')

class ActivityService:
    """사용자 활동 서비스 클래스"""
    
    def __init__(self):
        self.repository = ActivityRepository()
        
    async def create_activity(self, 
                             username: str, 
                             action: ActivityAction,
                             target_type: ActivityTargetType,
                             target_id: str,
                             target_title: Optional[str] = None,
                             changes: List[ChangeItem] = None,
                             metadata: Dict[str, Any] = None) -> Optional[UserActivity]:
        """
        사용자 활동을 생성합니다.
        
        Args:
            username: 활동을 수행한 사용자명
            action: 활동 동작 (수정, 생성 등)
            target_type: 대상 유형 (cve, poc 등)
            target_id: 대상 ID (CVE ID 등)
            target_title: 대상 제목 또는 요약 (검색 및 표시 용도)
            changes: 변경 사항 목록
            metadata: 추가 메타데이터
            
        Returns:
            생성된 활동 또는 None
        """
        try:
            # action과 target_type이 문자열이거나 Enum일 수 있으므로 각각 처리
            action_value = action if isinstance(action, str) else action.value
            target_type_value = target_type if isinstance(target_type, str) else target_type.value
            
            activity_data = {
                "username": username,
                "timestamp": datetime.now(ZoneInfo("UTC")),
                "action": action_value,
                "target_type": target_type_value,
                "target_id": target_id,
                "target_title": target_title,
                "changes": changes or [],
                "metadata": metadata or {}
            }
            
            # 활동 생성 및 반환
            activity = await self.repository.create_activity(activity_data)
            return activity
            
        except Exception as e:
            logger.error(f"활동 생성 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            return None
    
    def track_activity(self,
                      target_type: ActivityTargetType,
                      action: ActivityAction,
                      target_id_extractor: Callable[[Any, Dict[str, Any]], str],
                      target_title_extractor: Optional[Callable[[Any, Dict[str, Any]], Optional[str]]] = None,
                      changes_generator: Optional[Callable[[Any, Dict[str, Any]], List[ChangeItem]]] = None,
                      metadata_generator: Optional[Callable[[Any, Dict[str, Any]], Dict[str, Any]]] = None,
                      username_param: str = "username"):
        """
        메서드 활동을 자동으로 추적하는 데코레이터
        
        Args:
            target_type: 대상 유형 (ActivityTargetType 클래스 참조)
            action: 수행한 동작 (ActivityAction 클래스 참조)
            target_id_extractor: 함수 인자에서 target_id를 추출하는 함수
            target_title_extractor: 함수 인자에서 target_title을 추출하는 함수 (선택)
            changes_generator: 함수 인자에서 변경 사항을 생성하는 함수 (선택)
            metadata_generator: 함수 인자에서 메타데이터를 생성하는 함수 (선택)
            username_param: 사용자명을 포함하는 매개변수 이름 (기본값: "username")
        """
        def decorator(func: Callable[P, Awaitable[T]]) -> Callable[P, Awaitable[T]]:
            @functools.wraps(func)
            async def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:
                # 원래 함수 실행
                result = await func(*args, **kwargs)
                
                try:
                    # self 객체 추출 (일반적으로 첫 번째 인자)
                    self_obj = args[0] if args else None
                    
                    # 매개변수 정보 수집
                    params = {}
                    sig = inspect.signature(func)
                    
                    # 위치 인자를 이름이 있는 매개변수로 변환
                    param_names = list(sig.parameters.keys())
                    for i, arg in enumerate(args[1:], 1):  # args[0]은 self이므로 건너뜀
                        if i < len(param_names):
                            params[param_names[i]] = arg
                    
                    # 키워드 인자 추가
                    params.update(kwargs)
                    
                    # 필수 정보 추출
                    username = params.get(username_param, "system")
                    target_id = target_id_extractor(self_obj, params)
                    
                    # 선택적 정보 추출
                    target_title = None
                    if target_title_extractor:
                        target_title = target_title_extractor(self_obj, params)
                    
                    changes = []
                    if changes_generator:
                        changes = changes_generator(self_obj, params)
                    
                    metadata = {}
                    if metadata_generator:
                        metadata = metadata_generator(self_obj, params)
                    
                    # 결과 정보 추가 (해당되는 경우)
                    if hasattr(result, 'dict') and callable(getattr(result, 'dict')):
                        # Pydantic 모델 결과
                        metadata["result"] = {"success": True, "id": str(getattr(result, 'id', None))}
                    elif isinstance(result, tuple) and len(result) >= 2:
                        # (결과, 메시지) 형태의 튜플
                        success = bool(result[0])
                        metadata["result"] = {"success": success, "message": str(result[1])}
                    elif isinstance(result, dict) and "id" in result:
                        # ID가 포함된 딕셔너리
                        metadata["result"] = {"success": True, "id": str(result.get("id"))}
                    
                    # 활동 생성
                    if hasattr(self_obj, 'activity_service') and self_obj.activity_service:
                        await self_obj.activity_service.create_activity(
                            username=username,
                            action=action.value,
                            target_type=target_type.value,
                            target_id=target_id,
                            target_title=target_title,
                            changes=changes,
                            metadata=metadata
                        )
                except Exception as e:
                    logger.error(f"활동 추적 중 오류 발생: {str(e)}")
                    logger.error(traceback.format_exc())
                
                return result
            return wrapper
        return decorator
        
    async def get_activities_by_username(self, username: str, page: int = 1, limit: int = 10) -> Dict[str, Any]:
        """
        사용자명으로 활동 목록을 조회합니다.
        
        Args:
            username: 조회할 사용자명
            page: 페이지 번호
            limit: 페이지당 항목 수
            
        Returns:
            총 개수와 활동 목록
        """
        try:
            return await self.repository.get_activities_by_username(
                username=username,
                page=page,
                limit=limit
            )
        except Exception as e:
            logger.error(f"사용자 활동 조회 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            return {
                "total": 0,
                "items": [],
                "page": page,
                "limit": limit
            }
            
    async def get_activities_by_target(self, 
                                      target_type: ActivityTargetType, 
                                      target_id: str, 
                                      page: int = 1, 
                                      limit: int = 10) -> Dict[str, Any]:
        """
        대상 유형과 ID로 활동 목록을 조회합니다.
        
        Args:
            target_type: 대상 유형 (cve, poc 등)
            target_id: 대상 ID (CVE ID 등)
            page: 페이지 번호
            limit: 페이지당 항목 수
            
        Returns:
            총 개수와 활동 목록
        """
        try:
            return await self.repository.get_activities_by_target(
                target_type=target_type.value,
                target_id=target_id,
                page=page,
                limit=limit
            )
        except Exception as e:
            logger.error(f"대상 활동 조회 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            return {
                "total": 0,
                "items": [],
                "page": page,
                "limit": limit
            }
            
    async def get_all_activities(self, 
                                 filter_data: Optional[Dict[str, Any]] = None, 
                                 page: int = 1, 
                                 limit: int = 10) -> Dict[str, Any]:
        """
        모든 또는 필터링된 활동 목록을 조회합니다.
        
        Args:
            filter_data: 필터링할 데이터
            page: 페이지 번호
            limit: 페이지당 항목 수
            
        Returns:
            총 개수와 활동 목록
        """
        try:
            return await self.repository.get_all_activities(
                filter_data=filter_data,
                page=page,
                limit=limit
            )
        except Exception as e:
            logger.error(f"활동 목록 조회 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            return {
                "total": 0,
                "items": [],
                "page": page,
                "limit": limit
            }

    async def track_object_changes(
        self, 
        username: str, 
        action: ActivityAction,
        target_type: ActivityTargetType,
        target_id: str,
        old_obj: Any, 
        new_obj: Any,
        target_title: Optional[str] = None,
        ignore_fields: Optional[List[str]] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Optional[UserActivity]:
        """
        두 객체 간의 변경 사항을 감지하고 활동 기록을 생성합니다.
        
        Args:
            username: 활동 수행 사용자
            action: 활동 동작 유형
            target_type: 대상 유형
            target_id: 대상 ID
            old_obj: 변경 전 객체
            new_obj: 변경 후 객체
            target_title: 대상 제목 (선택)
            ignore_fields: 무시할 필드 (선택)
            metadata: 추가 메타데이터 (선택)
            
        Returns:
            생성된 활동 또는 None
        """
        try:
            # 변경 사항 감지
            change_logs = detect_object_changes(old_obj, new_obj, ignore_fields)
            
            # 변경 사항이 없으면 활동 기록 생성하지 않음
            if not change_logs:
                return None
            
            # 필드 이름 매핑 (한글명 또는 사용자 친화적 이름)
            field_name_mapping = {
                "title": "제목",
                "description": "설명",
                "status": "상태",
                "assigned_to": "담당자",
                "severity": "심각도",
                "pocs": "PoC",
                "snort_rules": "Snort 규칙",
                "references": "참조 문서",
                "username": "사용자명",
                "email": "이메일",
                "is_active": "활성 상태",
                "is_admin": "관리자 여부",
                "full_name": "이름",
                "comment": "댓글",
                # 필요한 필드 추가
            }
            
            # ChangeLogBase를 ChangeItem으로 변환
            from ..cve.models import ChangeItem
            
            # 변경 사항이 여러 개인 경우를 하나의 통합된 ChangeItem으로 처리
            # 필드가 여러 개인 경우 간단히 표시하기 위해 추가 요약
            if len(change_logs) > 1:
                # 필드명 수집
                changed_fields = [field_name_mapping.get(log.field, log.field) for log in change_logs]
                
                change_item = ChangeItem(
                    field="multiple",
                    field_name="여러 필드",
                    action="edit",
                    detail_type="simple",
                    summary=f"{len(changed_fields)}개 필드 변경됨: {', '.join(changed_fields[:3])}{' 등' if len(changed_fields) > 3 else ''}"
                )
                change_items = [change_item]
            else:
                # 단일 변경인 경우 상세 정보 제공
                log = change_logs[0] if change_logs else None
                if log:
                    field_name = field_name_mapping.get(log.field, log.field)
                    change_item = ChangeItem(
                        field=log.field,
                        field_name=field_name,
                        action="edit" if log.action == "edit" else ("add" if log.action == "add" else "delete"),
                        detail_type="detailed",
                        before=log.old_value,
                        after=log.new_value,
                        summary=log.summary if hasattr(log, 'summary') else f"{field_name} 변경됨"
                    )
                    change_items = [change_item]
                else:
                    change_items = []
                
            # 활동 기록 생성
            return await self.create_activity(
                username=username,
                action=action,
                target_type=target_type,
                target_id=target_id,
                target_title=target_title or str(target_id),
                changes=change_items,
                metadata=metadata or {}
            )
        except Exception as e:
            logger.error(f"변경 사항 추적 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            return None


============================================================
File: /home/CVEHub/backend/app/notification/router.py
------------------------------------------------------------
"""
알림(Notification) 관련 API 라우터
"""
from fastapi import APIRouter, HTTPException, Depends, status, Body, Query, Response, Path
from typing import List, Optional
from app.notification.models import Notification, NotificationCreate, NotificationStatus
from app.auth.models import User
from app.auth.service import get_current_user
from app.core.exceptions import NotFoundError, ValidationError, DatabaseError
from app.core.schemas import APIResponse, PaginatedResponse, Metadata
from app.socketio.manager import socketio_manager
from app.notification.service import NotificationService
from app.core.dependencies import get_notification_service
import logging
router = APIRouter()
logger = logging.getLogger(__name__)

@router.post("/", response_model=APIResponse[Notification])
async def create_notification(
    notification_data: NotificationCreate = Body(
        ...,
        description="생성할 알림 데이터",
        example={
            "recipient_id": "user123",
            "content": "새로운 CVE가 등록되었습니다.",
            "type": "cve_update"
        }
    ),
    current_user: User = Depends(get_current_user),
    notification_service: NotificationService = Depends(get_notification_service)
):
    """
    새로운 알림을 생성합니다.

    - **notification_data**: 생성할 알림의 상세 정보
    - 알림 생성 후 WebSocket을 통해 실시간으로 수신자에게 전송됩니다.
    """
    try:
        notification = await notification_service.create_notification(
            recipient_id=notification_data.recipient_id,
            sender_id=str(current_user.id),
            content=notification_data.content,
            type=notification_data.type,
            metadata=notification_data.metadata
        )
        await socketio_manager.emit("new_notification", notification.dict(), room=notification_data.recipient_id)
        return APIResponse(
            data=notification,
            message="알림이 성공적으로 생성되었습니다."
        )
    except Exception as e:
        logger.error(f"알림 생성 중 오류 발생: {str(e)}")
        raise DatabaseError(detail=str(e))

@router.get("/", response_model=PaginatedResponse[List[Notification]])
async def get_notifications(
    response: Response,
    skip: int = Query(0, ge=0, description="건너뛸 알림 수"),
    limit: int = Query(20, ge=1, le=100, description="한 페이지당 알림 수"),
    status: Optional[NotificationStatus] = Query(
        None,
        description="알림 상태 필터 (read/unread)"
    ),
    current_user: User = Depends(get_current_user),
    notification_service: NotificationService = Depends(get_notification_service)
):
    """
    사용자의 알림 목록을 조회합니다.

    응답 헤더:
    - **X-Total-Count**: 전체 알림 수
    - **X-Unread-Count**: 읽지 않은 알림 수

    페이지네이션:
    - **skip**: 건너뛸 알림 수 (기본값: 0)
    - **limit**: 한 페이지당 알림 수 (기본값: 20, 최대: 100)

    필터링:
    - **status**: 알림 상태로 필터링 (read/unread)
    """
    try:
        notifications = await notification_service.get_notifications(
            str(current_user.id),
            skip,
            limit,
            status
        )
        
        total_count = await notification_service.get_total_count(str(current_user.id))
        unread_count = await notification_service.get_unread_count(str(current_user.id))
        
        response.headers["X-Total-Count"] = str(total_count)
        response.headers["X-Unread-Count"] = str(unread_count)

        return PaginatedResponse(
            data=notifications,
            meta=Metadata(
                total=total_count,
                page=skip // limit + 1,
                pages=(total_count + limit - 1) // limit,
                has_next=skip + limit < total_count,
                has_prev=skip > 0
            ),
            message="알림 목록을 성공적으로 조회했습니다."
        )
    except Exception as e:
        logger.error(f"알림 목록 조회 중 오류 발생: {str(e)}")
        raise DatabaseError(detail=str(e))

@router.get("/unread/count", response_model=APIResponse[dict])
async def get_unread_count(
    current_user: User = Depends(get_current_user),
    notification_service: NotificationService = Depends(get_notification_service)
):
    """
    읽지 않은 알림 개수를 조회합니다.

    Returns:
        - **count**: 읽지 않은 알림 개수
    """
    try:
        count = await notification_service.get_unread_count(str(current_user.id))
        return APIResponse(
            data={"count": count},
            message="읽지 않은 알림 개수를 성공적으로 조회했습니다."
        )
    except Exception as e:
        logger.error(f"읽지 않은 알림 개수 조회 중 오류 발생: {str(e)}")
        raise DatabaseError(detail=str(e))

@router.patch("/{notification_id}/read", response_model=APIResponse[Notification])
async def mark_as_read(
    notification_id: str = Path(..., description="읽음 처리할 알림 ID"),
    current_user: User = Depends(get_current_user),
    notification_service: NotificationService = Depends(get_notification_service)
):
    """
    특정 알림을 읽음 상태로 변경합니다.

    Parameters:
        - **notification_id**: 읽음 처리할 알림의 ID
    """
    try:
        notification = await notification_service.mark_as_read(notification_id, str(current_user.id))
        return APIResponse(
            data=notification,
            message="알림이 읽음 상태로 변경되었습니다."
        )
    except NotFoundError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"알림 읽음 처리 중 오류 발생: {str(e)}")
        raise DatabaseError(detail=str(e))

@router.patch("/mark-all-read", response_model=APIResponse[dict])
async def mark_all_as_read(
    current_user: User = Depends(get_current_user),
    notification_service: NotificationService = Depends(get_notification_service)
):
    """
    사용자의 모든 알림을 읽음 상태로 변경합니다.
    """
    try:
        count = await notification_service.mark_all_as_read(str(current_user.id))
        return APIResponse(
            data={"count": count},
            message=f"{count}개의 알림이 모두 읽음 상태로 변경되었습니다."
        )
    except Exception as e:
        logger.error(f"모든 알림 읽음 처리 중 오류 발생: {str(e)}")
        raise DatabaseError(detail=str(e))

@router.patch("/mark-multiple-read", response_model=APIResponse[dict])
async def mark_multiple_as_read(
    notification_ids: List[str] = Body(..., embed=True),
    current_user: User = Depends(get_current_user),
    notification_service: NotificationService = Depends(get_notification_service)
):
    """
    여러 알림을 한 번에 읽음 상태로 변경합니다.
    
    Parameters:
        - **notification_ids**: 읽음 처리할 알림 ID 목록
    """
    if not notification_ids:
        return APIResponse(
            data={"count": 0},
            message="변경할 알림이 없습니다."
        )
    
    try:
        # 알림 ID를 ObjectId로 변환
        object_ids = []
        for id_str in notification_ids:
            try:
                object_ids.append(id_str)
            except Exception:
                raise ValidationError(f"유효하지 않은 알림 ID 형식: {id_str}")
        
        count = await notification_service.mark_multiple_as_read(object_ids, str(current_user.id))
        return APIResponse(
            data={"count": count},
            message=f"{count}개의 알림이 읽음 상태로 변경되었습니다."
        )
    except ValidationError as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))
    except Exception as e:
        logger.error(f"다중 알림 읽음 처리 중 오류 발생: {str(e)}")
        raise DatabaseError(detail=str(e))



============================================================
File: /home/CVEHub/backend/app/notification/repository.py
------------------------------------------------------------
"""
알림 관련 데이터 접근 레이어

사용자 알림 데이터에 대한 CRUD 및 조회 기능을 제공합니다.
"""
from typing import List, Optional, Dict, Any, Tuple
from datetime import datetime
from zoneinfo import ZoneInfo
import logging
from beanie import PydanticObjectId

from .models import Notification, NotificationType, NotificationStatus

logger = logging.getLogger(__name__)

class NotificationRepository:
    """알림 데이터 접근 레이어 클래스"""
    
    async def create(
        self,
        notification_type: NotificationType,
        recipient_id: str,
        content: str,
        sender_id: Optional[str] = None,
        cve_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Notification:
        """
        새로운 알림을 생성합니다.
        
        Args:
            notification_type: 알림 유형
            recipient_id: 수신자 ID
            content: 알림 내용
            sender_id: 발신자 ID (선택적)
            cve_id: 관련 CVE ID (선택적)
            metadata: 추가 메타데이터 (선택적)
            
        Returns:
            생성된 알림 객체
        """
        try:
            notification = Notification(
                type=notification_type,
                recipient_id=recipient_id,
                sender_id=sender_id,
                cve_id=cve_id,
                content=content,
                metadata=metadata or {},
                created_at=datetime.now(ZoneInfo("UTC"))
            )
            
            # 데이터베이스에 저장
            await notification.insert()
            return notification
        except Exception as e:
            logger.error(f"알림 생성 중 오류 발생: {str(e)}")
            raise
    
    async def get_by_id(self, notification_id: str) -> Optional[Notification]:
        """
        ID로 알림을 조회합니다.
        
        Args:
            notification_id: 알림 ID
            
        Returns:
            알림 객체 또는 None
        """
        try:
            # 문자열 ID를 ObjectId로 변환
            if isinstance(notification_id, str):
                try:
                    obj_id = PydanticObjectId(notification_id)
                except:
                    obj_id = notification_id
            else:
                obj_id = notification_id
                
            return await Notification.get(obj_id)
        except Exception as e:
            logger.error(f"알림 조회 중 오류 발생: {str(e)}")
            return None
    
    async def get_by_recipient(
        self,
        user_id: str,
        skip: int = 0,
        limit: int = 20,
        status: Optional[NotificationStatus] = None
    ) -> List[Notification]:
        """
        사용자가 수신한 알림 목록을 조회합니다.
        
        Args:
            user_id: 사용자 ID
            skip: 건너뛸 레코드 수 (페이징)
            limit: 가져올 최대 레코드 수 (페이징)
            status: 알림 상태로 필터링 (선택적)
            
        Returns:
            알림 목록
        """
        try:
            query = {"recipient_id": user_id}
            if status:
                query["status"] = status
                
            notifications = await Notification.find(query)\
                .sort(-Notification.created_at)\
                .skip(skip)\
                .limit(limit)\
                .to_list()
                
            return notifications
        except Exception as e:
            logger.error(f"알림 목록 조회 중 오류 발생: {str(e)}")
            return []
    
    async def get_recent_notifications(
        self,
        user_id: str,
        limit: int = 5
    ) -> List[Notification]:
        """
        사용자의 최근 알림 목록을 조회합니다.
        소셜 미디어 스타일의 알림 드롭다운에 표시할 최신 알림들
        
        Args:
            user_id: 사용자 ID
            limit: 가져올 최대 알림 수
            
        Returns:
            최근 알림 목록
        """
        try:
            notifications = await Notification.find({"recipient_id": user_id})\
                .sort(-Notification.created_at)\
                .limit(limit)\
                .to_list()
                
            return notifications
        except Exception as e:
            logger.error(f"최근 알림 조회 중 오류 발생: {str(e)}")
            return []
    
    async def mark_as_read(self, notification_id: str, user_id: str) -> bool:
        """
        알림을 읽음 처리합니다.
        
        Args:
            notification_id: 알림 ID
            user_id: 사용자 ID (권한 확인용)
            
        Returns:
            성공 여부
        """
        try:
            notification = await self.get_by_id(notification_id)
            if not notification or notification.recipient_id != user_id:
                return False
                
            notification.status = NotificationStatus.READ
            notification.read_at = datetime.now(ZoneInfo("UTC"))
            await notification.save()
            return True
        except Exception as e:
            logger.error(f"알림 읽음 처리 중 오류 발생: {str(e)}")
            return False
    
    async def mark_all_as_read(self, user_id: str) -> int:
        """
        사용자의 모든 알림을 읽음 처리합니다.
        
        Args:
            user_id: 사용자 ID
            
        Returns:
            읽음 처리된 알림 수
        """
        try:
            notifications = await Notification.find({
                "recipient_id": user_id,
                "status": NotificationStatus.UNREAD
            }).to_list()
            
            update_time = datetime.now(ZoneInfo("UTC"))
            for notification in notifications:
                notification.status = NotificationStatus.READ
                notification.read_at = update_time
                await notification.save()
                
            return len(notifications)
        except Exception as e:
            logger.error(f"모든 알림 읽음 처리 중 오류 발생: {str(e)}")
            return 0
    
    async def mark_as_delivered(self, notification_id: str) -> bool:
        """
        알림을 전송 완료로 표시합니다.
        
        Args:
            notification_id: 알림 ID
            
        Returns:
            성공 여부
        """
        try:
            notification = await self.get_by_id(notification_id)
            if not notification:
                return False
                
            notification.delivered = True
            await notification.save()
            return True
        except Exception as e:
            logger.error(f"알림 전송 완료 처리 중 오류 발생: {str(e)}")
            return False
    
    async def get_unread_count(self, user_id: str) -> int:
        """
        사용자의 읽지 않은 알림 개수를 조회합니다.
        
        Args:
            user_id: 사용자 ID
            
        Returns:
            읽지 않은 알림 개수
        """
        try:
            return await Notification.find({
                "recipient_id": user_id,
                "status": NotificationStatus.UNREAD
            }).count()
        except Exception as e:
            logger.error(f"읽지 않은 알림 개수 조회 중 오류 발생: {str(e)}")
            return 0
    
    async def get_total_count(self, user_id: str) -> int:
        """
        사용자의 전체 알림 개수를 조회합니다.
        
        Args:
            user_id: 사용자 ID
            
        Returns:
            전체 알림 개수
        """
        try:
            return await Notification.find({
                "recipient_id": user_id
            }).count()
        except Exception as e:
            logger.error(f"전체 알림 개수 조회 중 오류 발생: {str(e)}")
            return 0
    
    async def delete_by_id(self, notification_id: str, user_id: str) -> bool:
        """
        알림을 삭제합니다.
        
        Args:
            notification_id: 알림 ID
            user_id: 사용자 ID (권한 확인용)
            
        Returns:
            성공 여부
        """
        try:
            notification = await self.get_by_id(notification_id)
            if not notification or notification.recipient_id != user_id:
                return False
                
            await notification.delete()
            return True
        except Exception as e:
            logger.error(f"알림 삭제 중 오류 발생: {str(e)}")
            return False
    
    async def delete_old_notifications(self, days: int = 30) -> int:
        """
        오래된 알림을 삭제합니다.
        
        Args:
            days: 삭제할 기준 일수 (이전 알림)
            
        Returns:
            삭제된 알림 수
        """
        try:
            from datetime import timedelta
            
            # 기준 시간 계산 (현재 시간 - days일)
            cutoff_date = datetime.now(ZoneInfo("UTC")) - timedelta(days=days)
            
            # 오래된 알림 삭제
            result = await Notification.find({
                "created_at": {"$lt": cutoff_date}
            }).delete_many()
            
            return result.deleted_count if hasattr(result, 'deleted_count') else 0
        except Exception as e:
            logger.error(f"오래된 알림 삭제 중 오류 발생: {str(e)}")
            return 0
    
    async def get_notifications_by_type(
        self,
        user_id: str,
        notification_type: NotificationType,
        skip: int = 0,
        limit: int = 20
    ) -> List[Notification]:
        """
        특정 유형의 알림 목록을 조회합니다.
        
        Args:
            user_id: 사용자 ID
            notification_type: 알림 유형
            skip: 건너뛸 레코드 수 (페이징)
            limit: 가져올 최대 레코드 수 (페이징)
            
        Returns:
            알림 목록
        """
        try:
            notifications = await Notification.find({
                "recipient_id": user_id,
                "type": notification_type
            })\
                .sort(-Notification.created_at)\
                .skip(skip)\
                .limit(limit)\
                .to_list()
                
            return notifications
        except Exception as e:
            logger.error(f"유형별 알림 조회 중 오류 발생: {str(e)}")
            return []
    
    async def get_grouped_notifications(
        self,
        user_id: str,
        skip: int = 0,
        limit: int = 20
    ) -> Dict[str, List[Notification]]:
        """
        유형별로 그룹화된 알림 목록을 조회합니다.
        소셜 미디어 스타일 알림 탭에 유용함
        
        Args:
            user_id: 사용자 ID
            skip: 건너뛸 레코드 수 (페이징)
            limit: 가져올 최대 레코드 수 (페이징)
            
        Returns:
            유형별로 그룹화된 알림 목록 딕셔너리
        """
        try:
            # 먼저 모든 알림 가져오기
            notifications = await Notification.find({
                "recipient_id": user_id
            })\
                .sort(-Notification.created_at)\
                .skip(skip)\
                .limit(limit)\
                .to_list()
            
            # 유형별로 그룹화
            grouped = {}
            for notification in notifications:
                if notification.type not in grouped:
                    grouped[notification.type] = []
                grouped[notification.type].append(notification)
                
            return grouped
        except Exception as e:
            logger.error(f"그룹화된 알림 조회 중 오류 발생: {str(e)}")
            return {}


# 싱글톤 인스턴스
_notification_repository = NotificationRepository()

def get_notification_repository() -> NotificationRepository:
    """NotificationRepository 인스턴스를 반환합니다."""
    global _notification_repository
    return _notification_repository



============================================================
File: /home/CVEHub/backend/app/notification/models.py
------------------------------------------------------------
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any
from beanie import Document
from pydantic import BaseModel, Field
import pytz
from zoneinfo import ZoneInfo

KST = pytz.timezone('Asia/Seoul')

class NotificationType(str, Enum):
    MENTION = "mention"          # 멘션 알림
    CVE_UPDATE = "cve_update"    # CVE 업데이트 알림
    SYSTEM = "system"            # 시스템 알림

class NotificationStatus(str, Enum):
    UNREAD = "unread"
    READ = "read"

class Notification(Document):
    """알림 모델"""
    type: NotificationType
    recipient_id: str            # 수신자 ID
    sender_id: Optional[str]     # 발신자 ID
    cve_id: Optional[str]        # 관련 CVE ID
    content: str                 # 알림 내용
    metadata: Dict[str, Any] = Field(default_factory=dict)  # 멘션된 댓글 내용 등
    status: NotificationStatus = NotificationStatus.UNREAD
    created_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    read_at: Optional[datetime] = None
    delivered: bool = False
    
    class Settings:
        name = "notifications"
        indexes = [
            "recipient_id",
            "type",
            "status",
            "created_at"
        ]

    class Config:
        json_encoders = {
            datetime: lambda dt: dt.replace(tzinfo=ZoneInfo("UTC")).isoformat().replace('+00:00', 'Z') if dt else None
        }

    def dict(self, *args, **kwargs):
        """JSON 직렬화를 위한 딕셔너리 반환"""
        d = super().dict(*args, **kwargs)
        d['id'] = str(self.id)  # MongoDB의 _id를 id로 변환
        
        # datetime 필드들을 ISO 형식 문자열로 변환
        if self.created_at:
            d['created_at'] = self.created_at.isoformat()
        if self.read_at:
            d['read_at'] = self.read_at.isoformat()
            
        return d

class NotificationCreate(BaseModel):
    """알림 생성을 위한 입력 모델"""
    recipient_id: str
    sender_id: Optional[str] = None
    cve_id: Optional[str] = None
    content: str
    metadata: Dict[str, Any] = Field(default_factory=dict)



============================================================
File: /home/CVEHub/backend/app/notification/service.py
------------------------------------------------------------
from typing import List, Optional, Dict, Tuple, Any
from .models import Notification, NotificationType, NotificationStatus
from .repository import NotificationRepository, get_notification_repository
from app.socketio.manager import socketio_manager, WSMessageType
import logging

logger = logging.getLogger(__name__)

class NotificationService:
    def __init__(self, repository: Optional[NotificationRepository] = None):
        """NotificationService 초기화
        
        Args:
            repository: NotificationRepository 인스턴스 (선택적)
        """
        self.repository = repository or get_notification_repository()
    
    async def create_notification(
        self,
        notification_type: NotificationType,
        recipient_id: str,
        content: str,
        sender_id: Optional[str] = None,
        cve_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> Tuple[Notification, int]:
        """알림을 생성하고 저장합니다."""
        try:
            # Repository를 통해 알림 생성
            notification = await self.repository.create(
                notification_type=notification_type,
                recipient_id=recipient_id,
                content=content,
                sender_id=sender_id,
                cve_id=cve_id,
                metadata=metadata
            )

            # 온라인 사용자에게 실시간 전송 시도
            try:
                await self._deliver_notification(notification)
            except Exception as e:
                logger.error(f"Failed to deliver notification: {str(e)}")

            # 읽지 않은 알림 개수 조회
            unread_count = await self.get_unread_count(recipient_id)

            return notification, unread_count

        except Exception as e:
            logger.error(f"Error creating notification: {str(e)}")
            raise

    async def _deliver_notification(self, notification: Notification) -> bool:
        """온라인 사용자에게 알림 전송 시도"""
        try:
            # Socket.IO를 통해 실시간 전송
            await socketio_manager.emit(
                WSMessageType.NOTIFICATION,
                {
                    "notification": notification.dict(),
                    "unreadCount": await self.get_unread_count(notification.recipient_id)
                },
                room=notification.recipient_id
            )
            
            # 전송 성공 시 delivered 상태 업데이트
            await self.repository.mark_as_delivered(notification.id)
            return True
        except Exception as e:
            logger.error(f"Delivery failed: {str(e)}")
            return False

    async def get_notifications(
        self,
        user_id: str,
        skip: int = 0,
        limit: int = 20,
        status: Optional[NotificationStatus] = None
    ) -> List[Notification]:
        """사용자의 알림 목록을 조회합니다."""
        try:
            return await self.repository.get_by_recipient(
                user_id=user_id,
                skip=skip,
                limit=limit,
                status=status
            )
        except Exception as e:
            logger.error(f"Error fetching notifications: {str(e)}")
            return []

    async def mark_as_read(self, notification_id: str, user_id: str) -> bool:
        """알림을 읽음 처리합니다."""
        try:
            return await self.repository.mark_as_read(notification_id, user_id)
        except Exception as e:
            logger.error(f"Error marking notification as read: {str(e)}")
            return False

    async def get_unread_count(self, user_id: str) -> int:
        """읽지 않은 알림 개수를 조회합니다."""
        try:
            return await self.repository.get_unread_count(user_id)
        except Exception as e:
            logger.error(f"Error counting unread notifications: {str(e)}")
            return 0

    async def mark_all_as_read(self, user_id: str) -> bool:
        """모든 알림을 읽음 처리합니다."""
        try:
            count = await self.repository.mark_all_as_read(user_id)
            return count >= 0  # 에러가 없으면 True 반환
        except Exception as e:
            logger.error(f"Error marking all notifications as read: {str(e)}")
            return False

    async def get_total_count(self, user_id: str) -> int:
        """전체 알림 개수를 조회합니다."""
        try:
            return await self.repository.get_total_count(user_id)
        except Exception as e:
            logger.error(f"Error counting total notifications: {str(e)}")
            return 0

    async def create_mention_notification(
        self,
        recipient_id: str,
        sender_id: str,
        cve_id: str,
        comment_content: str,
        sender_username: str = None,  # 발신자 사용자명 추가
    ) -> Tuple[Notification, int]:
        """멘션 알림을 생성합니다."""
        try:
            # 사용자명이 없는 경우 "사용자"로 대체
            display_name = f"@{sender_username}" if sender_username else "누군가"
            content = f"{display_name}님이 회원님을 멘션했습니다"
            
            notification = await self.repository.create(
                notification_type=NotificationType.MENTION,
                recipient_id=recipient_id,
                sender_id=sender_id,
                cve_id=cve_id,
                content=content,
                metadata={
                    "comment_content": comment_content
                }
            )
            
            # 온라인 사용자에게 실시간 전송
            await self._deliver_notification(notification)
            
            return notification, await self.get_unread_count(recipient_id)
        except Exception as e:
            logger.error(f"Error creating mention notification: {str(e)}")
            raise
            
    async def get_recent_notifications(self, user_id: str, limit: int = 5) -> List[Notification]:
        """사용자의 최근 알림을 조회합니다 (알림 드롭다운용)"""
        try:
            return await self.repository.get_recent_notifications(user_id, limit)
        except Exception as e:
            logger.error(f"Error fetching recent notifications: {str(e)}")
            return []
    
    async def get_notifications_by_type(self, user_id: str, notification_type: NotificationType, 
                                       skip: int = 0, limit: int = 20) -> List[Notification]:
        """특정 유형의 알림 목록을 조회합니다."""
        try:
            return await self.repository.get_notifications_by_type(
                user_id, notification_type, skip, limit)
        except Exception as e:
            logger.error(f"Error fetching notifications by type: {str(e)}")
            return []
    
    async def get_grouped_notifications(self, user_id: str, skip: int = 0, limit: int = 20) -> Dict[str, List[Notification]]:
        """유형별로 그룹화된 알림 목록을 반환합니다 (소셜 미디어 스타일)"""
        try:
            return await self.repository.get_grouped_notifications(user_id, skip, limit)
        except Exception as e:
            logger.error(f"Error fetching grouped notifications: {str(e)}")
            return {}


============================================================
File: /home/CVEHub/backend/app/cache/router.py
------------------------------------------------------------
"""
캐시 정보 조회 라우터
"""
from fastapi import APIRouter, Depends, HTTPException, Query
from typing import Dict, List, Any, Optional
import logging
from app.core.cache import get_redis, CACHE_KEY_PREFIXES
import json
import redis as redis_sync
from datetime import datetime
from app.core.config import get_settings
import functools

router = APIRouter(tags=["cache"])
logger = logging.getLogger(__name__)

def cache_api_error_handler(func):
    """캐시 API 엔드포인트 예외 처리 데코레이터"""
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except HTTPException:
            # FastAPI HTTP 예외는 그대로 전달
            raise
        except redis_sync.RedisError as redis_err:
            # Redis 관련 에러는 로깅 후 500 에러로 반환
            logger.error(f"Redis 에러 in {func.__name__}: {str(redis_err)}")
            raise HTTPException(
                status_code=500, 
                detail=f"Redis 서버 오류: {str(redis_err)}"
            )
        except ValueError as val_err:
            # 값 검증 오류
            logger.warning(f"값 검증 오류 in {func.__name__}: {str(val_err)}")
            raise HTTPException(status_code=400, detail=str(val_err))
        except Exception as e:
            # 일반 예외는 서버 오류로 처리
            logger.error(f"Error in {func.__name__}: {str(e)}")
            raise HTTPException(
                status_code=500, 
                detail=f"{func.__name__} 중 오류 발생: {str(e)}"
            )
    return wrapper

@router.get("/info")
@cache_api_error_handler
async def get_cache_info():
    """
    Redis 캐시 서버 정보 조회
    """
    redis = await get_redis()
    info = await redis.info()
    
    # 추가 서버 정보 포맷팅
    server_info = {
        "redis_version": info.get("redis_version", ""),
        "uptime_in_seconds": info.get("uptime_in_seconds", 0),
        "uptime_in_days": info.get("uptime_in_days", 0),
        "connected_clients": info.get("connected_clients", 0),
        "used_memory": info.get("used_memory", 0),
        "used_memory_human": info.get("used_memory_human", ""),
        "used_memory_peak": info.get("used_memory_peak", 0),
        "used_memory_peak_human": info.get("used_memory_peak_human", ""),
        "total_system_memory": info.get("total_system_memory", 0),
        "total_system_memory_human": info.get("total_system_memory_human", ""),
        "maxmemory": info.get("maxmemory", 0),
        "maxmemory_human": info.get("maxmemory_human", ""),
        "maxmemory_policy": info.get("maxmemory_policy", ""),
        "mem_fragmentation_ratio": info.get("mem_fragmentation_ratio", 0),
        "role": info.get("role", ""),
        "os": info.get("os", ""),
        "arch_bits": info.get("arch_bits", ""),
        "process_id": info.get("process_id", 0),
        "tcp_port": info.get("tcp_port", 0),
        "config_file": info.get("config_file", ""),
        "status": "success"
    }
    
    return server_info

@router.get("/stats")
@cache_api_error_handler
async def get_cache_stats():
    """
    Redis 캐시 통계 정보 조회
    """
    redis = await get_redis()
    
    # 기본 통계 정보
    db_size = await redis.dbsize()
    memory_info = await redis.info("memory")
    stats_info = await redis.info("stats")
    
    # 키 타입 분포 계산
    key_types = {"string": 0, "list": 0, "hash": 0, "set": 0, "zset": 0, "stream": 0, "other": 0}
    
    # 각 프리픽스별 키 개수 조회
    key_counts = {}
    for prefix_name, prefix in CACHE_KEY_PREFIXES.items():
        count = 0
        async for _ in redis.scan_iter(match=f"{prefix}*"):
            count += 1
        key_counts[prefix_name] = count
    
    # 샘플링을 위한 키 목록 가져오기 (최대 1000개)
    keys = []
    count = 0
    async for key in redis.scan_iter(match="*"):
        if count < 1000:
            keys.append(key)
            count += 1
        else:
            break
    
    # 샘플링된 키의 타입 분포 계산
    for key in keys:
        key_type = await redis.type(key)
        if key_type in key_types:
            key_types[key_type] += 1
        else:
            key_types["other"] += 1
    
    # 샘플링된 결과를 전체 키 수에 비례하여 추정
    if count > 0 and db_size > 0:
        ratio = db_size / count
        for key_type in key_types:
            key_types[key_type] = int(key_types[key_type] * ratio)
    
    # 명령어 통계
    commands_stats = {
        "total_commands_processed": stats_info.get("total_commands_processed", 0),
        "instantaneous_ops_per_sec": stats_info.get("instantaneous_ops_per_sec", 0),
        "total_connections_received": stats_info.get("total_connections_received", 0),
        "rejected_connections": stats_info.get("rejected_connections", 0),
        "expired_keys": stats_info.get("expired_keys", 0),
        "evicted_keys": stats_info.get("evicted_keys", 0),
        "keyspace_hits": stats_info.get("keyspace_hits", 0),
        "keyspace_misses": stats_info.get("keyspace_misses", 0),
        "hit_rate": stats_info.get("keyspace_hits", 0) / (stats_info.get("keyspace_hits", 0) + stats_info.get("keyspace_misses", 1)) * 100 if (stats_info.get("keyspace_hits", 0) + stats_info.get("keyspace_misses", 0)) > 0 else 0,
    }
    
    # 메모리 통계
    memory_stats = {
        "used_memory": memory_info.get("used_memory", 0),
        "used_memory_human": memory_info.get("used_memory_human", ""),
        "used_memory_rss": memory_info.get("used_memory_rss", 0),
        "used_memory_rss_human": memory_info.get("used_memory_rss_human", ""),
        "used_memory_peak": memory_info.get("used_memory_peak", 0),
        "used_memory_peak_human": memory_info.get("used_memory_peak_human", ""),
        "total_system_memory": memory_info.get("total_system_memory", 0),
        "total_system_memory_human": memory_info.get("total_system_memory_human", ""),
        "maxmemory": memory_info.get("maxmemory", 0),
        "maxmemory_human": memory_info.get("maxmemory_human", ""),
        "maxmemory_policy": memory_info.get("maxmemory_policy", ""),
        "mem_fragmentation_ratio": memory_info.get("mem_fragmentation_ratio", 0),
        "mem_allocator": memory_info.get("mem_allocator", ""),
    }
    
    stats = {
        "status": "success",
        "total_keys": db_size,
        "key_types_distribution": key_types,
        "key_counts": key_counts,
        "commands_stats": commands_stats,
        "memory_stats": memory_stats,
    }
    
    return stats

@router.get("/keys")
@cache_api_error_handler
async def get_cache_keys(
    prefix: Optional[str] = Query(None, description="캐시 키 프리픽스 (예: cve_detail, cve_list)"),
    pattern: Optional[str] = Query("*", description="검색 패턴"),
    limit: int = Query(100, description="최대 조회 개수")
):
    """
    Redis 캐시 키 목록 조회
    """
    redis = await get_redis()
    
    # 프리픽스 적용
    search_pattern = pattern
    if prefix and prefix in CACHE_KEY_PREFIXES:
        search_pattern = f"{CACHE_KEY_PREFIXES[prefix]}{pattern}"
    elif prefix:
        search_pattern = f"{prefix}:{pattern}"
    
    # 키 목록 조회
    keys = []
    count = 0
    async for key in redis.scan_iter(match=search_pattern):
        if count >= limit:
            break
        
        # 키 유형 및 TTL 조회
        key_type = await redis.type(key)
        ttl = await redis.ttl(key)
        
        # 키 크기 계산
        size = 0
        if key_type == "string":
            size = await redis.strlen(key)
        elif key_type == "list":
            size = await redis.llen(key)
        elif key_type == "hash":
            size = await redis.hlen(key)
        elif key_type == "set":
            size = await redis.scard(key)
        elif key_type == "zset":
            size = await redis.zcard(key)
        
        keys.append({
            "key": key,
            "type": key_type,
            "ttl": ttl,
            "size": size
        })
        count += 1
    
    return {
        "status": "success",
        "total": len(keys),
        "keys": keys
    }

@router.get("/values")
@cache_api_error_handler
async def get_cache_values(
    prefix: Optional[str] = Query(None, description="캐시 키 프리픽스 (예: cve_detail, cve_list)"),
    pattern: Optional[str] = Query("*", description="검색 패턴"),
    limit: int = Query(20, description="최대 조회 개수")
):
    """
    Redis 캐시 값 조회
    """
    redis = await get_redis()
    
    # 프리픽스 적용
    search_pattern = pattern
    if prefix and prefix in CACHE_KEY_PREFIXES:
        search_pattern = f"{CACHE_KEY_PREFIXES[prefix]}{pattern}"
    elif prefix:
        search_pattern = f"{prefix}:{pattern}"
    
    # 키 목록 조회
    keys = []
    count = 0
    async for key in redis.scan_iter(match=search_pattern):
        if count >= limit:
            break
        keys.append(key)
        count += 1
    
    # 각 키의 값, 타입, TTL 정보 가져오기
    values = []
    types = []
    ttls = []
    
    for key in keys:
        key_type = await redis.type(key)
        ttl = await redis.ttl(key)
        ttls.append(ttl)
        types.append(key_type)
        
        # 키 타입에 따라 값 가져오기
        if key_type == "string":
            value = await redis.get(key)
            try:
                # JSON 파싱 시도
                value = json.loads(value)
            except (json.JSONDecodeError, TypeError):
                # 일반 문자열
                pass
        elif key_type == "list":
            value = await redis.lrange(key, 0, -1)
        elif key_type == "hash":
            value = await redis.hgetall(key)
        elif key_type == "set":
            value = list(await redis.smembers(key))
        elif key_type == "zset":
            value_pairs = await redis.zrange(key, 0, -1, withscores=True)
            value = {k: v for k, v in value_pairs}
        else:
            value = f"지원되지 않는 타입: {key_type}"
        
        values.append(value)
    
    return {
        "total": len(keys),
        "keys": keys,
        "values": values,
        "types": types,
        "ttls": ttls
    }

@router.get("/value/{key}")
@cache_api_error_handler
async def get_cache_value(key: str):
    """
    특정 Redis 키의 값을 반환합니다.
    """
    redis = await get_redis()
    
    # 키 존재 여부 확인
    if not await redis.exists(key):
        raise HTTPException(status_code=404, detail=f"키를 찾을 수 없습니다: {key}")
    
    key_type = await redis.type(key)
    ttl = await redis.ttl(key)
    
    # 키 타입에 따라 값 가져오기
    if key_type == "string":
        value = await redis.get(key)
        try:
            # JSON 파싱 시도
            value = json.loads(value)
        except (json.JSONDecodeError, TypeError):
            # 일반 문자열
            pass
    elif key_type == "list":
        value = await redis.lrange(key, 0, -1)
    elif key_type == "hash":
        value = await redis.hgetall(key)
    elif key_type == "set":
        value = list(await redis.smembers(key))
    elif key_type == "zset":
        value_pairs = await redis.zrange(key, 0, -1, withscores=True)
        value = {k: v for k, v in value_pairs}
    else:
        value = f"지원되지 않는 타입: {key_type}"
    
    return {
        "key": key,
        "value": value,
        "type": key_type,
        "ttl": ttl
    }

@router.delete("/keys/{key}")
@cache_api_error_handler
async def delete_cache_key(key: str):
    """
    Redis 키를 삭제합니다.
    """
    redis = await get_redis()
    
    # 키 존재 여부 확인
    if not await redis.exists(key):
        raise HTTPException(status_code=404, detail=f"키를 찾을 수 없습니다: {key}")
    
    # 키 삭제
    deleted = await redis.delete(key)
    return {
        "success": deleted > 0,
        "key": key,
        "deleted": deleted
    }

@router.delete("/clear")
@cache_api_error_handler
async def clear_cache(
    prefix: Optional[str] = Query(None, description="캐시 키 프리픽스 (예: cve_detail, cve_list)"),
    pattern: Optional[str] = Query("*", description="삭제할 키 패턴")
):
    """
    Redis 캐시 삭제
    """
    redis = await get_redis()
    
    # 프리픽스 적용
    search_pattern = pattern
    if prefix and prefix in CACHE_KEY_PREFIXES:
        search_pattern = f"{CACHE_KEY_PREFIXES[prefix]}{pattern}"
    elif prefix:
        search_pattern = f"{prefix}:{pattern}"
    
    # 키 목록 조회 및 삭제
    deleted_count = 0
    async for key in redis.scan_iter(match=search_pattern):
        await redis.delete(key)
        deleted_count += 1
    
    return {
        "status": "success",
        "deleted_count": deleted_count
    }



============================================================
File: /home/CVEHub/backend/app/cve/router.py
------------------------------------------------------------
"""
CVE 및 Comment API 라우터 - 모든 CVE 및 댓글 관련 엔드포인트 통합
"""
from fastapi import APIRouter, HTTPException, Query, Path, status, Depends, Response, BackgroundTasks
from typing import Dict, Any, Optional, Union, List
from datetime import datetime
import logging
import traceback
import json
import functools
from pydantic import ValidationError

from app.cve.models import (
    CVEModel, CVEListResponse, CVEDetailResponse, CVEOperationResponse,
    BulkOperationResponse, CVESearchResponse, CreateCVERequest, PatchCVERequest,
    BulkUpsertCVERequest, CommentCreate, CommentUpdate, CommentResponse
)
from app.auth.models import User
from app.cve.service import CVEService
from app.core.dependencies import get_cve_service
from app.auth.service import get_current_user, get_current_admin_user
from app.socketio.manager import socketio_manager, WSMessageType, DateTimeEncoder
from app.core.cache import (
    get_cache, cache_cve_detail, cache_cve_list, 
    invalidate_cve_caches, CACHE_KEY_PREFIXES
)
from app.core.config import get_settings

# 로거 설정
logger = logging.getLogger(__name__)

# 설정 가져오기
settings = get_settings()

# 기본 라우터
router = APIRouter()

# 예외 타입별 HTTP 상태 코드 매핑
exception_status_map = {
    ValidationError: status.HTTP_400_BAD_REQUEST,
    ValueError: status.HTTP_400_BAD_REQUEST,
    KeyError: status.HTTP_404_NOT_FOUND,
    IndexError: status.HTTP_404_NOT_FOUND,
    PermissionError: status.HTTP_403_FORBIDDEN,
    FileNotFoundError: status.HTTP_404_NOT_FOUND,
    NotImplementedError: status.HTTP_501_NOT_IMPLEMENTED,
}

# 예외 타입별 에러 메시지 매핑
exception_message_map = {
    ValidationError: "유효하지 않은 데이터 형식입니다",
    ValueError: "잘못된 값이 제공되었습니다",
    KeyError: "요청한 항목을 찾을 수 없습니다",
    IndexError: "색인이 범위를 벗어났습니다",
    PermissionError: "이 작업을 수행할 권한이 없습니다",
    FileNotFoundError: "파일을 찾을 수 없습니다",
    NotImplementedError: "이 기능은 아직 구현되지 않았습니다",
}

def cve_api_error_handler(func):
    """CVE API 엔드포인트 예외 처리 데코레이터"""
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except HTTPException:
            # FastAPI HTTP 예외는 그대로 전달
            raise
        except Exception as e:
            # 로깅
            endpoint = func.__name__
            logger.error(f"CVE API 오류 ({endpoint}): {str(e)}")
            if "current_user" in kwargs:
                user = kwargs["current_user"]
                logger.error(f"사용자: {user.username} (ID: {user.id})")
                
            # 예외 유형에 따른 상태 코드 결정
            error_status = status.HTTP_500_INTERNAL_SERVER_ERROR
            for exc_type, status_code in exception_status_map.items():
                if isinstance(e, exc_type):
                    error_status = status_code
                    break
                    
            # 예외 유형에 따른 메시지 결정
            base_message = "서버 내부 오류가 발생했습니다"
            for exc_type, message in exception_message_map.items():
                if isinstance(e, exc_type):
                    base_message = message
                    break
            
            # 상세 오류 정보 (개발 환경에서만)
            error_detail = f"{base_message}: {str(e)}"
            if settings.DEBUG:
                error_detail = f"{error_detail}\n{traceback.format_exc()}"
                
            # 표준화된 HTTP 예외 반환
            raise HTTPException(
                status_code=error_status,
                detail=error_detail
            )
    return wrapper

# ----- CVE 기본 엔드포인트 -----

@router.get("/total-count", response_model=dict)
@cve_api_error_handler
async def get_total_cve_count(
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """데이터베이스에 존재하는 전체 CVE 개수를 반환합니다."""
    logger.info(f"사용자 '{current_user.username}'이(가) 전체 CVE 개수 요청")
    count = await cve_service.get_total_cve_count()
    logger.info(f"전체 CVE 개수 조회 완료: {count}")
    return {"count": count}

@router.get("/list", response_model=CVEListResponse)
@cve_api_error_handler
async def get_cve_list(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    severity: Optional[str] = None,
    search: Optional[str] = None,
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """
    CVE 목록을 가져옵니다 (캐싱 적용)
    
    Args:
        page: 페이지 번호 (1부터 시작)
        limit: 페이지당 항목 수
        severity: 심각도 필터
        search: 검색어
        current_user: 현재 인증된 사용자
        cve_service: CVE 서비스 인스턴스
        
    Returns:
        CVE 목록 정보 (total, items, page, limit)
    """
    logger.info(f"사용자 '{current_user.username}'이(가) CVE 목록 요청. 페이지: {page}, 한도: {limit}, 검색어: {search or 'None'}")
    
    # 쿼리 파라미터로 캐시 키 생성
    query_params = {
        "page": page,
        "limit": limit,
        "severity": severity or "",
        "search": search or ""
    }
    
    cache_key = f"{CACHE_KEY_PREFIXES['cve_list']}{page}_{limit}_{severity or 'all'}_{search or 'none'}"
    
    # 캐시에서 먼저 조회
    cached_data = await get_cache(cache_key)
    if cached_data:
        logger.debug(f"캐시에서 CVE 목록 로드: {cache_key}")
        return cached_data
    
    # 캐시에 없으면 DB에서 조회
    start_time = datetime.now()
    result = await cve_service.get_cve_list(
        page=page, 
        limit=limit,
        severity=severity,
        search=search
    )
    
    # 성능 측정 및 로깅
    elapsed_time = (datetime.now() - start_time).total_seconds()
    logger.info(f"CVE 목록 검색 완료. 소요 시간: {elapsed_time:.3f}초, 총 항목: {result.get('total', 0)}")
    
    # 시간 필드 디버깅 로그 추가
    if result.get('items') and len(result['items']) > 0:
        sample_item = result['items'][0]
        if 'created_at' in sample_item:
            logger.debug(f"[시간 디버깅] CVE 목록 첫 항목의 created_at: {sample_item['created_at']} (타입: {type(sample_item['created_at']).__name__})")
        if 'last_modified_at' in sample_item:
            logger.debug(f"[시간 디버깅] CVE 목록 첫 항목의 last_modified_at: {sample_item['last_modified_at']} (타입: {type(sample_item['last_modified_at']).__name__})")
        
        # UTC 시간 변환 테스트
        current_utc = datetime.now().isoformat()
        logger.debug(f"[시간 디버깅] 현재 시간(UTC): {current_utc}")
    
    # 결과 캐싱
    await cache_cve_list(query_params, result)
    
    return result

# ----- CVE 통계 API 엔드포인트 -----

@router.get("/stats", response_model=Dict[str, int])
@cve_api_error_handler
async def get_cve_stats(
    cve_service: CVEService = Depends(get_cve_service)
):
    """CVE 통계 정보를 가져옵니다."""
    logger.info("CVE 통계 정보 요청")
    
    # 통계 계산
    stats = await cve_service.get_cve_stats()
    
    logger.info("CVE 통계 정보 제공 완료")
    return stats

@router.get("/{cve_id}", response_model=CVEDetailResponse)
@cve_api_error_handler
async def get_cve_detail(
    cve_id: str,
    bypass_cache: bool = Query(False, description="캐시를 우회하고 항상 데이터베이스에서 조회합니다."),
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """
    CVE ID로 CVE 상세 정보를 조회합니다.
    
    Args:
        cve_id: 조회할 CVE ID
        bypass_cache: 캐시를 우회할지 여부
        current_user: 현재 인증된 사용자
        cve_service: CVE 서비스 인스턴스
        
    Returns:
        CVE 상세 정보
    """
    # 라우터에서 직접 콘솔에 출력하는 print 로그 추가
    print(f"##### API 라우터: GET /cves/{cve_id} 호출됨, bypass_cache={bypass_cache} #####")
    
    logger.info(f"사용자 '{current_user.username}'이(가) CVE '{cve_id}' 상세 정보 요청")
    
    cache_key = f"{CACHE_KEY_PREFIXES['cve_detail']}{cve_id}"
    
    # 캐시 우회 옵션이 없으면 캐시에서 조회
    if not bypass_cache:
        cached_data = await get_cache(cache_key)
        if cached_data:
            print(f"##### 캐시에서 CVE 상세 정보 로드: {cache_key} #####")
            logger.debug(f"캐시에서 CVE 상세 정보 로드: {cache_key}")
            return cached_data
        else:
            print(f"##### 캐시에 데이터 없음: {cache_key} #####")
    else:
        print(f"##### 캐시 우회 옵션 활성화됨 #####")
    
    # 캐시에 없거나 우회 옵션이 설정된 경우 DB에서 조회
    print(f"##### cve_service.get_cve_detail({cve_id}) 호출 시작 #####")
    result = await cve_service.get_cve_detail(cve_id, include_details=True)
    print(f"##### cve_service.get_cve_detail({cve_id}) 호출 완료, 결과 있음: {result is not None} #####")
    
    # 결과가 None인 경우 404 오류 반환
    if result is None:
        logger.warning(f"CVE '{cve_id}' 정보를 찾을 수 없음")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"CVE ID '{cve_id}'를 찾을 수 없습니다."
        )
    
    # 결과 캐싱
    await cache_cve_detail(cve_id, result)
    
    return result

@router.get("/{cve_id}", response_model=CVEDetailResponse)
@cve_api_error_handler
async def get_cve_detail(
    cve_id: str,
    bypass_cache: bool = Query(False, description="캐시를 우회하고 항상 데이터베이스에서 조회합니다."),
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """CVE ID로 CVE 상세 정보를 조회합니다."""
    # 기존 구현 유지

@router.head("/{cve_id}")
@cve_api_error_handler
async def head_cve(
    cve_id: str,
    cve_service: CVEService = Depends(get_cve_service)
):
    """
    CVE의 메타데이터만 반환하는 HEAD 요청 처리
    클라이언트 캐싱을 위해 Last-Modified 헤더 제공
    """
    cve = await cve_service.get_cve_detail(cve_id, include_details=True)
    if not cve:
        raise HTTPException(status_code=404, detail=f"CVE ID {cve_id} not found")
    
    response = Response()
    
    # Last-Modified 헤더 설정
    if 'last_modified_at' in cve and cve['last_modified_at']:
        last_modified = cve['last_modified_at'].strftime("%a, %d %b %Y %H:%M:%S GMT")
        response.headers["Last-Modified"] = last_modified
    
    return response

@router.post("/", response_model=CVEDetailResponse)
@cve_api_error_handler
async def create_cve(
    cve_data: CreateCVERequest,
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """새로운 CVE를 생성합니다."""
    logger.info(f"CVE 생성 요청: cve_id={cve_data.cve_id}, 사용자={current_user.username}")
    
    # 이미 존재하는 CVE인지 확인 (중복 확인 중 오류가 발생해도 생성 시도를 계속 진행)
    try:
        # 대소문자 구분 없이 정확히 일치하는 CVE 검색
        existing_cve = await cve_service.repository.find_by_cve_id(cve_data.cve_id)
        
        if existing_cve:
            logger.warning(f"중복 CVE 생성 시도: {cve_data.cve_id} (이미 존재함: {existing_cve.cve_id})")
            raise HTTPException(
                status_code=409,
                detail=f"CVE ID {cve_data.cve_id}는 이미 존재합니다."
            )
    except Exception as e:
        if not isinstance(e, HTTPException):
            logger.error(f"중복 CVE 확인 중 오류 발생: {str(e)}")
            # 중복 확인 중 오류가 발생했지만 계속 진행 (생성 시 DB 레벨에서 다시 검증됨)
    
    # 현재 사용자 정보 추가
    creator = current_user.username
    
    # CVE 생성
    cve = await cve_service.create_cve(cve_data, creator)
    if not cve:
        raise HTTPException(
            status_code=500,
            detail="CVE 생성 중 오류가 발생했습니다."
        )
        
    # 모델을 딕셔너리로 변환
    cve_dict = cve.dict() if hasattr(cve, 'dict') else cve
    
    # id 필드가 문자열인지 확인하고 아니면 변환
    if 'id' in cve_dict and cve_dict['id'] is not None and not isinstance(cve_dict['id'], str):
        logger.debug(f"id 필드 타입 변환: {type(cve_dict['id'])} -> str")
        cve_dict['id'] = str(cve_dict['id'])
    
    # 소켓 알림 전송
    await send_cve_notification("add", cve_dict)
    
    # 캐시 무효화
    await invalidate_cve_caches(cve_data.cve_id)
    
    return cve_dict

@router.patch("/{cve_id}", response_model=CVEDetailResponse)
@cve_api_error_handler
async def update_cve(
    cve_id: str,
    update_data: PatchCVERequest,
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """기존 CVE를 수정합니다."""
    logger.info(f"CVE 업데이트 요청: cve_id={cve_id}, 사용자={current_user.username}")
    logger.debug(f"업데이트 요청 데이터: {update_data.dict(exclude_unset=True)}")
    
    # cve_id 형식 확인 로깅
    is_object_id = len(cve_id) == 24 and all(c in '0123456789abcdef' for c in cve_id)
    is_cve_format = cve_id.startswith("CVE-") and len(cve_id) > 4
    logger.debug(f"cve_id 형식: {cve_id}, ObjectId 형식: {is_object_id}, CVE 형식: {is_cve_format}")
    
    # CVE 존재 확인
    existing_cve = await cve_service.get_cve_detail(cve_id, include_details=True)
    if not existing_cve:
        logger.warning(f"업데이트할 CVE를 찾을 수 없음: {cve_id}")
        
        # 다른 방식으로 조회 시도
        if is_cve_format:
            logger.debug(f"대소문자 구분 없이 조회 시도")
            try:
                # 대소문자 구분 없이 조회 시도
                alt_cve = await cve_service.get_cve_detail(cve_id, include_details=True)
                if alt_cve:
                    logger.info(f"대소문자 구분 없이 CVE 찾음: {alt_cve.get('cve_id', '')}")
                    existing_cve = alt_cve
            except Exception as e:
                logger.error(f"대소문자 구분 없이 조회 중 오류: {str(e)}")
        
        if not existing_cve:
            error_msg = f"CVE ID {cve_id}를 찾을 수 없습니다."
            logger.error(error_msg)
            raise HTTPException(
                status_code=404,
                detail=error_msg
            )
    
    logger.debug(f"기존 CVE 정보: id={existing_cve.get('id', '')}, cve_id={existing_cve.get('cve_id', '')}")
    
    # 업데이트 데이터 준비
    update_dict = update_data.dict(exclude_unset=True)
    logger.debug(f"업데이트 데이터 (필터링 후): {update_dict}")
    
    # 업데이트된 필드 추적
    updated_fields = list(update_dict.keys())
    field_key = "general"  # 기본값
    
    # 특정 필드 업데이트 감지
    if len(updated_fields) == 1:
        if "pocs" in updated_fields:
            field_key = "poc"
        elif "snort_rules" in updated_fields:
            field_key = "snortRules"
        elif "references" in updated_fields:
            field_key = "references"
        elif "status" in updated_fields:
            field_key = "status"
        elif "title" in updated_fields:
            field_key = "title"
        elif "comments" in updated_fields:
            field_key = "comments"
    
    # 업데이트 처리
    updated_cve = await cve_service.update_cve(
        cve_id=cve_id,
        update_data=update_dict,
        updated_by=current_user.username
    )
    
    if not updated_cve:
        error_msg = f"CVE ID {cve_id} 업데이트 실패"
        logger.error(error_msg)
        raise HTTPException(
            status_code=500,
            detail=error_msg
        )
    
    logger.info(f"CVE 업데이트 성공: {cve_id}, 업데이트된 필드: {field_key}")
    
    # 소켓 알림 전송 - 업데이트된 필드 정보 포함
    await send_cve_notification("update", updated_cve, field_key=field_key, updated_fields=updated_fields)
    
    # 캐시 무효화
    await invalidate_cve_caches(cve_id)
    
    return updated_cve

@router.delete("/{cve_id}", response_model=CVEOperationResponse)
@cve_api_error_handler
async def delete_cve(
    cve_id: str,
    current_user: User = Depends(get_current_admin_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """CVE를 삭제합니다 (관리자 전용)."""
    logger.info(f"사용자 '{current_user.username}'이(가) CVE '{cve_id}' 삭제 요청")
    
    deleted = await cve_service.delete_cve(cve_id)
    if not deleted:
        raise HTTPException(
            status_code=404,
            detail=f"CVE ID {cve_id}를 찾을 수 없습니다."
        )
    
    # 소켓 알림 전송
    await send_cve_notification("delete", cve_id=cve_id)
    
    # 캐시 무효화
    await invalidate_cve_caches(cve_id)
    
    logger.info(f"CVE '{cve_id}' 삭제 완료")
    return {"success": True, "message": f"CVE ID {cve_id}가 삭제되었습니다."}

# ----- 댓글 관련 엔드포인트 -----

@router.post("/{cve_id}/comments", response_model=CommentResponse, status_code=status.HTTP_201_CREATED)
@cve_api_error_handler
async def create_comment(
    cve_id: str,
    comment_data: CommentCreate,
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """새 댓글을 생성합니다."""
    logger.info(f"CVE {cve_id}에 사용자 {current_user.username}의 댓글 생성")
    
    comment, message = await cve_service.create_comment(
        cve_id=cve_id,
        content=comment_data.content,
        user=current_user,
        parent_id=comment_data.parent_id,
        mentions=comment_data.mentions
    )
    
    if not comment:
        logger.error(f"댓글 생성 실패: {message}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)
    
    logger.info(f"댓글 생성 성공: {comment.id}")
    return comment

@router.put("/{cve_id}/comments/{comment_id}", response_model=CommentResponse)
@cve_api_error_handler
async def update_comment(
    cve_id: str,
    comment_id: str,
    comment_data: CommentUpdate,
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """댓글을 수정합니다."""
    logger.info(f"CVE {cve_id}의 댓글 {comment_id} 사용자 {current_user.username}에 의한 수정")
    
    comment, message = await cve_service.update_comment(
        cve_id=cve_id,
        comment_id=comment_id,
        content=comment_data.content,
        user=current_user
    )
    
    if not comment:
        logger.error(f"댓글 수정 실패: {message}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)
    
    logger.info(f"댓글 수정 성공: {comment_id}")
    return comment

@router.delete("/{cve_id}/comments/{comment_id}", status_code=status.HTTP_204_NO_CONTENT)
@cve_api_error_handler
async def delete_comment(
    cve_id: str,
    comment_id: str,
    permanent: bool = False,
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """댓글을 삭제합니다."""
    logger.info(f"CVE {cve_id}의 댓글 {comment_id} 사용자 {current_user.username}에 의한 삭제")
    
    success, message = await cve_service.delete_comment(
        cve_id=cve_id,
        comment_id=comment_id,
        user=current_user,
        permanent=permanent
    )
    
    if not success:
        logger.error(f"댓글 삭제 실패: {message}")
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)
    
    logger.info(f"댓글 삭제 성공: {comment_id}")
    return {"message": "댓글이 성공적으로 삭제되었습니다."}

@router.get("/{cve_id}/comments", response_model=List[CommentResponse])
@cve_api_error_handler
async def get_comments(
    cve_id: str,
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """CVE의 모든 댓글을 조회합니다."""
    logger.info(f"CVE {cve_id}의 댓글 조회")
    
    comments = await cve_service.get_comments(cve_id)
    
    logger.info(f"CVE {cve_id}의 댓글 {len(comments)}개 조회됨")
    return comments

@router.get("/{cve_id}/comments/count", response_model=int)
@cve_api_error_handler
async def get_comment_count(
    cve_id: str,
    current_user: User = Depends(get_current_user),
    cve_service: CVEService = Depends(get_cve_service)
):
    """CVE의 활성화된 댓글 수를 반환합니다."""
    logger.info(f"CVE {cve_id}의 댓글 수 요청")
    
    count = await cve_service.count_active_comments(cve_id)
    
    logger.info(f"CVE {cve_id}의 댓글 수: {count}")
    return count

# ----- WebSocket 알림 전송 유틸리티 함수 -----

async def send_cve_notification(type: str, cve: Optional[Union[CVEModel, Dict[str, Any]]] = None, cve_id: Optional[str] = None, message: Optional[str] = None, field_key: Optional[str] = None, updated_fields: Optional[list] = None):
    """WebSocket을 통해 CVE 관련 알림을 전송합니다."""
    try:
        if type == "add" or type == "update":
            if cve:
                # cve_id 추출 (객체 또는 딕셔너리에서)
                if hasattr(cve, "cve_id"):
                    # CVEModel 객체인 경우
                    notification_cve_id = cve.cve_id
                    cve_data = json.loads(json.dumps(cve.dict(), cls=DateTimeEncoder))
                elif isinstance(cve, dict) and "cve_id" in cve:
                    # 딕셔너리인 경우
                    notification_cve_id = cve["cve_id"]
                    cve_data = json.loads(json.dumps(cve, cls=DateTimeEncoder))
                else:
                    # cve_id를 직접 사용
                    notification_cve_id = cve_id
                    cve_data = cve
                
                data = {
                    "event": f"cve_{type}d",  # "cve_added" 또는 "cve_updated"
                    "cve_id": notification_cve_id,
                    "data": cve_data,
                    "timestamp": datetime.now().isoformat()
                }
                
                if field_key:
                    data["field_key"] = field_key
                if updated_fields:
                    data["updated_fields"] = updated_fields
                
                if type == "add":
                    message_type = WSMessageType.CVE_CREATED
                else:
                    message_type = WSMessageType.CVE_UPDATED
                    
                await socketio_manager.broadcast_cve_update(
                    cve_id=data["cve_id"],
                    data=data,
                    event_type=message_type
                )
                logger.info(f"Sent WebSocket notification: {type} for CVE {data['cve_id']}")
                
        elif type == "delete":
            data = {
                "event": "cve_deleted",
                "cve_id": cve_id,
                "message": message or f"CVE {cve_id} deleted",
                "timestamp": datetime.now().isoformat()
            }
            
            await socketio_manager.broadcast_cve_update(
                cve_id=cve_id,
                data=data,
                event_type=WSMessageType.CVE_DELETED
            )
            logger.info(f"Sent WebSocket notification: delete for CVE {cve_id}")
            
    except Exception as e:
        logger.error(f"Error sending WebSocket notification: {str(e)}")
        logger.error(traceback.format_exc())



============================================================
File: /home/CVEHub/backend/app/cve/repository.py
------------------------------------------------------------
from typing import List, Optional, Dict, Any, Union, Tuple
from datetime import datetime
from beanie import PydanticObjectId
from ..common.repositories.base import BaseRepository
from .models import CVEModel, CreateCVERequest, PatchCVERequest
from app.database import get_database
from fastapi.logger import logger
from bson import ObjectId
import traceback
import functools
import time
import re

def log_db_operation(operation_name):
    """
    데이터베이스 작업을 로깅하는 데코레이터
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(self, *args, **kwargs):
            start_time = time.perf_counter()
            try:
                result = await func(self, *args, **kwargs)
                elapsed = time.perf_counter() - start_time
                logger.info(f"{operation_name} 완료: 소요 시간 {elapsed:.4f}초")
                return result
            except Exception as e:
                elapsed = time.perf_counter() - start_time
                logger.error(f"{operation_name} 실패: {str(e)} (소요 시간 {elapsed:.4f}초)")
                raise
        return wrapper
    return decorator

class CVERepository(BaseRepository[CVEModel, CreateCVERequest, PatchCVERequest]):
    def __init__(self):
        super().__init__(CVEModel)
        self.db = get_database()
        self.collection = self.db.get_collection("cves")

    @log_db_operation("CVE 프로젝션 조회")
    async def find_with_projection(
        self, 
        query: Dict[str, Any], 
        projection: Dict[str, Any], 
        skip: int = 0, 
        limit: int = 10,
        sort: List[tuple] = None
    ) -> List[Dict[str, Any]]:
        """
        지정된 projection을 사용하여 CVE를 검색합니다.
        
        Args:
            query: 검색 쿼리
            projection: 반환할 필드 (1:포함, 0:제외)
            skip: 건너뛸 문서 수
            limit: 반환할 최대 문서 수
            sort: 정렬 기준 (필드명, 방향) 튜플 리스트
            
        Returns:
            List[Dict[str, Any]]: 조회된 CVE 목록
        """
        try:
            # Beanie ORM의 projection 메소드 대신 모터 컬렉션을 직접 사용
            collection = self.model.get_motor_collection()
            
            # 정렬 조건 변환
            sort_list = None
            if sort:
                sort_list = []
                for field, direction in sort:
                    sort_list.append((field, direction))
            
            # _id 필드는 제외하고 cve_id 필드를 포함시킴
            if "_id" in projection and projection["_id"] == 1:
                # _id 필드 제외
                projection.pop("_id")
            
            # cve_id 필드가 없으면 추가
            if "cve_id" not in projection:
                projection["cve_id"] = 1
                
            # 모터 컬렉션을 사용하여 쿼리 실행
            cursor = collection.find(query, projection=projection)
            
            if skip > 0:
                cursor = cursor.skip(skip)
            
            if limit > 0:
                cursor = cursor.limit(limit)
                
            if sort_list:
                cursor = cursor.sort(sort_list)
            
            # 결과를 문서 리스트로 변환
            result_docs = await cursor.to_list(length=limit)
            
            # 결과 반환 - 응답 모델 요구사항에 맞게 데이터 가공
            result = []
            for doc in result_docs:
                # _id 필드 제거 (MongoDB가 자동으로 추가한 경우)
                if '_id' in doc:
                    doc.pop('_id')
                
                # 날짜 필드 디버깅 - 특정 CVE ID에 대해서만 로그 출력
                cve_id = doc.get('cve_id', '알 수 없음')
                if cve_id and 'CVE-2023-' in cve_id:
                    if 'created_at' in doc:
                        logger.info(f"[Repository] CVE ID: {cve_id}, created_at 필드: {doc['created_at']}, 타입: {type(doc['created_at'])}")
                    else:
                        logger.warning(f"[Repository] CVE ID: {cve_id}, created_at 필드 없음")
                    
                    if 'last_modified_at' in doc:
                        logger.info(f"[Repository] CVE ID: {cve_id}, last_modified_at 필드: {doc['last_modified_at']}, 타입: {type(doc['last_modified_at'])}")
                    else:
                        logger.warning(f"[Repository] CVE ID: {cve_id}, last_modified_at 필드 없음")
                
                # 결과 문서 추가
                result.append(doc)
                
            return result
        except Exception as e:
            logger.error(f"find_with_projection 중 오류 발생: {e}")
            raise

    @log_db_operation("CVE 검색")
    async def search_cves(self, query: str, skip: int = 0, limit: int = 10) -> List[CVEModel]:
        """CVE를 검색합니다."""
        search_query = {
            "$or": [
                {"cve_id": {"$regex": query, "$options": "i"}},
                {"title": {"$regex": query, "$options": "i"}},
                {"description": {"$regex": query, "$options": "i"}}
            ]
        }
        return await self.model.find(search_query).skip(skip).limit(limit).to_list()
            
    @log_db_operation("CVE ID로 조회")
    async def find_by_cve_id(self, cve_id: str) -> Optional[CVEModel]:
        """CVE ID 문자열로 CVE를 조회합니다 (대소문자 구분 없음)."""
        try:           
            # 정규식을 사용하여 대소문자 구분 없이 검색
            query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}}
            document = await self.collection.find_one(query)
            
            if not document:
                return None
                
            # 모델로 변환
            try:
                return CVEModel(**document)
            except Exception as validation_error:
                logger.error(f"CVE 모델 변환 중 검증 오류: {str(validation_error)}")
                # 오류 세부 정보 로깅
                for error in getattr(validation_error, 'errors', []):
                    logger.error(f"검증 오류 상세: {error}")
                return None
        except Exception as e:
            logger.error(f"CVE ID 조회 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return None
            
    @log_db_operation("CVE ID로 투영 조회")
    async def find_by_cve_id_with_projection(self, cve_id: str, projection: Dict[str, Any]) -> Optional[CVEModel]:
        """
        CVE ID로 CVE를 조회하되, 지정된 필드만 가져옵니다.
        
        Args:
            cve_id: 조회할 CVE ID
            projection: 가져올 필드 (MongoDB projection 형식)
            
        Returns:
            Optional[CVEModel]: 조회된 CVE 모델 또는 None
        """
        try:
            # 대소문자 구분 없이 검색 (MongoDB $regex 사용)
            query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}}
            document = await self.collection.find_one(query, projection)
            
            if not document:
                return None
                
            try:
                return CVEModel(**document)
            except Exception as validation_error:
                logger.error(f"CVE 모델 변환 중 검증 오류 (projection): {str(validation_error)}")
                # 불완전한 모델을 handling하기 위한 추가 로직
                # _id 필드는 항상 포함되는지 확인
                if "_id" not in document and projection.get("_id", 1) != 0:
                    document["_id"] = PydanticObjectId()
                
                # 필수 필드가 없는 경우 기본값 추가
                base_fields = {
                    "cve_id": cve_id,
                    "title": document.get("title", ""),
                    "severity": document.get("severity", "Unknown"),
                    "status": document.get("status", "Unknown")
                }
                
                # 누락된 필요 필드 추가
                for field, default in base_fields.items():
                    if field not in document:
                        document[field] = default
                
                try:
                    return CVEModel(**document)
                except Exception as e:
                    logger.error(f"CVE 모델 변환 재시도 실패: {str(e)}")
                    return None
        except Exception as e:
            logger.error(f"CVE ID projection 조회 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return None

    @log_db_operation("상태별 CVE 조회")
    async def get_by_status(self, status: str, skip: int = 0, limit: int = 10) -> List[CVEModel]:
        """상태별로 CVE를 조회합니다."""
        return await self.model.find({"status": status}).skip(skip).limit(limit).to_list()
    
    @log_db_operation("문서 업데이트")
    async def update_document(self, 
                           cve_id: str, 
                           update_data: Dict[str, Any],
                           update_type: str = "set") -> Optional[CVEModel]:
        """
        통합 업데이트 메서드 - 다양한 업데이트 유형 지원
        
        Args:
            cve_id: 업데이트할 CVE ID
            update_data: 업데이트할 데이터
            update_type: 업데이트 유형 (set, push, pull 등)
            
        Returns:
            Optional[CVEModel]: 업데이트된 CVE 모델 또는 None
        """
        try:
            query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}}
            
            # 업데이트 작업 유형에 따른 MongoDB 연산자 결정
            update_op = {f"${update_type}": update_data}
            
            result = await self.collection.update_one(query, update_op)
            
            if result.matched_count == 0:
                logger.warning(f"업데이트할 CVE를 찾을 수 없음: {cve_id}")
                return None
                
            if result.modified_count == 0:
                logger.info(f"CVE {cve_id}에 변경사항이 없음")
                
            # 업데이트된 문서 반환
            return await self.find_by_cve_id(cve_id)
        except Exception as e:
            logger.error(f"CVE 업데이트 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    @log_db_operation("특정 필드 업데이트")
    async def update_field(self, cve_id: str, field: str, value: Any) -> bool:
        """
        CVE의 특정 필드만 업데이트합니다.
        
        Args:
            cve_id: 업데이트할 CVE ID
            field: 업데이트할 필드명
            value: 새 값
            
        Returns:
            bool: 업데이트 성공 여부
        """
        try:
            update_data = {field: value}
            result = await self.update_document(cve_id, update_data)
            return result is not None
        except Exception as e:
            logger.error(f"CVE 필드 업데이트 중 오류 발생: {str(e)}")
            return False

    @log_db_operation("다중 필드 업데이트")
    async def update_fields(self, cve_id: str, fields: Dict[str, Any]) -> bool:
        """
        CVE의 여러 필드를 한 번에 업데이트합니다.
        
        Args:
            cve_id: 업데이트할 CVE ID
            fields: 업데이트할 필드와 값 (예: {"status": "분석중", "severity": "High"})
            
        Returns:
            bool: 업데이트 성공 여부
        """
        try:
            result = await self.update_document(cve_id, fields)
            return result is not None
        except Exception as e:
            logger.error(f"CVE 다중 필드 업데이트 중 오류 발생: {str(e)}")
            return False

    @log_db_operation("CVE 존재 확인")
    async def check_cve_exists(self, cve_id: str) -> bool:
        """
        CVE ID가 데이터베이스에 이미 존재하는지 확인합니다.
        
        Args:
            cve_id: 확인할 CVE ID
            
        Returns:
            bool: CVE ID가 존재하면 True, 아니면 False
        """
        try:
            # 성능 향상을 위해 전체 문서가 아닌 ID만 확인
            query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}}
            result = await self.collection.find_one(query, {"_id": 1})
            return result is not None
        except Exception as e:
            logger.error(f"CVE 존재 확인 중 오류 발생: {str(e)}")
            return False

    @log_db_operation("댓글 추가")
    async def add_comment(self, cve_id: str, comment_data: dict) -> Optional[CVEModel]:
        """CVE에 댓글을 추가합니다."""
        try:
            result = await self.update_document(cve_id, {"comments": comment_data}, update_type="push")
            return result
        except Exception as e:
            logger.error(f"댓글 추가 중 오류 발생: {str(e)}")
            return None

    @log_db_operation("댓글 업데이트")
    async def update_comment(self, cve_id: str, comment_id: str, comment_data: dict) -> Optional[CVEModel]:
        """CVE의 댓글을 수정합니다."""
        try:
            # 특정 댓글 찾기 위한 조건과 업데이트 필드 설정
            query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}, 
                    "comments.id": comment_id}
            
            update_fields = {}
            for field, value in comment_data.items():
                update_fields[f"comments.$.{field}"] = value
            
            # MongoDB 업데이트 실행
            result = await self.collection.update_one(query, {"$set": update_fields})
            
            if result.matched_count == 0:
                logger.warning(f"업데이트할 댓글을 찾을 수 없음: {comment_id}")
                return None
                
            # 업데이트된 CVE 반환
            return await self.find_by_cve_id(cve_id)
        except Exception as e:
            logger.error(f"댓글 업데이트 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return None

    @log_db_operation("댓글 삭제")
    async def delete_comment(self, cve_id: str, comment_id: str, permanent: bool = False) -> Optional[CVEModel]:
        """CVE의 댓글을 삭제합니다."""
        try:
            if permanent:
                # 완전 삭제 - $pull 연산자 사용
                query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}}
                result = await self.collection.update_one(
                    query, 
                    {"$pull": {"comments": {"id": comment_id}}}
                )
            else:
                # 소프트 삭제 - 해당 댓글만 업데이트
                return await self.update_comment(cve_id, comment_id, {
                    "is_deleted": True,
                    "last_modified_at": datetime.now()
                })
            
            if result.matched_count == 0:
                logger.warning(f"삭제할 댓글을 찾을 수 없음: {comment_id}")
                return None
                
            # 업데이트된 CVE 반환
            return await self.find_by_cve_id(cve_id)
        except Exception as e:
            logger.error(f"댓글 삭제 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return None

    @log_db_operation("CVE ID로 업데이트")
    async def update_by_cve_id(self, cve_id: str, update_data: dict) -> Optional[CVEModel]:
        """
        CVE ID를 사용하여 CVE를 업데이트합니다.
        
        Args:
            cve_id: 업데이트할 CVE의 CVE ID (예: "CVE-2023-1234")
            update_data: 업데이트할 데이터
            
        Returns:
            Optional[CVEModel]: 업데이트된 CVE 모델 또는 None
        """
        try:
            # 새로운 update_document 메서드 사용
            return await self.update_document(cve_id, update_data)
        except Exception as e:
            logger.error(f"CVE 업데이트 중 오류 발생: {str(e)}")
            return None

    @log_db_operation("PoC 추가")
    async def add_poc(self, cve_id: str, poc_data: dict) -> Optional[CVEModel]:
        """CVE에 PoC를 추가합니다."""
        try:
            return await self.update_document(cve_id, {"pocs": poc_data}, update_type="push")
        except Exception as e:
            logger.error(f"PoC 추가 중 오류 발생: {str(e)}")
            return None

    @log_db_operation("Snort Rule 추가")
    async def add_snort_rule(self, cve_id: str, rule_data: dict) -> Optional[CVEModel]:
        """CVE에 Snort Rule을 추가합니다."""
        try:
            return await self.update_document(cve_id, {"snort_rules": rule_data}, update_type="push")
        except Exception as e:
            logger.error(f"Snort Rule 추가 중 오류 발생: {str(e)}")
            return None

    @log_db_operation("업데이트")
    async def update(self, cve_id: str, update_data: dict) -> bool:
        """
        CVE 정보 업데이트 - 하위 호환성 유지
        """
        try:
            logger.info(f"CVE 업데이트 시도: {cve_id}")
            
            # _id 필드가 있으면 제거 (MongoDB에서 _id는 변경 불가)
            if '_id' in update_data:
                logger.warning(f"업데이트 데이터에서 _id 필드 제거: {update_data['_id']}")
                update_data = update_data.copy()  # 원본 데이터 변경 방지
                del update_data['_id']
            
            # 통합 update_document 메서드 사용
            result = await self.update_document(cve_id, update_data)
            return result is not None
        except Exception as e:
            logger.error(f"CVE 업데이트 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    @log_db_operation("문서 교체")
    async def replace(self, cve_id: str, data: dict) -> bool:
        """CVE 문서 전체 교체 (사용하지 않음)"""
        try:
            # MongoDB replace_one 실행
            logger.info(f"CVE replace 시도: {cve_id}")
            
            # 데이터 복사본 생성
            data_copy = data.copy()
            
            # _id 필드 제거 (MongoDB가 자동으로 처리하도록)
            if '_id' in data_copy:
                logger.warning(f"replace 데이터에서 _id 필드 제거: {data_copy['_id']}")
                del data_copy['_id']
            
            # 쿼리 조건 설정
            query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}}
            
            # 문서가 존재하는지 확인
            doc = await self.collection.find_one(query)
            if not doc:
                logger.warning(f"replace: 문서를 찾을 수 없음: {cve_id}")
                return False
            
            # 기존 _id 유지
            if '_id' in doc:
                data_copy['_id'] = doc['_id']
            
            result = await self.collection.replace_one(
                query, 
                data_copy,
                upsert=False  # 문서가 없으면 생성하지 않음
            )
            
            logger.info(f"Replace 결과: matched={result.matched_count}, modified={result.modified_count}")
            return result.modified_count > 0
        except Exception as e:
            logger.error(f"CVE replace 중 오류: {str(e)}", exc_info=True)
            # 디버깅을 위한 JSON 덤프 시도
            try:
                import json
                logger.error(f"데이터 구조: {json.dumps(data)[:1000]}...")
            except:
                pass
            raise 

    @log_db_operation("Snort Rule 삭제")
    async def delete_snort_rule(self, cve_id: str, rule_id: str) -> Optional[CVEModel]:
        """CVE의 Snort Rule을 삭제합니다."""
        try:
            query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}}
            pull_query = {"$pull": {"snort_rules": {"id": rule_id}}}
            
            result = await self.collection.update_one(query, pull_query)
            
            if result.matched_count == 0:
                logger.warning(f"삭제할 Snort Rule을 찾을 수 없음: {rule_id}")
                return None
                
            # 업데이트된 CVE 반환
            return await self.find_by_cve_id(cve_id)
        except Exception as e:
            logger.error(f"Snort Rule 삭제 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return None
        
    @log_db_operation("CVE 삭제")
    async def delete_by_cve_id(self, cve_id: str) -> bool:
        """
        CVE ID를 사용하여 CVE를 삭제합니다.
        
        Args:
            cve_id: 삭제할 CVE의 CVE ID (예: "CVE-2023-1234")
            
        Returns:
            bool: 삭제 성공 여부
        """
        try:
            # 대소문자 구분 없는 삭제 쿼리
            query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}}
            result = await self.collection.delete_one(query)
            
            if result.deleted_count == 0:
                logger.warning(f"삭제할 CVE를 찾을 수 없음: {cve_id}")
                return False
                
            logger.info(f"CVE 삭제 성공: {cve_id}")
            return True
        except Exception as e:
            logger.error(f"CVE 삭제 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            return False


============================================================
File: /home/CVEHub/backend/app/cve/utils.py
------------------------------------------------------------
from typing import Dict, List, Optional, Any
from datetime import datetime
from .models import CVEModel, Reference, ModificationHistory
from app.common.utils.datetime_utils import get_utc_now

def create_reference(
    url: str,
    type: str = "OTHER",
    description: str = "",
    creator: str = "SYSTEM",
) -> Dict[str, Any]:
    """
    참조 링크(Reference) 객체를 생성합니다.
    
    Args:
        url (str): 참조 URL
        type (str): 참조 유형 (기본값: 'OTHER')
        description (str): 참조 설명
        creator (str): 생성자/추가자 이름
    
    Returns:
        Dict[str, Any]: Reference 모델에 맞는 딕셔너리
    """
    now = get_utc_now()
    return {
        "url": url,
        "type": type,
        "description": description,
        "created_at": now,
        "created_by": creator,
        "last_modified_at": now,
        "last_modified_by": creator
    }

def create_change_record(
    field: str,
    field_name: str,
    action: str,
    summary: str,
    old_value: Any = None,
    new_value: Any = None
) -> Dict[str, Any]:
    """
    변경 기록(Change) 객체를 생성합니다.
    
    Args:
        field (str): 변경된 필드 이름 (코드용)
        field_name (str): 변경된 필드 표시 이름 (사용자용)
        action (str): 변경 작업 유형 ('add', 'update', 'delete')
        summary (str): 변경 요약
        old_value (Any, optional): 이전 값
        new_value (Any, optional): 새 값
    
    Returns:
        Dict[str, Any]: Change 모델에 맞는 딕셔너리
    """
    return {
        "field": field,
        "field_name": field_name,
        "action": action,
        "summary": summary,
        "old_value": old_value,
        "new_value": new_value
    }

def create_basic_cve_data(
    cve_id: str,
    title: Optional[str] = None,
    description: Optional[str] = None,
    severity: str = "unknown",
    source: str = "SYSTEM",
    creator: str = "SYSTEM",
) -> Dict[str, Any]:
    """
    크롤러용 기본 CVE 데이터를 생성합니다.
    
    Args:
        cve_id (str): CVE ID
        title (str, optional): 제목
        description (str, optional): 설명
        severity (str, optional): 심각도
        source (str, optional): 데이터 소스
        creator (str, optional): 생성자
    
    Returns:
        Dict[str, Any]: 기본 CVE 데이터
    """
    now = get_utc_now()
    
    # 초기 변경 이력 생성
    initial_change = create_change_record(
        field="cve_id",
        field_name="CVE ID",
        action="add",
        summary=f"CVE {cve_id} 생성됨",
        new_value=cve_id
    )
    
    initial_history = {
        "username": creator,
        "modified_at": now,
        "changes": [initial_change]
    }
    
    return {
        "cve_id": cve_id,
        "title": title or cve_id,  # 제목이 없으면 CVE ID 사용
        "description": description or "",
        "severity": severity,
        "status": "신규등록",  # 기본 상태
        "source": source,
        "created_at": now,
        "last_modified_at": now,
        "created_by": creator,
        "last_modified_by": creator,
        "modification_history": [initial_history]
    }



============================================================
File: /home/CVEHub/backend/app/cve/models.py
------------------------------------------------------------
"""
CVE 및 Comment를 위한 통합 모델 및 스키마
모델: 데이터베이스 구조 정의
스키마: API 요청 및 응답 형식 정의
"""
from datetime import datetime
from typing import List, Optional, Literal, Any, Dict, Union
from beanie import Document, PydanticObjectId
from pydantic import BaseModel, Field, validator
from zoneinfo import ZoneInfo
import re
from bson import ObjectId
from app.common.models.base_models import BaseDocument, BaseSchema, TimestampMixin

# ---------- 유틸리티 함수 ----------

def serialize_datetime(dt):
    """datetime 객체를 ISO 8601 형식의 문자열로 직렬화"""
    if not dt:
        return None
    return dt.replace(tzinfo=ZoneInfo("UTC")).isoformat().replace('+00:00', 'Z')


# ---------- 임베디드 모델 (기본 Pydantic 모델) ----------

class Reference(BaseModel):
    """참조 정보 모델"""
    url: str = Field(..., description="참조 URL")
    type: str = Field(default="OTHER", description="참조 타입")
    description: Optional[str] = Field(None, description="참조 설명")
    created_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    created_by: str = Field(..., description="추가한 사용자")
    last_modified_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    last_modified_by: str = Field(..., description="마지막 수정자")
    
    class Config:
        json_encoders = {
            datetime: serialize_datetime
        }

class PoC(BaseModel):
    """PoC(Proof of Concept) 모델"""
    source: str = Field(..., description="PoC 소스")
    url: str = Field(..., description="PoC URL")
    description: Optional[str] = Field(None, description="PoC 설명")
    created_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    created_by: str = Field(..., description="추가한 사용자")
    last_modified_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    last_modified_by: str = Field(..., description="마지막 수정자")
    
    class Config:
        json_encoders = {
            datetime: serialize_datetime
        }

class SnortRule(BaseModel):
    """Snort Rule 모델"""
    rule: str = Field(..., description="Snort Rule 내용")
    type: str = Field(..., description="Rule 타입")
    description: Optional[str] = Field(None, description="Rule 설명")
    created_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    created_by: str = Field(..., description="추가한 사용자")
    last_modified_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    last_modified_by: str = Field(..., description="마지막 수정자")
    
    class Config:
        json_encoders = {
            datetime: serialize_datetime
        }

class Comment(BaseModel):
    """댓글 모델 - CVE에 임베디드됨"""
    id: str = Field(default_factory=lambda: str(ObjectId()))
    content: str
    created_by: str = Field(..., description="작성자 이름")
    parent_id: Optional[str] = None
    depth: int = 0
    is_deleted: bool = False
    created_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    last_modified_at: Optional[datetime] = None
    last_modified_by: Optional[str] = None
    mentions: List[str] = []
    
    class Config:
        json_encoders = {
            datetime: serialize_datetime
        }
    
    @classmethod
    def extract_mentions(cls, content: str) -> List[str]:
        """댓글 내용에서 멘션된 사용자명을 추출"""
        if not content:
            return []
        MENTION_PATTERN = re.compile(r'@(\w+)')
        matches = MENTION_PATTERN.findall(content)
        return [f"@{username}" for username in set(matches)]

class ChangeItem(BaseModel):
    """변경 사항을 표현하는 모델"""
    field: str  # 변경된 필드명
    field_name: str  # 필드의 한글명
    action: Literal["add", "edit", "delete"]  # 변경 유형
    detail_type: Literal["simple", "detailed"] = "detailed"  # 변경 내역 표시 방식
    before: Optional[Any] = None  # 변경 전 값
    after: Optional[Any] = None  # 변경 후 값
    items: Optional[List[dict]] = None  # 컬렉션 타입 필드의 변경 항목들
    summary: str  # 변경 요약

class ModificationHistory(BaseModel):
    """변경 이력 모델"""
    username: str  # 수정한 사용자 이름
    modified_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    changes: List[ChangeItem] = []


# ---------- 요청 모델 (API 입력) ----------

class CommentCreate(BaseSchema):
    """댓글 생성 요청 모델"""
    content: str = Field(..., description="댓글 내용")
    parent_id: Optional[str] = Field(None, description="부모 댓글 ID (답글인 경우)")
    mentions: List[str] = Field(default=[], description="멘션된 사용자 목록")
    
    @validator('content')
    def validate_content(cls, v):
        if not v.strip():
            raise ValueError("댓글 내용은 비워둘 수 없습니다.")
        return v.strip()

class CommentUpdate(BaseSchema):
    """댓글 수정 요청 모델"""
    content: str = Field(..., description="수정할 댓글 내용")

# 요청용 임베디드 모델 (시간 및 사용자 메타데이터 필드 선택적)
class ReferenceRequest(BaseModel):
    """참조 정보 요청 모델 (프론트엔드용)"""
    url: str = Field(..., description="참조 URL")
    type: str = Field(default="OTHER", description="참조 타입")
    description: Optional[str] = Field(None, description="참조 설명")
    created_at: Optional[datetime] = Field(None, description="생성 시간")
    created_by: Optional[str] = Field(None, description="추가한 사용자")
    last_modified_at: Optional[datetime] = Field(None, description="마지막 수정 시간")
    last_modified_by: Optional[str] = Field(None, description="마지막 수정자")
    
    class Config:
        json_encoders = {
            datetime: serialize_datetime
        }

class PoCRequest(BaseModel):
    """PoC 정보 요청 모델 (프론트엔드용)"""
    url: str = Field(..., description="PoC URL")
    source: Optional[str] = Field(default="Github", description="PoC 소스")
    description: Optional[str] = Field(None, description="PoC 설명")
    created_at: Optional[datetime] = Field(None, description="생성 시간")
    created_by: Optional[str] = Field(None, description="추가한 사용자")
    last_modified_at: Optional[datetime] = Field(None, description="마지막 수정 시간")
    last_modified_by: Optional[str] = Field(None, description="마지막 수정자")
    
    class Config:
        json_encoders = {
            datetime: serialize_datetime
        }

class SnortRuleRequest(BaseModel):
    """Snort 규칙 요청 모델 (프론트엔드용)"""
    rule: str = Field(..., description="Snort 규칙 문자열")
    type: str = Field(default="USER_DEFINED", description="규칙 타입")
    description: Optional[str] = Field(None, description="규칙 설명")
    created_at: Optional[datetime] = Field(None, description="생성 시간")
    created_by: Optional[str] = Field(None, description="추가한 사용자")
    last_modified_at: Optional[datetime] = Field(None, description="마지막 수정 시간")
    last_modified_by: Optional[str] = Field(None, description="마지막 수정자")
    
    class Config:
        json_encoders = {
            datetime: serialize_datetime
        }

class CreateCVERequest(BaseSchema):
    """CVE 생성 요청 모델"""
    cve_id: str
    title: Optional[str] = None
    description: Optional[str] = None
    status: str = "신규등록"
    severity: Optional[str] = None
    references: List[ReferenceRequest] = []
    pocs: List[PoCRequest] = []
    snort_rules: List[SnortRuleRequest] = []
    # 시간 필드를 선택적으로 설정
    created_at: Optional[datetime] = None
    created_by: Optional[str] = None
    last_modified_at: Optional[datetime] = None
    last_modified_by: Optional[str] = None

class PatchCVERequest(BaseSchema):
    """CVE 부분 업데이트 요청 모델"""
    title: Optional[str] = None
    description: Optional[str] = None
    status: Optional[str] = None
    severity: Optional[str] = None
    exploit_status: Optional[str] = None
    published_date: Optional[datetime] = None
    references: Optional[List[ReferenceRequest]] = None
    pocs: Optional[List[PoCRequest]] = None
    snort_rules: Optional[List[SnortRuleRequest]] = None
    tags: Optional[List[str]] = None
    # 시간 필드를 선택적으로 설정
    created_at: Optional[datetime] = None
    created_by: Optional[str] = None
    last_modified_at: Optional[datetime] = None
    last_modified_by: Optional[str] = None
    
    class Config:
        extra = "allow"

class BulkUpsertCVERequest(BaseSchema):
    """다중 CVE 업서트 요청 모델"""
    cves: List[CreateCVERequest]
    crawler_name: Optional[str] = None


# ---------- 응답 모델 (API 출력) ----------

class CommentResponse(BaseSchema):
    """댓글 응답 모델"""
    id: str
    content: str
    created_by: str
    parent_id: Optional[str] = None
    created_at: datetime
    last_modified_at: Optional[datetime] = None
    is_deleted: bool = False
    mentions: List[str] = []

class CVEListItem(BaseSchema):
    """CVE 목록 아이템 모델"""
    id: Optional[str]
    cve_id: str
    title: Optional[str] = None
    status: str
    created_at: datetime
    last_modified_at: Optional[datetime] = None
    severity: Optional[str] = None

class CVEListResponse(BaseSchema):
    """CVE 목록 응답 모델"""
    total: int
    items: List[CVEListItem]
    page: int = 1
    limit: int = 10

class CVEDetailResponse(BaseSchema):
    """CVE 상세 응답 모델"""
    id: Optional[str]
    cve_id: str
    title: Optional[str] = None
    description: Optional[str] = None
    status: str
    severity: Optional[str] = None
    created_at: datetime
    last_modified_at: Optional[datetime] = None
    references: List[Reference] = []
    pocs: List[PoC] = []
    snort_rules: List[SnortRule] = []
    comments: List[CommentResponse] = []
    modification_history: List[ModificationHistory] = []
    created_by: Optional[str] = None
    last_modified_by: Optional[str] = None

class CVEOperationResponse(BaseSchema):
    """CVE 작업 결과 응답 모델"""
    success: bool
    message: str
    cve_id: Optional[str] = None
    data: Optional[Dict[str, Any]] = None

class BulkOperationResponse(BaseSchema):
    """다중 CVE 작업 결과 응답 모델"""
    success: Dict[str, Any]
    errors: Dict[str, Any]
    total_processed: int

class CVESearchResponse(BaseSchema):
    """CVE 검색 결과 응답 모델"""
    total: int
    items: List[CVEListItem]
    query: str


# ---------- 문서 모델 (데이터베이스 엔티티) ----------

class CVEModel(BaseDocument):
    """CVE 모델"""
    cve_id: str = Field(..., description="CVE ID")
    title: Optional[str] = None
    description: Optional[str] = None
    status: str = "신규등록"  # 신규등록, 분석중, 릴리즈 완료, 분석불가
    assigned_to: Optional[str] = None
    severity: Optional[str] = None  # 심각도 필드
    created_by: str = Field(..., description="추가한 사용자")
    last_modified_by: str = Field(..., description="마지막 수정자")
    
    # 임베디드 필드
    comments: List[Comment] = []
    pocs: List[PoC] = []
    snort_rules: List[SnortRule] = Field(default_factory=list)
    references: List[Reference] = Field(default_factory=list)
    modification_history: List[ModificationHistory] = []
    
    # 편집 잠금 관련 필드
    is_locked: bool = False
    locked_by: Optional[str] = None
    lock_timestamp: Optional[datetime] = None
    lock_expires_at: Optional[datetime] = None
    
    # 기타 필드
    notes: Optional[str] = None
    nuclei_hash: Optional[str] = None
    
    class Settings:
        name = "cves"
        id_field = "cve_id"
        indexes = [
            "status",
            "assigned_to",
            "last_modified_at",
            "created_at",
            "created_by",
            "is_locked",
            "locked_by",
            [("last_modified_at", -1)], 
            [("created_at", -1)],
            [("status", 1), ("last_modified_at", -1)],
            [
                ("cve_id", "text"), 
                ("title", "text"), 
                ("description", "text")
            ]
        ]
        unique_indexes = [
            [("cve_id", 1)]
        ]


============================================================
File: /home/CVEHub/backend/app/cve/service.py
------------------------------------------------------------
#app/cve/service.py
"""
CVE 서비스 구현
모든 CVE 관련 비즈니스 로직 포함
"""
from typing import List, Optional, Tuple, Dict, Any, Union
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
from beanie import PydanticObjectId
from pymongo import DESCENDING
import logging
import traceback
import re
import asyncio
from pydantic import ValidationError
import json
from bson import ObjectId
from functools import wraps

from app.cve.models import (
    CVEModel, Reference, PoC, SnortRule, ModificationHistory, ChangeItem,
    CreateCVERequest, PatchCVERequest
)
from app.activity.models import ActivityAction, ActivityTargetType, UserActivity
from app.activity.service import ActivityService
from app.cve.repository import CVERepository
from app.common.utils.datetime_utils import get_utc_now, format_datetime, normalize_datetime_fields
from app.common.utils.change_detection import detect_object_changes
from app.comment.service import CommentService

# 로거 설정
logger = logging.getLogger(__name__)

# 클래스 외부로 이동한 데코레이터 함수
def track_cve_activity(action, extract_title=None, ignore_fields=None):
    """CVE 활동을 추적하는 데코레이터"""
    def decorator(func):
        @wraps(func)
        async def wrapper(self, cve_id, *args, **kwargs):
            # 사용자 이름 추출 시도
            username = None
            for arg in args:
                if isinstance(arg, str) and not arg.startswith('CVE-'):
                    username = arg
                    break
            
            for key, value in kwargs.items():
                if key in ['username', 'updated_by', 'created_by', 'deleted_by'] and isinstance(value, str):
                    username = value
                    break
            
            if not username:
                username = "system"
            
            # 변경 전 객체 조회 (업데이트/삭제 작업의 경우)
            old_cve = None
            if action != ActivityAction.CREATE:
                old_cve = await self.get_cve_detail(cve_id, as_model=True)
            
            # 원래 함수 실행
            result = await func(self, cve_id, *args, **kwargs)
            
            # 작업 성공 시 활동 기록
            if result:
                # 변경 후 객체 조회 (생성/업데이트 작업의 경우)
                new_cve = None
                if action != ActivityAction.DELETE:
                    if isinstance(result, dict) and 'cve_id' in result:
                        new_cve_id = result['cve_id']
                    else:
                        new_cve_id = cve_id
                    new_cve = await self.get_cve_detail(new_cve_id, as_model=True)
                
                # 제목 추출
                title = None
                if extract_title and callable(extract_title):
                    title = extract_title(old_cve, new_cve, result)
                elif new_cve:
                    title = new_cve.title or cve_id
                elif old_cve:
                    title = old_cve.title or cve_id
                else:
                    title = cve_id
                
                # 변경 사항 감지 (업데이트 작업의 경우)
                changes = []
                
                if action == ActivityAction.UPDATE and old_cve and new_cve:
                    # 객체 변경 자동 감지 사용
                    changes = detect_object_changes(
                        old_obj=old_cve.dict(),
                        new_obj=new_cve.dict(),
                        ignore_fields=ignore_fields or ['last_modified_at', '_id', 'id']
                    )
                elif action == ActivityAction.CREATE:
                    changes = [ChangeItem(
                        field="cve",
                        field_name="CVE",
                        action="add",
                        detail_type="simple",
                        summary=f"새 CVE '{cve_id}' 생성"
                    )]
                elif action == ActivityAction.DELETE:
                    changes = [ChangeItem(
                        field="cve",
                        field_name="CVE",
                        action="delete",
                        detail_type="simple",
                        summary=f"CVE '{cve_id}' 삭제"
                    )]
                
                # 메타데이터 준비
                metadata = {}
                
                # CVE 정보가 있으면 메타데이터에 추가
                if new_cve:
                    metadata.update({
                        "severity": new_cve.severity,
                        "status": new_cve.status
                    })
                elif old_cve:
                    metadata.update({
                        "severity": old_cve.severity,
                        "status": old_cve.status
                    })
                
                # 활동 생성
                if changes:  # 변경 사항이 있는 경우에만 기록
                    await self.activity_service.create_activity(
                        username=username,
                        action=action,
                        target_type=ActivityTargetType.CVE,
                        target_id=cve_id,
                        target_title=title,
                        changes=changes,
                        metadata=metadata
                    )
            
            return result
        return wrapper
    return decorator

class CVEService:
    """CVE 서비스"""
    
    def __init__(self, cve_repository: CVERepository = None, activity_service: ActivityService = None, comment_service = None):
        self.repository = cve_repository or CVERepository()
        self.activity_service = activity_service or ActivityService()
        self._comment_service = comment_service

    @property
    def comments(self):
        """댓글 관련 작업을 위한 서비스 접근자"""
        if self._comment_service is None:
            # comment_service가 주입되지 않은 경우 동적으로 생성
            from app.comment.service import CommentService
            from app.activity.service import ActivityService
            from app.comment.repository import CommentRepository
            self._comment_service = CommentService(
                cve_repository=self.repository,
                comment_repository=CommentRepository(),
                activity_service=self.activity_service or ActivityService()
            )
        return self._comment_service
    
    # 표준화된 결과 반환 메서드
    def _success_result(self, data, message="작업이 성공적으로 완료되었습니다"):
        """성공 결과를 표준 형식으로 반환"""
        return data, message
    
    def _error_result(self, message="작업 중 오류가 발생했습니다"):
        """오류 결과를 표준 형식으로 반환"""
        return None, message

    # === 활동 내역 추적을 위한 데코레이터 ===
    
    # ==== CVE 관련 메서드 ====
    
    async def get_cve_list(
        self,
        page: int = 1,
        limit: int = 10,
        status: Optional[str] = None,
        severity: Optional[str] = None,
        search: Optional[str] = None,
        skip: Optional[int] = None
    ) -> Dict[str, Any]:
        """페이지네이션을 적용한 CVE 목록을 조회합니다."""
        try:
            logger.info(f"CVE 목록 조회 시작: page={page}, limit={limit}, status={status}, severity={severity}, search={search}, skip={skip}")
            
            # 쿼리 구성
            query = {}
            
            if status:
                query["status"] = status
                
            if severity:
                query["severity"] = severity
                
            if search:
                query["$or"] = [
                    {"cve_id": {"$regex": search, "$options": "i"}},
                    {"title": {"$regex": search, "$options": "i"}},
                    {"description": {"$regex": search, "$options": "i"}}
                ]
            
            # skip 값 계산 (직접 지정하지 않은 경우)
            if skip is None:
                skip = (page - 1) * limit
            
            # 필요한 필드만 선택 (성능 최적화)
            projection = {
                "cve_id": 1,
                "title": 1,
                "status": 1,
                "created_at": 1,
                "last_modified_at": 1,
                "description": 1,
                "severity": 1,
            }
            
            # DB 쿼리 실행 (최적화된 방식)
            cves = await self.repository.find_with_projection(
                query=query,
                projection=projection,
                skip=skip,
                limit=limit,
                sort=[
                    ("last_modified_at", DESCENDING),
                    ("created_at", DESCENDING)
                ]
            )
            
            # 전체 개수 카운트 (별도 쿼리로 최적화)
            total = await self.repository.count(query)
            
            logger.info(f"CVE 목록 조회 완료: 총 {total}개 중 {len(cves)}개 조회됨")
            
            # null 날짜 필드 처리 - 현재 시간으로 설정
            current_time = get_utc_now()
            for cve in cves:
                # 날짜 필드가 없거나 null인 경우 현재 시간으로 설정
                if 'created_at' not in cve or cve['created_at'] is None:
                    cve['created_at'] = current_time
                if 'last_modified_at' not in cve or cve['last_modified_at'] is None:
                    cve['last_modified_at'] = current_time
                
                # id 필드가 없는 경우 cve_id 값을 복사
                if 'id' not in cve and 'cve_id' in cve:
                    cve['id'] = cve['cve_id']
            
            return {
                "total": total,
                "items": cves,
                "page": page if skip is None else skip // limit + 1,
                "limit": limit
            }
        except Exception as e:
            logger.error(f"CVE 목록 조회 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    async def get_cve_detail(
        self,
        cve_id: str,
        as_model: bool = False,
        include_details: bool = False,
        projection: Dict[str, Any] = None
    ) -> Union[Optional[CVEModel], Optional[Dict[str, Any]]]:
        """CVE ID로 CVE 상세 정보를 조회합니다."""
        try:
            # 프로젝션 최적화 - 필요한 필드만 조회
            if projection:
                cve = await self.repository.find_by_cve_id_with_projection(cve_id, projection)
            else:
                # 대소문자 구분 없이 CVE ID로 조회
                cve = await self.repository.find_by_cve_id(cve_id)
            
            if not cve:
                logger.info(f"CVE를 찾을 수 없음: {cve_id}")
                return None
                
            # 모델 그대로 반환 요청시
            if as_model:
                return cve
                
            # 모델을 딕셔너리로 변환
            cve_dict = cve.dict()

            # _id 필드가 있다면 제거
            if '_id' in cve_dict:
                cve_dict.pop('_id')

            # 날짜 필드 처리
            cve_dict = normalize_datetime_fields(cve_dict)
            
            # id 필드 처리 - 있으면 문자열로 변환, 없으면 cve_id 값 사용
            if 'id' in cve_dict:
                # PydanticObjectId 또는 ObjectId를 문자열로 변환
                if hasattr(cve_dict['id'], '__str__'):
                    cve_dict['id'] = str(cve_dict['id'])
            elif 'cve_id' in cve_dict:
                # id 필드가 없는 경우 cve_id 값을 사용
                cve_dict['id'] = cve_dict['cve_id']
            
            return cve_dict
            
        except Exception as e:
            error_msg = f"CVE '{cve_id}' 정보 조회 중 오류 발생: {str(e)}"
            logger.error(error_msg)
            logger.error(traceback.format_exc())
            raise Exception(error_msg)

    async def create_cve(self, cve_data: Union[dict, CreateCVERequest], username: str, is_crawler: bool = False, crawler_name: Optional[str] = None) -> Optional[CVEModel]:
        """새로운 CVE를 생성합니다."""
        # 트랜잭션 변수 선언
        new_cve = None
        
        try:
            logger.info(f"CVE 생성 시작: 사용자={username}, 크롤러={is_crawler}")
            
            # pydantic 모델을 딕셔너리로 변환
            if not isinstance(cve_data, dict):
                cve_data = cve_data.dict()
                
            # 날짜 필드 UTC 설정
            current_time = get_utc_now()
            
            # CVE 객체 자체에 시간 메타데이터 추가
            cve_data = self._add_timestamp_metadata(cve_data, username, current_time)
            
            # 각 컨테이너 필드에 대해 필수 필드 추가
            for field in ["references", "pocs", "snort_rules"]:
                # 필드가 있고, None이 아니고, 비어있지 않은 경우만 처리
                if field in cve_data and cve_data[field] is not None:
                    # 빈 리스트가 아닌지 확인하고 처리
                    if isinstance(cve_data[field], list) and any(cve_data[field]):
                        # 빈 항목 필터링 (None이나 빈 dict 제거)
                        cve_data[field] = [item for item in cve_data[field] if item and isinstance(item, dict)]
                        # 메타데이터 추가
                        cve_data[field] = self._add_timestamp_metadata(cve_data[field], username, current_time)
            
            # 크롤러 정보 추가
            if is_crawler and crawler_name:
                cve_data["source"] = {
                    "type": "crawler",
                    "name": crawler_name,
                    "crawled_at": current_time
                }
            
            # 기존 CVE 중복 체크 (cve_id가 있는 경우)
            cve_id = None
            if "cve_id" in cve_data and cve_data["cve_id"]:
                cve_id = cve_data["cve_id"]
                # 최적화: 전체 CVE 가져오지 않고 존재 여부만 확인
                exists = await self.repository.check_cve_exists(cve_id)
                if exists:
                    logger.warning(f"이미 존재하는 CVE ID: {cve_id}")
                    return None
            
            # CVE 생성
            new_cve = await self.repository.create(cve_data)
        
            if new_cve:
                logger.info(f"CVE 생성 성공: CVE ID={new_cve.cve_id}")
                
                # 활동 추적 - CVE 생성 기록
                changes = [ChangeItem(
                    field="cve",
                    field_name="CVE",
                    action="add",
                    detail_type="detailed",
                    summary=f"새 CVE '{new_cve.cve_id}' 생성"
                )]
                
                # 활동 로그를 위한 타이틀 생성 - CVE ID만 사용
                activity_title = new_cve.cve_id
                
                # 심각도 정보
                changes.append(ChangeItem(
                    field="severity_context",
                    field_name="심각도",
                    action="add",
                    detail_type="simple",
                    after=new_cve.severity,
                    summary=f"심각도: {new_cve.severity}"
                ))
                
                # 상태 정보
                changes.append(ChangeItem(
                    field="status_context",
                    field_name="상태",
                    action="add",
                    detail_type="simple",
                    after=new_cve.status,
                    summary=f"상태: {new_cve.status}"
                ))
                
                # 크롤러 정보
                if is_crawler:
                    changes.append(ChangeItem(
                        field="crawler_context",
                        field_name="크롤러",
                        action="add",
                        detail_type="simple",
                        after=crawler_name,
                        summary=f"크롤러: {crawler_name}"
                    ))
                
                # 생성자 정보
                changes.append(ChangeItem(
                    field="created_by_context",
                    field_name="생성자",
                    action="add",
                    detail_type="simple",
                    after=username,
                    summary=f"생성자: {username}"
                ))
                
                # PoC 정보 추가
                if new_cve.pocs and len(new_cve.pocs) > 0:
                    poc_items = []
                    for poc in new_cve.pocs:
                        poc_items.append({
                            "source": poc.source,
                            "url": poc.url,
                            "description": poc.description
                        })
                    changes.append(ChangeItem(
                        field="pocs",
                        field_name="PoC",
                        action="add",
                        detail_type="detailed",
                        items=poc_items,
                        summary=f"PoC {len(new_cve.pocs)}개 추가됨"
                    ))
                    
                    # PoC 개수 정보
                    changes.append(ChangeItem(
                        field="pocs_count",
                        field_name="PoC 수",
                        action="add",  
                        detail_type="simple",
                        after=len(new_cve.pocs),
                        summary=f"PoC 총 {len(new_cve.pocs)}개"
                    ))
                
                # 참조문서 정보 추가
                if new_cve.references and len(new_cve.references) > 0:
                    ref_items = []
                    for ref in new_cve.references:
                        ref_items.append({
                            "type": ref.type,
                            "url": ref.url,
                            "description": ref.description
                        })
                    changes.append(ChangeItem(
                        field="references",
                        field_name="참조문서",
                        action="add",
                        detail_type="detailed",
                        items=ref_items,
                        summary=f"참조문서 {len(new_cve.references)}개 추가됨"
                    ))
                    
                    # 참조문서 개수 정보
                    changes.append(ChangeItem(
                        field="references_count",
                        field_name="참조문서 수",
                        action="add",  
                        detail_type="simple",
                        after=len(new_cve.references),
                        summary=f"참조문서 총 {len(new_cve.references)}개"
                    ))
                
                # Snort 규칙 정보 추가
                if new_cve.snort_rules and len(new_cve.snort_rules) > 0:
                    snort_items = []
                    for snort in new_cve.snort_rules:
                        snort_items.append({
                            "type": snort.type,
                            "rule": snort.rule,
                            "description": snort.description
                        })
                    changes.append(ChangeItem(
                        field="snort_rules",
                        field_name="Snort 규칙",
                        action="add",
                        detail_type="detailed",
                        items=snort_items,
                        summary=f"Snort 규칙 {len(new_cve.snort_rules)}개 추가됨"
                    ))
                    
                    # Snort 규칙 개수 정보
                    changes.append(ChangeItem(
                        field="snort_rules_count",
                        field_name="Snort 규칙 수",
                        action="add",  
                        detail_type="simple",
                        after=len(new_cve.snort_rules),
                        summary=f"Snort 규칙 총 {len(new_cve.snort_rules)}개"
                    ))
                
                await self.activity_service.create_activity(
                    username=username,
                    action=ActivityAction.CREATE,
                    target_type=ActivityTargetType.CVE,
                    target_id=new_cve.cve_id,
                    target_title=activity_title,  # CVE ID를 활동 타이틀로 사용
                    changes=changes
                )
                
                return new_cve
            else:
                logger.error("CVE 생성 실패: Repository에서 None 반환")
                return new_cve
                
        except Exception as e:
            logger.error(f"CVE 생성 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            
            # 이미 CVE가 생성되었다면 롤백 시도
            if new_cve and hasattr(new_cve, 'cve_id'):
                try:
                    logger.warning(f"오류 발생으로 CVE 롤백 시도: {new_cve.cve_id}")
                    # 문자열 ID를 사용하여 삭제 (타입 변환 오류 방지)
                    cve_id_str = str(new_cve.cve_id) if not isinstance(new_cve.cve_id, str) else new_cve.cve_id
                    await self.repository.delete_by_cve_id(cve_id_str)
                    logger.info(f"CVE 롤백 성공: {cve_id_str}")
                except Exception as rollback_error:
                    logger.error(f"CVE 롤백 실패: {str(rollback_error)}")
            
            return None

    async def update_cve(self, cve_id: str, update_data: Union[dict, PatchCVERequest], updated_by: str = None) -> Optional[Dict[str, Any]]:
        """
        CVE 정보를 업데이트합니다. 객체 변경 감지를 통한 활동 추적 사용.
        
{{ ... }}
        Args:
            cve_id: 업데이트할 CVE ID
            update_data: 업데이트할 데이터 (dict 또는 PatchCVERequest)
            updated_by: 업데이트한 사용자 이름
            
        Returns:
            업데이트된 CVE 정보 (없으면 None)
        """
        try:
            logger.info(f"CVE 업데이트 요청: cve_id={cve_id}, updated_by={updated_by}")
            
            # 기존 CVE 조회 - 객체 변경 감지용
            existing_cve = await self.get_cve_detail(cve_id, as_model=True)
            if not existing_cve:
                logger.warning(f"업데이트할 CVE를 찾을 수 없음: {cve_id}")
                return None
                
            logger.info(f"기존 CVE 정보: cve_id={existing_cve.cve_id}")
            
            # 기존 객체 저장 (변경 감지용)
            old_cve_dict = existing_cve.dict()
                
            # pydantic 모델을 딕셔너리로 변환
            if not isinstance(update_data, dict):
                update_data = update_data.dict(exclude_unset=True)
            
            # 준비된 업데이트 데이터 생성
            processed_data = self._prepare_update_data(update_data, existing_cve, updated_by)
            
            # 업데이트 실행 - repository의 update_document 메서드 사용
            result = await self.repository.update_document(cve_id, processed_data)
            
            if not result:
                logger.warning(f"CVE 업데이트 실패: {cve_id}")
                return None
            
            # 업데이트된 CVE 가져오기
            updated_cve = await self.get_cve_detail(cve_id, as_model=False)
                
            # 객체 변경 감지를 이용한 활동 추적
            excluded_fields = ['last_modified_at', '_id', 'id']
            
            # 추가 변경 사항 수집 - 변경 컸텍스트 정보 포함
            additional_changes = []
            
            # 상태 문맵 정보
            severity_val = updated_cve.get('severity') or existing_cve.severity
            status_val = updated_cve.get('status') or existing_cve.status
            
            # 상태 정보 추가 (비교용)
            additional_changes.append(ChangeItem(
                field="severity_context",
                field_name="현재 심각도",
                action="context",
                detail_type="simple",
                after=severity_val,
                summary=f"현재 심각도: {severity_val}"
            ))
            
            additional_changes.append(ChangeItem(
                field="status_context",
                field_name="현재 상태",
                action="context",
                detail_type="simple",
                after=status_val,
                summary=f"현재 상태: {status_val}"
            ))
            
            # 변경자 정보 추가
            additional_changes.append(ChangeItem(
                field="updated_by_context",
                field_name="변경자",
                action="context",
                detail_type="simple",
                after=updated_by or "system",
                summary=f"변경자: {updated_by or 'system'}"
            ))
            
            # 컬렉션 아이템 수량 정보 비교 추가
            collections = [
                {"field": "pocs", "field_name": "PoC 수", "old": len(old_cve_dict.get('pocs', [])), "new": len(updated_cve.get('pocs', []))},
                {"field": "references", "field_name": "참조문서 수", "old": len(old_cve_dict.get('references', [])), "new": len(updated_cve.get('references', []))},
                {"field": "snort_rules", "field_name": "Snort 규칙 수", "old": len(old_cve_dict.get('snort_rules', [])), "new": len(updated_cve.get('snort_rules', []))}
            ]
            
            for collection in collections:
                if collection["old"] != collection["new"]:
                    additional_changes.append(ChangeItem(
                        field=f"{collection['field']}_count",
                        field_name=collection["field_name"],
                        action="count_change",
                        detail_type="simple",
                        before=collection["old"],
                        after=collection["new"],
                        summary=f"{collection['field_name']} {collection['old']}개에서 {collection['new']}개로 변경"
                    ))
            
            # track_object_changes 호출
            await self.activity_service.track_object_changes(
                username=updated_by or "system",
                action=ActivityAction.UPDATE,
                target_type=ActivityTargetType.CVE,
                target_id=cve_id,
                old_obj=old_cve_dict,
                new_obj=updated_cve,
                target_title=updated_cve.get('title') or existing_cve.title or cve_id,
                ignore_fields=excluded_fields,
                additional_changes=additional_changes
            )
                    
            return updated_cve
        except Exception as e:
            logger.error(f"CVE 업데이트 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    def _prepare_update_data(self, update_data: dict, existing_cve: CVEModel, updated_by: str) -> dict:
        """
        업데이트 데이터 전처리 및 메타데이터 추가
        
        Args:
            update_data: 원본 업데이트 데이터
            existing_cve: 기존 CVE 모델
            updated_by: 업데이트한 사용자명
            
        Returns:
            dict: 처리된 업데이트 데이터
        """
        processed_data = update_data.copy()
        
        # _id 필드 제거
        if '_id' in processed_data:
            processed_data.pop('_id')
        
        # 날짜 필드 UTC 설정
        current_time = get_utc_now()
        
        # 임베디드 필드에 시간 메타데이터 추가
        for field in ["references", "pocs", "snort_rules"]:
            # 필드가 있고, None이 아니고, 비어있지 않은 경우만 처리
            if field in processed_data and processed_data[field] is not None:
                # 빈 리스트가 아닌지 확인하고 처리
                if isinstance(processed_data[field], list) and any(processed_data[field]):
                    # 빈 항목 필터링 (None이나 빈 dict 제거)
                    processed_data[field] = [item for item in processed_data[field] if item and isinstance(item, dict)]
                    # 메타데이터 추가
                    processed_data[field] = self._add_timestamp_metadata(processed_data[field], updated_by or "system", current_time)
        
        # 업데이트 시간 및 사용자 설정
        processed_data['last_modified_at'] = current_time
        processed_data['last_modified_by'] = updated_by or "system"
        
        # 변경 이력 추가
        changes = self._extract_complex_changes(existing_cve, processed_data)
        if changes:
            processed_data = self._add_modification_history(existing_cve, processed_data, changes, updated_by)
        
        return processed_data

    def _add_modification_history(self, existing_cve: CVEModel, update_data: dict, changes: List[ChangeItem], updated_by: str) -> dict:
        """
        변경 이력을 업데이트 데이터에 추가
        
        Args:
            existing_cve: 기존 CVE 모델
            update_data: 업데이트 데이터
            changes: 변경 사항 목록
            updated_by: 업데이트한 사용자명
            
        Returns:
            dict: 변경 이력이 추가된 업데이트 데이터
        """
        # 변경 이력 데이터 생성
        modification_history = ModificationHistory(
            username=updated_by or "system",
            modified_at=get_utc_now(),
            changes=changes
        )
        
        # 기존 modification_history 불러오기
        existing_history = existing_cve.dict().get("modification_history", [])
        
        # 업데이트 데이터에 추가
        update_data["modification_history"] = existing_history + [modification_history.dict()]
        
        return update_data



    def _extract_complex_changes(self, existing_cve: CVEModel, update_data: dict) -> List[ChangeItem]:
        """
        복잡한 변경 사항을 추출하는 유틸리티 메서드 (필드별 커스텀 처리)
        주로 컬렉션 타입 필드(pocs, references, snort_rules)의 변경 사항을 추적
        """
        # 필드별 한글 이름 매핑
        field_names = {
            "title": "제목",
            "description": "설명",
            "status": "상태",
            "severity": "심각도",
            "pocs": "PoC",
            "references": "참조문서",
            "snort_rules": "Snort 규칙",
            "notes": "노트",
            "assigned_to": "담당자"
        }
        
        changes = []
        excluded_fields = ['last_modified_at', '_id', 'id']
        
        for field, new_value in update_data.items():
            if field in excluded_fields:
                continue
                
            if field in existing_cve.dict() and existing_cve.dict()[field] != new_value:
                field_name = field_names.get(field, field)
                
                # 필드 유형별로 변경 내역 기록 방식 다르게 처리
                if field in ['pocs', 'references', 'snort_rules'] and isinstance(new_value, list):
                    # 컬렉션 아이템 비교 로직
                    old_items = existing_cve.dict().get(field, [])
                    
                    # 새로 추가된 아이템
                    added_items = []
                    for new_item in new_value:
                        is_new = True
                        for old_item in old_items:
                            if self._is_same_item(new_item, old_item, field):
                                is_new = False
                                break
                        if is_new:
                            added_items.append(new_item)
                    
                    # 삭제된 아이템
                    removed_items = []
                    for old_item in old_items:
                        is_removed = True
                        for new_item in new_value:
                            if self._is_same_item(new_item, old_item, field):
                                is_removed = False
                                break
                        if is_removed:
                            removed_items.append(old_item)
                    
                    # 아이템 필드 정보 보강
                    if field == 'pocs':
                        added_items_detail = []
                        for item in added_items:
                            added_items_detail.append({
                                "source": item.get('source', ''),
                                "url": item.get('url', ''),
                                "description": item.get('description', '')
                            })
                        removed_items_detail = []
                        for item in removed_items:
                            removed_items_detail.append({
                                "source": item.get('source', ''),
                                "url": item.get('url', ''),
                                "description": item.get('description', '')
                            })
                        added_items = added_items_detail
                        removed_items = removed_items_detail
                    elif field == 'references':
                        added_items_detail = []
                        for item in added_items:
                            added_items_detail.append({
                                "url": item.get('url', ''),
                                "type": item.get('type', ''),
                                "description": item.get('description', '')
                            })
                        removed_items_detail = []
                        for item in removed_items:
                            removed_items_detail.append({
                                "url": item.get('url', ''),
                                "type": item.get('type', ''),
                                "description": item.get('description', '')
                            })
                        added_items = added_items_detail
                        removed_items = removed_items_detail
                    elif field == 'snort_rules':
                        added_items_detail = []
                        for item in added_items:
                            added_items_detail.append({
                                "rule_content": item.get('rule_content', ''),
                                "type": item.get('type', ''),
                                "description": item.get('description', '')
                            })
                        removed_items_detail = []
                        for item in removed_items:
                            removed_items_detail.append({
                                "rule_content": item.get('rule_content', ''),
                                "type": item.get('type', ''),
                                "description": item.get('description', '')
                            })
                        added_items = added_items_detail
                        removed_items = removed_items_detail
                    
                    # 추가된 아이템 변경 사항 추가
                    if added_items:
                        changes.append(ChangeItem(
                            field=field,
                            field_name=field_name,
                            action="add",
                            detail_type="detailed",
                            items=added_items,
                            summary=f"{field_name} {len(added_items)}개 추가됨"
                        ))
                    
                    # 삭제된 아이템 변경 사항 추가
                    if removed_items:
                        changes.append(ChangeItem(
                            field=field,
                            field_name=field_name,
                            action="remove",
                            detail_type="detailed",
                            items=removed_items,
                            summary=f"{field_name} {len(removed_items)}개 삭제됨"
                        ))
                else:
                    # 일반 필드 변경
                    changes.append(ChangeItem(
                        field=field,
                        field_name=field_name,
                        action="edit",
                        detail_type="detailed",
                        before=existing_cve.dict().get(field),
                        after=new_value,
                        summary=f"{field_name} 변경됨"
                    ))
                    
        return changes

    # 데코레이터 패턴 적용 예시 - 상태 업데이트 메서드
    @track_cve_activity(
        action=ActivityAction.UPDATE,
        extract_title=lambda old, new, result: old.title if old else (new.title if new else None),
        ignore_fields=['last_modified_at', '_id', 'id']
    )
    async def update_cve_status(self, cve_id: str, status: str, updated_by: str = None) -> Optional[Dict[str, Any]]:
        """CVE 상태만 업데이트하는 간소화된 메서드"""
        try:
            logger.info(f"CVE 상태 업데이트: cve_id={cve_id}, status={status}, updated_by={updated_by}")
            
            # 업데이트 데이터 준비
            update_data = {
                'status': status,
                'last_modified_at': get_utc_now(),
                'last_modified_by': updated_by or 'system'
            }
            
            # 부분 업데이트 최적화 - repository의 update_field 메서드 사용
            result = await self.repository.update_fields(cve_id, update_data)
            
            if result:
                # 최적화: 필요한 필드만 가져오기
                projection = {"title": 1, "status": 1, "severity": 1}
                return await self.get_cve_detail(cve_id, as_model=False, projection=projection)
            return None
        except Exception as e:
            logger.error(f"CVE 상태 업데이트 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return None

    def _is_same_item(self, item1, item2, item_type):
        """두 아이템이 동일한지 비교"""
        if item_type == 'pocs':
            return item1.get('url') == item2.get('url')
        elif item_type == 'references':
            return item1.get('url') == item2.get('url')
        elif item_type == 'snort_rules':
            return item1.get('rule') == item2.get('rule')
        return False
        
    def _add_timestamp_metadata(self, items, user, current_time=None):
        """
        객체 또는 컬렉션에 시간 및 사용자 메타데이터를 추가합니다.
        
        Args:
            items: 처리할 객체 또는 컬렉션
            user: 사용자 정보
            current_time: 현재 시간 (기본값은 현재 시간)
            
        Returns:
            시간 메타데이터가 추가된 객체 또는 컬렉션
        """
        if not items:
            return items
            
        if current_time is None:
            current_time = get_utc_now()
            
        # 단일 객체인 경우
        if isinstance(items, dict):
            for field, default_value in {
                "created_by": user,
                "last_modified_by": user,
                "created_at": current_time,
                "last_modified_at": current_time
            }.items():
                # None 값이거나, 필드가 없거나, 값이 비어있는 경우 새 값 설정
                if field not in items or items.get(field) is None or not items[field]:
                    items[field] = default_value
            return items
            
        # 컬렉션인 경우
        for item in items:
            if not isinstance(item, dict):
                continue
                
            # 필수 필드 보장
            for field, default_value in {
                "created_by": user,
                "last_modified_by": user,
                "created_at": current_time,
                "last_modified_at": current_time
            }.items():
                # None 값이거나, 필드가 없거나, 값이 비어있는 경우 새 값 설정
                if field not in item or item.get(field) is None or not item[field]:
                    item[field] = default_value
                    
        return items
    
    # 데코레이터 패턴 적용 - CVE 삭제 (간단한 동작)
    @track_cve_activity(
        action=ActivityAction.DELETE,
        extract_title=lambda old, new, result: old.title if old else None
    )
    async def delete_cve(self, cve_id: str, deleted_by: str = "system") -> bool:
        """CVE를 삭제합니다."""
        try:
            logger.info(f"CVE 삭제 시도: {cve_id}, 삭제자: {deleted_by}")
            
            # 삭제 실행 - repository의 delete_by_cve_id 메서드 사용
            result = await self.repository.delete_by_cve_id(cve_id)
            
            if result:
                logger.info(f"CVE 삭제 성공: {cve_id}")
            else:
                logger.warning(f"CVE 삭제 실패: {cve_id}")
                
            return result
        except Exception as e:
            logger.error(f"CVE 삭제 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    async def get_total_cve_count(self) -> int:
        """
        데이터베이스에 존재하는 전체 CVE 개수를 반환합니다.
        필터링 없이 순수하게 DB에 저장된 모든 CVE의 개수를 반환합니다.
        """
        try:
            count = await self.repository.count()
            logger.info(f"전체 CVE 개수 조회 결과: {count}")
            return count
        except Exception as e:
            logger.error(f"전체 CVE 개수 조회 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    async def update_empty_date_fields(self) -> dict:
        """
        데이터베이스에 있는 모든 CVE의 빈 날짜 필드를 검사하고 로깅합니다.
        실제로 값을 변경하지는 않습니다.
        
        Returns:
            dict: 검사 결과 통계
        """
        try:
            logger.info("빈 날짜 필드 검사 작업 시작")
            
            # 모든 CVE 조회
            all_cves = await self.repository.get_all()
            
            # 검사 통계
            stats = {
                "total": len(all_cves),
                "empty_fields_found": 0,
                "cves_with_empty_fields": [],
                "fields_empty": {
                    "created_at": 0,
                    "last_modified_at": 0
                }
            }
            
            # 각 CVE에 대해 빈 날짜 필드 확인
            for cve in all_cves:
                cve_dict = cve.dict()
                cve_id = cve_dict.get("cve_id")
                
                if not cve_id:
                    logger.warning(f"CVE ID가 없는 문서 발견: {cve_dict.get('_id')}")
                    continue
                
                # 빈 필드 확인
                empty_fields = []
                date_fields = ["created_at", "last_modified_at"]
                
                for field in date_fields:
                    # 필드가 없거나, None이거나, 빈 객체이거나, 빈 문자열인 경우
                    if field in cve_dict and (
                        cve_dict[field] is None or 
                        (isinstance(cve_dict[field], dict) and len(cve_dict[field]) == 0) or
                        (isinstance(cve_dict[field], str) and not cve_dict[field].strip())
                    ):
                        empty_fields.append(field)
                        stats["fields_empty"][field] += 1
                
                # 빈 필드가 있는 경우
                if empty_fields:
                    stats["empty_fields_found"] += len(empty_fields)
                    stats["cves_with_empty_fields"].append({
                        "cve_id": cve_id,
                        "empty_fields": empty_fields
                    })
                    logger.warning(f"CVE {cve_id}에 빈 날짜 필드가 발견되었습니다: {empty_fields}")
            
            logger.info(f"빈 날짜 필드 검사 작업 완료: {stats}")
            return stats
            
        except Exception as e:
            logger.error(f"빈 날짜 필드 검사 작업 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    async def get_cve_stats(self) -> Dict[str, int]:
        """
        CVE 통계 데이터를 계산합니다.
        
        Returns:
            각종 통계 데이터를 포함한 딕셔너리
        """
        try:
            logger.info("CVE 통계 데이터 계산 시작")
            
            # MongoDB 집계 파이프라인 사용 (최적화)
            collection = self.repository.collection
            
            # 카운트 쿼리 병렬 실행 (성능 향상)
            tasks = [
                # 모든 CVE 수
                collection.count_documents({}),
                # 심각도 높음 (High 또는 Critical)
                collection.count_documents({
                    "$or": [
                        {"severity": {"$regex": "high", "$options": "i"}},
                        {"severity": {"$regex": "critical", "$options": "i"}}
                    ]
                }),
                # 최근 7일 내 등록된 CVE
                collection.count_documents({
                    "created_at": {"$gte": get_utc_now() - timedelta(days=7)}
                }),
                # 분석 중인 CVE
                collection.count_documents({
                    "status": "분석중"
                }),
                # 완료된 CVE
                collection.count_documents({
                    "status": "릴리즈 완료"
                })
            ]
            
            # 병렬 실행 후 결과 조합
            results = await asyncio.gather(*tasks)
            
            # 결과 반환
            stats = {
                "totalCount": results[0],
                "highSeverityCount": results[1],
                "newLastWeekCount": results[2],
                "inProgressCount": results[3],
                "completedCount": results[4]
            }
            
            logger.info(f"CVE 통계 데이터 계산 완료: {stats}")
            return stats
            
        except Exception as e:
            logger.error(f"CVE 통계 데이터 계산 중 오류 발생: {str(e)}")
            logger.error(traceback.format_exc())
            raise
    
    # ==== 내부 댓글 관리 클래스 ====
    


============================================================
File: /home/CVEHub/backend/app/system/models.py
------------------------------------------------------------
"""시스템 구성 및 상태 모델"""
from datetime import datetime
from pydantic import Field
from typing import Dict, Optional
import logging
from beanie import Document

logger = logging.getLogger(__name__)

class SystemConfig(Document):
    """시스템 설정 및 상태 정보 모델"""
    
    key: str = Field(..., description="설정 키")
    value: Dict = Field(default={}, description="설정 값 (딕셔너리 형태)")
    last_modified_at: datetime = Field(default_factory=datetime.now, description="마지막 업데이트 시간")
    
    class Settings:
        name = "system_configs"
        
    @classmethod
    async def get_crawler_last_updates(cls) -> dict:
        """크롤러 마지막 업데이트 시간 조회"""
        try:
            config = await cls.find_one({"key": "crawler_last_updates"})
            if config:
                return config.value
            
            # 없으면 새로 생성
            new_config = cls(key="crawler_last_updates", value={})
            await new_config.save()
            return {}
        except Exception as e:
            logger.error(f"크롤러 업데이트 시간 조회 중 오류 발생: {str(e)}")
            logger.exception(e)
            
            # 기본값 반환
            return {}
    
    @classmethod
    async def update_crawler_last_update(cls, crawler_type: str, update_time: datetime):
        """크롤러 마지막 업데이트 시간 저장"""
        try:
            if not crawler_type:
                logger.warning("유효하지 않은 crawler_type입니다.")
                return {}
                
            config = await cls.find_one({"key": "crawler_last_updates"})
            if not config:
                logger.info(f"crawler_last_updates 설정을 새로 생성합니다. crawler_type: {crawler_type}")
                config = cls(key="crawler_last_updates", value={})
            
            # 업데이트 시간 저장
            config.value[crawler_type] = update_time.isoformat()
            config.last_modified_at = datetime.now()
            
            await config.save()
            return config.value
        except Exception as e:
            logger.error(f"크롤러 업데이트 시간 저장 중 오류 발생 - crawler_type: {crawler_type}, 오류: {str(e)}", exc_info=True)
            return {} 


============================================================
File: /home/CVEHub/backend/app/database.py
------------------------------------------------------------
import os
import logging
import traceback
from motor.motor_asyncio import AsyncIOMotorClient
from beanie import init_beanie
from pymongo import IndexModel, ASCENDING, DESCENDING, TEXT
from .cve.models import CVEModel, Comment
from .auth.models import User, RefreshToken
from .notification.models import Notification
from .core.config import get_settings
from passlib.context import CryptContext
from .system.models import SystemConfig
from .activity.models import UserActivity
from beanie import Document

# 비밀번호 해싱을 위한 context
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
settings = get_settings()

# MongoDB 클라이언트 생성
client = AsyncIOMotorClient(
    settings.MONGODB_URL,
    uuidRepresentation="standard"
)

db = client[settings.DATABASE_NAME]

# 데이터베이스 객체 export
__all__ = ["get_database", "init_db", "db"]

# 데이터베이스 객체를 외부에서 사용할 수 있도록 함수 제공
def get_database():
    return db

async def init_db():
    """데이터베이스 초기화"""
    try:
        # 현재 컬렉션 목록 확인
        collections = await db.list_collection_names()
        logging.info(f"Current collections before initialization: {collections}")
        
        # 모든 모델에 get_model_type 메서드를 무조건 추가
        # Beanie는 초기화 과정에서 이 메서드를 사용하여 모델을 정렬함
        document_models = [User, CVEModel, Comment, Notification, RefreshToken, SystemConfig, UserActivity]
        
        # 모든 모델에 get_model_type 메서드를 추가
        for model in document_models:
            # 클래스 레벨에서 직접 메서드 추가
            try:
                # 모든 모델에 메서드를 추가
                setattr(model, 'get_model_type', classmethod(lambda cls, *args, **kwargs: 'Document'))
                logging.info(f"Added get_model_type method to {model.__name__}")
            except Exception as e:
                logging.error(f"Error adding get_model_type to {model.__name__}: {str(e)}")
        
        # Beanie 초기화 - 기존 인덱스를 제거하고 새로 생성하도록 옵션 추가
        await init_beanie(
            database=db,
            document_models=document_models,
            allow_index_dropping=True  # 기존 인덱스를 제거하도록 설정
        )
        
        logging.info("Database initialized successfully with beanie ODM")
        
        # 초기화 후 컬렉션 목록 확인
        collections = await db.list_collection_names()
        logging.info(f"Available collections after initialization: {collections}")
        
        return client
        
    except Exception as e:
        logging.error(f"Failed to initialize database: {e}")
        logging.error(f"Traceback: {traceback.format_exc()}")
        raise



============================================================
File: /home/CVEHub/backend/app/core/schemas.py
------------------------------------------------------------
from typing import TypeVar, Generic, Optional, Any, Dict, List
from pydantic import BaseModel, Field
from datetime import datetime

T = TypeVar('T')

class PaginationParams(BaseModel):
    skip: int = Field(0, ge=0, description="건너뛸 항목 수")
    limit: int = Field(20, ge=1, le=100, description="반환할 항목 수")

class Metadata(BaseModel):
    total: Optional[int] = None
    page: Optional[int] = None
    pages: Optional[int] = None
    has_next: Optional[bool] = None
    has_prev: Optional[bool] = None

class APIResponse(BaseModel, Generic[T]):
    success: bool = True
    message: Optional[str] = None
    data: Optional[T] = None
    meta: Optional[Metadata] = None
    error: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.now)

    class Config:
        arbitrary_types_allowed = True

class ErrorResponse(BaseModel):
    success: bool = False
    message: str
    error_code: Optional[str] = None
    details: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.now)

class PaginatedResponse(APIResponse, Generic[T]):
    data: List[T]
    meta: Metadata 


============================================================
File: /home/CVEHub/backend/app/core/logging_utils.py
------------------------------------------------------------
"""
로깅 유틸리티 모듈

애플리케이션 전체에서 일관된 로깅 형식과 컨텍스트를 제공하기 위한 유틸리티 함수들을 포함합니다.
"""

import logging
import inspect
import functools
from typing import Any, Dict, Optional, Union, Callable
from contextvars import ContextVar

# 현재 요청의 컨텍스트 정보를 저장하기 위한 ContextVar
request_id_var = ContextVar("request_id", default=None)
user_id_var = ContextVar("user_id", default=None)

class LoggerAdapter(logging.LoggerAdapter):
    """
    로깅 어댑터 클래스
    
    표준화된 로그 포맷과 컨텍스트 정보를 제공합니다.
    """
    
    def process(self, msg, kwargs):
        """
        로그 메시지를 처리하고 컨텍스트 정보를 추가합니다.
        
        Args:
            msg: 원본 로그 메시지
            kwargs: 로깅 함수에 전달된 키워드 인자
            
        Returns:
            처리된 메시지와 키워드 인자
        """
        # 기존 extra 정보 가져오기
        extra = kwargs.get("extra", {})
        
        # 컨텍스트 정보 추가
        if request_id := request_id_var.get():
            extra["request_id"] = request_id
        
        if user_id := user_id_var.get():
            extra["user_id"] = user_id
            
        # 호출자 정보 추가 (모듈, 함수)
        frame = inspect.currentframe().f_back.f_back
        module = inspect.getmodule(frame)
        module_name = module.__name__ if module else "unknown"
        function_name = frame.f_code.co_name
        
        extra["app_module"] = module_name
        extra["function"] = function_name
        
        # 원본 extra 정보 업데이트
        kwargs["extra"] = extra
        
        # 포맷팅된 메시지 반환
        formatted_msg = f"[{module_name}.{function_name}] {msg}"
        return formatted_msg, kwargs

def get_logger(name: str) -> LoggerAdapter:
    """
    표준화된 로거 인스턴스를 반환합니다.
    
    Args:
        name: 로거 이름 (일반적으로 __name__)
        
    Returns:
        LoggerAdapter 인스턴스
    """
    logger = logging.getLogger(name)
    return LoggerAdapter(logger, {})

def set_request_context(request_id: str, user_id: Optional[str] = None) -> None:
    """
    현재 요청의 컨텍스트 정보를 설정합니다.
    
    Args:
        request_id: 요청 ID
        user_id: 사용자 ID (선택 사항)
    """
    request_id_var.set(request_id)
    if user_id:
        user_id_var.set(user_id)

def clear_request_context() -> None:
    """현재 요청의 컨텍스트 정보를 초기화합니다."""
    request_id_var.set(None)
    user_id_var.set(None)

def log_function_call(logger: Optional[LoggerAdapter] = None) -> Callable:
    """
    함수 호출을 로깅하는 데코레이터
    
    Args:
        logger: 사용할 로거 인스턴스 (None인 경우 함수의 모듈 이름으로 로거 생성)
        
    Returns:
        데코레이터 함수
    """
    def decorator(func):
        # 로거가 제공되지 않은 경우 함수의 모듈 이름으로 로거 생성
        nonlocal logger
        if logger is None:
            module = inspect.getmodule(func)
            module_name = module.__name__ if module else "unknown"
            logger = get_logger(module_name)
        
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            func_name = func.__name__
            logger.debug(f"함수 호출: {func_name}")
            try:
                result = func(*args, **kwargs)
                logger.debug(f"함수 완료: {func_name}")
                return result
            except Exception as e:
                logger.error(f"함수 오류: {func_name} - {str(e)}")
                raise
        
        return wrapper
    
    # 데코레이터가 인자 없이 사용된 경우 처리
    if callable(logger):
        func, logger = logger, None
        return decorator(func)
    
    return decorator



============================================================
File: /home/CVEHub/backend/app/core/exceptions.py
------------------------------------------------------------
from fastapi import HTTPException, status
from typing import Optional, Any, Dict
import logging

logger = logging.getLogger(__name__)

class CVEHubException(HTTPException):
    """기본 CVEHub 예외 클래스 - 에러 코드와 상세 메시지를 포함"""
    def __init__(
        self,
        status_code: int,
        detail: str,
        error_code: str = None,
        extra: Dict[str, Any] = None
    ):
        super().__init__(status_code=status_code, detail=detail)
        self.error_code = error_code
        self.extra = extra or {}
        
        # 에러 로깅
        logger.error(
            f"CVEHubException: {error_code or 'NO_CODE'} - {detail}",
            extra={
                "status_code": status_code,
                "error_code": error_code,
                "extra": extra
            }
        )

class NotFoundException(CVEHubException):
    """리소스를 찾을 수 없을 때 발생하는 예외"""
    def __init__(self, detail: str = "요청한 리소스를 찾을 수 없습니다.", error_code: str = "NOT_FOUND"):
        super().__init__(status_code=status.HTTP_404_NOT_FOUND, detail=detail, error_code=error_code)

class UnauthorizedException(CVEHubException):
    """인증되지 않은 요청에 대한 예외"""
    def __init__(self, detail: str = "인증이 필요합니다.", error_code: str = "AUTHENTICATION_ERROR"):
        super().__init__(status_code=status.HTTP_401_UNAUTHORIZED, detail=detail, error_code=error_code)

class ForbiddenException(CVEHubException):
    """권한이 없는 요청에 대한 예외"""
    def __init__(self, detail: str = "이 작업을 수행할 권한이 없습니다.", error_code: str = "AUTHORIZATION_ERROR"):
        super().__init__(status_code=status.HTTP_403_FORBIDDEN, detail=detail, error_code=error_code)

class ValidationException(CVEHubException):
    """데이터 유효성 검사 실패 시 발생하는 예외"""
    def __init__(self, detail: str = "입력 데이터가 유효하지 않습니다.", error_code: str = "VALIDATION_ERROR"):
        super().__init__(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY, detail=detail, error_code=error_code)

class DatabaseException(CVEHubException):
    """데이터베이스 작업 실패 시 발생하는 예외"""
    def __init__(self, detail: str = "데이터베이스 작업 중 오류가 발생했습니다.", error_code: str = "DATABASE_ERROR"):
        super().__init__(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=detail, error_code=error_code)

class DatabaseOperationError(CVEHubException):
    """데이터베이스 작업 중 특정 오퍼레이션 실패 시 발생하는 예외"""
    def __init__(self, detail: str = "데이터베이스 작업 수행 중 오류가 발생했습니다.", error_code: str = "DATABASE_OPERATION_ERROR"):
        super().__init__(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=detail, error_code=error_code)

class DuplicateException(CVEHubException):
    """중복된 데이터 생성 시도 시 발생하는 예외"""
    def __init__(self, detail: str = "이미 존재하는 데이터입니다."):
        super().__init__(status_code=status.HTTP_409_CONFLICT, detail=detail)

# 자주 사용되는 에러 타입 정의
class NotFoundError(CVEHubException):
    def __init__(self, detail: str = "요청한 리소스를 찾을 수 없습니다.", error_code: str = "NOT_FOUND"):
        super().__init__(status_code=404, detail=detail, error_code=error_code)

class ValidationError(CVEHubException):
    def __init__(self, detail: str = "입력값이 올바르지 않습니다.", error_code: str = "VALIDATION_ERROR"):
        super().__init__(status_code=400, detail=detail, error_code=error_code)

class AuthenticationError(CVEHubException):
    def __init__(self, detail: str = "인증에 실패했습니다.", error_code: str = "AUTHENTICATION_ERROR"):
        super().__init__(status_code=401, detail=detail, error_code=error_code)

class AuthorizationError(CVEHubException):
    def __init__(self, detail: str = "권한이 없습니다.", error_code: str = "AUTHORIZATION_ERROR"):
        super().__init__(status_code=403, detail=detail, error_code=error_code)

class DatabaseError(CVEHubException):
    def __init__(self, detail: str = "데이터베이스 오류가 발생했습니다.", error_code: str = "DATABASE_ERROR"):
        super().__init__(status_code=500, detail=detail, error_code=error_code)

class WebSocketError(CVEHubException):
    def __init__(self, detail: str = "WebSocket 연결 오류가 발생했습니다.", error_code: str = "WEBSOCKET_ERROR"):
        super().__init__(status_code=500, detail=detail, error_code=error_code)

class WebSocketConnectionError(Exception):
    """
    WebSocket 연결 관련 오류를 나타내는 예외 클래스입니다.
    
    이 예외는 WebSocket 연결이 필요한 작업을 수행할 때 활성 연결이 없는 경우 발생합니다.
    """
    def __init__(self, message="WebSocket 연결이 없거나 비활성 상태입니다"):
        self.message = message
        super().__init__(self.message)



============================================================
File: /home/CVEHub/backend/app/core/security.py
------------------------------------------------------------
from passlib.context import CryptContext
import logging

logger = logging.getLogger(__name__)

# 비밀번호 해싱을 위한 컨텍스트 설정
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """일반 텍스트 비밀번호와 해시된 비밀번호를 비교합니다."""
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except Exception as e:
        logger.error(f"비밀번호 검증 중 오류 발생: {str(e)}")
        return False

def get_password_hash(password: str) -> str:
    """비밀번호를 해시화합니다."""
    try:
        return pwd_context.hash(password)
    except Exception as e:
        logger.error(f"비밀번호 해시화 중 오류 발생: {str(e)}")
        raise



============================================================
File: /home/CVEHub/backend/app/core/dependencies.py
------------------------------------------------------------
from functools import lru_cache
# 변경: 새 통합 서비스 파일 사용
from ..auth.service import UserService
from ..cve.service import CVEService
from ..comment.service import CommentService
from ..comment.repository import CommentRepository
from ..notification.service import NotificationService
from ..crawler.service import CrawlerService
from app.socketio.manager import get_socket_manager, SocketManager
from fastapi import Depends
from typing import Annotated

# 싱글톤 인스턴스를 저장할 변수
_socket_manager: SocketManager = None
_user_service: UserService = None

@lru_cache()
def get_user_service() -> UserService:
    """UserService 인스턴스를 반환합니다."""
    global _user_service
    if _user_service is None:
        # socket_manager 의존성 주입
        _user_service = UserService(socket_manager=get_socket_manager())
    return _user_service

@lru_cache()
def get_comment_repository() -> CommentRepository:
    """CommentRepository 인스턴스를 반환합니다."""
    return CommentRepository()

@lru_cache()
def get_comment_service() -> CommentService:
    """CommentService 인스턴스를 반환합니다."""
    from ..cve.repository import CVERepository
    from ..activity.service import ActivityService
    return CommentService(
        comment_repository=get_comment_repository(),
        activity_service=ActivityService(),
        cve_repository=CVERepository()
    )

@lru_cache()
def get_cve_service() -> CVEService:
    """CVEService 인스턴스를 반환합니다."""
    return CVEService(comment_service=get_comment_service())

@lru_cache()
def get_notification_service() -> NotificationService:
    """NotificationService 인스턴스를 반환합니다."""
    return NotificationService()

@lru_cache()
def get_crawler_service() -> CrawlerService:
    """CrawlerService 인스턴스를 반환합니다."""
    return CrawlerService()

def get_socket_manager() -> SocketManager:
    """
    SocketManager 인스턴스를 반환합니다.
    애플리케이션 시작 시 초기화된 인스턴스를 사용합니다.
    """
    global _socket_manager
    if _socket_manager is None:
        _socket_manager = SocketManager()
    return _socket_manager

def initialize_socket_manager() -> SocketManager:
    """
    SocketManager 인스턴스를 초기화합니다.
    애플리케이션 시작 시 호출됩니다.
    """
    global _socket_manager
    if _socket_manager is None:
        _socket_manager = SocketManager()
    return _socket_manager

# FastAPI의 Depends를 사용한 타입 어노테이션
UserServiceDep = Annotated[UserService, Depends(get_user_service)]
CVEServiceDep = Annotated[CVEService, Depends(get_cve_service)]
CommentServiceDep = Annotated[CommentService, Depends(get_comment_service)]
CommentRepositoryDep = Annotated[CommentRepository, Depends(get_comment_repository)]
NotificationServiceDep = Annotated[NotificationService, Depends(get_notification_service)]
CrawlerServiceDep = Annotated[CrawlerService, Depends(get_crawler_service)]
SocketManagerDep = Annotated[SocketManager, Depends(get_socket_manager)]


============================================================
File: /home/CVEHub/backend/app/core/error_handlers.py
------------------------------------------------------------
from fastapi import Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException
from .exceptions import CVEHubException
import logging
from typing import Union
from pydantic import ValidationError
import traceback

async def cvehub_exception_handler(request: Request, exc: CVEHubException):
    """CVEHub 커스텀 예외 처리기"""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "detail": exc.detail,
            "error_code": exc.error_code
        }
    )

async def validation_exception_handler(request: Request, exc: ValidationError):
    """Pydantic 유효성 검사 예외 처리기"""
    return JSONResponse(
        status_code=400,
        content={
            "detail": str(exc),
            "error_code": "VALIDATION_ERROR"
        }
    )

async def request_validation_exception_handler(request: Request, exc: RequestValidationError):
    """FastAPI 요청 검증 예외 처리"""
    errors = []
    for error in exc.errors():
        error_detail = {
            "loc": error["loc"],
            "msg": error["msg"],
            "type": error["type"]
        }
        errors.append(error_detail)

    return JSONResponse(
        status_code=422,
        content={
            "detail": "입력값 검증 오류가 발생했습니다.",
            "errors": errors,
            "error_code": "REQUEST_VALIDATION_ERROR"
        }
    )

async def http_exception_handler(request: Request, exc: HTTPException):
    """HTTP 예외 처리"""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "detail": exc.detail,
            "error_code": "HTTP_ERROR"
        }
    )

async def general_exception_handler(request: Request, exc: Exception):
    """일반 예외 처리기"""
    # 예외 정보 로깅
    logging.error(f"Unhandled exception occurred: {str(exc)}")
    logging.error(traceback.format_exc())

    return JSONResponse(
        status_code=500,
        content={
            "detail": "내부 서버 오류가 발생했습니다.",
            "error_code": "INTERNAL_SERVER_ERROR"
        }
    ) 


============================================================
File: /home/CVEHub/backend/app/core/session.py
------------------------------------------------------------
from fastapi import HTTPException, status, Depends, Request
from fastapi.security import APIKeyCookie
from fastapi_sessions.backends.implementations import InMemoryBackend
from uuid import UUID
from pydantic import BaseModel
import logging

logger = logging.getLogger(__name__)

# 세션 데이터 모델
class SessionData(BaseModel):
    username: str
    email: str
    is_admin: bool = False

# 세션 백엔드 초기화
backend = InMemoryBackend[str, SessionData]()

# 세션 쿠키 설정
cookie_sec = APIKeyCookie(name="session_id", auto_error=False)

async def get_session_data(
    session_id: str = Depends(cookie_sec)
) -> SessionData:
    """현재 세션의 사용자 데이터를 반환합니다."""
    if not session_id:
        logger.error("No session cookie found")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated"
        )

    try:
        session_data = await backend.read(session_id)
        if not session_data:
            logger.error(f"Invalid session: {session_id}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid session"
            )
        return session_data
    except Exception as e:
        logger.error(f"Session verification error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Session verification failed"
        )



============================================================
File: /home/CVEHub/backend/app/core/cache.py
------------------------------------------------------------
"""
통합 캐싱 서비스 - 시스템 전체 캐싱 기능 제공
"""
import json
from typing import Any, Optional, List, Dict, Union
from datetime import datetime, timedelta
# aioredis 대신 redis.asyncio 사용
import redis.asyncio as redis_async
import logging
from .config import get_settings

logger = logging.getLogger(__name__)
import asyncio
settings = get_settings()

# Redis 연결 설정
redis_url = settings.REDIS_URL or "redis://localhost:6379/0"
_redis = None

# 캐시 키 프리픽스 및 기본 TTL 정의
CACHE_KEY_PREFIXES = {
    "crawler_result": "cache:crawler_result:",
    "cve_detail": "cache:cve_detail:",
    "cve_list": "cache:cve_list:",
    "user": "cache:user:",
    "stats": "cache:stats:"
}

DEFAULT_TTL = {
    "crawler_result": 86400,  # 1일
    "cve_detail": 3600,       # 1시간
    "cve_list": 300,          # 5분
    "user": 1800,             # 30분
    "stats": 600              # 10분
}

async def get_redis():
    """Redis 연결 얻기"""
    global _redis
    if _redis is None:
        try:
            # redis.asyncio 모듈 사용
            _redis = redis_async.from_url(
                redis_url,
                encoding="utf-8",
                decode_responses=True
            )
            logger.info(f"Redis 연결 성공: {redis_url}")
        except Exception as e:
            logger.error(f"Redis 연결 실패: {str(e)}")
            raise
    return _redis

# JSON 인코더 - datetime 객체를 ISO 포맷 문자열로 변환
class DateTimeJSONEncoder(json.JSONEncoder):
    """datetime 객체를 ISO 포맷 문자열로 변환하는 JSON 인코더"""
    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.isoformat()
        return super().default(obj)

async def set_cache(key: str, value: Any, expire: int = None, cache_type: str = None) -> bool:
    """
    캐시에 값 저장
    
    Args:
        key: 캐시 키
        value: 저장할 값 (자동으로 JSON 직렬화됨)
        expire: 만료 시간 (초)
        cache_type: 캐시 유형 (crawler_result, cve_detail, cve_list 등)
        
    Returns:
        성공 여부
    """
    try:
        # 캐시 타입에 따른 TTL 설정
        if expire is None and cache_type:
            expire = DEFAULT_TTL.get(cache_type, 3600)
            
        # 타임스탬프 추가
        if isinstance(value, dict):
            value["_cached_at"] = datetime.now().isoformat()
        
        redis = await get_redis()
        # datetime 객체를 처리할 수 있는 인코더 사용
        serialized = json.dumps(value, cls=DateTimeJSONEncoder)
        await redis.set(key, serialized, ex=expire)
        logger.debug(f"캐시 저장 성공: {key}")
        return True
    except Exception as e:
        logger.error(f"캐시 저장 실패 ({key}): {str(e)}")
        # 디버깅을 위한 추가 정보 로깅
        if isinstance(value, dict):
            problematic_keys = []
            for k, v in value.items():
                if isinstance(v, datetime):
                    problematic_keys.append(f"{k} (datetime)")
            if problematic_keys:
                logger.error(f"직렬화 문제가 있는 필드: {', '.join(problematic_keys)}")
        return False

# CVE 상세 정보 캐싱
async def cache_cve_detail(cve_id: str, data: Dict[str, Any]) -> bool:
    """
    CVE 상세 정보 캐싱
    """
    key = f"{CACHE_KEY_PREFIXES['cve_detail']}{cve_id}"
    return await set_cache(key, data, cache_type="cve_detail")

# CVE 목록 캐싱
async def cache_cve_list(query_params: Dict[str, Any], data: Dict[str, Any]) -> bool:
    """
    CVE 목록 캐싱 - 쿼리 파라미터 기반
    """
    # 쿼리 파라미터를 정렬된 문자열로 변환하여 일관된 키 생성
    params_str = "&".join(f"{k}={v}" for k, v in sorted(query_params.items()) 
                         if k not in ["_t", "timestamp"])
    
    key = f"{CACHE_KEY_PREFIXES['cve_list']}{params_str}"
    return await set_cache(key, data, cache_type="cve_list")

# 캐시 무효화 - CVE 업데이트 시
async def invalidate_cve_caches(cve_id: str = None) -> bool:
    """
    CVE 관련 캐시 무효화
    - 특정 CVE 캐시만 무효화하거나 모든 CVE 목록 캐시 무효화
    - 캐시 무효화 시 웹소켓으로 알림 발송 (클라이언트가 캐시 즉시 갱신하도록)
    
    Args:
        cve_id (str, optional): 무효화할 특정 CVE ID. None인 경우 모든 CVE 목록 캐시 무효화
        
    Returns:
        bool: 하나 이상의 캐시가 무효화되었는지 여부
    """
    try:
        # Redis 연결 상태 확인
        try:
            redis = await get_redis()
            # Redis 연결 테스트
            await redis.ping()
            logger.debug("Redis 연결 상태: 정상")
        except Exception as redis_err:
            logger.error(f"Redis 연결 오류: {str(redis_err)}")
            # Redis 연결 실패 시 빈 결과 반환하고 계속 진행
            return False
            
        invalidated = False
        
        # 특정 CVE 상세 정보 캐시 삭제
        if cve_id:
            start_time = datetime.now()
            # 상세 캐시 키 (기본 키 포함)
            detail_key = f"{CACHE_KEY_PREFIXES['cve_detail']}{cve_id}"
            try:
                detail_deleted = await redis.delete(detail_key)
                
                # 상세 정보 삭제 결과 로깅
                if detail_deleted:
                    logger.info(f"캐시 무효화: CVE 상세 정보 ({cve_id}) 삭제됨")
                    invalidated = True
                else:
                    logger.debug(f"캐시 무효화: CVE 상세 정보 ({cve_id})가 캐시에 없었음")
            except Exception as detail_err:
                logger.error(f"CVE 상세 캐시 삭제 중 오류: {str(detail_err)}")
            
            # 파생 캐시 키도 삭제 (다양한 형태로 저장된 관련 캐시 검색)
            try:
                derived_pattern = f"{CACHE_KEY_PREFIXES['cve_detail']}*{cve_id}*"
                async for derived_key in redis.scan_iter(match=derived_pattern):
                    if derived_key != detail_key:  # 이미 삭제한 기본 키는 제외
                        try:
                            deleted = await redis.delete(derived_key)
                            if deleted:
                                logger.info(f"캐시 무효화: 파생 CVE 상세 캐시 ({derived_key}) 삭제됨")
                                invalidated = True
                        except Exception as key_err:
                            logger.error(f"파생 캐시 키 삭제 중 오류 ({derived_key}): {str(key_err)}")
            except Exception as scan_err:
                logger.error(f"캐시 키 스캔 중 오류: {str(scan_err)}")
            
            # 처리 시간 측정 및 로깅
            processing_time = (datetime.now() - start_time).total_seconds() * 1000
            logger.debug(f"CVE 상세 캐시 무효화 처리 시간: {processing_time:.2f}ms")
        
        # CVE 목록 캐시는 패턴 매칭으로 모두 삭제
        start_time = datetime.now()
        cve_list_pattern = f"{CACHE_KEY_PREFIXES['cve_list']}*"
        
        # scan_iter로 모든 매칭되는 키 찾기
        list_keys = []
        try:
            async for key in redis.scan_iter(match=cve_list_pattern):
                list_keys.append(key)
        except Exception as scan_err:
            logger.error(f"목록 캐시 키 스캔 중 오류: {str(scan_err)}")
        
        # 목록 캐시가 있으면 파이프라인으로 일괄 삭제
        if list_keys:
            # 로깅을 위한 키 샘플링 (최대 5개)
            sample_keys = list_keys[:5]
            logger.info(f"삭제할 목록 캐시 키 샘플: {sample_keys} (총 {len(list_keys)}개)")
            
            try:
                # 파이프라인으로 효율적으로 삭제
                pipe = redis.pipeline()
                for key in list_keys:
                    pipe.delete(key)
                results = await pipe.execute()
                
                # 삭제된 키 수 집계 및 로깅
                deleted_count = sum(1 for res in results if res)
                if deleted_count > 0:
                    logger.info(f"캐시 무효화: {deleted_count}개의 CVE 목록 캐시 삭제됨 (총 {len(list_keys)}개 중)")
                    invalidated = True
                else:
                    logger.warning(f"캐시 무효화: 목록 캐시 키는 {len(list_keys)}개 발견되었으나 삭제된 캐시가 없음")
            except Exception as pipe_err:
                logger.error(f"파이프라인 실행 중 오류: {str(pipe_err)}")
        else:
            logger.debug("캐시 무효화: 삭제할 CVE 목록 캐시가 없음")
        
        # 목록 캐시 처리 시간 측정 및 로깅
        processing_time = (datetime.now() - start_time).total_seconds() * 1000
        logger.debug(f"CVE 목록 캐시 무효화 처리 시간: {processing_time:.2f}ms")
        
        # 캐시 무효화 결과를 웹소켓으로 브로드캐스트
        if invalidated:
            event_data = {
                "event": "cache_invalidated",
                "data": {
                    "cve_id": cve_id,
                    "timestamp": datetime.now().isoformat(),
                    "invalidated_detail": cve_id is not None,
                    "invalidated_lists": len(list_keys) > 0
                }
            }
            
            try:
                # 웹소켓 이벤트 발생 (비동기 태스크로 실행)
                ws_task = asyncio.create_task(
                    handle_websocket_event(
                        "cache_invalidated", 
                        event_data["data"]
                    )
                )
                # 태스크에 이름 지정 (디버깅 용이)
                ws_task.set_name(f"ws_cache_invalidate_{cve_id if cve_id else 'all'}")
                logger.info(f"캐시 무효화 웹소켓 이벤트 발생: {cve_id if cve_id else '전체 목록'}")
            except Exception as ws_err:
                logger.error(f"웹소켓 이벤트 발생 중 오류: {str(ws_err)}")
                logger.error(traceback.format_exc())
            
        return invalidated
        
    except Exception as e:
        logger.error(f"캐시 무효화 중 오류 발생: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        # 오류 발생 시에도 계속 진행
        return False

# 웹소켓 이벤트 기반 캐시 무효화 함수
async def handle_websocket_event(event_type: str, data: Dict[str, Any]) -> None:
    """
    웹소켓 이벤트에 따른 캐시 무효화 처리
    """
    if event_type in ["cve_created", "cve_updated", "cve_deleted"]:
        cve_id = data.get("cve_id") or data.get("cveId")
        if cve_id:
            logger.info(f"웹소켓 이벤트 {event_type}에 따른 캐시 무효화: {cve_id}")
            await invalidate_cve_caches(cve_id)
    
    elif event_type == "comment_added" or event_type == "comment_updated":
        cve_id = data.get("cve_id") or data.get("cveId")
        if cve_id:
            # 댓글 관련 업데이트는 CVE 상세 캐시만 무효화
            detail_key = f"{CACHE_KEY_PREFIXES['cve_detail']}{cve_id}"
            await get_redis().delete(detail_key)

async def get_cache(key: str) -> Optional[Any]:
    """
    캐시에서 값 조회
    
    Args:
        key: 캐시 키
        
    Returns:
        저장된 값 (JSON으로 역직렬화됨) 또는 None
    """
    try:
        redis = await get_redis()
        value = await redis.get(key)
        if value is None:
            return None
        return json.loads(value)
    except Exception as e:
        logger.error(f"캐시 조회 실패 ({key}): {str(e)}")
        return None

async def delete_cache(key: str) -> bool:
    """
    캐시에서 키 삭제
    
    Args:
        key: 캐시 키
        
    Returns:
        성공 여부
    """
    try:
        redis = await get_redis()
        await redis.delete(key)
        return True
    except Exception as e:
        logger.error(f"캐시 삭제 실패 ({key}): {str(e)}")
        return False


============================================================
File: /home/CVEHub/backend/app/core/config.py
------------------------------------------------------------
from pydantic import BaseSettings
from typing import List
from functools import lru_cache
from datetime import timedelta

class Settings(BaseSettings):
    # App settings
    PROJECT_NAME: str = "CVEHub"
    VERSION: str = "1.0.0"
    CORS_ORIGINS: List[str] = ["http://localhost:3000", "http://127.0.0.1:3000"]
    DEBUG: bool = False

    # Database settings
    MONGODB_URL: str
    DATABASE_NAME: str = "cvehub"
    MAX_CONNECTIONS_COUNT: int = 10
    MIN_CONNECTIONS_COUNT: int = 1

    # JWT settings
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7

    # Timezone settings
    TZ: str = "Asia/Seoul"
    TIMEZONE: str = "Asia/Seoul"
    DATETIME_FORMAT: str = "%Y-%m-%d %H:%M:%S"

    # WebSocket settings
    WS_PING_INTERVAL: int = 30
    WS_PING_TIMEOUT: int = 10
    WS_CLOSE_TIMEOUT: int = 5
    WS_MAX_HTTP_BUFFER_SIZE: int = 1024 * 1024  # 1MB
    WS_ENGINEIO_LOGGER: bool = False
    WS_CLEANUP_INTERVAL: int = 300  # 5분마다 정리
    LOG_PING_PONG: bool = False

    @property
    def socket_path(self) -> str:
        return '/ws/socket.io'
    
    # 데이터 디렉토리 설정 추가
    DATA_DIR: str = "/home/CVEHub/data"

    # Redis settings
    REDIS_URL: str = "redis://redis:6379/0"

    # Crawler settings
    NUCLEI_TEMPLATES_URL: str = "https://github.com/projectdiscovery/nuclei-templates.git"
    EMERGING_THREATS_URL: str = "https://rules.emergingthreats.net/open/snort-2.9.0/rules/emerging-all.rules"
    TEMP_DIR: str = "/tmp/cvehub"

    class Config:
        env_prefix = ""
        env_file = ".env"
        case_sensitive = True
        extra = "allow"

    @property
    def REFRESH_TOKEN_EXPIRE_DELTA(self) -> timedelta:
        """리프레시 토큰 만료 기간을 timedelta로 반환"""
        return timedelta(days=self.REFRESH_TOKEN_EXPIRE_DAYS)

@lru_cache()
def get_settings() -> Settings:
    return Settings()



============================================================
File: /home/CVEHub/backend/app/core/scheduler.py
------------------------------------------------------------
import asyncio
import logging
from datetime import datetime
import pytz
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from apscheduler.triggers.cron import CronTrigger
from app.crawler.crawler_manager import CrawlerManager
from .config import get_settings
from app.system.models import SystemConfig
from app.socketio.manager import socketio_manager
from app.crawler.crawler_base import LoggingMixin
import functools
from typing import Optional, Dict, Any, List, Tuple
import traceback

logger = logging.getLogger(__name__)
settings = get_settings()

# KST 타임존 정의
KST = pytz.timezone('Asia/Seoul')

# 현재 시간을 KST로 가져오는 함수
def get_now_kst():
    """현재 시간을 KST 시간대로 반환"""
    return datetime.now(KST)

# 캐시 데코레이터
def async_cache(ttl_seconds=300):
    """비동기 함수 결과를 캐싱하는 데코레이터"""
    cache = {}
    
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            # 캐시 키 생성
            key = str(args) + str(kwargs)
            now = datetime.now()
            
            # 캐시에 있고 유효 기간이 지나지 않았으면 캐시 반환
            if key in cache and (now - cache[key]['timestamp']).total_seconds() < ttl_seconds:
                return cache[key]['result']
            
            # 함수 실행
            result = await func(*args, **kwargs)
            
            # 결과 캐싱
            cache[key] = {
                'result': result,
                'timestamp': now
            }
            
            return result
        return wrapper
    return decorator

class CrawlerScheduler(LoggingMixin):
    """Nuclei-templates 및 기타 크롤러를 스케줄링하는 클래스"""
    
    _instance = None
    _is_running = False
    _last_update = {}
    _initialized = False
    _db_state_initialized = False
    _running_crawlers = {}  # 크롤러 유형별 실행 상태
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(CrawlerScheduler, cls).__new__(cls)
            cls._instance._scheduler = AsyncIOScheduler()
            cls._instance._crawler_manager = CrawlerManager()
            cls._instance._lock = asyncio.Lock()
            # 데이터베이스 초기화 이전에는 빈 상태로 시작
            cls._instance._last_update = {}
            cls._instance._initialized = False
            cls._instance._update_results = {}  # 마지막 업데이트 결과 저장
        return cls._instance
    
    def start(self):
        """스케줄러 시작"""
        if not self._scheduler.running:
            self._setup_jobs()
            self._scheduler.start()
            self.log_info("Scheduler started")
    
    def _setup_jobs(self):
        """정기적인 크롤링 작업 설정"""
        # Nuclei 크롤러 - 매일 자정 실행
        self._scheduler.add_job(
            self._run_crawler_task,
            trigger=CronTrigger(hour=0, minute=0, timezone=KST),
            args=["nuclei"],
            id="nuclei_daily",
            replace_existing=True
        )
        
        # Metasploit 크롤러 - 매주 월요일 새벽 3시 실행
        self._scheduler.add_job(
            self._run_crawler_task,
            trigger=CronTrigger(day_of_week="mon", hour=3, minute=0, timezone=KST),
            args=["metasploit"],
            id="metasploit_weekly",
            replace_existing=True
        )
        
        self.log_info("Scheduled jobs set up")
    
    async def _run_crawler_task(self, crawler_type: str):
        """스케줄러에서 호출할 크롤러 실행 작업"""
        try:
            # 크롤러 인스턴스 생성
            crawler = self._crawler_manager.create_crawler(crawler_type)
            if not crawler:
                logger.error(f"크롤러 생성 실패: {crawler_type}")
                return False
            
            # 조용한 모드 활성화 (스케줄러에 의한 실행이므로)
            if hasattr(crawler, 'set_quiet_mode'):
                crawler.set_quiet_mode(True)
                logger.info(f"{crawler_type} 크롤러: 조용한 모드 활성화 (스케줄러 실행)")
            
            # 크롤러 실행
            success = await crawler.crawl()
            
            # 실행 결과 로깅
            if success:
                logger.info(f"스케줄 {crawler_type} 크롤러 실행 성공")
            else:
                logger.error(f"스케줄 {crawler_type} 크롤러 실행 실패")
                
            return success
        except Exception as e:
            logger.error(f"스케줄 크롤러 실행 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return False
    
    async def init_db(self):
        """데이터베이스가 초기화된 후 호출되는 메서드"""
        if not self._initialized:
            try:
                self.log_info("크롤러 스케줄러 데이터베이스 초기화 중...")
                await self._load_last_updates()
                self._initialized = True
                self._db_state_initialized = True  # DB 초기화 플래그 설정
                self.log_info("크롤러 스케줄러 데이터베이스 초기화 완료")
            except Exception as e:
                self.log_error(f"크롤러 스케줄러 데이터베이스 초기화 중 오류 발생: {e}")
                # 오류가 발생해도 초기화는 계속 진행
                self._initialized = True
                # 최소한의 기능을 위해 DB 상태 초기화됨으로 설정
                self._db_state_initialized = True
    
    async def _load_last_updates(self):
        """시스템 설정에서 마지막 업데이트 시간 로드"""
        try:
            from ..models.system_config_model import SystemConfig
            
            # SystemConfig 모델이 초기화되었는지 확인
            try:
                updates = await SystemConfig.get_crawler_last_updates()
                if updates:
                    self._last_update = updates
                    self.log_info(f"마지막 업데이트 시간 로드: {updates}")
                else:
                    self.log_info("이전 업데이트 기록 없음")
            except Exception as e:
                if "CollectionWasNotInitialized" in str(e):
                    self.log_warning("SystemConfig 모델이 초기화되지 않았습니다. 기본값 사용")
                    # SystemConfig가 초기화되지 않았다면 빈 딕셔너리 사용
                    self._last_update = {}
                    
                    # 초기 데이터 생성 시도
                    try:
                        # SystemConfig 컬렉션 초기화 (부분적 초기화)
                        from motor.motor_asyncio import AsyncIOMotorClient
                        from ..core.config import get_settings
                        settings = get_settings()
                        
                        # MongoDB 연결
                        client = AsyncIOMotorClient(settings.MONGODB_URL)
                        db = client[settings.DATABASE_NAME]
                        
                        # system_config 컬렉션에 직접 문서 삽입
                        await db.system_config.insert_one({
                            "key": "crawler_last_updates",
                            "value": {}
                        })
                        
                        self.log_info("SystemConfig 초기 데이터 생성 완료")
                    except Exception as init_err:
                        self.log_error(f"SystemConfig 초기화 실패: {init_err}")
                else:
                    self.log_error(f"마지막 업데이트 시간 로드 중 오류: {e}")
                    self._last_update = {}
                
        except Exception as e:
            self.log_error(f"마지막 업데이트 시간 로드 중 오류: {e}")
            # 오류 발생 시 빈 딕셔너리로 초기화
            self._last_update = {}
    
    async def _save_last_update(self, crawler_type: str, update_time: datetime):
        """데이터베이스에 마지막 업데이트 시간 저장"""
        try:
            if not self._initialized:
                self.log_warning("데이터베이스가 초기화되지 않아 업데이트 시간을 저장할 수 없습니다.")
                return
                
            if not crawler_type:
                self.log_warning("크롤러 타입이 지정되지 않았습니다.")
                return
                
            if not update_time:
                self.log_warning("업데이트 시간이 지정되지 않았습니다.")
                return
                
            # 타임존 정보가 없는 경우 KST로 설정
            if update_time.tzinfo is None:
                update_time = KST.localize(update_time)
                
            await SystemConfig.update_crawler_last_update(crawler_type, update_time)
            self.log_info(f"크롤러 {crawler_type}의 마지막 업데이트 시간 저장됨: {update_time}")
        except Exception as e:
            self.log_error(f"크롤러 {crawler_type}의 업데이트 시간 저장 중 오류 발생: {e}")
    
    async def _broadcast_progress(self, crawler_type: str, stage: str, percent: int, message: str, updated_cves=None):
        """웹소켓을 통해 진행 상황을 브로드캐스트합니다."""
        try:
            # 단순화된 데이터 구조
            data = {
                "type": "crawler_update_progress",
                "data": {
                    "crawler": crawler_type,
                    "stage": stage,
                    "percent": percent,
                    "message": message,
                    "timestamp": datetime.now().isoformat(),  # 이미 문자열로 변환
                    "isRunning": self._is_running
                }
            }
            
            # 업데이트된 CVE 정보가 있으면 추가
            if updated_cves:
                # datetime 객체를 문자열로 직접 변환
                if isinstance(updated_cves, dict) and "items" in updated_cves:
                    for item in updated_cves["items"]:
                        if "created_at" in item and isinstance(item["created_at"], datetime):
                            item["created_at"] = item["created_at"].isoformat()
                
                data["data"]["updated_cves"] = updated_cves
            
            # 웹소켓으로 전송
            await socketio_manager.broadcast_json(data)
            
            # 로그
            self.log_info(f"진행 상황 [{crawler_type}]: {stage} {percent}% - {message}")
            
        except Exception as e:
            self.log_error(f"웹소켓 진행 상황 전송 중 오류: {str(e)}")
            self.log_error(traceback.format_exc())
    
    async def run_specific_crawler(self, crawler_type: str, user_id: Optional[str] = None, quiet_mode: bool = False):
        """특정 크롤러 실행"""
        try:
            # 크롤러 인스턴스 생성
            crawler = self._crawler_manager.create_crawler(crawler_type)
            if not crawler:
                logger.error(f"크롤러 생성 실패: {crawler_type}")
                return False
            
            # 사용자 ID 설정 (개인화된 메시지 전송용)
            if hasattr(crawler, 'set_requester_id') and user_id:
                crawler.set_requester_id(user_id)
            
            # 조용한 모드 설정
            if hasattr(crawler, 'set_quiet_mode'):
                crawler.set_quiet_mode(quiet_mode)
                if quiet_mode:
                    logger.info(f"{crawler_type} 크롤러: 조용한 모드로 실행")
            
            # 크롤러 실행 상태 설정 (async with 사용)
            async with self._lock:
                self._running_crawlers[crawler_type] = True
                self._is_running = True  # 전역 상태도 유지
                
                # 업데이트 시작 시간 기록
                start_time = get_now_kst()
                
                # 업데이트 시작 상태 브로드캐스트
                await self._broadcast_progress(
                    crawler_type=crawler_type,
                    stage="준비 중",
                    percent=0,
                    message=f"{crawler_type} 업데이트를 시작합니다."
                )
                
                try:
                    # 크롤러 실행
                    update_result = await crawler.crawl()
                    
                    # 크롤러 실행 성공 시
                    if update_result and update_result.get("stage") == "success":
                        # 마지막 업데이트 시간 저장
                        self._last_update[crawler_type] = start_time
                        await self._save_last_update(crawler_type, start_time)
                        
                        # 결과 저장
                        self._update_results[crawler_type] = update_result
                        
                        # 완료 단계
                        if update_result and isinstance(update_result.get("updated_cves"), dict):
                            updated_count = update_result["updated_cves"].get("count", 0)
                            success_message = f"{crawler_type} 업데이트가 완료되었습니다. {updated_count}개의 CVE가 업데이트되었습니다."
                            
                            # 업데이트가 없는 경우
                            if updated_count == 0:
                                success_message = f"{crawler_type} 업데이트가 완료되었습니다. 업데이트된 CVE가 없습니다."
                            
                            # 완료 메시지 전송
                            await self._broadcast_progress(
                                crawler_type=crawler_type,
                                stage="완료",
                                percent=100,
                                message=success_message,
                                updated_cves=update_result.get("updated_cves")
                            )
                        else:
                            # 기본 완료 메시지
                            await self._broadcast_progress(
                                crawler_type=crawler_type,
                                stage="완료",
                                percent=100,
                                message=f"{crawler_type} 업데이트가 완료되었습니다."
                            )
                        
                        return True
                    else:
                        # 오류 메시지
                        error_message = update_result.get("message", f"{crawler_type} 업데이트 중 오류가 발생했습니다.") if update_result else f"{crawler_type} 업데이트 중 오류가 발생했습니다."
                        
                        # 오류 상태 브로드캐스트
                        await self._broadcast_progress(
                            crawler_type=crawler_type,
                            stage="오류",
                            percent=0,
                            message=error_message
                        )
                        
                        return False
                except Exception as e:
                    # 크롤러 실행 중 오류 발생
                    error_message = f"크롤러 실행 중 오류 발생: {str(e)}"
                    self.log_error(error_message, e)
                    
                    # 오류 상태 브로드캐스트
                    await self._broadcast_progress(
                        crawler_type=crawler_type,
                        stage="오류",
                        percent=0,
                        message=error_message
                    )
                    
                    return False
                finally:
                    # 크롤러 실행 상태 해제
                    self._running_crawlers[crawler_type] = False
                    
                    # 다른 크롤러가 실행 중인지 확인
                    if not any(self._running_crawlers.values()):
                        self._is_running = False
        except Exception as e:
            # 전체 프로세스 오류
            error_message = f"크롤러 실행 중 오류 발생: {str(e)}"
            self.log_error(error_message, e)
            
            try:
                # 오류 상태 브로드캐스트
                await self._broadcast_progress(
                    crawler_type=crawler_type,
                    stage="오류",
                    percent=0,
                    message=error_message
                )
            except Exception as broadcast_error:
                self.log_error(f"오류 메시지 전송 실패: {str(broadcast_error)}", broadcast_error)
            
            return False
    
    def is_update_running(self) -> bool:
        """현재 업데이트가 진행 중인지 확인"""
        return self._is_running
    
    def get_last_update(self, crawler_type: str = None) -> Dict[str, datetime]:
        """마지막 업데이트 시간 조회"""
        if crawler_type:
            return {crawler_type: self._last_update.get(crawler_type)}
        return self._last_update
    
    def get_update_results(self, crawler_type: str = None) -> Dict[str, Dict[str, Any]]:
        """업데이트 결과 조회"""
        if crawler_type:
            return {crawler_type: self._update_results.get(crawler_type)}
        return self._update_results

    async def _batch_process_data(self, crawler_type: str, data_list: List[Dict[str, Any]], batch_size: int = 20) -> int:
        """데이터를 배치로 처리
        
        Args:
            crawler_type: 크롤러 유형
            data_list: 처리할 데이터 리스트
            batch_size: 배치 크기
            
        Returns:
            int: 처리된 데이터 수
        """
        if not data_list:
            return 0
            
        total = len(data_list)
        processed = 0
        
        # 배치 단위로 나누기
        batches = [data_list[i:i+batch_size] for i in range(0, total, batch_size)]
        
        for i, batch in enumerate(batches):
            # 배치 처리 진행률 계산
            progress = int((i / len(batches)) * 100)
            
            # 진행 상황 보고
            await self._broadcast_progress(
                crawler_type=crawler_type,
                stage="처리",
                percent=progress,
                message=f"{len(batch)}개 항목 처리 중... ({processed}/{total})"
            )
            
            # 배치 병렬 처리
            tasks = []
            for item in batch:
                # 여기서 실제 데이터 처리 로직 호출
                # 예: crawler.process_data(item)
                tasks.append(asyncio.create_task(self._process_single_item(crawler_type, item)))
            
            # 배치의 모든 작업이 완료될 때까지 대기
            batch_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # 결과 처리
            for result in batch_results:
                if result is True:  # 성공적으로 처리된 경우
                    processed += 1
                elif isinstance(result, Exception):
                    self.log_error(f"데이터 처리 중 오류: {str(result)}")
            
        return processed
    
    async def _process_single_item(self, crawler_type: str, item: Dict[str, Any]) -> bool:
        """단일 데이터 항목 처리
        
        실제 구현에서는 해당 크롤러의 process_data 메서드를 호출
        
        Args:
            crawler_type: 크롤러 유형
            item: 처리할 데이터 항목
            
        Returns:
            bool: 처리 성공 여부
        """
        try:
            # 크롤러 인스턴스 생성 방식 개선
            if hasattr(self._crawler_manager, 'create_crawler'):
                crawler = self._crawler_manager.create_crawler(crawler_type)
            elif hasattr(self._crawler_manager, 'factory') and self._crawler_manager.factory:
                crawler = self._crawler_manager.factory.create_crawler(crawler_type)
            else:
                return False
            
            if crawler:
                return await crawler.process_data(item)
            return False
        except Exception as e:
            self.log_error(f"항목 처리 중 오류: {str(e)}", e)
            return False
    
    def is_db_initialized(self) -> bool:
        """데이터베이스가 초기화되었는지 확인합니다."""
        try:
            # DB 연결 상태를 확인하는 간단한 방법
            if self._db_state_initialized:
                return True
            
            # 비동기 함수를 동기적으로 실행
            loop = asyncio.get_event_loop()
            if loop.is_running():
                # 이미 이벤트 루프가 실행 중인 경우 (FastAPI 내에서 호출)
                # 새로운 루프를 생성하지 않고 현재 실행 중인 루프에서 future를 실행
                return True  # FastAPI 컨텍스트 내에서는 일단 성공으로 가정
            else:
                # 독립 실행 환경에서는 새 루프 생성
                return asyncio.run(self._check_db_connection())
        except Exception as e:
            self.log_error(f"데이터베이스 초기화 확인 중 오류: {str(e)}", e)
            return False
        
    async def _check_db_connection(self) -> bool:
        """데이터베이스 연결을 비동기적으로 확인합니다."""
        try:
            from ..models.cve_model import CVEModel
            # 간단한 쿼리 실행
            await CVEModel.find_all().limit(1).to_list()
            self._db_state_initialized = True  # 연결 성공 시 상태 저장
            return True
        except Exception as e:
            self.log_error(f"DB 연결 확인 중 오류: {str(e)}", e)
            return False

    async def init_scheduler_state(self):
        """
        스케줄러의 내부 상태를 초기화하는 메서드
        
        참고: 이 메서드는 실제로 데이터베이스를 초기화하지 않습니다. 
        데이터베이스가 이미 초기화된 후에 스케줄러의 상태만 설정합니다.
        """
        return await self.init_db()

def setup_scheduler():
    """호환성을 위한 함수 - CrawlerScheduler 인스턴스 반환"""
    return CrawlerScheduler() 


============================================================
File: /home/CVEHub/backend/app/core/base_service.py
------------------------------------------------------------
"""
베이스 서비스 모듈

서비스 클래스에서 공통으로 사용하는 기능을 제공하는 기본 클래스입니다.
이 클래스는 템플릿 메서드 패턴을 사용하여 에러 처리, 로깅, 응답 형식 등의 공통 로직을 정의합니다.
"""

from typing import Any, Dict, Optional, TypeVar, Generic, Type, Union, List, Tuple, Protocol
import traceback
import logging
from abc import ABC, abstractmethod

# 제네릭 타입 변수 정의
T = TypeVar('T')
R = TypeVar('R')

# 로거 설정
logger = logging.getLogger(__name__)


class BaseRepository(Protocol):
    """저장소 인터페이스 프로토콜

    이 프로토콜은 저장소 클래스가 구현해야 하는 기본적인 메서드를 정의합니다.
    실제 구현은 각 저장소 클래스에서 해야 합니다.
    """
    pass


class BaseService(ABC, Generic[T]):
    """기본 서비스 클래스

    템플릿 메서드 패턴을 사용하여 공통 로직을 제공하는 기본 서비스 클래스입니다.
    이 클래스를 상속받아 구체적인 서비스 구현을 만들 수 있습니다.
    """

    def __init__(self, repository: Optional[T] = None):
        """서비스 초기화

        Args:
            repository: 저장소 인스턴스 (선택적)
        """
        self.repository = repository
        self.logger = self._get_logger()

    def _get_logger(self) -> logging.Logger:
        """로거 인스턴스를 반환합니다.

        이 메서드는 하위 클래스에서 오버라이드하여 다른 로거를 사용할 수 있습니다.

        Returns:
            로거 인스턴스
        """
        return logging.getLogger(self.__class__.__module__)

    async def execute_with_error_handling(self, func, *args, **kwargs) -> Dict[str, Any]:
        """오류 처리와 함께 비동기 함수를 실행합니다.

        Args:
            func: 실행할 비동기 함수
            *args: 함수에 전달할 위치 인자
            **kwargs: 함수에 전달할 키워드 인자

        Returns:
            실행 결과를 담은 딕셔너리 (성공 또는 오류 정보 포함)
        """
        try:
            # 함수 실행
            result = await func(*args, **kwargs)
            
            # 성공 응답 생성
            return self.create_success_response(result)
        except Exception as e:
            # 오류 로깅
            self.logger.error(f"함수 실행 중 오류 발생: {str(e)}")
            self.logger.error(traceback.format_exc())
            
            # 오류 응답 생성
            return self.create_error_response(str(e))

    def create_success_response(self, data: Any = None) -> Dict[str, Any]:
        """성공 응답을 생성합니다.

        Args:
            data: 응답에 포함할 데이터

        Returns:
            성공 응답 딕셔너리
        """
        response = {"success": True}
        
        if data is not None:
            # 반환 데이터가 딕셔너리인 경우 병합
            if isinstance(data, dict):
                response.update(data)
            else:
                # 딕셔너리가 아닌 경우 result 키로 저장
                response["result"] = data
                
        return response

    def create_error_response(self, error_message: str, error_code: str = None) -> Dict[str, Any]:
        """오류 응답을 생성합니다.

        Args:
            error_message: 오류 메시지
            error_code: 오류 코드 (선택적)

        Returns:
            오류 응답 딕셔너리
        """
        error = {
            "message": error_message
        }
        
        if error_code:
            error["code"] = error_code
            
        return {
            "success": False,
            "error": error
        }

    async def handle_operation(self, operation_name: str, operation_func, *args, **kwargs) -> Dict[str, Any]:
        """작업을 처리하고 결과를 반환합니다.

        이 템플릿 메서드는 작업 전후 로깅과 오류 처리를 포함한 공통 로직을 제공합니다.

        Args:
            operation_name: 작업 이름 (로깅용)
            operation_func: 실행할 비동기 함수
            *args: 함수에 전달할 위치 인자
            **kwargs: 함수에 전달할 키워드 인자

        Returns:
            작업 결과를 담은 딕셔너리
        """
        self.logger.debug(f"{operation_name} 작업 시작")
        
        try:
            # 작업 전 전처리 (하위 클래스에서 구현 가능)
            self.before_operation(operation_name, *args, **kwargs)
            
            # 작업 실행
            result = await self.execute_with_error_handling(operation_func, *args, **kwargs)
            
            # 작업 후 후처리 (하위 클래스에서 구현 가능)
            self.after_operation(operation_name, result, *args, **kwargs)
            
            self.logger.debug(f"{operation_name} 작업 완료: {result.get('success', False)}")
            return result
        except Exception as e:
            self.logger.error(f"{operation_name} 작업 중 예외 발생: {str(e)}")
            self.logger.error(traceback.format_exc())
            
            # 예외 처리 (하위 클래스에서 구현 가능)
            self.handle_operation_exception(operation_name, e, *args, **kwargs)
            
            return self.create_error_response(str(e))

    def before_operation(self, operation_name: str, *args, **kwargs) -> None:
        """작업 실행 전 호출되는 메서드

        하위 클래스에서 오버라이드하여 전처리 로직을 구현할 수 있습니다.

        Args:
            operation_name: 작업 이름
            *args: 작업에 전달된 위치 인자
            **kwargs: 작업에 전달된 키워드 인자
        """
        pass

    def after_operation(self, operation_name: str, result: Dict[str, Any], *args, **kwargs) -> None:
        """작업 실행 후 호출되는 메서드

        하위 클래스에서 오버라이드하여 후처리 로직을 구현할 수 있습니다.

        Args:
            operation_name: 작업 이름
            result: 작업 결과
            *args: 작업에 전달된 위치 인자
            **kwargs: 작업에 전달된 키워드 인자
        """
        pass

    def handle_operation_exception(self, operation_name: str, exception: Exception, *args, **kwargs) -> None:
        """작업 중 예외 발생 시 호출되는 메서드

        하위 클래스에서 오버라이드하여 예외 처리 로직을 구현할 수 있습니다.

        Args:
            operation_name: 작업 이름
            exception: 발생한 예외
            *args: 작업에 전달된 위치 인자
            **kwargs: 작업에 전달된 키워드 인자
        """
        pass



============================================================
File: /home/CVEHub/backend/app/comment/router.py
------------------------------------------------------------
"""
댓글 관련 API 라우터 - CVE 라우터에서 분리
"""
from fastapi import APIRouter, HTTPException, Depends, Query, Path, status, BackgroundTasks
from typing import List, Optional, Dict, Any, Union
import logging
import traceback
import functools

from app.auth.models import User
from app.auth.service import get_current_user
from app.comment.models import CommentCreate, CommentUpdate, CommentResponse
from app.comment.service import CommentService
from app.core.dependencies import get_comment_service
from app.cve.service import CVEService
from app.core.dependencies import get_cve_service
from app.core.config import get_settings

# 로거 설정
logger = logging.getLogger(__name__)

# 설정 가져오기
settings = get_settings()

# 댓글 라우터
router = APIRouter()

# 예외 타입별 HTTP 상태 코드 매핑
exception_status_map = {
    ValueError: status.HTTP_400_BAD_REQUEST,
    KeyError: status.HTTP_404_NOT_FOUND,
    IndexError: status.HTTP_404_NOT_FOUND,
    PermissionError: status.HTTP_403_FORBIDDEN,
    FileNotFoundError: status.HTTP_404_NOT_FOUND,
    NotImplementedError: status.HTTP_501_NOT_IMPLEMENTED,
}

# 예외 타입별 에러 메시지 매핑
exception_message_map = {
    ValueError: "잘못된 값이 제공되었습니다",
    KeyError: "요청한 항목을 찾을 수 없습니다",
    IndexError: "색인이 범위를 벗어났습니다",
    PermissionError: "이 작업을 수행할 권한이 없습니다",
    FileNotFoundError: "파일을 찾을 수 없습니다",
    NotImplementedError: "이 기능은 아직 구현되지 않았습니다",
}

def comment_api_error_handler(func):
    """댓글 API 엔드포인트 예외 처리 데코레이터"""
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except HTTPException:
            # FastAPI HTTP 예외는 그대로 전달
            raise
        except Exception as e:
            # 로깅
            endpoint = func.__name__
            logger.error(f"댓글 API 오류 ({endpoint}): {str(e)}")
            if "current_user" in kwargs:
                user = kwargs["current_user"]
                logger.error(f"사용자: {user.username} (ID: {user.id})")
                
            # 예외 유형에 따른 상태 코드 결정
            error_status = status.HTTP_500_INTERNAL_SERVER_ERROR
            for exc_type, status_code in exception_status_map.items():
                if isinstance(e, exc_type):
                    error_status = status_code
                    break
                    
            # 예외 유형에 따른 메시지 결정
            base_message = "서버 내부 오류가 발생했습니다"
            for exc_type, message in exception_message_map.items():
                if isinstance(e, exc_type):
                    base_message = message
                    break
            
            # 상세 오류 정보 (개발 환경에서만)
            error_detail = f"{base_message}: {str(e)}"
            if settings.DEBUG:
                error_detail = f"{error_detail}\n{traceback.format_exc()}"
                
            # 표준화된 HTTP 예외 반환
            raise HTTPException(
                status_code=error_status,
                detail=error_detail
            )
    return wrapper


@router.post("/{cve_id}/comments", response_model=Dict[str, str])
@comment_api_error_handler
async def create_comment(
    cve_id: str,
    comment_data: CommentCreate,
    current_user: User = Depends(get_current_user),
    comment_service: CommentService = Depends(get_comment_service),
    cve_service: CVEService = Depends(get_cve_service),
    background_tasks: BackgroundTasks = None
):
    """새 댓글을 생성합니다."""
    logger.info(f"댓글 생성 요청: {cve_id}")
    
    # 현재 사용자 정보 추가
    comment_dict = comment_data.dict()
    comment_dict["created_by"] = current_user.username
    
    # 댓글 생성
    comment_id = await comment_service.create_comment(cve_id, comment_dict)
    
    if not comment_id:
        message = f"댓글 생성 실패: CVE ID {cve_id}를 찾을 수 없거나 댓글을 추가할 수 없습니다."
        logger.error(message)
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)
    
    # CVE 캐시 무효화 (백그라운드 작업)
    if background_tasks:
        background_tasks.add_task(cve_service.invalidate_cve_cache, cve_id)
    
    logger.info(f"댓글 생성 성공: {comment_id}")
    return {"comment_id": comment_id, "message": "댓글이 성공적으로 생성되었습니다."}


@router.put("/{cve_id}/comments/{comment_id}", response_model=Dict[str, str])
@comment_api_error_handler
async def update_comment(
    cve_id: str,
    comment_id: str,
    comment_data: CommentUpdate,
    current_user: User = Depends(get_current_user),
    comment_service: CommentService = Depends(get_comment_service),
    cve_service: CVEService = Depends(get_cve_service),
    background_tasks: BackgroundTasks = None
):
    """댓글을 수정합니다."""
    logger.info(f"댓글 수정 요청: {comment_id} (CVE: {cve_id})")
    
    # 현재 사용자 정보 추가
    comment_dict = comment_data.dict()
    comment_dict["last_modified_by"] = current_user.username
    
    # 댓글 수정
    success = await comment_service.update_comment(cve_id, comment_id, comment_dict, current_user.username)
    
    if not success:
        message = f"댓글 수정 실패: CVE ID {cve_id} 또는 댓글 ID {comment_id}를 찾을 수 없거나 권한이 없습니다."
        logger.error(message)
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)
    
    # CVE 캐시 무효화 (백그라운드 작업)
    if background_tasks:
        background_tasks.add_task(cve_service.invalidate_cve_cache, cve_id)
    
    logger.info(f"댓글 수정 성공: {comment_id}")
    return {"message": "댓글이 성공적으로 수정되었습니다."}


@router.delete("/{cve_id}/comments/{comment_id}", response_model=Dict[str, str])
@comment_api_error_handler
async def delete_comment(
    cve_id: str,
    comment_id: str,
    permanent: bool = False,
    current_user: User = Depends(get_current_user),
    comment_service: CommentService = Depends(get_comment_service),
    cve_service: CVEService = Depends(get_cve_service),
    background_tasks: BackgroundTasks = None
):
    """댓글을 삭제합니다."""
    logger.info(f"댓글 삭제 요청: {comment_id} (CVE: {cve_id}, 영구삭제: {permanent})")
    
    # 댓글 삭제
    success = await comment_service.delete_comment(cve_id, comment_id, current_user.username, permanent)
    
    if not success:
        message = f"댓글 삭제 실패: CVE ID {cve_id} 또는 댓글 ID {comment_id}를 찾을 수 없거나 권한이 없습니다."
        logger.error(message)
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=message)
    
    # CVE 캐시 무효화 (백그라운드 작업)
    if background_tasks:
        background_tasks.add_task(cve_service.invalidate_cve_cache, cve_id)
    
    logger.info(f"댓글 삭제 성공: {comment_id}")
    return {"message": "댓글이 성공적으로 삭제되었습니다."}


@router.get("/{cve_id}/comments", response_model=List[CommentResponse])
@comment_api_error_handler
async def get_comments(
    cve_id: str,
    current_user: User = Depends(get_current_user),
    comment_service: CommentService = Depends(get_comment_service)
):
    """CVE의 모든 댓글을 조회합니다."""
    logger.info(f"CVE {cve_id}의 댓글 조회")
    
    comments = await comment_service.get_comments(cve_id)
    
    logger.info(f"CVE {cve_id}의 댓글 {len(comments)}개 조회됨")
    return comments


@router.get("/{cve_id}/comments/count", response_model=int)
@comment_api_error_handler
async def get_comment_count(
    cve_id: str,
    current_user: User = Depends(get_current_user),
    comment_service: CommentService = Depends(get_comment_service)
):
    """CVE의 활성화된 댓글 수를 반환합니다."""
    logger.info(f"CVE {cve_id}의 댓글 수 요청")
    
    count = await comment_service.count_active_comments(cve_id)
    
    logger.info(f"CVE {cve_id}의 댓글 수: {count}")
    return count



============================================================
File: /home/CVEHub/backend/app/comment/repository.py
------------------------------------------------------------
"""
댓글 관련 리포지토리 - CVE 리포지토리에서 분리
"""
from typing import List, Optional, Dict, Any, Union
from datetime import datetime
from bson import ObjectId
import traceback
import re
import functools
import time

from fastapi.logger import logger
from app.database import get_database
from app.common.repositories.base import BaseRepository
from app.comment.models import Comment, CommentCreate, CommentUpdate


def log_db_operation(operation_name):
    """
    데이터베이스 작업을 로깅하는 데코레이터
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(self, *args, **kwargs):
            start_time = time.perf_counter()
            try:
                result = await func(self, *args, **kwargs)
                elapsed = time.perf_counter() - start_time
                logger.info(f"{operation_name} 완료: 소요 시간 {elapsed:.4f}초")
                return result
            except Exception as e:
                elapsed = time.perf_counter() - start_time
                logger.error(f"{operation_name} 실패: {str(e)} (소요 시간 {elapsed:.4f}초)")
                raise
        return wrapper
    return decorator


class CommentRepository:
    """댓글 관련 데이터베이스 작업을 처리하는 리포지토리"""
    
    def __init__(self):
        """리포지토리 초기화"""
        self.db = get_database()
        self.collection = self.db.get_collection("cves")
        
    @log_db_operation("댓글 추가")
    async def add_comment(self, cve_id: str, comment_data: dict) -> Optional[str]:
        """
        CVE에 댓글을 추가합니다.
        
        Args:
            cve_id: 댓글을 추가할 CVE ID
            comment_data: 댓글 데이터
            
        Returns:
            Optional[str]: 추가된 댓글 ID 또는 None (실패시)
        """
        try:
            # 댓글 생성
            comment = Comment(**comment_data)
            
            # mentions 필드 자동 추출
            if "content" in comment_data:
                comment.mentions = Comment.extract_mentions(comment_data["content"])
            
            # 쿼리 조건 설정 (대소문자 구분 없음)
            query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}}
            
            # 댓글 추가 (push)
            result = await self.collection.update_one(
                query,
                {"$push": {"comments": comment.dict()}}
            )
            
            if result.matched_count == 0:
                logger.warning(f"댓글 추가 실패: CVE를 찾을 수 없음 {cve_id}")
                return None
                
            logger.info(f"댓글 추가 성공: {comment.id} (CVE: {cve_id})")
            return comment.id
            
        except Exception as e:
            logger.error(f"댓글 추가 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            raise
            
    @log_db_operation("댓글 수정")
    async def update_comment(self, cve_id: str, comment_id: str, comment_data: dict) -> bool:
        """
        CVE의 댓글을 수정합니다.
        
        Args:
            cve_id: 댓글이 속한 CVE ID
            comment_id: 수정할 댓글 ID
            comment_data: 수정할 댓글 데이터
            
        Returns:
            bool: 수정 성공 여부
        """
        try:
            # 새로운 멘션 추출
            mentions = Comment.extract_mentions(comment_data.get("content", ""))
            
            # 업데이트할 필드 설정
            update_fields = {
                "comments.$.content": comment_data.get("content"),
                "comments.$.last_modified_at": datetime.now(),
                "comments.$.last_modified_by": comment_data.get("last_modified_by"),
                "comments.$.mentions": mentions
            }
            
            # null 값 제거
            update_fields = {k: v for k, v in update_fields.items() if v is not None}
            
            # 쿼리 조건 설정 (대소문자 구분 없음)
            query = {
                "cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"},
                "comments.id": comment_id
            }
            
            # 댓글 수정
            result = await self.collection.update_one(
                query,
                {"$set": update_fields}
            )
            
            if result.matched_count == 0:
                logger.warning(f"댓글 수정 실패: CVE 또는 댓글을 찾을 수 없음 (CVE: {cve_id}, 댓글: {comment_id})")
                return False
                
            logger.info(f"댓글 수정 성공: {comment_id} (CVE: {cve_id})")
            return True
            
        except Exception as e:
            logger.error(f"댓글 수정 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            raise
            
    @log_db_operation("댓글 삭제")
    async def delete_comment(self, cve_id: str, comment_id: str, permanent: bool = False) -> bool:
        """
        CVE의 댓글을 삭제합니다.
        
        Args:
            cve_id: 댓글이 속한 CVE ID
            comment_id: 삭제할 댓글 ID
            permanent: 영구 삭제 여부 (True: 물리적 삭제, False: 논리적 삭제)
            
        Returns:
            bool: 삭제 성공 여부
        """
        try:
            # 쿼리 조건 설정 (대소문자 구분 없음)
            query = {
                "cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"},
                "comments.id": comment_id
            }
            
            if permanent:
                # 영구 삭제 (pull)
                result = await self.collection.update_one(
                    query,
                    {"$pull": {"comments": {"id": comment_id}}}
                )
            else:
                # 논리적 삭제 (is_deleted = True)
                result = await self.collection.update_one(
                    query,
                    {"$set": {"comments.$.is_deleted": True}}
                )
            
            if result.matched_count == 0:
                logger.warning(f"댓글 삭제 실패: CVE 또는 댓글을 찾을 수 없음 (CVE: {cve_id}, 댓글: {comment_id})")
                return False
                
            delete_type = "영구 삭제" if permanent else "논리적 삭제"
            logger.info(f"댓글 {delete_type} 성공: {comment_id} (CVE: {cve_id})")
            return True
            
        except Exception as e:
            logger.error(f"댓글 삭제 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            raise
            
    @log_db_operation("댓글 조회")
    async def get_comments(self, cve_id: str, include_deleted: bool = False) -> List[Comment]:
        """
        CVE의 모든 댓글을 조회합니다.
        
        Args:
            cve_id: 댓글을 조회할 CVE ID
            include_deleted: 삭제된 댓글 포함 여부
            
        Returns:
            List[Comment]: 댓글 목록
        """
        try:
            # 쿼리 조건 설정 (대소문자 구분 없음)
            query = {"cve_id": {"$regex": f"^{re.escape(cve_id)}$", "$options": "i"}}
            projection = {"_id": 0, "comments": 1}
            
            # 댓글 조회
            result = await self.collection.find_one(query, projection)
            
            if not result or "comments" not in result:
                return []
                
            # 댓글 객체 생성
            comments = [Comment(**c) for c in result["comments"]]
            
            # 삭제된 댓글 필터링 (필요한 경우)
            if not include_deleted:
                comments = [c for c in comments if not c.is_deleted]
                
            return comments
            
        except Exception as e:
            logger.error(f"댓글 조회 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return []
            
    @log_db_operation("활성 댓글 수 조회")
    async def count_active_comments(self, cve_id: str) -> int:
        """
        CVE의 활성화된 댓글 수를 반환합니다.
        
        Args:
            cve_id: 댓글 수를 조회할 CVE ID
            
        Returns:
            int: 활성화된 댓글 수
        """
        try:
            comments = await self.get_comments(cve_id, include_deleted=False)
            return len(comments)
        except Exception as e:
            logger.error(f"댓글 수 조회 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return 0



============================================================
File: /home/CVEHub/backend/app/comment/models.py
------------------------------------------------------------
"""
댓글 관련 모델 정의 - CVE 모델에서 분리
"""
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime
from zoneinfo import ZoneInfo
from bson import ObjectId
import re

from app.common.utils.datetime_utils import serialize_datetime


class Comment(BaseModel):
    """댓글 모델 - CVE 댓글 기능"""
    id: str = Field(default_factory=lambda: str(ObjectId()))
    content: str
    created_by: str = Field(..., description="작성자 이름")
    parent_id: Optional[str] = None
    depth: int = 0
    is_deleted: bool = False
    created_at: datetime = Field(default_factory=lambda: datetime.now(ZoneInfo("UTC")))
    last_modified_at: Optional[datetime] = None
    last_modified_by: Optional[str] = None
    mentions: List[str] = []
    
    class Config:
        json_encoders = {
            datetime: serialize_datetime
        }
    
    @classmethod
    def extract_mentions(cls, content: str) -> List[str]:
        """댓글 내용에서 멘션된 사용자명을 추출 - 개선된 버전
        
        특징:
        1. 한글, 영문, 숫자, 밑줄(_)을 포함하는 사용자명 지원
        2. 공백이나 문장 시작에 위치한 @사용자명만 인식
        3. 중복 제거 및 정규화
        """
        if not content:
            return []
            
        # 더 정교한 정규식 패턴
        # (?:^|\s): 줄의 시작 또는 공백 뒤에 나오는 패턴
        # @: @ 기호
        # ([\w가-힣]+): 영문, 숫자, 밑줄, 한글을 포함하는 사용자명
        MENTION_PATTERN = re.compile(r'(?:^|\s)@([\w가-힣]+)')
        matches = MENTION_PATTERN.findall(content)
        
        # 중복 제거 및 정규화 - 소문자로 변환하여 일관성 유지
        return [f"@{username}" for username in set(matches)]


class CommentCreate(BaseModel):
    """댓글 생성 요청 모델"""
    content: str
    parent_id: Optional[str] = None


class CommentUpdate(BaseModel):
    """댓글 수정 요청 모델"""
    content: str


class CommentResponse(Comment):
    """댓글 응답 모델"""
    pass



============================================================
File: /home/CVEHub/backend/app/comment/service.py
------------------------------------------------------------
#app/comment/service.py
"""
댓글 관련 서비스 구현
댓글 생성, 수정, 삭제 및 조회 기능 제공
"""
from typing import List, Optional, Tuple, Dict, Any, Union
from datetime import datetime
from zoneinfo import ZoneInfo
import logging
import traceback
import asyncio
from bson import ObjectId

from app.cve.models import CVEModel, Comment
from app.notification.models import Notification
from app.auth.models import User
from app.activity.models import ActivityAction, ActivityTargetType, ChangeItem
from app.activity.service import ActivityService
from app.socketio.manager import socketio_manager, WSMessageType
from app.comment.repository import CommentRepository

# 로거 설정
logger = logging.getLogger(__name__)

class CommentService:
    """댓글 관련 작업을 관리하는 서비스 클래스"""
    
    def __init__(self, comment_repository: CommentRepository, activity_service: ActivityService, cve_repository=None):
        """CommentService 초기화"""
        self.repository = comment_repository
        self.activity_service = activity_service
        self.cve_repository = cve_repository
        
    @staticmethod
    def comment_to_dict(comment: Comment) -> dict:
        """Comment 객체를 JSON 직렬화 가능한 딕셔너리로 변환"""
        comment_dict = comment.dict()
        comment_dict["created_at"] = comment.created_at.isoformat()
        if comment.last_modified_at:
            comment_dict["last_modified_at"] = comment.last_modified_at.isoformat()
        return comment_dict
    
    async def process_mentions(self, content: str, cve_id: str, comment_id: str,
                          sender: User, mentioned_usernames: List[str] = None) -> Tuple[int, List[str]]:
        """댓글 내용에서 멘션된 사용자를 찾아 알림을 생성합니다."""
        try:
            # Comment 모델의 extract_mentions 사용 (중복 코드 제거)
            mentions = mentioned_usernames or Comment.extract_mentions(content)
            if not mentions:
                return 0, []
            
            logger.info(f"발견된 멘션: {mentions}")
            
            # 멘션된 사용자들을 한 번에 조회 (N+1 쿼리 문제 해결)
            # @ 기호 제거하고 사용자명만 추출
            usernames = [m.replace('@', '') for m in mentions]
            users = await User.find({"username": {"$in": usernames}}).to_list()
            
            # 사용자별 ID 매핑 생성 (조회 최적화)
            username_to_user = {user.username: user for user in users}
            
            # 병렬 알림 처리 준비
            notifications_created = 0
            processed_users = []
            notification_tasks = []
            
            for username in usernames:
                if username in username_to_user and str(username_to_user[username].id) != str(sender.id):
                    user = username_to_user[username]
                    
                    # 비동기 작업 생성 (병렬 처리)
                    task = self._create_mention_notification(
                        user.id, sender, cve_id, comment_id, content
                    )
                    notification_tasks.append(task)
                    processed_users.append(username)
                    notifications_created += 1
            
            # 알림 작업 병렬 실행
            if notification_tasks:
                await asyncio.gather(*notification_tasks)
                
            return notifications_created, processed_users
        except Exception as e:
            logger.error(f"process_mentions 중 오류 발생: {str(e)}")
            return 0, []

    async def _create_mention_notification(self, recipient_id, sender, cve_id, comment_id, content):
        """알림 생성 헬퍼 메서드 - 중복 코드 제거 및 재사용성 향상"""
        try:
            notification, unread_count = await Notification.create_notification(
                recipient_id=recipient_id,
                sender_id=sender.id,
                sender_username=sender.username,
                cve_id=cve_id,
                comment_id=comment_id,
                comment_content=content,
                content=f"{sender.username}님이 댓글에서 언급했습니다."
            )
            
            # 웹소켓으로 실시간 알림 전송
            await socketio_manager.emit(
                "notification",
                {
                    "type": WSMessageType.NOTIFICATION,
                    "data": {
                        "notification": self.comment_to_dict(notification),
                        "unread_count": unread_count
                    }
                },
                room=str(recipient_id)
            )
            
            return notification
        except Exception as e:
            logger.error(f"알림 생성 중 오류: {str(e)}")
            return None
    
    async def count_active_comments(self, cve_id: str) -> int:
        """CVE의 활성화된 댓글 수를 계산합니다."""
        try:
            # 최적화: 전체 CVE 가져오지 않고 댓글만 조회
            projection = {"comments": 1}
            cve = await self.repository.find_by_cve_id_with_projection(cve_id, projection)
            
            if not cve or not hasattr(cve, 'comments'):
                logger.error(f"CVE를 찾을 수 없거나 댓글이 없음: {cve_id}")
                return 0
                
            # 삭제되지 않은 댓글 수 계산
            active_comments = [c for c in cve.comments if not c.is_deleted]
            logger.info(f"CVE {cve_id}의 활성 댓글 수: {len(active_comments)}개")
            return len(active_comments)
        except Exception as e:
            logger.error(f"활성 댓글 수 계산 중 오류: {str(e)}")
            return 0
    
    async def send_comment_update(self, cve_id: str) -> None:
        """댓글 수 업데이트를 Socket.IO로 전송합니다."""
        try:
            count = await self.count_active_comments(cve_id)
            await socketio_manager.emit(
                "comment_count",
                {
                    "type": WSMessageType.COMMENT_COUNT_UPDATE,
                    "data": {"cve_id": cve_id, "count": count}
                },
                broadcast=True
            )
            logger.info(f"{cve_id}의 댓글 수 업데이트 전송: {count}")
        except Exception as e:
            logger.error(f"댓글 업데이트 전송 중 오류: {str(e)}")
    
    async def create_comment(self, cve_id: str, content: str, user: User, 
                           parent_id: Optional[str] = None, 
                           mentions: List[str] = None) -> Tuple[Optional[Comment], str]:
        """새 댓글을 생성합니다."""
        try:
            # 댓글 트리 구조 확인 (depth 제한)
            MAX_COMMENT_DEPTH = 10
            depth = 0
            
            # 최적화: 부모 댓글 정보만 선택적으로 조회
            if parent_id:
                # MongoDB 투영(projection) 사용해 부모 댓글만 조회 (최적화)
                parent = await CVEModel.find_one(
                    {"cve_id": cve_id, "comments.id": parent_id},
                    {"comments.$": 1}  # 일치하는 댓글만 가져오는 projection
                )
                
                if not parent or not parent.comments:
                    logger.error(f"부모 댓글을 찾을 수 없음: {parent_id}")
                    return None, f"부모 댓글을 찾을 수 없습니다: {parent_id}"
                
                # 부모 댓글 깊이 계산
                parent_comment = parent.comments[0]
                depth = parent_comment.depth + 1
                
                if depth >= MAX_COMMENT_DEPTH:
                    logger.error(f"최대 댓글 깊이에 도달: {MAX_COMMENT_DEPTH}")
                    return None, f"최대 댓글 깊이({MAX_COMMENT_DEPTH})에 도달했습니다."
            
            # 댓글 생성
            now = datetime.now(ZoneInfo("UTC"))
            comment = Comment(
                id=str(ObjectId()),
                content=content,
                created_by=user.username,
                parent_id=parent_id,
                depth=depth,  # 계산된 깊이 저장
                created_at=now,
                last_modified_at=None,
                is_deleted=False,
                # Comment 모델의 extract_mentions 메서드 사용
                mentions=Comment.extract_mentions(content) if not mentions else mentions
            )
            
            # repository의 add_comment 메서드 사용
            result = await self.repository.add_comment(cve_id, comment.dict())
            
            if not result:
                logger.error(f"댓글 추가 실패: {cve_id}")
                return None, "댓글을 추가할 수 없습니다. CVE를 찾을 수 없거나 DB 오류가 발생했습니다."
            
            # 멘션 처리
            await self.process_mentions(
                content=content,
                cve_id=cve_id,
                comment_id=comment.id,
                sender=user,
                mentioned_usernames=mentions
            )
            
            # 댓글 수 업데이트 전송
            await self.send_comment_update(cve_id)
            
            # 활동 추적 유틸리티 메서드 사용
            await self._track_comment_activity(
                user.username,
                cve_id,
                comment.id,
                ActivityAction.COMMENT,
                content=content,
                parent_id=parent_id
            )
            
            return comment, "댓글이 성공적으로 생성되었습니다."
        except Exception as e:
            logger.error(f"댓글 생성 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return None, f"댓글 생성 중 오류가 발생했습니다: {str(e)}"
    
    async def update_comment(self, cve_id: str, comment_id: str, content: str, user: User) -> Tuple[Optional[Comment], str]:
        """댓글을 수정합니다."""
        try:
            # 최적화: 필요한 정보만 조회
            projection = {"comments.$": 1, "title": 1, "severity": 1, "status": 1}
            
            # MongoDB 투영(projection) 사용해 해당 댓글만 조회
            cve = await CVEModel.find_one(
                {"cve_id": cve_id, "comments.id": comment_id},
                projection
            )
            
            if not cve or not cve.comments:
                logger.error(f"댓글을 찾을 수 없음: {comment_id}")
                return None, f"댓글을 찾을 수 없습니다: {comment_id}"
            
            # 첫 번째 일치하는 댓글 (comments.$ 연산자 결과)
            comment = cve.comments[0]
            
            # 권한 확인
            if comment.created_by != user.username and not user.is_admin:
                logger.error(f"사용자 {user.username}의 댓글 {comment_id} 수정 권한 없음")
                return None, "댓글 수정 권한이 없습니다."
            
            # 댓글이 삭제되었는지 확인
            if comment.is_deleted:
                logger.error(f"삭제된 댓글 수정 불가: {comment_id}")
                return None, "삭제된 댓글은 수정할 수 없습니다."
            
            # 변경 전 내용 저장 (변경 감지용)
            old_content = comment.content
            old_mentions = set(comment.mentions) if comment.mentions else set()
            
            # 새 멘션 추출
            new_mentions = set(Comment.extract_mentions(content))
            
            # repository의 update_comment 메서드 사용
            now = datetime.now(ZoneInfo("UTC"))
            update_data = {
                "content": content,
                "last_modified_at": now,
                "last_modified_by": user.username,
                "mentions": list(new_mentions)
            }
            result = await self.repository.update_comment(cve_id, comment_id, update_data)
            
            if not result:
                logger.error(f"댓글 수정 실패: {comment_id}")
                return None, "댓글 수정에 실패했습니다"
            
            # 수정된 댓글 객체 생성 (응답용)
            updated_comment = Comment(
                id=comment.id,
                content=content,
                created_by=comment.created_by,
                created_at=comment.created_at,
                parent_id=comment.parent_id,
                depth=comment.depth,
                is_deleted=False,
                last_modified_at=now,
                last_modified_by=user.username,
                mentions=list(new_mentions)
            )
            
            # 멘션 처리 (새 멘션이 추가된 경우만)
            added_mentions = new_mentions - old_mentions
            if added_mentions:
                await self.process_mentions(
                    content=content,
                    cve_id=cve_id,
                    comment_id=comment_id,
                    sender=user,
                    mentioned_usernames=list(added_mentions)
                )
            
            # 활동 추적
            await self._track_comment_activity(
                user.username,
                cve_id,
                comment_id,
                ActivityAction.COMMENT_UPDATE,
                content=content,
                old_content=old_content,
                cve_title=cve.title
            )
            
            return updated_comment, "댓글이 성공적으로 수정되었습니다."
        except Exception as e:
            logger.error(f"댓글 수정 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return None, f"댓글 수정 중 오류가 발생했습니다: {str(e)}"
    
    async def delete_comment(self, cve_id: str, comment_id: str, user: User, permanent: bool = False) -> Tuple[bool, str]:
        """댓글을 삭제합니다."""
        try:
            # 최적화: 필요한 정보만 조회
            projection = {"comments.$": 1, "title": 1, "severity": 1, "status": 1}
            
            # MongoDB 투영(projection) 사용해 해당 댓글만 조회
            cve = await CVEModel.find_one(
                {"cve_id": cve_id, "comments.id": comment_id},
                projection
            )
            
            if not cve or not cve.comments:
                logger.error(f"댓글을 찾을 수 없음: {comment_id}")
                return False, f"댓글을 찾을 수 없습니다: {comment_id}"
            
            # 첫 번째 일치하는 댓글 (comments.$ 연산자 결과)
            comment = cve.comments[0]
            
            # 권한 확인
            if comment.created_by != user.username and not user.is_admin:
                logger.error(f"사용자 {user.username}의 댓글 {comment_id} 삭제 권한 없음")
                return False, "댓글 삭제 권한이 없습니다."
            
            if permanent and not user.is_admin:
                logger.error("관리자만 영구 삭제 가능")
                return False, "영구 삭제는 관리자만 가능합니다."
            
            comment_content = comment.content
            
            # repository의 delete_comment 메서드 사용
            result = await self.repository.delete_comment(cve_id, comment_id, permanent)
            
            if not result:
                logger.error(f"댓글 삭제 실패: {comment_id}")
                return False, "댓글 삭제에 실패했습니다"
            
            # 댓글 수 업데이트 전송
            await self.send_comment_update(cve_id)
            
            # 활동 추적
            await self._track_comment_activity(
                user.username,
                cve_id,
                comment_id,
                ActivityAction.COMMENT_DELETE,
                content=comment_content,
                cve_title=cve.title,
                permanent=permanent
            )
            
            return True, "댓글이 성공적으로 삭제되었습니다."
        except Exception as e:
            logger.error(f"댓글 삭제 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return False, f"댓글 삭제 중 오류가 발생했습니다: {str(e)}"
    
    async def get_comments(self, cve_id: str, include_deleted: bool = False) -> List[Comment]:
        """CVE의 모든 댓글을 조회합니다."""
        try:
            # 최적화: 댓글 필드만 조회
            projection = {"comments": 1}
            cve = await self.repository.find_by_cve_id_with_projection(cve_id, projection)
            
            if not cve:
                logger.error(f"CVE를 찾을 수 없음: {cve_id}")
                return []
            
            # 삭제된 댓글 필터링 (필요한 경우)
            comments = cve.comments
            if not include_deleted:
                comments = [c for c in comments if not c.is_deleted]
            
            # 댓글 정렬 (생성 시간순)
            return sorted(comments, key=lambda x: x.created_at)
        except Exception as e:
            logger.error(f"댓글 조회 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return []
    
    async def _track_comment_activity(self, 
                                   username: str,
                                   cve_id: str, 
                                   comment_id: str,
                                   activity_type: ActivityAction,
                                   content: str = None,
                                   old_content: str = None,
                                   cve_title: str = None,
                                   parent_id: str = None,
                                   permanent: bool = False):
        """댓글 활동 추적을 위한 유틸리티 메서드 - 중복 코드 제거"""
        try:
            # 기본 메타데이터 설정
            metadata = {
                "comment_id": comment_id
            }
            
            # 추가 메타데이터 설정
            if parent_id:
                metadata["parent_id"] = parent_id
            if permanent:
                metadata["permanent"] = permanent
            
            # CVE 정보가 없는 경우 조회
            if not cve_title:
                projection = {"title": 1, "severity": 1, "status": 1}
                cve = await self.repository.find_by_cve_id_with_projection(cve_id, projection)
                if cve:
                    cve_title = cve.title or cve_id
                    metadata.update({
                        "severity": cve.severity,
                        "status": cve.status
                    })
            
            # 활동 유형에 따른 변경 내역 생성
            changes = []
            
            if activity_type == ActivityAction.COMMENT:
                changes.append(ChangeItem(
                    field="comments",
                    field_name="댓글",
                    action="add",
                    detail_type="detailed",
                    summary="댓글 추가됨",
                    items=[{"content": content}]
                ))
            elif activity_type == ActivityAction.COMMENT_UPDATE:
                changes.append(ChangeItem(
                    field="comments",
                    field_name="댓글",
                    action="edit",
                    detail_type="detailed",
                    before=old_content,
                    after=content,
                    summary="댓글 수정됨"
                ))
            elif activity_type == ActivityAction.COMMENT_DELETE:
                changes.append(ChangeItem(
                    field="comments",
                    field_name="댓글",
                    action="delete",
                    detail_type="detailed",
                    before=content,
                    summary=f"댓글 {permanent and '영구 ' or ''}삭제됨"
                ))
            
            # 활동 기록 생성
            await self.activity_service.create_activity(
                username=username,
                activity_type=activity_type,
                target_type=ActivityTargetType.CVE,
                target_id=cve_id,
                target_title=cve_title or cve_id,
                changes=changes,
                metadata=metadata
            )
            
            return True
        except Exception as e:
            logger.error(f"댓글 활동 추적 중 오류: {str(e)}")
            logger.error(traceback.format_exc())
            return False


============================================================
File: /home/CVEHub/backend/app/crawler/schemas.py
------------------------------------------------------------
"""
크롤러 관련 스키마 정의
"""
from typing import List, Dict, Any, Optional, TypeVar, Generic
from datetime import datetime
from pydantic import BaseModel, Field


class CrawlerResponse(BaseModel):
    """크롤러 응답 스키마"""
    message: str = Field(..., description="응답 메시지")
    stage: str = Field(..., description="상태 (예: completed, running, failed)")
    crawler_type: str = Field(..., description="크롤러 유형 (예: nuclei, metasploit)")


class DBStatusResponse(BaseModel):
    """데이터베이스 상태 응답 스키마"""
    status: str = Field(..., description="데이터베이스 상태")
    message: str = Field(..., description="상태 메시지")
    initialized: bool = Field(..., description="초기화 완료 여부")


class UpdatedCVE(BaseModel):
    """업데이트된 CVE 정보"""
    cve_id: str = Field(..., description="CVE ID")
    title: Optional[str] = Field(None, description="CVE 제목")
    fields_updated: List[str] = Field([], description="업데이트된 필드 목록")


class UpdatedCVEList(BaseModel):
    """업데이트된 CVE 목록"""
    cves: List[UpdatedCVE] = Field(..., description="업데이트된 CVE 목록")
    count: int = Field(..., description="업데이트된 CVE 개수")


class CrawlerResult(BaseModel):
    """크롤러 결과 스키마"""
    added: int = Field(0, description="추가된 항목 수")
    updated: int = Field(0, description="업데이트된 항목 수")
    failed: int = Field(0, description="실패한 항목 수")
    skipped: int = Field(0, description="건너뛴 항목 수")
    total: int = Field(0, description="전체 처리 항목 수")
    errors: List[str] = Field([], description="발생한 오류 목록")


class CrawlerStatusResponse(BaseModel):
    """크롤러 상태 응답 스키마"""
    isRunning: bool = Field(..., description="크롤러 실행 중 여부")
    lastUpdate: Optional[datetime] = Field(None, description="마지막 업데이트 시간")
    results: Optional[Dict[str, CrawlerResult]] = Field(None, description="각 크롤러별 결과")


class CrawlerUpdateResult(BaseModel):
    """크롤러 업데이트 결과 스키마"""
    crawler_id: str = Field(..., description="크롤러 ID")
    results: Optional[Dict[str, Any]] = Field(None, description="업데이트 결과 상세")


class AvailableCrawler(BaseModel):
    """사용 가능한 크롤러 정보"""
    id: str = Field(..., description="크롤러 ID")
    name: str = Field(..., description="크롤러 이름")
    description: Optional[str] = Field(None, description="크롤러 설명")
    type: str = Field(..., description="크롤러 유형")
    enabled: bool = Field(True, description="활성화 여부")


class AvailableCrawlers(BaseModel):
    """사용 가능한 크롤러 목록"""
    crawlers: List[AvailableCrawler] = Field(..., description="사용 가능한 크롤러 목록")
    count: int = Field(..., description="크롤러 개수")

# 제네릭 데이터 타입 (다양한 응답 구조 지원)
T = TypeVar('T')

class StandardResponse(BaseModel, Generic[T]):
    """표준 API 응답 스키마"""
    success: bool = Field(..., description="요청 성공 여부")
    message: str = Field(..., description="응답 메시지")
    data: Optional[T] = Field(None, description="응답 데이터")
    timestamp: datetime = Field(default_factory=datetime.now, description="응답 시간")


============================================================
File: /home/CVEHub/backend/app/crawler/crawler_factory.py
------------------------------------------------------------
import logging
from typing import Dict, List, Optional, Any, Type
from .crawler_base import BaseCrawlerService

logger = logging.getLogger(__name__)

class CrawlerRegistry:
    """
    크롤러 등록 및 관리를 위한 레지스트리 클래스
    """
    _registry = {}

    @classmethod
    def register(cls, crawler_type: str, crawler_class: Type[BaseCrawlerService]) -> None:
        """
        크롤러 클래스를 등록합니다.
        
        Args:
            crawler_type: 크롤러 유형 (소문자로 정규화됨)
            crawler_class: 크롤러 클래스 (BaseCrawlerService 상속)
        """
        cls._registry[crawler_type.lower()] = crawler_class
        logger.info(f"크롤러 등록: {crawler_type}")

    @classmethod
    def get_crawler_class(cls, crawler_type: str) -> Optional[Type[BaseCrawlerService]]:
        """
        등록된 크롤러 클래스를 반환합니다.
        
        Args:
            crawler_type: 크롤러 유형
            
        Returns:
            등록된 크롤러 클래스 또는 None
        """
        return cls._registry.get(crawler_type.lower())

    @classmethod
    def get_registered_types(cls) -> List[str]:
        """
        등록된 모든 크롤러 유형을 반환합니다.
        
        Returns:
            등록된 크롤러 유형 목록
        """
        return list(cls._registry.keys())

    @classmethod
    def create_crawler(cls, crawler_type: str) -> Optional[BaseCrawlerService]:
        """
        지정된 유형의 크롤러 인스턴스를 생성합니다.
        
        Args:
            crawler_type: 크롤러 유형
            
        Returns:
            생성된 크롤러 인스턴스 또는 None
        """
        crawler_class = cls.get_crawler_class(crawler_type)
        if not crawler_class:
            logger.warning(f"미등록 크롤러 유형: {crawler_type}")
            return None
            
        try:
            return crawler_class()
        except Exception as e:
            logger.error(f"크롤러 생성 오류: {str(e)}")
            return None

    @classmethod
    def discover_crawlers(cls) -> None:
        """
        자동으로 크롤러 클래스를 발견하고 등록합니다.
        현재 디렉토리의 크롤러 모듈을 검색합니다.
        """
        try:
            import importlib
            import inspect
            import pkgutil
            import app.crawler.crawlers as crawlers_pkg
            
            for _, modname, _ in pkgutil.iter_modules(crawlers_pkg.__path__):
                try:
                    module = importlib.import_module(f"app.crawler.crawlers.{modname}")
                    
                    for name, obj in inspect.getmembers(module):
                        if (inspect.isclass(obj) and 
                            issubclass(obj, BaseCrawlerService) and 
                            obj != BaseCrawlerService):
                            
                            # 크롤러 ID 추출 (클래스 이름에서 'CrawlerService' 제거)
                            crawler_id = name.replace('CrawlerService', '').lower()
                            cls.register(crawler_id, obj)
                            logger.info(f"자동 등록된 크롤러: {crawler_id} ({name})")
                            
                except Exception as e:
                    logger.error(f"모듈 {modname} 로딩 중 오류: {str(e)}")
        except Exception as e:
            logger.error(f"크롤러 자동 발견 중 오류: {str(e)}")


============================================================
File: /home/CVEHub/backend/app/crawler/router.py
------------------------------------------------------------
"""크롤러 관련 API 엔드포인트"""
import logging
import functools
from typing import List
from fastapi import APIRouter, Depends, HTTPException, status

from app.auth.models import User
from app.cve.models import CreateCVERequest
from app.auth.service import get_current_admin_user, get_current_user
from app.core.dependencies import get_crawler_service
from app.crawler.service import CrawlerService
from app.crawler.schemas import (
    CrawlerResponse, 
    DBStatusResponse, 
    CrawlerStatusResponse, 
    CrawlerUpdateResult,
    AvailableCrawlers
)

# 로거 설정
logger = logging.getLogger(__name__)

router = APIRouter(tags=["crawler"])

def api_error_handler(func):
    """API 엔드포인트 예외 처리 데코레이터"""
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except HTTPException:
            # FastAPI HTTP 예외는 그대로 전달
            raise
        except Exception as e:
            # 로깅
            endpoint = func.__name__
            logger.error(f"Error in {endpoint}: {str(e)}")
            
            # 상세 오류 정보
            error_detail = f"{str(e)}"
            if settings.DEBUG:
                import traceback
                error_detail = f"{str(e)}\n{traceback.format_exc()}"
                
            # 표준화된 HTTP 예외 반환
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"서버 내부 오류가 발생했습니다: {error_detail}"
            )
    return wrapper

@router.post("/crawl", response_model=CrawlerResponse)
@api_error_handler
async def trigger_crawl(
    current_user: User = Depends(get_current_admin_user),
    crawler_service: CrawlerService = Depends(get_crawler_service)
):
    """수동 크롤링을 트리거합니다.
    
    Args:
        current_user: 현재 인증된 관리자 사용자
        crawler_service: 크롤러 서비스 인스턴스
        
    Returns:
        크롤링 실행 결과
    """
    logger.info(f"Manual crawl triggered by {current_user.username}")
    
    success, message = await crawler_service.trigger_manual_crawl()
    
    if not success:
        logger.error(f"Manual crawling failed: {message}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=message
        )
    
    return CrawlerResponse(
        message="크롤링이 성공적으로 완료되었습니다",
        stage="completed",
        crawler_type="nuclei"
    )

@router.post("/run/{crawler_type}", response_model=CrawlerResponse)
@api_error_handler
async def run_crawler(
    crawler_type: str,
    current_user: User = Depends(get_current_admin_user),
    crawler_service: CrawlerService = Depends(get_crawler_service)
):
    """지정된 크롤러를 실행합니다."""
    logger.info(f"Running crawler {crawler_type} by {current_user.username}")
    
    result = await crawler_service.run_specific_crawler(
        crawler_type=crawler_type,
        user_id=str(current_user.id),
        quiet_mode=False
    )
    
    if not result.get("success"):
        # 이미 실행 중인 경우는 별도 처리
        if result.get("stage") == "already_running":
            return CrawlerResponse(
                message=result.get("message"),
                stage=result.get("stage"),
                crawler_type=result.get("crawler_type")
            )
            
        # 오류 응답
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=result.get("message")
        )
    
    return CrawlerResponse(
        message=result.get("message"),
        stage=result.get("stage"),
        crawler_type=result.get("crawler_type")
    )

@router.get("/status", response_model=CrawlerStatusResponse)
@api_error_handler
async def get_crawler_status(
    current_user: User = Depends(get_current_user),
    crawler_service: CrawlerService = Depends(get_crawler_service)
):
    """크롤러 상태 및 마지막 업데이트 시간을 조회합니다.
    
    Args:
        current_user: 현재 인증된 사용자
        crawler_service: 크롤러 서비스 인스턴스
        
    Returns:
        크롤러 상태 정보
    """
    logger.info(f"Getting crawler status for user {current_user.username}")
    
    crawler_status = await crawler_service.get_crawler_status()
    
    # lastUpdate가 딕셔너리인 경우 처리
    last_update = crawler_status.get("lastUpdate")
    if isinstance(last_update, dict):
        # 딕셔너리에서 첫 번째 값을 사용하거나 None 반환
        if last_update and len(last_update) > 0:
            # 첫 번째 크롤러의 업데이트 시간 사용
            first_crawler = next(iter(last_update))
            last_update = last_update[first_crawler]
        else:
            last_update = None
    
    return CrawlerStatusResponse(
        isRunning=crawler_status.get("isRunning"),
        lastUpdate=last_update,
        results=crawler_status.get("results")
    )

@router.get("/db-status", response_model=DBStatusResponse)
@api_error_handler
async def get_db_status(
    current_user: User = Depends(get_current_admin_user),
    crawler_service: CrawlerService = Depends(get_crawler_service)
):
    """데이터베이스 초기화 상태를 확인합니다.
    
    Args:
        current_user: 현재 인증된 관리자 사용자
        crawler_service: 크롤러 서비스 인스턴스
        
    Returns:
        데이터베이스 상태 정보
    """
    logger.info(f"Getting DB status for admin user {current_user.username}")
    
    status_result = await crawler_service.get_db_status()
    
    return DBStatusResponse(
        status=status_result.get("status"),
        message=status_result.get("message"),
        initialized=status_result.get("initialized")
    )

@router.get("/available", response_model=AvailableCrawlers)
@api_error_handler
async def get_available_crawlers(
    current_user: User = Depends(get_current_user),
    crawler_service: CrawlerService = Depends(get_crawler_service)
):
    """사용 가능한 크롤러 목록을 조회합니다."""
    logger.info(f"Getting available crawlers for user {current_user.username}")
    
    result = await crawler_service.get_available_crawlers()
    
    return AvailableCrawlers(
        crawlers=result.get("crawlers"),
        count=result.get("count")
    )

@router.get("/results/{crawler_id}", response_model=CrawlerUpdateResult)
@api_error_handler
async def get_update_results(
    crawler_id: str,
    current_user: User = Depends(get_current_user),
    crawler_service: CrawlerService = Depends(get_crawler_service)
):
    """특정 크롤러의 최근 업데이트 결과를 가져옵니다.
    
    Args:
        crawler_id: 크롤러 ID
        current_user: 현재 인증된 사용자
        crawler_service: 크롤러 서비스 인스턴스
        
    Returns:
        업데이트 결과
    """
    logger.info(f"Getting update results for crawler {crawler_id}, user {current_user.username}")
    
    results = await crawler_service.get_update_results(crawler_id)
    
    if not results:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"크롤러 ID '{crawler_id}'에 대한 업데이트 결과를 찾을 수 없습니다"
        )
    
    return CrawlerUpdateResult(
        crawler_id=results.get("crawler_id"),
        results=results.get("results")
    )



============================================================
File: /home/CVEHub/backend/app/crawler/crawler_base.py
------------------------------------------------------------
from abc import ABC, abstractmethod
import logging
from typing import Dict, Any, Optional
import traceback
from datetime import datetime
from ..core.config import get_settings
from app.socketio.manager import socketio_manager, WSMessageType
from app.cve.models import CVEModel
from app.cve.service import CVEService

settings = get_settings()
logger = logging.getLogger(__name__)

# 크롤러 진행 단계 정의
CRAWLER_STAGES = [
    {
        "key": "preparing",
        "label": "준비",
        "description": "크롤러 초기화 및 저장소 연결 준비"
    },
    {
        "key": "fetching",
        "label": "데이터 수집",
        "description": "소스에서 데이터 수집 중"
    },
    {
        "key": "processing",
        "label": "데이터 처리",
        "description": "수집된 데이터 처리 및 분석"
    },
    {
        "key": "saving",
        "label": "데이터베이스 업데이트",
        "description": "처리된 데이터 데이터베이스에 저장"
    },
    {
        "key": "completed",
        "label": "완료",
        "description": "크롤링 작업 완료"
    },
    {
        "key": "error",
        "label": "오류",
        "description": "크롤링 작업 중 오류 발생"
    }
]

# 단계 키를 통해 단계 정보 가져오기
def get_stage_by_key(key: str) -> Dict[str, Any]:
    """
    단계 키를 통해 단계 정보를 가져옵니다.
    
    Args:
        key (str): 단계 키
        
    Returns:
        Dict[str, Any]: 단계 정보
    """
    for stage in CRAWLER_STAGES:
        if stage["key"] == key:
            return stage
    
    # 키가 없으면 준비 단계 반환
    logger.warning(f"단계 키 '{key}'에 해당하는 단계 정보가 없습니다. 기본값 반환")
    return CRAWLER_STAGES[0]

class LoggingMixin:
    """로깅 기능을 제공하는 믹스인 클래스"""

    @property
    def logger(self):
        """클래스별 로거 인스턴스 반환"""
        name = '.'.join([self.__module__, self.__class__.__name__])
        return logging.getLogger(name)
    
    def log_info(self, message: str) -> None:
        """정보 로그 기록"""
        self.logger.info(message)
    
    def log_warning(self, message: str) -> None:
        """경고 로그 기록"""
        self.logger.warning(message)
    
    def log_error(self, message: str, exception: Optional[Exception] = None) -> None:
        """오류 로그 기록"""
        if exception:
            self.logger.error(f"{message}: {str(exception)}")
            self.logger.error(traceback.format_exc())
        else:
            self.logger.error(message)
    
    def log_debug(self, message: str) -> None:
        """디버그 로그 기록"""
        self.logger.debug(message)

class BaseCrawlerService(ABC, LoggingMixin):
    """
    크롤러 서비스의 기본 추상 클래스.
    모든 크롤러 구현체는 이 클래스를 상속받아야 합니다.
    """
    
    def __init__(self, crawler_id, display_name=None, cve_service=None):
        self.crawler_id = crawler_id.lower()
        self.display_name = display_name or crawler_id
        self.cve_service = cve_service or CVEService()
        self.requester_id = None
        self.quiet_mode = False
        self.websocket_enabled = True
    
    @abstractmethod
    async def fetch_data(self) -> Any:
        """
        원격 저장소나 API로부터 데이터를 가져옵니다.
        (git clone, API 호출 등)
        """
        pass
    
    @abstractmethod
    async def parse_data(self, raw_data: Any) -> Dict[str, Any]:
        """
        가져온 데이터를 파싱하여 CVE 정보를 추출합니다.
        """
        pass
    
    @abstractmethod
    async def process_data(self, parsed_data: Dict[str, Any]) -> bool:
        """
        파싱된 CVE 데이터를 처리하고 데이터베이스에 저장합니다.
        """
        pass
    
    @abstractmethod
    async def crawl(self) -> Dict[str, Any]:
        """
        전체 크롤링 프로세스를 실행합니다.
        """
        pass
    
    async def report_progress(self, stage, percent, message, **kwargs):
        """
        크롤링 진행 상황을 보고합니다.
        
        Args:
            stage (str): 진행 단계 (preparing, fetching, processing, saving, completed, error)
            percent (int): 진행률 (0-100)
            message (str): 진행 상황 메시지
            **kwargs: 추가 데이터
        """
        # 기본 로깅
        stage_key = stage.lower().strip()
        self.log_info(f"[{stage_key}] {percent}% - {message}")
    
        # 조용한 모드이거나 웹소켓이 비활성화된 경우 웹소켓 메시지 전송 안함
        if self.quiet_mode:
            self.log_debug(f"조용한 모드에서 메시지 무시: {message}")
            return
            
        if not self.websocket_enabled:
            self.log_debug(f"웹소켓 비활성화 상태: {message}")
            return
        
        # 메시지 데이터 준비
        message_data = {
            "crawler": self.crawler_id,
            "stage": stage_key,
            "percent": percent,
            "message": message,
            "isRunning": stage_key not in ["completed", "error"],
            "timestamp": datetime.now().isoformat()
        }
        
        # 추가 데이터가 있으면 포함
        for key, value in kwargs.items():
            message_data[key] = value
        
        # WebSocket 메시지 전송
        try:            
            if hasattr(self, 'requester_id') and self.requester_id:
                self.log_debug(f"사용자 {self.requester_id}에게 진행 상황 전송 중...")
                await socketio_manager.emit_to_user(
                    self.requester_id, 
                    WSMessageType.CRAWLER_UPDATE_PROGRESS, 
                    {"type": "crawler_update_progress", "data": message_data}
                )
            else:
                self.log_debug("모든 사용자에게 진행 상황 전송 중...")
                await socketio_manager.emit(
                    WSMessageType.CRAWLER_UPDATE_PROGRESS, 
                    {"type": "crawler_update_progress", "data": message_data}
                )
            self.log_debug(f"웹소켓 메시지 전송 완료: {stage_key} {percent}%")
        except Exception as e:
            self.log_error(f"웹소켓 메시지 전송 실패: {str(e)}", e)
            
    def set_requester_id(self, user_id: str):
        """업데이트를 요청한 사용자 ID 설정"""
        self.requester_id = user_id
        self.log_info(f"요청자 ID 설정: {user_id}")

    def set_quiet_mode(self, quiet: bool = True):
        """
        크롤러의 조용한 모드 설정
        
        조용한 모드가 활성화되면 진행 상황 메시지가 웹소켓으로 전송되지 않습니다.
        스케줄러에 의한 자동 크롤링 작업에 유용합니다.
        """
        self.quiet_mode = quiet
        self.log_info(f"조용한 모드 {'활성화' if quiet else '비활성화'}")
        
    async def update_cve(self, cve_id: str, data: Dict[str, Any], creator: str) -> Optional[CVEModel]:
        """
        CVE 모델을 생성하거나 업데이트합니다.
        """       
        try:
            # 기존 CVE 찾기
            existing = await self.cve_service.get_cve_detail(cve_id)
            is_new = existing is None
            
            if is_new:
                # 새 CVE 생성
                self.log_info(f"새 CVE 생성: {cve_id}")
                
                # 필수 필드 설정
                data_with_defaults = self._prepare_new_cve_data(cve_id, data, creator)
                
                # CVE 모델 생성 (Pydantic 모델 사용)
                from ..cve.models import CreateCVERequest
                cve_request = CreateCVERequest(**data_with_defaults)
                
                # CVEService를 통해 CVE 생성
                await self.cve_service.create_cve(cve_request, creator)
            else:
                # 기존 CVE 업데이트
                self.log_info(f"기존 CVE 업데이트: {cve_id}")
                
                # 업데이트 데이터 준비
                data_for_update = self._prepare_update_cve_data(data, creator)
                
                # 필드 제한된 패치 데이터 생성
                from ..cve.models import PatchCVERequest
                patch_data = PatchCVERequest(**data_for_update)
                
                # CVEService를 통해 업데이트
                # MongoDB ID 대신 항상 CVE ID를 사용 - 이렇게 하면 CVE ID로 조회할 때 일관성 유지
                # CVE ID는 전역적으로 유일하므로 이 방법이 더 안전함
                await self.cve_service.update_cve(cve_id, patch_data, creator)
                
            # MongoDB ID가 아닌 CVE ID를 사용하여 항상 조회
            # CVE-ID는 표준 형식이고 데이터베이스 내에서 유일해야 함
            return await self.cve_service.get_cve_detail(cve_id)
        except Exception as e:
            self.log_error(f"CVE {cve_id} 업데이트 실패: {str(e)}", e)
            return None
            
    def _prepare_new_cve_data(self, cve_id: str, data: Dict[str, Any], creator: str) -> Dict[str, Any]:
        """새 CVE 생성을 위한 데이터 준비"""
        result = data.copy()
        
        # 필수 필드 설정
        if "title" not in result or not result["title"]:
            result["title"] = cve_id
        
        if "description" not in result or not result["description"]:
            result["description"] = ""
            
        if "severity" not in result:
            result["severity"] = "unknown"
            
        # 시간 정보 설정
        from app.common.utils.datetime_utils import get_utc_now
        now = get_utc_now()
        result["created_at"] = now
        result["last_modified_at"] = now
        result["created_by"] = creator
        result["last_modified_by"] = creator
        result["status"] = "신규등록"
        result["source"] = result.get("source", self.crawler_id)
        
        # 변경 이력 생성
        changes = [{
            "field": "cve_id",
            "field_name": "CVE ID",
            "action": "add",
            "summary": f"{cve_id} 등록됨",
            "old_value": None,
            "new_value": cve_id
        }]
        
        # 수정 이력 객체 생성
        mod_history = {
            "username": creator,
            "modified_at": now,
            "changes": changes
        }
        
        # 수정 이력 추가
        result["modification_history"] = [mod_history]
        
        return result
        
    def _prepare_update_cve_data(self, data: Dict[str, Any], creator: str) -> Dict[str, Any]:
        """CVE 업데이트를 위한 데이터 준비"""
        result = data.copy()
        
        # 업데이트 시간 설정
        from app.common.utils.datetime_utils import get_utc_now
        result["last_modified_at"] = get_utc_now()
        result["last_modified_by"] = creator
        
        return result


============================================================
File: /home/CVEHub/backend/app/crawler/crawlers/nuclei_crawler.py
------------------------------------------------------------
import logging
import os
import aiohttp
import asyncio
import json
import hashlib
import yaml
import git
import glob
from typing import Dict, List, Any, Optional, Union
from datetime import datetime
from pathlib import Path
from zoneinfo import ZoneInfo
from app.cve.models import CVEModel
from ..crawler_base import BaseCrawlerService
from app.core.config import get_settings
import re
from app.common.utils.datetime_utils import get_utc_now
from app.cve.utils import create_reference

logger = logging.getLogger(__name__)
settings = get_settings()

class NucleiCrawlerService(BaseCrawlerService):
    """Nuclei-Templates 데이터 수집/처리를 위한 크롤러 서비스"""
    
    def __init__(self):
        # 부모 클래스 초기화
        super().__init__(
            crawler_id="nuclei",  
            display_name="Nuclei Templates Crawler"
        )
        
        # 저장소 정보
        self.repo_url = "https://github.com/projectdiscovery/nuclei-templates.git"
        self.repo_path = os.path.join(settings.DATA_DIR, "nuclei-templates")
        self.cves_path = os.path.join(self.repo_path, "http", "cves")
        
        # 디렉토리 생성
        os.makedirs(settings.DATA_DIR, exist_ok=True)
        
        # 웹소켓 항상 활성화 상태로 유지
        self.websocket_enabled = True
        
        self.log_info(f"NucleiCrawlerService 초기화됨, 저장소 경로: {self.repo_path}")
    
    async def crawl(self) -> Dict[str, Any]:
        """전체 크롤링 프로세스 - 간결하고 오류에 강한 구현"""
        # 웹소켓은 이미 초기화에서 활성화됨
        
        try:
            # 시작 시간 기록 (성능 측정용)
            start_time = datetime.now()
            
            # 1. 초기 상태 보고
            await self.report_progress("preparing", 0, f"{self.crawler_id} 업데이트를 시작합니다.", require_websocket=True)
            
            # 2. 저장소 준비 - 에러 처리 강화
            if not await self._clone_or_pull_repo():
                raise Exception("저장소 클론/풀 작업 실패")
            await self.report_progress("preparing", 10, "저장소 준비 완료")
            
            # 3. 데이터 수집 - 검증 단순화
            await self.report_progress("fetching", 10, "템플릿 파일 수집 시작...")
            templates = await self.fetch_data()
            if not templates:
                raise Exception("템플릿 파일을 찾지 못했습니다.")
            
            # 파일 수집 완료 - 25% 지점
            await self.report_progress("fetching", 20, f"템플릿 파일 {len(templates)}개 수집 완료")
            
            # 4. 데이터 처리 - 검증 단순화
            await self.report_progress("processing", 20, f"{len(templates)}개 템플릿 파일 처리 시작...")
            processed_data = await self.parse_data(templates)
            if not processed_data.get('items'):
                raise Exception("템플릿 파일 처리 중 오류가 발생했습니다.")
            
            # 파일 처리 완료 - 60% 지점
            processed_count = len(processed_data['items'])
            await self.report_progress("processing", 60, f"템플릿 파일 {processed_count}개 처리 완료")
            
            # 5. 데이터베이스 업데이트
            await self.report_progress("saving", 60, f"{processed_count}개 항목 업데이트 시작...")
            if not await self.process_data(processed_data):
                raise Exception("데이터베이스 업데이트 중 오류가 발생했습니다.")
                
            # 6. 완료 보고
            updated_count = len(getattr(self, 'updated_cves', []))
            
            # 소요 시간 계산
            elapsed_time = (datetime.now() - start_time).total_seconds()
            time_per_item = elapsed_time / max(1, processed_count)
            
            # 완료 메시지 - 성능 정보 포함
            completion_message = (f"완료: {updated_count}개의 CVE가 업데이트되었습니다. "  
                                f"(처리 속도: {time_per_item:.2f}초/항목, 총 소요 시간: {elapsed_time:.1f}초)")
            
            await self.report_progress("completed", 100, completion_message, 
                                updated_cves=getattr(self, 'updated_cves', []))
            
            # 성능 요약 로깅
            self.log_info(f"크롤링 완료: {processed_count}개 항목 분석, {updated_count}개 항목 업데이트")
            self.log_info(f"총 소요 시간: {elapsed_time:.1f}초, 평균 처리 속도: {time_per_item:.2f}초/항목")
            
            return {
                "stage": "success",
                "message": completion_message,
                "updated": updated_count,
                "performance": {
                    "total_time": round(elapsed_time, 1),
                    "time_per_item": round(time_per_item, 2),
                    "items_processed": processed_count
                }
            }
        except Exception as e:
            self.log_error(f"크롤러 오류: {str(e)}", e)
            await self.report_progress("error", 0, f"오류 발생: {str(e)}")
            return {
                "stage": "error",
                "message": str(e),
                "error": str(e)
            }
        finally:
            self.websocket_enabled = False
    
    async def fetch_data(self) -> List[str]:
        """템플릿 파일 가져오기 - 간결하고 효율적인 구현"""
        await self.report_progress("fetching", 30, "Nuclei 템플릿 파일 검색 중...")
        
        # 템플릿 파일 검색 - 이미 비동기 함수로 구현
        files = await self._find_template_files()
        
        if not files:
            self.log_warning("템플릿 파일을 찾지 못했습니다.")
            return []
        
        self.log_info(f"총 {len(files)}개의 템플릿 파일 발견")
        await self.report_progress("fetching", 40, f"데이터 수집 완료: {len(files)}개 파일")
        
        return files
    
    async def parse_data(self, raw_data: Any) -> Dict[str, Any]:
        """데이터 파싱 - 타입 안전성 강화"""
        if not raw_data:
            self.log_warning("파싱할 데이터가 없습니다.")
            return {"items": [], "count": 0}
        
        # 입력 데이터 정규화
        template_files = []
        if isinstance(raw_data, str):
            template_files = [raw_data]
        elif isinstance(raw_data, list):
            template_files = raw_data
        else:
            self.log_error(f"파싱할 데이터가 잘못된 형식입니다: {type(raw_data)}")
            return {"items": [], "count": 0}
        
        # 템플릿 처리 (실질적인 비즈니스 로직)
        processed_data = await self._process_templates(template_files)
        
        return {
            "items": processed_data,
            "count": len(processed_data)
        }

    async def process_data(self, cve_data: dict) -> bool:
        """파싱된 CVE 데이터를 처리하고 데이터베이스에 저장"""
        try:
            # 상위 클래스의 cve_service 활용
            self.updated_cves = []
            total_count = len(cve_data.get('items', []))
            
            # 성능 최적화를 위한 로깅 제한
            log_interval = max(1, total_count // 20)  # 전체 항목의 5%마다 로그 출력
            
            # 진행률 보고를 위한 마일스톤 계산 (0%, 25%, 50%, 75%, 100%)
            milestones = [int(total_count * p) for p in [0, 0.25, 0.5, 0.75, 1.0]]
            next_milestone_idx = 0
            
            for idx, item in enumerate(cve_data.get('items', [])):
                try:
                    # 중요 마일스톤에 도달했을 때만 웹소켓 메시지 전송
                    if next_milestone_idx < len(milestones) and idx >= milestones[next_milestone_idx]:
                        # 진행률 계산 (0-100%)
                        progress = 60 + int((next_milestone_idx / 4) * 40)
                        milestone_percent = int(next_milestone_idx * 25)
                        
                        await self.report_progress(
                            "saving", progress, 
                            f"데이터베이스 업데이트 {milestone_percent}% 완료: {idx}/{total_count} 항목"
                        )
                        next_milestone_idx += 1
                    
                    cve_id = item.get('cve_id')
                    if not cve_id:
                        self.log_warning(f"CVE ID가 없는 항목 건너뜀: {item}")
                        continue
                    
                    # Nuclei 특화 로직: digest 해시 처리
                    content = item.get('content', '')
                    content_hash = self._extract_digest_hash(content)
                    item['nuclei_hash'] = content_hash or ""
                    
                    # 상위 클래스의 업데이트 메서드 활용
                    updated_cve = await self.update_cve(cve_id, item, creator="Nuclei-Crawler")
                    
                    # 제한된 로깅 - 특정 간격으로만 상세 로그 출력
                    if updated_cve:
                        if idx % log_interval == 0 or idx == total_count - 1:
                            self.log_info(f"CVE 업데이트 진행 중: {idx+1}/{total_count} ({(idx+1)/total_count*100:.1f}%)")
                        self.updated_cves.append(item)
                    else:
                        self.log_error(f"CVE 업데이트 실패: {cve_id}")
                        
                except Exception as e:
                    self.log_error(f"항목 처리 중 오류: {str(e)}", e)
                    continue
            
            # 최종 결과 요약 로깅
            self.log_info(f"총 {total_count}개 항목 중 {len(self.updated_cves)}개 업데이트 완료")
            return len(self.updated_cves) > 0
            
        except Exception as e:
            self.log_error(f"데이터 처리 중 오류: {str(e)}", e)
            return False

    async def _find_template_files(self) -> List[str]:
        """CVE 템플릿 파일 목록 찾기 - 비동기 파일 시스템 처리로 최적화"""
        self.log_info(f"템플릿 파일 검색 시작: {self.cves_path}")
        
        try:
            # asyncio 사용하여 IO 작업 비동기 처리
            template_files = []
            loop = asyncio.get_event_loop()
            
            # 디렉토리 내의 모든 연도 폴더 비동기 확인
            def get_year_dirs():
                return glob.glob(os.path.join(self.cves_path, "*"))
            
            year_dirs = await loop.run_in_executor(None, get_year_dirs)
            
            # 각 연도 디렉토리 병렬 처리
            async def process_year_dir(year_dir):
                if not os.path.isdir(year_dir):
                    return []
                    
                def get_yaml_files():
                    return glob.glob(os.path.join(year_dir, "*.yaml"))
                    
                return await loop.run_in_executor(None, get_yaml_files)
            
            # 모든 연도 디렉토리에서 병렬로 YAML 파일 검색
            tasks = [process_year_dir(year_dir) for year_dir in year_dirs]
            results = await asyncio.gather(*tasks)
            
            # 결과 병합
            for year_files in results:
                template_files.extend(year_files)
            
            self.log_info(f"템플릿 파일 검색 완료: {len(template_files)}개 파일 발견")
            return template_files
        except Exception as e:
            self.log_error(f"템플릿 파일 검색 중 오류: {str(e)}", e)
            return []
        
    async def _process_templates(self, template_files: List[str]) -> List[Dict[str, Any]]:
        """
        템플릿 파일 처리 최적화 - 병렬 처리, 메모리 효율성 개선
        헬퍼 메소드 활용으로 코드 중복 제거
        """
        if not template_files:
            return []
            
        self.log_info(f"템플릿 처리 시작: {len(template_files)}개 파일")
        results = []
        total = len(template_files)
        
        # 청크 단위로 처리 (메모리 효율성)
        chunk_size = 50  # 한 번에 처리할 파일 수
        
        # 진행률 보고를 위한 마일스톤 계산 (0%, 25%, 50%, 75%, 100%)
        milestones = [int(total * p) for p in [0, 0.25, 0.5, 0.75, 1.0]]
        next_milestone_idx = 0
        
        # 로그 최적화를 위한 간격 설정
        log_interval = max(1, total // 10)  # 10% 간격으로 로그 출력
        
        processed_count = 0
        for chunk_start in range(0, total, chunk_size):
            chunk_end = min(chunk_start + chunk_size, total)
            current_chunk = template_files[chunk_start:chunk_end]
            processed_count += len(current_chunk)
            
            # 중요 마일스톤에 도달했을 때만 웹소켓 메시지 전송
            if next_milestone_idx < len(milestones) and processed_count >= milestones[next_milestone_idx]:
                # 진행률 계산 (0-60%)
                progress = 20 + int((next_milestone_idx / 4) * 40)
                milestone_percent = int(next_milestone_idx * 25)
                
                await self.report_progress(
                    "processing", progress, 
                    f"파일 처리 {milestone_percent}% 완료: {processed_count}/{total} 항목"
                )
                next_milestone_idx += 1
            
            # 제한된 로깅 - 특정 간격으로만 상세 로그 출력
            if chunk_start % log_interval < chunk_size or chunk_end == total:
                self.log_info(f"템플릿 처리 진행 중: {processed_count}/{total} ({processed_count/total*100:.1f}%)")
            
            # 청크 내 파일 병렬 처리
            tasks = [self._process_single_template(file_path) for file_path in current_chunk]
            chunk_results = await asyncio.gather(*tasks)
            
            # 유효한 결과만 추가
            for result in chunk_results:
                if result:
                    results.append(result)
        
        self.log_info(f"템플릿 처리 완료: {len(results)}/{len(template_files)} 성공")
        return results
        
    async def _process_single_template(self, file_path: str) -> Optional[Dict[str, Any]]:
        """단일 템플릿 파일 처리 - 코드 모듈화"""
        try:
            # 파일명에서 CVE ID 추출
            file_name = os.path.basename(file_path)
            cve_id = self._extract_cve_id_from_filename(file_name)
            
            if not cve_id:
                # 디버그 레벨로 낮춤 - 많은 파일이 처리되므로 경고 로그가 과도하게 생성됨
                self.logger.debug(f"CVE ID를 추출할 수 없음: {file_name}")
                return None
            
            # YAML 파일 읽기
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            try:
                yaml_data = yaml.safe_load(content)
            except Exception as e:
                self.log_error(f"YAML 파싱 오류 ({file_path}): {str(e)}")
                return None
                
            if not yaml_data or not isinstance(yaml_data, dict):
                # 디버그 레벨로 낮춤
                self.logger.debug(f"유효하지 않은 YAML 형식 ({file_path})")
                return None
                
            # 기본 데이터 추출
            info = yaml_data.get('info', {})
            
            severity = info.get('severity', '')
            description = info.get('description', '')
            name = info.get('name', '')
            
            # CVE 데이터 구성
            cve_data = {
                'cve_id': cve_id,
                'title': name,
                'description': description,
                'severity': self._standardize_severity(severity),
                'content': content,  # 원본 콘텐츠 보존
                'references': self._extract_references(info.get('reference', [])),
                'pocs': self._create_pocs(cve_id, file_path),
                'snort_rules': [],
                'file_path': file_path
            }
            
            # 로그 제거 - 파일이 많아 로그가 과도하게 생성됨
            return cve_data
            
        except Exception as e:
            self.log_error(f"템플릿 처리 중 오류: {file_path}, {str(e)}")
            return None
            
    # 헬퍼 메서드들로 분리하여 가독성 향상
    def _extract_cve_id_from_filename(self, file_name: str) -> str:
        """파일명에서 CVE ID 추출"""
        cve_id_from_file = file_name.split(".")[0].upper()
        if cve_id_from_file.startswith("CVE-"):
            return cve_id_from_file
            
        # 파일명에 CVE ID가 포함되어 있는지 확인
        cve_pattern = r'(CVE-\d{4}-\d{4,})'
        match = re.search(cve_pattern, file_name, re.IGNORECASE)
        if match:
            return match.group(1).upper()
        
        return f"NUCLEI-{file_name.split('.')[0]}"
    
    def _standardize_severity(self, severity: str) -> str:
        """심각도 표준화"""
        if severity in ['critical', 'high', 'medium', 'low', 'info', 'unknown']:
            return severity
        
        # 매핑 로직
        severity_lower = severity.lower()
        if any(term in severity_lower for term in ['critical', 'crit']):
            return 'critical'
        elif any(term in severity_lower for term in ['high', 'severe']):
            return 'high'
        elif any(term in severity_lower for term in ['medium', 'moderate', 'med']):
            return 'medium'
        elif any(term in severity_lower for term in ['low', 'minor']):
            return 'low'
        elif any(term in severity_lower for term in ['info', 'information']):
            return 'info'
        
        return 'unknown'

    def _extract_references(self, references) -> List[Dict[str, Any]]:
        """참조 URL 추출 및 객체 변환"""
        if isinstance(references, str):
            references = [references]
        elif not references:
            return []
        
        reference_objects = []
        current_time = datetime.now(ZoneInfo("UTC")).isoformat()
        
        # URL 패턴과 해당 타입을 매핑하는 딕셔너리
        url_type_mapping = {
            "nvd.nist.gov": "NVD",
            "exploit.db.com": "Exploit",
            "nuclei-templates": "Exploit",
            "metasploit-framework": "Exploit"
            # 필요시 여기에 더 많은 매핑을 추가할 수 있습니다
        }
        
        for ref_url in references:
            if not ref_url:
                continue
                
            # 기본 타입은 OTHER로 설정
            ref_type = "OTHER"
            description = "Nuclei Template Reference"
            
            # URL 패턴 매칭
            for pattern, type_value in url_type_mapping.items():
                if pattern in ref_url:
                    ref_type = type_value
                    description = f"{type_value} Reference"
                    break
                    
            reference_objects.append({
                "url": ref_url,
                "type": ref_type,
                "description": description,
                "created_at": current_time,
                "created_by": "Nuclei-Crawler",
                "last_modified_at": current_time,
                "last_modified_by": "Nuclei-Crawler"
            })
        
    return reference_objects

    def _create_pocs(self, cve_id: str, file_path: str) -> List[Dict[str, Any]]:
        """PoC 정보 생성"""
        # CVE ID에서 연도 추출
        cve_year_match = re.match(r'CVE-(\d{4})-\d+', cve_id)
        cve_year = cve_year_match.group(1) if cve_year_match else "unknown"
        
        # GitHub URL 생성
        github_url = f"https://github.com/projectdiscovery/nuclei-templates/blob/main/http/cves/{cve_year}/{cve_id}.yaml"
        
        current_time = datetime.now(ZoneInfo("UTC")).isoformat()
        return [{
            "source": "Nuclei-Templates",
            "url": github_url,
            "description": f"Nuclei Template for {cve_id}",
            "created_at": current_time,
            "created_by": "Nuclei-Crawler",
            "last_modified_at": current_time,
            "last_modified_by": "Nuclei-Crawler"
        }]

    async def _clone_or_pull_repo(self) -> bool:
        """저장소 클론 또는 풀 - 비동기 처리로 최적화"""
        try:
            loop = asyncio.get_event_loop()
            
            if not os.path.exists(self.repo_path):
                # 클론 작업 시작
                self.log_info(f"저장소 클론 시작: {self.repo_url} -> {self.repo_path}")
                
                # 비동기로 클론 작업 수행
                await loop.run_in_executor(
                    None, 
                    lambda: git.Repo.clone_from(self.repo_url, self.repo_path)
                )
                
                self.log_info("저장소 클론 완료")
            else:
                # 풀 작업 시작
                self.log_info(f"저장소 풀 시작: {self.repo_path}")
                
                # 저장소 불러오기
                def load_and_pull():
                    repo = git.Repo(self.repo_path)
                    origin = repo.remotes.origin
                    origin.pull()
                    return True
                
                # 비동기로 풀 작업 수행
                await loop.run_in_executor(None, load_and_pull)
                
                self.log_info("저장소 풀 완료")
            
            return True
        except Exception as e:
            self.log_error(f"저장소 클론/풀 중 오류: {str(e)}", e)
            
            # 오류 후 복구 시도
            if os.path.exists(self.repo_path):
                self.log_warning(f"문제가 있는 저장소 디렉토리 삭제 시도: {self.repo_path}")
                try:
                    import shutil
                    await loop.run_in_executor(None, lambda: shutil.rmtree(self.repo_path, ignore_errors=True))
                    self.log_info(f"다음 실행 시 새로 클론할 수 있도록 저장소 디렉토리 삭제됨")
                except Exception as cleanup_err:
                    self.log_error(f"저장소 디렉토리 정리 중 오류: {str(cleanup_err)}")
            
            return False
    
    def _extract_digest_hash(self, content: Union[str, Dict]) -> str:
        """템플릿 파일에서 digest 해시 값 추출"""
        # 텍스트 콘텐츠로 변환
        if isinstance(content, dict):
            try:
                # 딕셔너리를 YAML 텍스트로 변환
                import yaml
                content = yaml.dump(content)
                # self.log_debug("딕셔너리를 YAML 텍스트로 변환하여 digest 추출을 시도합니다.")
            except Exception as e:
                self.log_error(f"YAML 변환 중 오류: {str(e)}")
                content = str(content)  # 실패 시 문자열로 변환

        if not isinstance(content, str):
            content = str(content)
            self.log_warning(f"콘텐츠가 문자열이 아니므로 변환했습니다: {type(content)}")

        # 파일 끝에 있는 digest 주석 형식 검색
        digest_pattern = r'#\s*digest:\s*([a-fA-F0-9:]+)'
        match = re.search(digest_pattern, content)
        
        if match:
            # self.log_debug(f"파일에서 digest 값을 추출했습니다: {match.group(1)}")
            return match.group(1)
        
        # digest를 찾지 못한 경우 에러 로깅
        self.log_error("템플릿 파일에서 digest 값을 찾을 수 없습니다. 모든 Nuclei 템플릿에는 digest 값이 있어야 합니다.")
        # 첫 100자와 마지막 100자 로깅하여 문제 확인 가능하도록 함
        content_start = content[:100] if len(content) > 100 else content
        content_end = content[-100:] if len(content) > 100 else content
        self.log_error(f"콘텐츠 시작 부분: {content_start}...")
        self.log_error(f"콘텐츠 마지막 부분: ...{content_end}")
        
        # digest가 없을 경우 빈 문자열 반환 (오류 표시를 위해)
        return ""


============================================================
File: /home/CVEHub/backend/app/crawler/crawlers/metasploit_crawler.py
------------------------------------------------------------
import os
import git
import re
import logging
from pathlib import Path
from ..crawler_base import BaseCrawlerService
from ...models.cve_model import CVEModel
from ...core.config import get_settings
from datetime import datetime
from zoneinfo import ZoneInfo

logger = logging.getLogger(__name__)
settings = get_settings()

class MetasploitCrawlerService(BaseCrawlerService):
    """
    Metasploit Framework 저장소에서 CVE 관련 PoC를 크롤링하는 서비스
    """
    def __init__(self):
        super().__init__(crawler_name="Metasploit-Crawler")
        self.repo_url = "https://github.com/rapid7/metasploit-framework.git"
        
        # BASE_DIR이 없는 경우 기본 경로 사용
        base_dir = getattr(settings, 'BASE_DIR', '/app/crawlers')
        
        # 절대 경로 보장
        if not os.path.isabs(base_dir):
            base_dir = os.path.abspath(base_dir)
            
        # 기본 디렉토리가 없으면 생성
        os.makedirs(base_dir, exist_ok=True)
        
        self.repo_path = os.path.join(settings.DATA_DIR, "metasploit-framework")
        self.modules_path = os.path.join(self.repo_path, "modules/exploits")
        
        # modules_path의 상위 디렉토리도 생성
        os.makedirs(os.path.dirname(self.modules_path), exist_ok=True)
        
        self.log_info(f"Metasploit 크롤러가 초기화되었습니다. 저장소 경로: {self.repo_path}")
    
    async def fetch_data(self) -> bool:
        """저장소 클론 또는 풀"""
        try:
            if not os.path.exists(self.repo_path):
                self.log_info(f"Metasploit 저장소를 {self.repo_path}에 클론합니다")
                git.Repo.clone_from(self.repo_url, self.repo_path, depth=1)  # shallow clone for faster download
            else:
                self.log_info("Metasploit 최신 변경사항을 가져옵니다")
                repo = git.Repo(self.repo_path)
                origin = repo.remotes.origin
                origin.pull()
            return True
        except Exception as e:
            self.log_error("데이터 가져오기 중 오류 발생", e)
            return False
    
    async def parse_data(self, file_path: str) -> dict:
        """Ruby 파일에서 CVE 정보 파싱"""
        try:
            # Ruby 파일 읽기
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            # CVE ID 찾기 (예: CVE-2021-1234)
            cve_pattern = r'CVE-\d{4}-\d{1,7}'
            cve_matches = re.findall(cve_pattern, content)
            
            if not cve_matches:
                return None
                
            cve_id = cve_matches[0]  # 첫 번째 CVE ID 사용
            
            # 모듈 이름과 설명 찾기
            name_match = re.search(r"['\"']Name['\"']\s*=>\s*['\"']([^'\"']+)['\"']", content)
            desc_match = re.search(r"['\"']Description['\"']\s*=>\s*['\"']([^'\"']+)['\"']", content)
            
            name = name_match.group(1) if name_match else "Unknown Metasploit Module"
            description = desc_match.group(1) if desc_match else "No description available"
            
            # Reference URLs 찾기
            reference_pattern = r"['\"']References['\"']\s*=>\s*\[(.*?)\]"
            reference_section = re.search(reference_pattern, content, re.DOTALL)
            
            references = []
            if reference_section:
                ref_text = reference_section.group(1)
                url_matches = re.findall(r"['\"'](https?://[^'\"']+)['\"']", ref_text)
                
                for url in url_matches:
                    ref_type = 'NVD' if 'nvd.nist.gov' in url else 'OTHER'
                    references.append({
                        'url': url,
                        'source': 'metasploit-framework',
                        'type': ref_type,
                        'created_by': self.crawler_name
                    })
            
            # Metasploit 모듈 URL 생성
            relative_path = os.path.relpath(file_path, self.repo_path)
            module_url = f"https://github.com/rapid7/metasploit-framework/blob/master/{relative_path}"
            
            # PoC 정보 생성
            current_time = self.get_current_time()
            
            # Metasploit 모듈 URL을 Reference에 추가
            references.append({
                'url': module_url,
                'source': 'metasploit-framework',
                'type': 'Exploit',
                'description': 'Metasploit Module',
                'created_by': self.crawler_name
            })
            
            # PoC 객체 생성
            pocs = [{
                'source': 'Metasploit-Framework',
                'url': module_url,
                'description': f'Metasploit: {name}',
                'created_at': current_time,
                'created_by': self.crawler_name
            }]
            
            return {
                'cve_id': cve_id,
                'title': name,
                'description': description,
                'references': references,
                'pocs': pocs,
                'created_at': current_time,
                'last_modified_at': current_time,
                'created_by': self.crawler_name
            }
        except Exception as e:
            self.log_error(f"Error parsing {file_path}", e)
            return None
    
    async def process_data(self, cve_data: dict) -> bool:
        """CVE 데이터 처리 및 DB 저장"""
        try:
            if not cve_data or not cve_data.get('cve_id'):
                return False
                
            # 기존 CVE 검색
            cve = await CVEModel.find_one({'cve_id': cve_data['cve_id']})
            
            if not cve:
                # 새로운 CVE인 경우 전체 데이터 저장
                
                # 히스토리 정보 추가
                current_time = datetime.now(ZoneInfo("UTC"))
                changes = []
                
                # 기본 CVE 생성 정보
                changes.append({
                    "field": "cve",
                    "field_name": "CVE",
                    "action": "add",
                    "summary": "CVE 생성 (Metasploit-Crawler)"
                })
                
                # 제목 정보 기록
                if cve_data.get('title'):
                    changes.append({
                        "field": "title",
                        "field_name": "제목",
                        "action": "add",
                        "detail_type": "detailed",
                        "after": cve_data.get('title'),
                        "summary": "제목 추가됨"
                    })
                    
                # 설명 정보 기록
                if cve_data.get('description'):
                    changes.append({
                        "field": "description",
                        "field_name": "설명",
                        "action": "add",
                        "detail_type": "detailed",
                        "after": cve_data.get('description'),
                        "summary": "설명 추가됨"
                    })
                    
                # 상태 정보 기록
                changes.append({
                    "field": "status",
                    "field_name": "상태",
                    "action": "add",
                    "detail_type": "detailed",
                    "after": "신규등록",
                    "summary": "상태가 '신규등록'(으)로 설정됨"
                })
                
                # 참조 정보 기록
                if cve_data.get('references') and len(cve_data.get('references')) > 0:
                    changes.append({
                        "field": "references",
                        "field_name": "References",
                        "action": "add",
                        "detail_type": "simple",
                        "summary": f"Reference {len(cve_data.get('references'))}개 추가됨"
                    })
                    
                # PoC 정보 기록
                if cve_data.get('pocs') and len(cve_data.get('pocs')) > 0:
                    changes.append({
                        "field": "pocs",
                        "field_name": "PoC",
                        "action": "add",
                        "detail_type": "simple",
                        "summary": f"PoC {len(cve_data.get('pocs'))}개 추가됨"
                    })
                
                modification_history = [{
                    "username": "Metasploit-Crawler",
                    "modified_at": current_time,
                    "changes": changes
                }]
                
                cve = CVEModel(
                    cve_id=cve_data['cve_id'],
                    title=cve_data['title'],
                    description=cve_data['description'],
                    references=cve_data['references'],
                    pocs=cve_data['pocs'],
                    created_at=cve_data['created_at'],
                    last_modified_at=cve_data['last_modified_at'],
                    created_by="Metasploit-Crawler",
                    modification_history=modification_history
                )
            else:
                # 기존 CVE의 경우 PoC와 Reference만 업데이트
                # 기존 Reference에 없는 새로운 Reference만 추가
                existing_ref_urls = [ref.url for ref in cve.references]
                for new_ref in cve_data['references']:
                    if new_ref['url'] not in existing_ref_urls:
                        cve.references.append(new_ref)
                        
                # 기존 PoC에 없는 새로운 PoC만 추가
                existing_poc_urls = [poc.url for poc in cve.pocs]
                for new_poc in cve_data['pocs']:
                    if new_poc['url'] not in existing_poc_urls:
                        cve.pocs.append(new_poc)
                        
                # last_modified_at 업데이트
                cve.last_modified_at = cve_data['last_modified_at']
                
            await cve.save()
            return True
        except Exception as e:
            self.log_error("Error processing CVE data", e)
            return False
            
    async def crawl(self) -> bool:
        """전체 크롤링 프로세스"""
        try:
            # 초기 상태 메시지 (웹소켓 연결 필수)
            await self.report_progress("준비", 0, f"Metasploit 크롤링을 시작합니다", require_websocket=True)
            
            if not await self.fetch_data():
                await self.report_progress("오류", 0, "저장소 데이터를 가져오는데 실패했습니다", require_websocket=True)
                return False
                
            success_count = 0
            error_count = 0
            
            # Ruby 파일 순회
            for ruby_file in Path(self.modules_path).rglob("*.rb"):
                try:
                    cve_data = await self.parse_data(str(ruby_file))
                    if cve_data and await self.process_data(cve_data):
                        success_count += 1
                    elif cve_data:  # 파싱은 성공했지만 저장 실패
                        error_count += 1
                except Exception as e:
                    self.log_error(f"Error processing {ruby_file}", e)
                    error_count += 1
                    
            self.log_info(f"Metasploit crawling completed - Success: {success_count}, Errors: {error_count}")
            await self.report_progress("완료", 100, f"Metasploit 크롤링 완료 - 성공: {success_count}, 오류: {error_count}", require_websocket=True)
            
            return True
        except Exception as e:
            try:
                await self.report_progress("오류", 0, f"크롤링 중 오류 발생: {str(e)}", require_websocket=True)
            except:
                self.log_error(f"크롤러 오류 및 웹소켓 메시지 전송 실패: {str(e)}")
            return False
            
    async def crawl_single_cve(self, cve_id: str) -> bool:
        """단일 CVE 크롤링"""
        try:
            if not await self.fetch_data():
                self.log_error("Failed to fetch repository data")
                return False
                
            # 해당 CVE ID가 포함된 파일 검색
            cve_pattern = re.compile(re.escape(cve_id), re.IGNORECASE)
            success_count = 0
            
            for ruby_file in Path(self.modules_path).rglob("*.rb"):
                try:
                    with open(ruby_file, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        
                    if cve_pattern.search(content):
                        self.log_info(f"Found matching file: {ruby_file}")
                        cve_data = await self.parse_data(str(ruby_file))
                        if cve_data and await self.process_data(cve_data):
                            success_count += 1
                except Exception as e:
                    self.log_error(f"Error processing {ruby_file}", e)
            
            if success_count > 0:
                self.log_info(f"Successfully processed {success_count} modules for {cve_id}")
                return True
            else:
                self.log_error(f"No valid modules found for {cve_id}")
                return False
                
        except Exception as e:
            self.log_error(f"Error in crawl_single_cve for {cve_id}", e)
            return False 


============================================================
File: /home/CVEHub/backend/app/crawler/crawlers/emerging_threats_crawler.py
------------------------------------------------------------
import os
import re
import aiohttp
import asyncio
from typing import Dict, List, Optional, Any
import json
from datetime import datetime
from zoneinfo import ZoneInfo
from app.cve.models import CVEModel, SnortRule
from app.core.config import get_settings
from ..crawler_base import BaseCrawlerService
from app.common.utils.datetime_utils import get_utc_now

settings = get_settings()

class EmergingThreatsCrawlerService(BaseCrawlerService):
    """EmergingThreats 룰을 크롤링하는 서비스"""
    
    def __init__(self):
        super().__init__("emerging_threats", "EmergingThreats Crawler")
        self.rule_url = settings.EMERGING_THREATS_URL
        self.data_dir = settings.DATA_DIR
        self.rule_file_path = os.path.join(self.data_dir, "emerging-all.rules")
        self.hash_file_path = os.path.join(self.data_dir, "emerging-all.hash")
        self.updated_cves = []  # 업데이트된 CVE 목록
        
        # 임시 디렉토리 생성
        os.makedirs(self.data_dir, exist_ok=True)
    
    async def fetch_data(self) -> bool: 
        """원격 저장소에서 룰 파일 다운로드"""
        try:
            await self.report_progress("preparing", 0, "EmergingThreats 룰 파일 다운로드 준비 중...")
            
            # 최신 파일 해시 확인
            current_hash = await self._get_remote_file_hash()
            if not current_hash:
                self.log_error("원격 파일 해시를 가져올 수 없습니다.")
                await self.report_progress("error", 0, "원격 파일 해시를 가져올 수 없습니다.")
                return False
            
            # 이전 해시와 비교
            previous_hash = await self._get_stored_hash()
            
            if current_hash == previous_hash and os.path.exists(self.rule_file_path):
                self.log_info("EmergingThreats 룰 파일이 최신 상태입니다. 다운로드를 건너뜁니다.")
                await self.report_progress("fetching", 100, "파일이 이미 최신 상태입니다.")
                return True
            
            # 파일 다운로드
            await self.report_progress("fetching", 10, "EmergingThreats 룰 파일 다운로드 중...")
            async with aiohttp.ClientSession() as session:
                async with session.get(self.rule_url) as response:
                    if response.status != 200:
                        self.log_error(f"룰 파일 다운로드 실패: {response.status}")
                        await self.report_progress("error", 0, f"룰 파일 다운로드 실패: HTTP {response.status}")
                        return False
                    
                    content = await response.text()
                    with open(self.rule_file_path, 'w', encoding='utf-8') as f:
                        f.write(content)
            
            # 새 해시 저장
            with open(self.hash_file_path, 'w') as f:
                f.write(current_hash)
            
            self.log_info(f"EmergingThreats 룰 파일 다운로드 완료: {len(content)} 바이트")
            await self.report_progress("fetching", 100, "EmergingThreats 룰 파일 다운로드 완료")
            return True
            
        except Exception as e:
            self.log_error(f"데이터 다운로드 중 오류 발생: {str(e)}")
            await self.report_progress("error", 0, f"데이터 다운로드 중 오류 발생: {str(e)}")
            return False
    
    async def _get_remote_file_hash(self) -> Optional[str]:
        """원격 파일의 해시 값을 가져옵니다."""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(self.rule_url) as response:
                    if response.status != 200:
                        return None
                    content = await response.read()
                    return hashlib.sha256(content).hexdigest()
        except Exception as e:
            self.log_error(f"원격 파일 해시 가져오기 실패: {str(e)}")
            return None
    
    async def _get_stored_hash(self) -> Optional[str]:
        """저장된 이전 해시 값을 가져옵니다."""
        if not os.path.exists(self.hash_file_path):
            return None
        try:
            with open(self.hash_file_path, 'r') as f:
                return f.read().strip()
        except Exception as e:
            self.log_error(f"저장된 해시 가져오기 실패: {str(e)}")
            return None
    
    async def parse_data(self, data_path: str) -> dict:
        """파일에서 CVE 정보가 있는 룰만 파싱"""
        try:
            await self.report_progress("processing", 0, "EmergingThreats 룰 파싱 중...")
            
            rules_with_cve = []
            total_rules = 0
            cve_rules = 0
            
            with open(self.rule_file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                # 주석 제거
                content = re.sub(r'^\s*#.*$', '', content, flags=re.MULTILINE)
                # 빈 줄 제거
                content = re.sub(r'^\s*$', '', content, flags=re.MULTILINE)
                
                # 각 룰 분리하여 처리
                for i, rule in enumerate(re.finditer(r'alert\s+.*?\)\s*$', content, re.MULTILINE | re.DOTALL)):
                    total_rules += 1
                    
                    # 진행 상황 업데이트 (10%마다)
                    if total_rules % 100 == 0:
                        percent = min(int((i / len(content)) * 100), 99)
                        await self.report_progress("processing", percent, f"룰 파싱 중... ({total_rules}개 처리)")
                    
                    rule_text = rule.group(0)
                    
                    # CVE 참조 확인
                    cve_matches = re.finditer(r'reference:cve,(\d{4}-\d+)', rule_text)
                    cves = [match.group(1) for match in cve_matches]
                    
                    if cves:
                        cve_rules += 1
                        
                        # URL 참조 추출
                        url_refs = []
                        for url_match in re.finditer(r'reference:url,([^;]+)', rule_text):
                            url_refs.append(url_match.group(1).strip())
                        
                        # 룰에서 메시지 추출 (디버깅용, title로는 사용하지 않음)
                        msg_match = re.search(r'msg:"([^"]+)"', rule_text)
                        msg = msg_match.group(1) if msg_match else "No description"
                        
                        # sid 추출
                        sid_match = re.search(r'sid:(\d+)', rule_text)
                        sid = sid_match.group(1) if sid_match else "unknown"
                        
                        # Rule 코드에서 reference와 metadata 부분 제거
                        clean_rule = re.sub(r'reference:[^;]+;', '', rule_text)
                        clean_rule = re.sub(r'metadata:[^;]+;', '', clean_rule)
                        
                        # 각 CVE ID에 대해 정보 저장
                        for cve_id in cves:
                            rules_with_cve.append({
                                "cve_id": f"CVE-{cve_id}",
                                "msg": msg,  # 원본 메시지 (참고용)
                                "rule_sid": sid,
                                "rule_content": clean_rule.strip(),
                                "references": url_refs
                            })
            
            await self.report_progress("processing", 100, 
                                     f"룰 파싱 완료: 총 {total_rules}개 룰 중 {cve_rules}개 CVE 관련 룰 발견")
            
            return {
                "rules": rules_with_cve,
                "total_rules": total_rules,
                "cve_rules": cve_rules
            }
            
        except Exception as e:
            self.log_error(f"룰 파싱 중 오류 발생: {str(e)}")
            await self.report_progress("error", 0, f"룰 파싱 중 오류 발생: {str(e)}")
            return {"rules": [], "total_rules": 0, "cve_rules": 0}
    
    async def process_data(self, cve_data: dict) -> bool:
        """파싱된 데이터를 DB에 저장"""
        try:
            rules = cve_data["rules"]
            total_rules = len(rules)
            
            if total_rules == 0:
                self.log_info("처리할 CVE 룰이 없습니다.")
                await self.report_progress("saving", 100, "처리할 CVE 룰이 없습니다.")
                return True
            
            self.log_info(f"처리 시작: {total_rules}개의 CVE 룰")
            await self.report_progress("saving", 0, f"{total_rules}개의 CVE 룰 처리 시작")
            
            # 중복 처리 방지를 위한 처리 완료된 CVE ID 추적
            processed_cves = set()
            updated_count = 0
            new_count = 0
            
            for i, rule_data in enumerate(rules):
                cve_id = rule_data["cve_id"]
                
                # 진행 상황 업데이트
                if i % 10 == 0 or i == total_rules - 1:
                    percent = int((i / total_rules) * 100)
                    await self.report_progress("saving", percent, 
                                             f"CVE 업데이트 중... ({i}/{total_rules})")
                
                # 이미 처리된 CVE는 건너뛰기
                if cve_id in processed_cves:
                    continue
                
                processed_cves.add(cve_id)
                
                # 기본 CVE 데이터 생성
                cve_data = {
                    "title": cve_id,  # title을 CVE ID로 설정
                    "description": "",  # description은 빈 상태로 설정
                    "severity": "unassigned",  # 기본값
                    "source": "EmergingThreats"
                }
                
                # 룰 객체 생성
                rule_obj = {
                    "type": "Emerging-Threats",  # Emerging-Threats로 설정
                    "rule": rule_data["rule_content"],
                    "sid": rule_data["rule_sid"],
                    "created_by": "emerging_threats_crawler",
                    "created_at": get_utc_now()
                }
                
                # 기존 CVE 가져오기
                cve = await self.cve_service.get_cve_detail(cve_id)
                is_new = cve is None
                
                if cve:
                    # 기존 CVE의 스노트 룰 가져오기
                    if hasattr(cve, "snort_rules") and cve.snort_rules:
                        current_rules = cve.snort_rules
                    else:
                        current_rules = []
                        
                    # SID로 기존 룰 검색
                    rule_exists = False
                    for idx, existing_rule in enumerate(current_rules):
                        if isinstance(existing_rule, dict) and existing_rule.get("sid") == rule_data["rule_sid"]:
                            # 기존 룰 업데이트
                            current_rules[idx] = rule_obj
                            rule_exists = True
                            break
                    
                    if not rule_exists:
                        current_rules.append(rule_obj)
                        
                    # 업데이트할 데이터에 룰 추가
                    cve_data["snort_rules"] = current_rules
                    updated_count += 1
                else:
                    # 새 CVE의 경우
                    cve_data["snort_rules"] = [rule_obj]
                    new_count += 1
                
                # 참조 URL 처리
                if rule_data["references"]:
                    references = []
                    
                    # 기존 참조 URL 가져오기
                    if cve and hasattr(cve, "references") and cve.references:
                        existing_urls = {
                            ref.get("url") if isinstance(ref, dict) else ref
                            for ref in cve.references
                        }
                        references = cve.references
                    else:
                        existing_urls = set()
                        references = []
                    
                    # 새로운 URL 추가
                    for url in rule_data["references"]:
                        if url not in existing_urls:
                            # cve_utils의 create_reference 함수 사용
                            from ..utils.cve_utils import create_reference
                            reference_obj = create_reference(
                                url=url,
                                type="ADVISORY",
                                description="EmergingThreats Rule Reference",
                                creator="emerging_threats_crawler"
                            )
                            references.append(reference_obj)
                            existing_urls.add(url)
                    
                    # 업데이트할 데이터에 참조 URL 추가
                    cve_data["references"] = references
                
                # BaseCrawlerService의 update_cve 메서드 사용
                cve = await self.update_cve(cve_id, cve_data, "EmergingThreats-Crawler")
                
                # 업데이트된 CVE 목록에 추가
                self.updated_cves.append({
                    "cve_id": cve_id,
                    "title": cve.title if hasattr(cve, "title") and cve.title else cve_id,
                    "is_new": is_new
                })
            
            # 완료 메시지
            status_msg = f"업데이트 완료: {new_count}개 신규 CVE, {updated_count}개 기존 CVE 업데이트"
            self.log_info(status_msg)
            await self.report_progress("completed", 100, status_msg, self.updated_cves)
            
            return True
            
        except Exception as e:
            self.log_error(f"데이터 처리 중 오류 발생: {str(e)}")
            await self.report_progress("error", 0, f"데이터 처리 중 오류 발생: {str(e)}")
            return False
    
    async def crawl(self, requester_id: str = None, quiet_mode: bool = False) -> dict:
        """EmergingThreats 규칙을 크롤링하고 데이터베이스에 저장합니다."""
        self.requester_id = requester_id
        self.quiet_mode = quiet_mode
        
        try:
            # 초기화 단계
            await self.report_progress("preparing", 0, "크롤링 초기화 중")
            
            # 데이터 수집 단계
            await self.report_progress("fetching", 10, "EmergingThreats 규칙 다운로드 시작")
            success = await self.fetch_data()
            if not success:
                await self.report_progress("error", 0, "EmergingThreats 규칙 다운로드 실패")
                return {"success": False, "message": "EmergingThreats 규칙 다운로드 실패"}
            
            await self.report_progress("fetching", 50, "EmergingThreats 규칙 다운로드 완료")
            
            # 데이터 처리 단계
            await self.report_progress("processing", 60, "EmergingThreats 규칙 파싱 시작")
            parsed_data = await self.parse_data(self.rule_file_path)
            if not parsed_data:
                await self.report_progress("error", 0, "EmergingThreats 규칙 파싱 실패")
                return {"success": False, "message": "EmergingThreats 규칙 파싱 실패"}
            
            await self.report_progress("processing", 80, f"EmergingThreats 규칙 파싱 완료 ({len(parsed_data.get('rules', []))} 개 규칙)")
            
            # 데이터베이스 업데이트 단계
            await self.report_progress("saving", 85, "데이터베이스 업데이트 시작")
            success = await self.process_data(parsed_data)
            if not success:
                await self.report_progress("error", 0, "데이터베이스 업데이트 실패")
                return {"success": False, "message": "데이터베이스 업데이트 실패"}
            
            # 완료 단계
            await self.report_progress("completed", 100, f"EmergingThreats 크롤링 완료 ({len(self.updated_cves)} 개 CVE 업데이트)", updated_cves=self.updated_cves)
            
            return {
                "success": True,
                "message": f"EmergingThreats 크롤링 완료 ({len(self.updated_cves)} 개 CVE 업데이트)",
                "updated_count": len(self.updated_cves)
            }
            
        except Exception as e:
            error_message = f"EmergingThreats 크롤링 중 오류 발생: {str(e)}"
            self.log_exception(error_message)
            await self.report_progress("error", 0, error_message)
            return {"success": False, "message": error_message}


============================================================
File: /home/CVEHub/backend/app/crawler/test_crawler.py
------------------------------------------------------------
import asyncio
import sys
import os
import logging
from pathlib import Path

# 상위 디렉토리를 Python 경로에 추가
project_root = str(Path(__file__).parent.parent.parent)
sys.path.append(project_root)

# .env 파일 경로 설정을 위한 환경변수 추가
os.environ["ENV_FILE"] = os.path.join(project_root, ".env")

from app.services.crawler import NucleiCrawlerService
from app.core.config import get_settings
from motor.motor_asyncio import AsyncIOMotorClient
from beanie import init_beanie
from app.cve.models import CVEModel

# 로깅 설정
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

async def test_all_cves():
    """모든 CVE에 대한 크롤링 테스트"""
    try:
        # MongoDB 연결 설정
        settings = get_settings()
        client = AsyncIOMotorClient(settings.MONGODB_URL)
        
        # Beanie 초기화
        await init_beanie(
            database=client[settings.DATABASE_NAME],
            document_models=[CVEModel]
        )

        crawler = NucleiCrawlerService()
        
        # 전체 크롤링 실행
        if await crawler.crawl():
            logger.info("Successfully completed crawling all CVEs")
        else:
            logger.error("Failed to complete crawling")

    except Exception as e:
        logger.error(f"Error in test_all_cves: {str(e)}")
    finally:
        # MongoDB 연결 종료
        client.close()

async def test_single_cve(cve_id: str):
    """단일 CVE에 대한 크롤링 테스트"""
    try:
        # MongoDB 연결 설정
        settings = get_settings()
        client = AsyncIOMotorClient(settings.MONGODB_URL)
        
        # Beanie 초기화
        await init_beanie(
            database=client[settings.DATABASE_NAME],
            document_models=[CVEModel]
        )

        crawler = NucleiCrawlerService()
        
        # 저장소 클론/풀
        if not await crawler.clone_or_pull_repo():
            logger.error("Failed to clone/pull repository")
            return

        # CVE ID로 YAML 파일 찾기
        cve_file = None
        for year_dir in Path(crawler.cves_path).iterdir():
            if year_dir.is_dir() and year_dir.name.isdigit():
                potential_file = year_dir / f"{cve_id}.yaml"
                if potential_file.exists():
                    cve_file = potential_file
                    break

        if not cve_file:
            logger.error(f"YAML file for {cve_id} not found")
            return

        # YAML 파일 파싱 및 처리
        logger.info(f"Processing {cve_file}")
        cve_data = await crawler.parse_yaml_file(str(cve_file))
        
        if cve_data:
            logger.info("Parsed CVE data:")
            logger.info(f"CVE ID: {cve_data.get('cve_id')}")
            logger.info(f"Title: {cve_data.get('title')}")
            logger.info(f"Description: {cve_data.get('description')}")
            logger.info(f"References: {cve_data.get('references')}")

            # DB에 저장
            success = await crawler.process_cve_data(cve_data)
            if success:
                logger.info("Successfully saved to database")
            else:
                logger.error("Failed to save to database")
        else:
            logger.error("Failed to parse YAML file")

    except Exception as e:
        logger.error(f"Error in test_single_cve: {str(e)}")
    finally:
        # MongoDB 연결 종료
        client.close()

def main():
    """메인 함수"""
    if len(sys.argv) == 1:
        # 인자가 없으면 전체 CVE 업데이트
        print("Updating all CVEs...")
        asyncio.run(test_all_cves())
    elif len(sys.argv) == 2:
        # CVE ID가 주어진 경우 해당 CVE만 업데이트
        cve_id = sys.argv[1]
        print(f"Updating single CVE: {cve_id}")
        asyncio.run(test_single_cve(cve_id))
    else:
        print("Usage:")
        print("  python test_crawler.py           # Update all CVEs")
        print("  python test_crawler.py <CVE-ID>  # Update single CVE")
        print("Example: python test_crawler.py CVE-2023-0334")
        sys.exit(1)

if __name__ == "__main__":
    main() 


============================================================
File: /home/CVEHub/backend/app/crawler/service.py
------------------------------------------------------------
"""크롤러 관련 비즈니스 로직을 처리하는 서비스 클래스"""
import logging
from typing import Dict, List, Any, Optional, Tuple
import asyncio

from app.cve.service import CVEService
from app.crawler.crawler_manager import CrawlerManager
from app.core.scheduler import CrawlerScheduler
from app.core.cache import get_cache, set_cache

logger = logging.getLogger(__name__)

class CrawlerService:
    """크롤러 관련 비즈니스 로직을 처리하는 서비스 클래스"""
    
    def __init__(self, cve_service: Optional[CVEService] = None):
        """
        CrawlerService 생성자
        
        Args:
            cve_service: CVE 서비스 인스턴스 (선택적)
        """
        self.cve_service = cve_service
        self.crawler_manager = CrawlerManager()
        self.scheduler = CrawlerScheduler()
        self.logger = logging.getLogger(__name__)
    
    async def run_specific_crawler(self, crawler_type: str, user_id: Optional[str] = None, quiet_mode: bool = False) -> Dict[str, Any]:
        """지정된 크롤러를 실행합니다.
        
        Args:
            crawler_type: 실행할 크롤러 유형
            user_id: 요청한 사용자 ID
            quiet_mode: 조용한 모드 활성화 여부
            
        Returns:
            실행 결과 정보
        """
        try:
            # 이미 실행 중인지 확인
            if self.scheduler.is_update_running():
                current_status = self.scheduler.get_current_status()
                self.logger.warning(f"Crawler already running: {current_status.get('crawler_type')}")
                return {
                    "success": False,
                    "message": f"이미 {current_status.get('crawler_type')} 크롤러가 실행 중입니다 ({current_status.get('progress')}%)",
                    "stage": "already_running",
                    "crawler_type": current_status.get('crawler_type'),
                    "progress": current_status.get('progress')
                }
            
            # 백그라운드에서 크롤러 실행
            asyncio.create_task(self.scheduler.run_specific_crawler(crawler_type, user_id, quiet_mode))
            
            self.logger.info(f"{crawler_type} crawler started in background")
            return {
                "success": True,
                "message": f"{crawler_type} 크롤러가 백그라운드에서 실행 중입니다",
                "stage": "running",
                "crawler_type": crawler_type
            }
        except Exception as e:
            self.logger.error(f"Run crawler error: {str(e)}")
            return {
                "success": False,
                "message": f"크롤러 실행 중 오류가 발생했습니다: {str(e)}",
                "stage": "error",
                "crawler_type": crawler_type if 'crawler_type' in locals() else "unknown"
            }

    async def get_crawler_status(self) -> Dict[str, Any]:
        """크롤러 상태 및 마지막 업데이트 정보를 조회합니다.
        
        Returns:
            상태 정보
        """
        return {
            "isRunning": self.scheduler.is_update_running(),
            "lastUpdate": self.scheduler.get_last_update(),
            "results": self.scheduler.get_update_results()
        }

    async def get_available_crawlers(self) -> Dict[str, Any]:
        """사용 가능한 크롤러 목록을 조회합니다.
        
        Returns:
            크롤러 목록 정보
        """
        available_crawlers = self.crawler_manager.get_available_crawlers()
        
        # 프론트엔드에 적합한 형식으로 변환
        formatted_crawlers = []
        for crawler in available_crawlers:
            formatted_crawlers.append({
                "id": crawler.get("id"),
                "name": crawler.get("name", crawler.get("id")),
                "description": crawler.get("description", ""),
                "type": crawler.get("type", "crawler"),
                "enabled": True
            })
            
        return {
            "crawlers": formatted_crawlers,
            "count": len(formatted_crawlers)
        }

    async def get_update_results(self, crawler_id: str) -> Optional[Dict[str, Any]]:
        """특정 크롤러의 최근 업데이트 결과를 가져옵니다.
        
        Args:
            crawler_id: 크롤러 ID
            
        Returns:
            업데이트 결과 또는 None
        """
        # 캐시에서 결과 조회
        cache_key = f"crawler_update_result:{crawler_id}"
        cached_result = await get_cache(cache_key)
        
        if cached_result:
            self.logger.info(f"Returning cached results for crawler: {crawler_id}")
            return {
                "crawler_id": crawler_id,
                "results": cached_result
            }
        
        # 데이터베이스 또는 스케줄러에서 결과 조회 시도
        scheduler_result = self.scheduler.get_crawler_result(crawler_id)
        if scheduler_result:
            return {
                "crawler_id": crawler_id,
                "results": scheduler_result
            }
        
        self.logger.warning(f"No update results found for crawler: {crawler_id}")
        return None
        
    async def run_all_crawlers(self, user_id: Optional[str] = None, quiet_mode: bool = False) -> Dict[str, Any]:
        """모든 사용 가능한 크롤러를 실행합니다.
        
        Args:
            user_id: 요청한 사용자 ID
            quiet_mode: 조용한 모드 활성화 여부
            
        Returns:
            실행 결과 정보
        """
        try:
            # 이미 실행 중인지 확인
            if self.scheduler.is_update_running():
                current_status = self.scheduler.get_current_status()
                self.logger.warning(f"Crawler already running: {current_status.get('crawler_type')}")
                return {
                    "success": False,
                    "message": f"이미 업데이트가 실행 중입니다 ({current_status.get('progress')}%)",
                    "stage": "already_running"
                }
            
            # 사용 가능한 크롤러 목록 가져오기
            available_crawlers = self.crawler_manager.get_available_crawlers()
            crawler_types = [crawler.get("id") for crawler in available_crawlers]
            
            if not crawler_types:
                return {
                    "success": False,
                    "message": "사용 가능한 크롤러가 없습니다",
                    "stage": "error"
                }
            
            # 백그라운드에서 모든 크롤러 실행
            asyncio.create_task(self.scheduler.run_all_crawlers(user_id, quiet_mode))
            
            self.logger.info(f"All crawlers ({len(crawler_types)}) started in background")
            return {
                "success": True,
                "message": f"모든 크롤러({len(crawler_types)}개)가 백그라운드에서 실행 중입니다",
                "stage": "running",
                "crawler_count": len(crawler_types)
            }
        except Exception as e:
            self.logger.error(f"Run all crawlers error: {str(e)}")
            return {
                "success": False,
                "message": f"크롤러 실행 중 오류가 발생했습니다: {str(e)}",
                "stage": "error"
            }


============================================================
File: /home/CVEHub/backend/app/crawler/crawler_manager.py
------------------------------------------------------------
import logging
import asyncio
from typing import List, Dict, Optional, Any
from .crawler_base import BaseCrawlerService
from .crawler_base import LoggingMixin


logger = logging.getLogger(__name__)

class CrawlerManager(LoggingMixin):
    """
    다양한 크롤러를 관리하고 실행하는 매니저 클래스 (싱글톤)
    """
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(CrawlerManager, cls).__new__(cls)
            cls._instance._crawlers = {}
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        if not self._initialized:
            self._initialize()
            self._initialized = True
    
    def _initialize(self):
        """
        크롤러 매니저를 초기화합니다.
        """
        # 등록된 모든 크롤러 유형에 대해 인스턴스 생성
        from .crawler_factory import CrawlerRegistry
        
        # 먼저 자동 발견 시도
        CrawlerRegistry.discover_crawlers()
        
        for crawler_type in CrawlerRegistry.get_registered_types():
            try:
                self._crawlers[crawler_type] = CrawlerRegistry.create_crawler(crawler_type)
                self.log_info(f"크롤러 초기화됨: {crawler_type}")
            except Exception as e:
                self.log_error(f"크롤러 초기화 실패: {crawler_type}", e)
    
    def get_available_crawlers(self) -> List[Dict[str, Any]]:
        """
        사용 가능한 크롤러 목록을 반환합니다.
        
        Returns:
            크롤러 정보 목록 (ID, 이름, 설명)
        """
        crawlers = []
        
        for crawler_id, crawler in self._crawlers.items():
            if not crawler:
                continue
                
            crawler_info = {
                "id": crawler_id,
                "name": getattr(crawler, "display_name", crawler_id),
                "description": getattr(crawler, "__doc__", "").strip() or None,
                "type": crawler.__class__.__name__
            }
            
            crawlers.append(crawler_info)
            
        return crawlers
    
    def get_crawler(self, crawler_type: str) -> Optional[BaseCrawlerService]:
        """
        지정된 유형의 크롤러를 반환합니다.
        
        Args:
            crawler_type: 크롤러 유형
            
        Returns:
            크롤러 인스턴스 또는 None
        """
        return self._crawlers.get(crawler_type.lower())
        
    def create_crawler(self, crawler_type: str) -> Optional[BaseCrawlerService]:
        """
        지정된 유형의 크롤러를 생성합니다. (하위 호환성을 위한 메서드)
        내부적으로 get_crawler 메서드를 호출합니다.
        
        Args:
            crawler_type: 크롤러 유형
            
        Returns:
            크롤러 인스턴스 또는 None
        """
        return self.get_crawler(crawler_type)
    
    async def run_crawler(self, crawler_type: str, user_id: Optional[str] = None, quiet_mode: bool = False) -> Dict[str, Any]:
        """
        지정된 크롤러를 실행합니다.
        
        Args:
            crawler_type: 실행할 크롤러 유형
            user_id: 요청자 ID (선택적)
            quiet_mode: 조용한 모드 활성화 여부
            
        Returns:
            실행 결과
        """
        try:
            crawler = self.get_crawler(crawler_type)
            if not crawler:
                self.log_warning(f"크롤러를 찾을 수 없음: {crawler_type}")
                return {
                    "success": False,
                    "message": f"크롤러를 찾을 수 없습니다: {crawler_type}",
                    "stage": "error"
                }
            
            # 사용자 ID 및 조용한 모드 설정
            if user_id:
                crawler.set_requester_id(user_id)
                
            crawler.set_quiet_mode(quiet_mode)
            
            # 크롤러 실행
            self.log_info(f"크롤러 실행 시작: {crawler_type}")
            result = await crawler.crawl()
            
            # 성공 여부 확인
            success = isinstance(result, dict) and result.get("stage") == "success"
            
            if success:
                self.log_info(f"크롤러 실행 성공: {crawler_type}")
                return {
                    "success": True,
                    "message": result.get("message", "크롤러가 성공적으로 실행되었습니다"),
                    "stage": "completed",
                    "crawler_type": crawler_type,
                    "result": result
                }
            else:
                self.log_warning(f"크롤러 실행 실패: {crawler_type}")
                return {
                    "success": False,
                    "message": result.get("message", "크롤러 실행 실패"),
                    "stage": "error",
                    "crawler_type": crawler_type,
                    "result": result
                }
                
        except Exception as e:
            self.log_error(f"크롤러 실행 중 오류: {crawler_type}", e)
            return {
                "success": False,
                "message": f"크롤러 실행 중 오류가 발생했습니다: {str(e)}",
                "stage": "error",
                "crawler_type": crawler_type
            }
    
    async def run_all_crawlers(self, user_id: Optional[str] = None, quiet_mode: bool = False) -> Dict[str, Dict[str, Any]]:
        """
        모든 크롤러를 실행합니다.
        
        Args:
            user_id: 요청자 ID (선택적)
            quiet_mode: 조용한 모드 활성화 여부
            
        Returns:
            각 크롤러의 실행 결과
        """
        results = {}
        
        # 모든 크롤러 비동기 실행
        tasks = []
        for crawler_type in self._crawlers.keys():
            task = asyncio.create_task(self.run_crawler(crawler_type, user_id, quiet_mode))
            tasks.append((crawler_type, task))
        
        # 모든 작업 완료 대기
        for crawler_type, task in tasks:
            try:
                result = await task
                results[crawler_type] = result
            except Exception as e:
                self.log_error(f"크롤러 실행 중 예외 발생: {crawler_type}", e)
                results[crawler_type] = {
                    "success": False,
                    "message": f"크롤러 실행 중 예외가 발생했습니다: {str(e)}",
                    "stage": "error",
                    "crawler_type": crawler_type
                }
        
        return results
    
    async def run_specific_crawlers(self, crawler_types: List[str], user_id: Optional[str] = None, quiet_mode: bool = False) -> Dict[str, Dict[str, Any]]:
        """
        지정된 크롤러들을 실행합니다.
        
        Args:
            crawler_types: 실행할 크롤러 유형 목록
            user_id: 요청자 ID (선택적)
            quiet_mode: 조용한 모드 활성화 여부
            
        Returns:
            각 크롤러의 실행 결과
        """
        results = {}
        
        # 지정된 크롤러 비동기 실행
        tasks = []
        for crawler_type in crawler_types:
            task = asyncio.create_task(self.run_crawler(crawler_type, user_id, quiet_mode))
            tasks.append((crawler_type, task))
        
        # 모든 작업 완료 대기
        for crawler_type, task in tasks:
            try:
                result = await task
                results[crawler_type] = result
            except Exception as e:
                self.log_error(f"크롤러 실행 중 예외 발생: {crawler_type}", e)
                results[crawler_type] = {
                    "success": False,
                    "message": f"크롤러 실행 중 예외가 발생했습니다: {str(e)}",
                    "stage": "error",
                    "crawler_type": crawler_type
                }
        
        return results
    
    async def crawl_single_cve(self, cve_id: str, crawler_type: str = "nuclei") -> Dict[str, Any]:
        """
        단일 CVE를 크롤링합니다.
        
        Args:
            cve_id: 크롤링할 CVE ID
            crawler_type: 사용할 크롤러 유형 (기본값: nuclei)
            
        Returns:
            크롤링 결과
        """
        try:
            crawler = self.get_crawler(crawler_type)
            if not crawler:
                self.log_warning(f"크롤러를 찾을 수 없음: {crawler_type}")
                return {
                    "success": False,
                    "message": f"크롤러를 찾을 수 없습니다: {crawler_type}",
                    "cve_id": cve_id
                }
            
            # 크롤러에 단일 CVE 크롤링 메서드가 있는지 확인
            if hasattr(crawler, 'crawl_single_cve') and callable(getattr(crawler, 'crawl_single_cve')):
                result = await crawler.crawl_single_cve(cve_id)
                return {
                    "success": True,
                    "message": f"CVE {cve_id} 크롤링 완료",
                    "cve_id": cve_id,
                    "result": result
                }
            else:
                self.log_warning(f"크롤러에 단일 CVE 크롤링 기능이 없습니다: {crawler_type}")
                return {
                    "success": False,
                    "message": f"크롤러에 단일 CVE 크롤링 기능이 없습니다: {crawler_type}",
                    "cve_id": cve_id
                }
        except Exception as e:
            self.log_error(f"단일 CVE 크롤링 중 오류: {cve_id}", e)
            return {
                "success": False,
                "message": f"단일 CVE 크롤링 중 오류가 발생했습니다: {str(e)}",
                "cve_id": cve_id
            }


============================================================
File: /home/CVEHub/backend/app/socketio/router.py
------------------------------------------------------------
"""
소켓 관련 HTTP 엔드포인트 라우터

소켓 연결과 관련된 HTTP 엔드포인트를 제공합니다.
주로 세션 관리, 구독 정리 등의 기능을 제공합니다.
"""
from fastapi import APIRouter, Depends, HTTPException, status, Request
import logging
import traceback

from .models import SessionCleanupRequest
from .service import get_socket_service
from .manager import get_socket_manager
from ..auth.service import get_current_user
from ..core.logging_utils import get_logger

# 로거 설정
logger = get_logger(__name__)

# 라우터 생성
router = APIRouter(prefix="/socket", tags=["socket"])


@router.post("/cleanup_subscriptions")
async def cleanup_orphaned_subscriptions(
    request: SessionCleanupRequest,
    current_user = Depends(get_current_user)
):
    """
    세션 구독 정리 API
    
    사용자 세션의 고아 구독을 정리합니다. (예: 새로고침, 브라우저 종료 후 재접속 시)
    
    Args:
        request: 세션 정리 요청
        current_user: 현재 인증된 사용자
        
    Returns:
        정리 결과
    """
    try:
        # 요청 검증
        user_id_to_clean = request.user_id or str(current_user.id)
        session_id_to_clean = request.session_id
        
        logger.info(f"세션 구독 정리 요청 - 요청자: {current_user.id}, 대상 사용자: {user_id_to_clean}, 세션: {session_id_to_clean}")
        
        if not session_id_to_clean:
            logger.warning(f"세션 ID 없는 정리 요청 - 요청자: {current_user.id}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="세션 ID가 필요합니다."
            )
        
        # 소켓 서비스를 통해 세션 정리 처리
        socket_service = get_socket_service()
        result = await socket_service.handle_session_cleanup(
            session_id=session_id_to_clean,
            user_id=user_id_to_clean
        )
        
        if not result.get("success", False):
            error = result.get("error", {})
            logger.warning(f"세션 정리 실패 - 코드: {error.get('code')}, 메시지: {error.get('message')}")
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND if error.get("code") in ["SESSION_NOT_FOUND", "USER_SESSION_NOT_FOUND"] else status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=error.get("message", "알 수 없는 오류")
            )
        
        logger.info(f"세션 구독 정리 완료 - 세션: {session_id_to_clean}, 정리된 CVE 수: {result.get('cleaned_cves_count', 0)}")
        return {
            "success": True,
            "message": "세션 구독 정리가 완료되었습니다.",
            "session_id": session_id_to_clean,
            "cleaned_cves_count": result.get("cleaned_cves_count", 0)
        }
        
    except HTTPException as http_exc:
        # HTTP 예외는 그대로 전달
        raise http_exc
    except Exception as e:
        logger.error(f"세션 구독 정리 요청 처리 중 오류 발생: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"세션 구독 정리 요청 처리 중 서버 오류 발생: {str(e)}"
        )


@router.get("/status")
async def get_socket_status(current_user = Depends(get_current_user)):
    """
    소켓 서버 상태 API
    
    현재 소켓 서버의 연결, 구독 통계 정보를 제공합니다.
    관리자만 접근 가능합니다.
    
    Args:
        current_user: 현재 인증된 사용자
        
    Returns:
        소켓 서버 상태 정보
    """
    try:
        # 관리자 권한 확인
        if not current_user.is_admin:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="관리자만 접근 가능합니다."
            )
        
        # 소켓 저장소에서 통계 정보 조회
        from .repository import get_socket_repository
        socket_repository = get_socket_repository()
        stats = await socket_repository.get_stats()
        
        # 현재 사용자의 연결 정보 추가
        user_sessions = await socket_repository.get_user_sessions(str(current_user.id))
        stats["current_user_sessions"] = len(user_sessions)
        stats["current_user_sessions_list"] = [session.dict() for session in user_sessions]
        
        return {
            "success": True,
            "stats": stats
        }
        
    except HTTPException as http_exc:
        # HTTP 예외는 그대로 전달
        raise http_exc
    except Exception as e:
        logger.error(f"소켓 상태 조회 중 오류 발생: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"소켓 상태 조회 중 서버 오류 발생: {str(e)}"
        )



============================================================
File: /home/CVEHub/backend/app/socketio/manager.py
------------------------------------------------------------
"""
Socket.IO 서버 관리 클래스

Socket.IO 서버를 초기화하고, 클라이언트와의 연결을 관리하며, 이벤트 처리를 담당합니다.
"""
from typing import Dict, List, Set, Any, Optional, Union, Callable
import socketio
import asyncio
import json
import logging
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from .models import WSMessageType, SocketSession, SocketError
from .repository import get_socket_repository
from .interfaces import SocketRepositoryInterface, SocketServiceInterface
from ..core.logging_utils import get_logger
from ..core.config import get_settings
from ..auth.service import verify_token, UserService
from ..auth.models import UserResponse
import traceback

# 로거 설정
logger = get_logger(__name__)


class DateTimeEncoder(json.JSONEncoder):
    """JSON 직렬화 시 datetime 및 ObjectId 객체 처리"""
    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.isoformat()  # ISO 표준 포맷 사용
        try:
            from bson import ObjectId
            if isinstance(obj, ObjectId):
                return str(obj)
        except ImportError:
            pass  # bson 라이브러리가 없는 경우 무시
        return super().default(obj)


class SocketManager:
    """소켓 통신 서비스"""
    
    def __init__(self, 
                 user_service: Optional[UserService] = None,
                 repository: Optional[SocketRepositoryInterface] = None,
                 service: Optional[SocketServiceInterface] = None):
        """
        Socket.IO 매니저 초기화
        
        Args:
            user_service: 사용자 인증 서비스. None인 경우 내부에서 생성
            repository: 소켓 저장소 인터페이스. None인 경우 내부에서 생성
            service: 소켓 서비스 인터페이스. None인 경우 내부에서 생성
        """
        self.logger = logger
        self.settings = get_settings()
        
        # 의존성 주입 또는 생성
        self.user_service = user_service
        self.repository = repository or get_socket_repository()
        
        # service는 지연 로딩
        self._service = None
        if service:
            self._service = service
        
        # ping/pong 로깅을 억제하기 위해 socketio 로거 레벨을 WARNING으로 설정
        socketio_logger = logging.getLogger('socketio.server')
        socketio_logger.setLevel(logging.WARNING)
        
        engineio_logger = logging.getLogger('engineio.server')
        engineio_logger.setLevel(logging.WARNING)
        
        # Socket.IO 서버 생성
        self.sio = socketio.AsyncServer(
            async_mode='asgi',
            cors_allowed_origins='*',
            json=json,
            logger=False,  # 핑/퐁 메시지 로깅 비활성화
            engineio_logger=self.settings.WS_ENGINEIO_LOGGER,
            ping_timeout=self.settings.WS_PING_TIMEOUT,
            ping_interval=self.settings.WS_PING_INTERVAL,
            max_http_buffer_size=self.settings.WS_MAX_HTTP_BUFFER_SIZE
        )
        
        # 이벤트 핸들러 등록
        self._setup_event_handlers()
        
        # 앱 인스턴스 생성
        self.app = socketio.ASGIApp(
            self.sio,
            socketio_path=self.settings.socket_path
        )
    
    def _setup_event_handlers(self):
        """소켓 이벤트 핸들러 등록"""
        
        @self.sio.event
        async def connect(sid, environ, auth):
            """연결 이벤트 핸들러"""
            await self._handle_connect(sid, environ, auth)
            
        @self.sio.event
        async def disconnect(sid):
            """연결 해제 이벤트 핸들러"""
            await self._handle_disconnect(sid)
            
        # ping/pong 이벤트 핸들러 제거 - Socket.IO가 내부적으로 처리하도록 함
            
        @self.sio.event
        async def subscribe_cve(sid, data):
            """구독 이벤트 핸들러"""
            # 지연 로딩
            await self._ensure_service()
            response = await self._service.handle_event(sid, WSMessageType.SUBSCRIBE_CVE, data)
            await self.sio.emit(WSMessageType.SUBSCRIPTION_STATUS, response, room=sid)
            
        @self.sio.event
        async def unsubscribe_cve(sid, data):
            """구독 해제 이벤트 핸들러"""
            # 지연 로딩
            await self._ensure_service()
            response = await self._service.handle_event(sid, WSMessageType.UNSUBSCRIBE_CVE, data)
            await self.sio.emit(WSMessageType.SUBSCRIPTION_STATUS, response, room=sid)
    
    async def _handle_connect(self, sid: str, environ: Dict[str, Any], auth: Dict[str, Any]) -> None:
        """
        Socket.IO 'connect' 이벤트의 실제 처리 로직.
        인증 수행, 사용자 연결 정보 등록, 세션 구독 복원 등을 처리합니다.
        
        Args:
            sid: 소켓 ID
            environ: WSGI 환경 변수
            auth: 인증 정보
        """
        try:
            self.logger.info(f"소켓 연결 시도 - SID: {sid}")
            
            # 인증 정보 확인
            auth_success = False
            user_info = None
            
            # auth 파라미터 또는 쿼리 파라미터에서 인증 정보 추출
            token = None
            username = None
            
            if auth:
                token = auth.get('token')
                username = auth.get('username')
            
            if not token or not username:
                # environ의 쿼리 파라미터에서 인증 정보 추출
                query = environ.get('QUERY_STRING', '')
                import urllib.parse
                query_params = dict(urllib.parse.parse_qsl(query))
                token = query_params.get('token') or token
                username = query_params.get('username') or query_params.get('userId') or query_params.get('user_id') or username
            
            # 일단 소켓 연결 정보 로깅
            self.logger.info(f"소켓 인증 시도 - SID: {sid}, token 존재: {token is not None}, username 존재: {username is not None}")
            if token:
                self.logger.info(f"토큰 정보 - 길이: {len(token)}, 형태: {token[:10]}...")
            if username:
                self.logger.info(f"사용자명 정보: {username}")
            
            # auth 파라미터 전체 로깅
            self.logger.info(f"전체 auth 파라미터: {auth}")
            
            # 인증 정보가 있는 경우 토큰 검증
            if token and username:
                if not self.user_service:
                    # UserService가 아직 설정되지 않은 경우 생성
                    from app.auth.service import UserService
                    self.user_service = UserService()
                    
                try:
                    # 토큰 검증 전 로깅
                    self.logger.info(f"소켓 인증 시도 - 토큰 검증 전")
                    
                    # 토큰 검증
                    user_info = await verify_token(token)
                    
                    # 토큰 검증 결과 확인
                    if user_info:
                        self.logger.info(f"토큰 검증 성공 - 토큰 사용자명: {user_info.username}, 요청 사용자명: {username}")
                    else:
                        self.logger.warning(f"토큰 검증 실패 - 유효하지 않은 토큰")
                    
                    if user_info and str(user_info.username) == str(username):
                        auth_success = True
                        self.logger.info(f"소켓 인증 성공 - SID: {sid}, 사용자명: {username}")
                    else:
                        self.logger.warning(f"소켓 인증 실패 - SID: {sid}, 토큰의 사용자명({user_info.username if user_info else 'None'})와 요청 사용자명({username}) 불일치")
                except Exception as e:
                    self.logger.error(f"소켓 인증 중 오류 발생: {str(e)}")
                    self.logger.error(traceback.format_exc())
            
            # 세션 ID 확인 (클라이언트에서 제공하거나 새로 생성)
            session_id = None
            if auth:
                session_id = auth.get('sessionId') or auth.get('session_id')
            if not session_id:
                session_id = environ.get('HTTP_X_SESSION_ID') or f"s_{sid}"
            
            # 소켓 세션 추가
            await self.repository.add_session(
                sid=sid,
                username=username if auth_success else None,
                session_id=session_id
            )
            
            # 인증 결과와 세션 정보를 클라이언트에 전송
            await self.sio.emit(
                WSMessageType.CONNECT_ACK if auth_success else WSMessageType.CONNECTED,
                {
                    "authenticated": auth_success,
                    "username": username if auth_success else None,
                    "sessionId": session_id,
                    "serverTime": datetime.now(ZoneInfo("UTC")).isoformat()
                },
                room=sid
            )
            
            self.logger.info(f"소켓 연결 완료 - SID: {sid}, 인증: {auth_success}, 세션 ID: {session_id}")
        
        except Exception as e:
            self.logger.error(f"소켓 연결 처리 중 오류 발생: {str(e)}")
            self.logger.error(traceback.format_exc())
            
            # 오류 발생 시 클라이언트에 오류 메시지 전송
            try:
                await self.sio.emit(
                    WSMessageType.ERROR,
                    {
                        "code": "CONNECTION_ERROR",
                        "message": "Connection initialization failed",
                        "details": {"reason": str(e)}
                    },
                    room=sid
                )
            except Exception:
                self.logger.error("오류 메시지 전송 중 추가 오류 발생")
    
    async def _handle_disconnect(self, sid: str) -> None:
        """
        Socket.IO 'disconnect' 이벤트의 실제 처리 로직.
        사용자 연결 정보 및 관련 매핑 정보를 정리합니다.
        
        Args:
            sid: 소켓 ID
        """
        try:
            self.logger.info(f"소켓 연결 해제 - SID: {sid}")
            
            # 세션 정보 조회
            session = await self.repository.get_session(sid)
            if not session:
                self.logger.warning(f"연결 해제 시 세션을 찾을 수 없음 - SID: {sid}")
                return
            
            # 사용자 정보 저장
            username = session.username
            session_id = session.session_id
            
            # 세션 제거
            await self.repository.remove_session(sid)
            
            self.logger.info(f"소켓 연결 해제 완료 - SID: {sid}, 사용자: {username}, 세션 ID: {session_id}")
        
        except Exception as e:
            self.logger.error(f"소켓 연결 해제 처리 중 오류 발생: {str(e)}")
            self.logger.error(traceback.format_exc())
    
    async def emit(
        self, 
        event: Union[str, WSMessageType], 
        data: Any, 
        room: Optional[str] = None,
        namespace: Optional[str] = None,
        skip_sid: Optional[str] = None,
        callback: Optional[Callable] = None
    ) -> bool:
        """
        Socket.IO 이벤트를 발신합니다.
        
        Args:
            event: 이벤트 이름 또는 WSMessageType
            data: 이벤트 데이터
            room: 특정 룸이나 SID
            namespace: 네임스페이스 (기본값: '/')
            skip_sid: 제외할 SID
            callback: 콜백 함수
            
        Returns:
            발신 성공 여부
        """
        try:
            # 이벤트 이름 정규화
            event_name = event.value if isinstance(event, WSMessageType) else event
            
            # 데이터 직렬화 시도
            try:
                # 테스트 직렬화 (오류 검증용)
                json.dumps(data, cls=DateTimeEncoder)
            except TypeError as e:
                self.logger.error(f"이벤트 데이터 직렬화 실패 - 이벤트: {event_name}, 오류: {str(e)}")
                if isinstance(data, dict):
                    # 직렬화 가능한 항목만 필터링
                    filtered_data = {}
                    for k, v in data.items():
                        try:
                            json.dumps({k: v}, cls=DateTimeEncoder)
                            filtered_data[k] = v
                        except TypeError:
                            self.logger.warning(f"직렬화 불가능한 필드 제외 - 필드: {k}")
                    data = filtered_data
                else:
                    # 직렬화 불가능한 데이터는 문자열로 변환
                    data = str(data)
            
            # 룸이 사용자 ID인 경우 해당 사용자의 모든 세션에 발신
            if room and len(room) < 50:  # SID는 보통 길기 때문에 사용자 ID인지 확인
                user_sessions = await self.repository.get_user_sessions(room)
                if user_sessions:
                    # 사용자의 모든 세션에 발신
                    for session in user_sessions:
                        await self.sio.emit(
                            event_name,
                            data,
                            room=session.sid,
                            namespace=namespace,
                            skip_sid=skip_sid,
                            callback=callback
                        )
                    return True
            
            # 일반적인 발신
            await self.sio.emit(
                event_name,
                data,
                room=room,
                namespace=namespace,
                skip_sid=skip_sid,
                callback=callback
            )
            return True
            
        except Exception as e:
            self.logger.error(f"이벤트 발신 중 오류 발생 - 이벤트: {event}, 오류: {str(e)}")
            self.logger.error(traceback.format_exc())
            return False

    async def _ensure_service(self):
        """소켓 서비스가 있는지 확인하고 없는 경우 로딩합니다."""
        if self._service is None:
            from .service import get_socket_service
            self._service = get_socket_service()
        return self._service
        
    async def broadcast_json(self, data: Dict[str, Any], event_name: str = "notification") -> bool:
        """연결된 모든 클라이언트에게 JSON 메시지를 브로드캐스트하고 성공 여부를 반환합니다.
        
        Args:
            data: 전송할 JSON 데이터
            event_name: 이벤트 이름 (기본값: notification)
            
        Returns:
            브로드캐스트 성공 여부
        """
        try:
            await self.sio.emit(event_name, data)
            return True
        except Exception as e:
            self.logger.error(f"broadcast_json 메서드 실행 중 오류 발생: {str(e)}")
            self.logger.error(traceback.format_exc())
            return False
            
    async def emit_message(self, event_name: str, data: Any,
                        target_user: Optional[str] = None, target_room: Optional[str] = None,
                        target_sid: Optional[str] = None, broadcast_all: bool = False,
                        skip_sid: Optional[str] = None, namespace: str = "/") -> str:
        """
        범용 메시지 전송 유틸리티 메서드.
        다양한 타겟(특정 SID, 사용자, 룸, 전체)에게 메시지를 전송합니다.
        
        Args:
            event_name: 전송할 이벤트 이름
            data: 전송할 데이터
            target_user: 메시지를 전송할 특정 사용자 ID
            target_room: 메시지를 전송할 특정 룸 이름
            target_sid: 메시지를 전송할 특정 세션 ID
            broadcast_all: 모든 클라이언트에게 전송할지 여부
            skip_sid: 전송 제외할 세션 ID
            namespace: 네임스페이스
            
        Returns:
            전송 결과 메시지
        """
        try:
            if broadcast_all:
                # 모든 클라이언트에게 전송
                await self.sio.emit(event_name, data, namespace=namespace, skip_sid=skip_sid)
                return f"Broadcast to all clients"
            elif target_sid:
                # 특정 세션에만 전송
                await self.sio.emit(event_name, data, room=target_sid, namespace=namespace)
                return f"Sent to session {target_sid}"
            elif target_user:
                # 특정 사용자의 모든 세션에 전송
                user_sessions = await self.repository.get_user_sessions(target_user)
                if not user_sessions:
                    return f"User {target_user} has no active sessions"
                
                sent_count = 0
                for session in user_sessions:
                    await self.sio.emit(event_name, data, room=session.sid, namespace=namespace)
                    sent_count += 1
                return f"Sent to {sent_count} sessions of user {target_user}"
            elif target_room:
                # 특정 룸에 전송
                await self.sio.emit(event_name, data, room=target_room, namespace=namespace)
                return f"Sent to room {target_room}"
            else:
                # 적절한 타겟이 지정되지 않은 경우
                self.logger.warning(f"emit_message: 타겟이 지정되지 않았습니다. 기본적으로 브로드캐스트합니다.")
                await self.sio.emit(event_name, data, namespace=namespace)
                return "Broadcast (default)"
        
        except Exception as e:
            self.logger.error(f"emit_message 메서드 실행 중 오류 발생: {str(e)}")
            self.logger.error(traceback.format_exc())
            return "Error during message emission"
            
    async def broadcast_cve_update(self, cve_id: str, data: Any, event_type: WSMessageType) -> str:
        """
        CVE 업데이트 정보를 모든 클라이언트에게 브로드캐스트합니다.
        
        Args:
            cve_id: 업데이트된 CVE의 ID
            data: 전송할 데이터
            event_type: WebSocket 메시지 타입 (WSMessageType)
            
        Returns:
            전송 결과 메시지
        """
        try:
            event_name = str(event_type.value)
            self.logger.info(f"CVE 업데이트 정보 브로드캐스트: {cve_id} - {event_name}")
            
            # 모든 클라이언트에게 전송
            await self.sio.emit(event_name, data)
            return f"CVE {cve_id} 업데이트가 브로드캐스트되었습니다."
        except Exception as e:
            self.logger.error(f"broadcast_cve_update 중 오류 발생: {str(e)}")
            import traceback
            self.logger.error(traceback.format_exc())
            return f"CVE {cve_id} 업데이트 브로드캐스트 중 오류: {str(e)}"
    
    async def emit_to_user(self, username, event_name, data, raise_exception=False, **kwargs) -> int:
        """
        특정 사용자에게 메시지를 보내고, 성공적으로 전송된 연결 수를 반환합니다.
        전송 실패 시 raise_exception이 True면 예외를 발생시키고, 아니면 0을 반환합니다.
        
        Args:
            username: 메시지를 보낼 사용자명
            event_name: 이벤트 이름
            data: 전송할 데이터
            raise_exception: 예외 발생 여부
            **kwargs: 추가 파라미터
            
        Returns:
            성공적으로 전송된 연결 수
        """
        try:
            result = await self.emit_message(event_name, data, target_user=username, **kwargs)
            if isinstance(result, str) and result.startswith("Sent to"):
                try: 
                    return int(result.split()[2])
                except: 
                    pass  # 숫자 변환 실패 시 0 반환
            elif raise_exception:
                raise Exception(f"메시지 전송 실패: {result}")
            return 0
        except Exception as e:
            self.logger.error(f"emit_to_user 메서드 실행 중 오류 발생: {str(e)}")
            if raise_exception:
                raise
            return 0

# 싱글톤 인스턴스
socket_manager = SocketManager()

# 하위 호환성을 위한 별칭
socketio_manager = socket_manager

# 의존성 주입을 위한 함수
def get_socket_manager():
    """소켓 매니저 인스턴스를 반환합니다."""
    global socket_manager
    return socket_manager

# UserService 설정 함수
def initialize_socket_manager_with_user_service(user_service: UserService) -> SocketManager:
    """
    SocketManager에 UserService를 설정합니다.
    
    Args:
        user_service: UserService 인스턴스
        
    Returns:
        SocketManager 인스턴스
    """
    global socket_manager
    socket_manager.user_service = user_service
    logger.info("SocketManager에 UserService가 설정되었습니다.")
    return socket_manager



============================================================
File: /home/CVEHub/backend/app/socketio/__init__.py
------------------------------------------------------------
"""
CVEHub 소켓 통신 모듈

Socket.IO를 사용한 실시간 통신 기능을 제공합니다.
"""

# 모델 노출
from .models import (
    WSMessageType,
    SocketSession,
    SocketError,
    SocketMessage,
    SessionCleanupRequest
)

# 저장소 노출
from .repository import (
    get_socket_repository,
    SocketRepository
)

# 서비스 노출
from .service import (
    get_socket_service,
    SocketService
)

# 매니저 노출
from .manager import (
    get_socket_manager,
    initialize_socket_manager_with_user_service,
    SocketManager
)

# 라우터 노출
from .router import router as socket_router

# 버전 정보
__version__ = "1.0.0"

# 주요 함수 및 클래스 정의
__all__ = [
    # 모델
    "WSMessageType",
    "SocketSession",
    "SocketError",
    "SocketMessage",
    "SessionCleanupRequest",
    
    # 저장소
    "get_socket_repository",
    "SocketRepository",
    
    # 서비스
    "get_socket_service",
    "SocketService",
    
    # 매니저
    "get_socket_manager",
    "initialize_socket_manager_with_user_service",
    "SocketManager",
    
    # 라우터
    "socket_router"
]



============================================================
File: /home/CVEHub/backend/app/socketio/repository.py
------------------------------------------------------------
"""
소켓 세션 및 연결 상태 관리 리파지토리

소켓 세션, 사용자 연결, CVE 구독 상태 등의 데이터를 관리합니다.
메모리 기반 저장소를 사용하며, 필요한 경우 Redis와 같은 외부 저장소로 확장 가능합니다.
"""
from typing import Dict, Set, List, Optional, Any, Tuple
import asyncio
import logging
from datetime import datetime
from zoneinfo import ZoneInfo

from .models import SocketSession
from ..core.logging_utils import get_logger

# 로거 설정
logger = get_logger(__name__)


class SocketRepository:
    """소켓 세션 및 연결 상태 관리 리파지토리"""
    
    def __init__(self):
        """리파지토리 초기화"""
        self.logger = logger
        
        # 세션 관련 매핑
        self.sessions: Dict[str, SocketSession] = {}  # sid -> 세션 정보
        self.user_sessions: Dict[str, Set[str]] = {}  # 사용자명 -> sid 집합
        self.session_id_map: Dict[str, Set[str]] = {}  # 세션 ID -> sid 집합
        
        # 구독 관련 매핑
        self.user_subscriptions: Dict[str, Set[str]] = {}  # 사용자명 -> 구독 CVE ID 집합
        self.cve_subscribers: Dict[str, Set[str]] = {}  # CVE ID -> 구독 사용자명 집합
        
        # 락 객체
        self._lock = asyncio.Lock()
    
    async def add_session(self, sid: str, username: Optional[str], session_id: str) -> SocketSession:
        """새 소켓 세션을 추가합니다."""
        async with self._lock:
            # 세션 객체 생성
            session = SocketSession(
                sid=sid,
                username=username,
                session_id=session_id,
                connected_at=datetime.now(ZoneInfo("UTC"))
            )
            
            # 세션 매핑 업데이트
            self.sessions[sid] = session
            
            # 사용자명이 있는 경우 사용자-세션 매핑 업데이트
            if username:
                if username not in self.user_sessions:
                    self.user_sessions[username] = set()
                self.user_sessions[username].add(sid)
            
            # 세션 ID 매핑 업데이트
            if session_id not in self.session_id_map:
                self.session_id_map[session_id] = set()
            self.session_id_map[session_id].add(sid)
            
            self.logger.info(f"세션 추가됨 - SID: {sid}, 사용자명: {username}, 세션 ID: {session_id}")
            return session
    
    async def remove_session(self, sid: str) -> Optional[SocketSession]:
        """소켓 세션을 제거합니다."""
        async with self._lock:
            session = self.sessions.pop(sid, None)
            if not session:
                return None
                
            # 사용자명이 있는 경우 사용자-세션 매핑 업데이트
            if session.username and session.username in self.user_sessions:
                self.user_sessions[session.username].discard(sid)
                # 빈 집합인 경우 키 삭제
                if not self.user_sessions[session.username]:
                    del self.user_sessions[session.username]
            
            # 세션 ID 매핑 업데이트
            if session.session_id in self.session_id_map:
                self.session_id_map[session.session_id].discard(sid)
                # 빈 집합인 경우 키 삭제
                if not self.session_id_map[session.session_id]:
                    del self.session_id_map[session.session_id]
            
            self.logger.info(f"세션 제거됨 - SID: {sid}, 사용자명: {session.username}, 세션 ID: {session.session_id}")
            return session
    
    async def get_session(self, sid: str) -> Optional[SocketSession]:
        """소켓 세션 정보를 조회합니다."""
        return self.sessions.get(sid)
    
    async def get_user_sessions(self, username: str) -> List[SocketSession]:
        """사용자명에 연결된 모든 세션을 조회합니다."""
        if username not in self.user_sessions:
            return []
        
        return [self.sessions[sid] for sid in self.user_sessions[username] if sid in self.sessions]
    
    async def get_session_by_id(self, session_id: str) -> List[SocketSession]:
        """세션 ID에 연결된 모든 세션을 조회합니다."""
        if session_id not in self.session_id_map:
            return []
        
        sessions = []
        for sid in self.session_id_map[session_id]:
            session = self.sessions.get(sid)
            if session:
                sessions.append(session)
        return sessions
    
    async def add_cve_subscription(self, sid: str, cve_id: str) -> bool:
        """세션에 CVE 구독을 추가합니다."""
        async with self._lock:
            session = self.sessions.get(sid)
            if not session:
                return False
                
            # 세션의 구독 목록에 CVE 추가
            session.subscribed_cves.add(cve_id)
            
            # 사용자명이 있는 경우 사용자-구독 매핑 업데이트
            if session.username:
                if session.username not in self.user_subscriptions:
                    self.user_subscriptions[session.username] = set()
                self.user_subscriptions[session.username].add(cve_id)
            
            # CVE-구독자 매핑 업데이트
            if cve_id not in self.cve_subscribers:
                self.cve_subscribers[cve_id] = set()
            if session.username:
                self.cve_subscribers[cve_id].add(session.username)
            
            self.logger.info(f"CVE 구독 추가됨 - SID: {sid}, 사용자명: {session.username}, CVE: {cve_id}")
            return True
    
    async def remove_cve_subscription(self, sid: str, cve_id: str) -> bool:
        """세션에서 CVE 구독을 제거합니다."""
        async with self._lock:
            session = self.sessions.get(sid)
            if not session:
                return False
                
            # 세션의 구독 목록에서 CVE 제거
            session.subscribed_cves.discard(cve_id)
            
            # 사용자명이 있는 경우 다른 세션에서 같은 CVE를 구독 중인지 확인
            if session.username:
                user_still_subscribed = False
                if session.username in self.user_sessions:
                    for other_sid in self.user_sessions[session.username]:
                        if other_sid != sid and self.sessions.get(other_sid) and cve_id in self.sessions[other_sid].subscribed_cves:
                            user_still_subscribed = True
                            break
                
                # 사용자의 모든 세션에서 구독 해제된 경우 사용자-구독 매핑 업데이트
                if not user_still_subscribed:
                    if session.username in self.user_subscriptions:
                        self.user_subscriptions[session.username].discard(cve_id)
                        if not self.user_subscriptions[session.username]:
                            del self.user_subscriptions[session.username]
                    
                    # CVE-구독자 매핑 업데이트
                    if cve_id in self.cve_subscribers:
                        self.cve_subscribers[cve_id].discard(session.username)
                        if not self.cve_subscribers[cve_id]:
                            del self.cve_subscribers[cve_id]
            
            self.logger.info(f"CVE 구독 제거됨 - SID: {sid}, 사용자명: {session.username}, CVE: {cve_id}")
            return True
    
    async def get_cve_subscribers(self, cve_id: str) -> Set[str]:
        """CVE를 구독 중인 사용자명 집합을 조회합니다."""
        return self.cve_subscribers.get(cve_id, set()).copy()
    
    async def get_user_subscriptions(self, username: str) -> Set[str]:
        """사용자가 구독 중인 CVE ID 집합을 조회합니다."""
        return self.user_subscriptions.get(username, set()).copy()
    
    async def clear_user_subscriptions(self, username: str) -> int:
        """사용자의 모든 구독을 정리합니다."""
        async with self._lock:
            if username not in self.user_subscriptions:
                return 0
                
            subscribed_cves = self.user_subscriptions.pop(username, set())
            count = len(subscribed_cves)
            
            # CVE-구독자 매핑 업데이트
            for cve_id in subscribed_cves:
                if cve_id in self.cve_subscribers:
                    self.cve_subscribers[cve_id].discard(username)
                    if not self.cve_subscribers[cve_id]:
                        del self.cve_subscribers[cve_id]
            
            # 사용자의 모든 세션에서 구독 정보 업데이트
            if username in self.user_sessions:
                for sid in self.user_sessions[username]:
                    session = self.sessions.get(sid)
                    if session:
                        session.subscribed_cves.clear()
            
            self.logger.info(f"사용자 구독 전체 정리됨 - 사용자명: {username}, 정리된 CVE 수: {count}")
            return count
    
    async def get_stats(self) -> Dict[str, Any]:
        """소켓 연결 및 구독 통계 정보를 조회합니다."""
        return {
            "active_sessions": len(self.sessions),
            "connected_users": len(self.user_sessions),
            "active_cve_subscriptions": len(self.cve_subscribers),
            "total_user_subscriptions": sum(len(subs) for subs in self.user_subscriptions.values())
        }


# 싱글톤 인스턴스
socket_repository = SocketRepository()

# 의존성 주입을 위한 함수
def get_socket_repository() -> SocketRepository:
    """SocketRepository 인스턴스를 반환합니다."""
    global socket_repository
    return socket_repository



============================================================
File: /home/CVEHub/backend/app/socketio/models.py
------------------------------------------------------------
"""
소켓 모듈의 데이터 모델 정의

WebSocket 메시지 타입, 이벤트 타입, 구독 정보 등 소켓 통신에 필요한 데이터 구조를 정의합니다.
"""
from enum import Enum
from typing import Dict, List, Optional, Set, Any, Union
from pydantic import BaseModel, Field
from datetime import datetime


class WSMessageType(str, Enum):
    """WebSocket 메시지 타입 열거형"""
    CONNECTED = "connected"
    CONNECT_ACK = "connect_ack"
    SESSION_INFO_ACK = "session_info_ack"
    PING = "ping"
    PONG = "pong"
    ERROR = "error"
    NOTIFICATION = "notification"
    NOTIFICATION_READ = "notification_read"
    ALL_NOTIFICATIONS_READ = "all_notifications_read"
    CVE_CREATED = "cve_created"
    CVE_UPDATED = "cve_updated"
    CVE_DELETED = "cve_deleted"
    CRAWLER_UPDATE_PROGRESS = "crawler_update_progress"
    COMMENT_ADDED = "comment_added"
    COMMENT_UPDATED = "comment_updated"
    COMMENT_DELETED = "comment_deleted"
    COMMENT_REACTION_ADDED = "comment_reaction_added"
    COMMENT_REACTION_REMOVED = "comment_reaction_removed"
    COMMENT_COUNT_UPDATE = "comment_count_update"
    SUBSCRIBE_CVE = "subscribe_cve"
    UNSUBSCRIBE_CVE = "unsubscribe_cve"
    SUBSCRIPTION_STATUS = "subscription_status"
    CVE_SUBSCRIBERS_UPDATED = "cve_subscribers_updated"


class SocketSession(BaseModel):
    """소켓 세션 정보 모델"""
    sid: str
    username: Optional[str] = None
    session_id: str
    connected_at: datetime
    subscribed_cves: Set[str] = Field(default_factory=set)
    
    class Config:
        arbitrary_types_allowed = True


class SocketError(BaseModel):
    """소켓 오류 모델"""
    code: str
    message: str
    details: Optional[Dict[str, Any]] = None


class SocketMessage(BaseModel):
    """소켓 메시지 기본 모델"""
    type: WSMessageType
    data: Optional[Any] = None
    timestamp: datetime = Field(default_factory=datetime.now)


class SocketSubscription(BaseModel):
    """소켓 구독 요청/응답 모델"""
    cve_id: str
    success: bool = True
    error: Optional[SocketError] = None


class SocketNotification(BaseModel):
    """소켓 알림 메시지 모델"""
    notification_id: str
    recipient_id: str
    type: str
    content: str
    created_at: datetime
    unread_count: int
    metadata: Optional[Dict[str, Any]] = None


class SocketAuth(BaseModel):
    """소켓 인증 정보 모델"""
    token: str
    user_id: str
    session_id: Optional[str] = None


class SessionCleanupRequest(BaseModel):
    """세션 구독 정리 요청 모델"""
    session_id: str
    user_id: Optional[str] = None



============================================================
File: /home/CVEHub/backend/app/socketio/interfaces.py
------------------------------------------------------------
"""
소켓 모듈의 인터페이스 정의

이 모듈은 순환 참조를 방지하기 위해 소켓 모듈에서 사용되는 다양한 컴포넌트의 
인터페이스(또는 프로토콜)를 정의합니다.
"""
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List, Set, Union, Protocol, runtime_checkable
from datetime import datetime

from .models import WSMessageType, SocketSession, SocketError, SocketSubscription


@runtime_checkable
class SocketServiceInterface(Protocol):
    """Socket 서비스 인터페이스"""
    
    @abstractmethod
    async def handle_event(self, sid: str, event_type: WSMessageType, data: Any) -> Dict[str, Any]:
        """
        Socket.IO 이벤트를 처리합니다.
        
        Args:
            sid: 소켓 ID
            event_type: 이벤트 타입
            data: 이벤트 데이터
            
        Returns:
            처리 결과
        """
        ...
    
    @abstractmethod
    async def handle_subscription(self, sid: str, user_id: Optional[str], cve_id: str, subscribe: bool = True) -> SocketSubscription:
        """
        CVE 구독/구독취소 요청을 처리합니다.
        
        Args:
            sid: 소켓 ID
            user_id: 사용자 ID (옵션)
            cve_id: CVE ID
            subscribe: 구독 여부 (True=구독, False=구독취소)
            
        Returns:
            구독 상태 응답
        """
        ...
    
    @abstractmethod
    async def create_and_deliver_notification(
        self, 
        recipient_id: str, 
        notification_type: str,
        content: str, 
        sender_id: Optional[str] = None,
        cve_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        알림을 생성하고 전송합니다.
        
        Args:
            recipient_id: 수신자 ID
            notification_type: 알림 유형
            content: 알림 내용
            sender_id: 발신자 ID (옵션)
            cve_id: 관련 CVE ID (옵션)
            metadata: 추가 메타데이터 (옵션)
            
        Returns:
            생성된 알림 정보
        """
        ...


@runtime_checkable
class SocketRepositoryInterface(Protocol):
    """Socket 저장소 인터페이스"""
    
    @abstractmethod
    async def get_session(self, sid: str) -> Optional[SocketSession]:
        """
        SID로 세션 정보를 조회합니다.
        
        Args:
            sid: 소켓 ID
            
        Returns:
            세션 정보 또는 None
        """
        ...
    
    @abstractmethod
    async def get_user_sessions(self, user_id: str) -> List[SocketSession]:
        """
        사용자 ID로 모든 세션 정보를 조회합니다.
        
        Args:
            user_id: 사용자 ID
            
        Returns:
            세션 목록
        """
        ...
    
    @abstractmethod
    async def save_session(self, session: SocketSession) -> SocketSession:
        """
        세션 정보를 저장합니다.
        
        Args:
            session: 저장할 세션 정보
            
        Returns:
            저장된 세션 정보
        """
        ...
    
    @abstractmethod
    async def delete_session(self, sid: str) -> bool:
        """
        세션 정보를 삭제합니다.
        
        Args:
            sid: 소켓 ID
            
        Returns:
            삭제 성공 여부
        """
        ...
    
    @abstractmethod
    async def get_cve_subscribers(self, cve_id: str) -> Set[str]:
        """
        CVE 구독자 ID 목록을 조회합니다.
        
        Args:
            cve_id: CVE ID
            
        Returns:
            구독자 ID 목록
        """
        ...


@runtime_checkable
class NotificationServiceInterface(Protocol):
    """알림 서비스 인터페이스"""
    
    @abstractmethod
    async def create_notification(
        self,
        notification_type: Any,  # NotificationType
        recipient_id: str,
        content: str,
        sender_id: Optional[str] = None,
        cve_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ) -> tuple:
        """
        알림을 생성하고 저장합니다.
        
        Args:
            notification_type: 알림 유형
            recipient_id: 수신자 ID
            content: 알림 내용
            sender_id: 발신자 ID (옵션)
            cve_id: 관련 CVE ID (옵션)
            metadata: 추가 메타데이터 (옵션)
            
        Returns:
            생성된 알림과 읽지 않은 알림 수의 튜플
        """
        ...
    
    @abstractmethod
    async def get_unread_count(self, user_id: str) -> int:
        """
        읽지 않은 알림 개수를 조회합니다.
        
        Args:
            user_id: 사용자 ID
            
        Returns:
            읽지 않은 알림 개수
        """
        ...


# 싱글톤 인스턴스의 타입 선언을 위한 함수 타입 정의
def get_socket_service_interface() -> SocketServiceInterface:
    """Socket 서비스 인스턴스를 반환합니다"""
    ...

def get_socket_repository_interface() -> SocketRepositoryInterface:
    """Socket 저장소 인스턴스를 반환합니다"""
    ...

def get_notification_service_interface() -> NotificationServiceInterface:
    """알림 서비스 인스턴스를 반환합니다"""
    ...



============================================================
File: /home/CVEHub/backend/app/socketio/service.py
------------------------------------------------------------
"""
소켓 통신 비즈니스 로직 서비스

알림 전송, 구독 관리, 메시지 처리 등 소켓 통신의 핵심 비즈니스 로직을 제공합니다.
"""
from typing import Dict, List, Set, Optional, Any, Union, Tuple, Type, cast
import asyncio
import json
import traceback
from datetime import datetime
from zoneinfo import ZoneInfo

from .models import WSMessageType, SocketSession, SocketError, SocketMessage
from .repository import get_socket_repository
from .interfaces import SocketRepositoryInterface, NotificationServiceInterface
from ..core.logging_utils import get_logger
from ..auth.models import User
from ..notification.models import Notification, NotificationType
from app.core.dependencies import get_user_service

# 로거 설정
logger = get_logger(__name__)


class SocketService:
    """소켓 통신 비즈니스 로직 서비스"""
    
    def __init__(self, repository=None, notification_service=None):
        """서비스 초기화
        
        Args:
            repository: 소켓 저장소 인터페이스 (선택적)
            notification_service: 알림 서비스 인터페이스 (선택적)
        """
        self.logger = logger
        self.repository = repository or get_socket_repository()
        
        # 알림 서비스는 필요할 때 지연 로딩
        self._notification_service = notification_service
        
        # 이벤트 핸들러 레지스트리
        self._event_handlers = {}
        
        # 기본 이벤트 핸들러 등록
        self._register_default_handlers()
        
    async def _get_subscriber_details(self, subscriber_ids: Set[str]) -> List[Dict[str, Any]]:
        """주어진 구독자 ID 목록에서 구독자 상세 정보를 가져옵니다.
        
        Args:
            subscriber_ids: 구독자 ID 집합
            
        Returns:
            구독자 상세 정보 목록 (사용자 객체 리스트)
        """
        subscribers = []
        
        if not subscriber_ids:
            return subscribers
            
        try:
            user_service = get_user_service()
            
            for username in subscriber_ids:
                if username:  # None이 아닌 경우만 처리
                    try:
                        user = await user_service.get_user_by_username(username)
                        if user:
                            subscribers.append({
                                "id": str(user.id),
                                "username": user.username,
                                "displayName": user.full_name,
                                "profileImage": ""
                            })
                    except Exception as e:
                        self.logger.warning(f"사용자 정보 조회 실패 - 사용자명: {username}, 오류: {str(e)}")
        except Exception as e:
            self.logger.error(f"구독자 상세 정보 조회 중 오류: {str(e)}")
            self.logger.error(traceback.format_exc())
            
        return subscribers
        
    def _register_default_handlers(self):
        """기본 이벤트 핸들러를 등록합니다."""
        # 핑 이벤트 핸들러
        self.register_event_handler(WSMessageType.PING, self._handle_ping)
        
        # 구독 이벤트 핸들러
        self.register_event_handler(WSMessageType.SUBSCRIBE_CVE, self._handle_cve_subscribe)
        self.register_event_handler(WSMessageType.UNSUBSCRIBE_CVE, self._handle_cve_unsubscribe)
    
    def register_event_handler(self, event_type: WSMessageType, handler_func):
        """이벤트 핸들러를 등록합니다."""
        self._event_handlers[event_type] = handler_func
        self.logger.debug(f"이벤트 핸들러 등록됨 - 이벤트: {event_type}")
    
    async def handle_event(self, sid: str, event_type: WSMessageType, data: Any = None) -> Dict[str, Any]:
        """이벤트를 처리합니다."""
        try:
            # 이벤트 핸들러 확인
            handler = self._event_handlers.get(event_type)
            if not handler:
                self.logger.warning(f"등록되지 않은 이벤트 핸들러 - 이벤트: {event_type}")
                return {
                    "success": False,
                    "error": {
                        "code": "UNKNOWN_EVENT",
                        "message": f"Unknown event type: {event_type}"
                    }
                }
            
            # 이벤트 핸들러 호출
            return await handler(sid, data)
        except Exception as e:
            self.logger.error(f"이벤트 처리 중 오류 발생 - 이벤트: {event_type}, 오류: {str(e)}")
            self.logger.error(traceback.format_exc())
            return {
                "success": False,
                "error": {
                    "code": "EVENT_HANDLER_ERROR",
                    "message": str(e)
                }
            }
    
    async def _handle_ping(self, sid: str, data: Any = None) -> Dict[str, Any]:
        """핑 이벤트를 처리합니다."""
        timestamp = data.get("timestamp") if isinstance(data, dict) else None
        return {
            "success": True,
            "type": WSMessageType.PONG,
            "timestamp": timestamp,
            "server_time": datetime.now(ZoneInfo("UTC")).isoformat()
        }
    
    async def _handle_cve_subscribe(self, sid: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """CVE 구독 이벤트를 처리합니다."""
        try:
            if not isinstance(data, dict) or "cve_id" not in data:
                return {
                    "success": False,
                    "error": {
                        "code": "INVALID_REQUEST",
                        "message": "Invalid subscribe request, cve_id is required"
                    }
                }
            
            cve_id = data["cve_id"]
            
            # 세션 확인
            session = await self.repository.get_session(sid)
            if not session:
                return {
                    "success": False,
                    "error": {
                        "code": "SESSION_NOT_FOUND",
                        "message": "Session not found"
                    }
                }
            
            # CVE 구독 추가
            result = await self.repository.add_cve_subscription(sid, cve_id)
            
            # 구독자 정보 한 번만 조회
            subscriber_ids = await self.repository.get_cve_subscribers(cve_id)
            subscribers = await self._get_subscriber_details(subscriber_ids)
            
            # 기존 구독자들에게 구독자 업데이트 알림
            if result and session.username and subscriber_ids:
                await self.broadcast_to_users(
                    event_type=WSMessageType.CVE_SUBSCRIBERS_UPDATED,
                    data={
                        "cve_id": cve_id,
                        "subscriber_count": len(subscriber_ids),
                        "subscribers": subscribers
                    },
                    user_names=subscriber_ids,
                    exclude_user_name=session.username
                )
            
            self.logger.info(f"CVE 구독 완료: {cve_id}, 구독자 수: {len(subscriber_ids)}")
            
            return {
                "success": True,
                "cve_id": cve_id,
                "subscribed": True,
                "username": session.username,
                "subscriber_count": len(subscriber_ids),
                "subscribers": subscribers,
                "type": WSMessageType.SUBSCRIPTION_STATUS,
                "status": "subscribed" if result else "failed"
            }
        except Exception as e:
            self.logger.error(f"CVE 구독 처리 중 오류 발생 - 오류: {str(e)}")
            self.logger.error(traceback.format_exc())
            return {
                "success": False,
                "error": {
                    "code": "SUBSCRIPTION_ERROR",
                    "message": str(e)
                }
            }
    
    async def _handle_cve_unsubscribe(self, sid: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """CVE 구독 해제 이벤트를 처리합니다."""
        try:
            if not isinstance(data, dict) or "cve_id" not in data:
                return {
                    "success": False,
                    "error": {
                        "code": "INVALID_REQUEST",
                        "message": "Invalid unsubscribe request, cve_id is required"
                    }
                }
            
            cve_id = data["cve_id"]
            
            # 세션 확인
            session = await self.repository.get_session(sid)
            if not session:
                return {
                    "success": False,
                    "error": {
                        "code": "SESSION_NOT_FOUND",
                        "message": "Session not found"
                    }
                }
            
            # 기존 구독자 수 확인
            old_subscriber_ids = await self.repository.get_cve_subscribers(cve_id)

            # 세션과 구독 상태 확인
            result = await self.repository.remove_cve_subscription(sid, cve_id)
            
            # 구독자 변경사항 알림
            if result:
                new_subscriber_ids = await self.repository.get_cve_subscribers(cve_id)
                
                # 구독자 상세 정보 가져오기
                new_subscribers = []
                if new_subscriber_ids:
                    try:
                        user_service = get_user_service()
                        
                        for username in new_subscriber_ids:
                            if username:  # None이 아닌 경우만 처리
                                try:
                                    user = await user_service.get_user_by_username(username)
                                    if user:
                                        new_subscribers.append({
                                            "id": str(user.id),
                                            "username": user.username,
                                            "displayName": user.full_name,
                                            "profileImage": ""
                                        })
                                except Exception as e:
                                    self.logger.warning(f"사용자 정보 조회 실패 - 사용자명: {username}, 오류: {str(e)}")
                    except Exception as e:
                        self.logger.error(f"구독자 상세 정보 조회 중 오류: {str(e)}")
                        self.logger.error(traceback.format_exc())
                
                if old_subscriber_ids != new_subscriber_ids:
                    await self.broadcast_to_users(
                        event_type=WSMessageType.CVE_SUBSCRIBERS_UPDATED,
                        data={
                            "cve_id": cve_id,
                            "subscriber_count": len(new_subscriber_ids),
                            "subscribers": new_subscribers
                        },
                        user_names=new_subscriber_ids
                    )
            
            # 구독자 상세 정보 가져오기
            subscriber_ids = await self.repository.get_cve_subscribers(cve_id)
            subscribers = await self._get_subscriber_details(subscriber_ids)
            
            self.logger.info(f"CVE 구독 해제 완료: {cve_id}, 구독자 수: {len(subscriber_ids)}")
            
            return {
                "success": True,
                "cve_id": cve_id,
                "subscribed": False,
                "username": session.username,
                "subscriber_count": len(subscriber_ids),
                "subscribers": subscribers,  # 구독자 상세 정보 추가
                "type": WSMessageType.SUBSCRIPTION_STATUS,
                "status": "unsubscribed" if result else "failed"
            }
        except Exception as e:
            self.logger.error(f"CVE 구독 해제 처리 중 오류 발생 - 오류: {str(e)}")
            self.logger.error(traceback.format_exc())
            return {
                "success": False,
                "error": {
                    "code": "UNSUBSCRIPTION_ERROR",
                    "message": str(e)
                }
            }
    
    async def broadcast_to_users(
        self, 
        event_type: WSMessageType, 
        data: Any, 
        user_names: Set[str],
        exclude_user_name: Optional[str] = None,
        manager = None
    ) -> int:
        """여러 사용자에게 메시지를 브로드캐스트합니다."""
        if not manager:
            from .manager import get_socket_manager
            manager = get_socket_manager()
        
        sent_count = 0
        for user_name in user_names:
            if exclude_user_name and user_name == exclude_user_name:
                continue
            
            sessions = await self.repository.get_user_sessions(user_name)
            for session in sessions:
                try:
                    if await manager.emit(event_type, data, room=session.sid):
                        sent_count += 1
                except Exception as e:
                    self.logger.error(f"브로드캐스트 중 오류 발생 - 사용자: {user_name}, SID: {session.sid}, 오류: {str(e)}")
        
        return sent_count
    
    async def broadcast_to_cve_subscribers(
        self, 
        event_type: WSMessageType, 
        data: Any, 
        cve_id: str,
        exclude_user_name: Optional[str] = None,
        manager = None
    ) -> int:
        """CVE 구독자들에게 메시지를 브로드캐스트합니다."""
        subscribers = await self.repository.get_cve_subscribers(cve_id)
        return await self.broadcast_to_users(
            event_type=event_type,
            data=data,
            user_names=subscribers,
            exclude_user_name=exclude_user_name,
            manager=manager
        )
    
    async def create_and_deliver_notification(
        self, 
        notification_type: NotificationType, 
        recipient_id: str, 
        content: str, 
        sender_id: Optional[str] = None, 
        cve_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
        manager = None
    ) -> Dict[str, Any]:
        """알림을 생성하고 실시간으로 전송합니다."""
        try:
            # 알림 서비스 지연 로딩
            if not self._notification_service:
                from ..notification.service import get_notification_service
                self._notification_service = get_notification_service()
            
            # 알림 생성 및 저장
            notification, unread_count = await self._notification_service.create_notification(
                notification_type=notification_type,
                recipient_id=recipient_id,
                content=content,
                sender_id=sender_id,
                cve_id=cve_id,
                metadata=metadata
            )
            
            # 읽지 않은 알림 수 조회
            unread_count = await self._notification_service.get_unread_count(recipient_id)
            
            # 알림 전송
            if manager is None:
                # 지연 임포트로 순환 참조 방지
                from app.socketio.manager import socketio_manager
                manager = socketio_manager
            
            # 사용자가 온라인 상태인 경우 실시간 알림 전송
            await manager.emit(
                WSMessageType.NOTIFICATION,
                {
                    "notification": notification.dict(),
                    "unreadCount": unread_count
                },
                room=recipient_id
            )
            
            # 전송 성공 시 delivered 상태 업데이트
            notification.delivered = True
            await notification.save()
            
            return {
                "success": True,
                "notification_id": str(notification.id),
                "unread_count": unread_count
            }
        except Exception as e:
            self.logger.error(f"알림 생성 및 전송 중 오류 발생: {str(e)}")
            self.logger.error(traceback.format_exc())
            return {
                "success": False,
                "error": str(e)
            }
    
    async def process_mentions(
        self,
        content: str,
        sender_id: str,
        cve_id: Optional[str] = None,
        comment_id: Optional[str] = None,
        mentioned_usernames: List[str] = None,
        manager = None
    ) -> Dict[str, Any]:
        """댓글 내용에서 멘션을 처리하고 알림을 생성합니다."""
        try:
            # 멘션 추출 (없는 경우)
            if not mentioned_usernames:
                from ..comment.models import Comment
                mentioned_usernames = Comment.extract_mentions(content)
                
            if not mentioned_usernames:
                return {
                    "success": True,
                    "count": 0,
                    "processed_users": []
                }
                
            self.logger.info(f"멘션 처리 시작 - 멘션된 사용자: {mentioned_usernames}")
            
            # 발신자 정보 조회
            sender = await User.find_one({"_id": sender_id})
            if not sender:
                raise ValueError(f"발신자를 찾을 수 없음: {sender_id}")
                
            # 중복 제거 및 사용자명 정규화
            normalized_usernames = []
            for username in mentioned_usernames:
                # @ 기호 제거
                clean_username = username.replace('@', '')
                normalized_usernames.append(clean_username.lower())
                
            # 사용자 조회 - 정규식으로 대소문자 구분 없이 조회
            regex_patterns = [{"username": {"$regex": f"^{username}$", "$options": "i"}} 
                             for username in set(normalized_usernames)]
            users = await User.find({"$or": regex_patterns}).to_list()
            
            # CVE 정보 한 번만 조회 (중복 쿼리 방지)
            cve_info = None
            if cve_id:
                from ..cve.repository import CVERepository
                cve_repository = CVERepository()
                cve_info = await cve_repository.find_by_cve_id_with_projection(
                    cve_id, {"title": 1, "severity": 1}
                )
                
            # 알림 생성 작업 병렬 처리
            tasks = []
            processed_users = []
            
            for user in users:
                # 자기 자신에게는 알림 생성 안함
                if str(user.id) == str(sender_id):
                    continue
                    
                processed_users.append(user.username)
                
                # 알림 메타데이터 준비
                metadata = {
                    "comment_content": content,
                    "sender_username": sender.username
                }
                
                if comment_id:
                    metadata["comment_id"] = comment_id
                    
                if cve_info:
                    metadata["cve_title"] = cve_info.title
                
                # 알림 생성 및 전송 작업 추가
                tasks.append(
                    self.create_and_deliver_notification(
                        notification_type=NotificationType.MENTION,
                        recipient_id=str(user.id),
                        content=f"{sender.username}님이 회원님을 멘션했습니다",
                        sender_id=str(sender_id),
                        cve_id=cve_id,
                        metadata=metadata,
                        manager=manager
                    )
                )
                
            # 병렬 처리 실행
            if tasks:
                results = await asyncio.gather(*tasks, return_exceptions=True)
                
                # 오류 처리
                for i, result in enumerate(results):
                    if isinstance(result, Exception):
                        self.logger.error(f"멘션 알림 생성 중 오류 - 사용자: {processed_users[i]}, 오류: {str(result)}")
                
            return {
                "success": True,
                "count": len(processed_users),
                "processed_users": processed_users
            }
                
        except Exception as e:
            self.logger.error(f"멘션 처리 중 오류 발생: {str(e)}")
            self.logger.error(traceback.format_exc())
            return {
                "success": False,
                "error": str(e),
                "count": 0,
                "processed_users": []
            }
    
    async def handle_session_cleanup(self, session_id: str, username: Optional[str] = None) -> Dict[str, Any]:
        """세션 구독 정리를 처리합니다."""
        try:
            self.logger.info(f"세션 정리 처리 시작 - 세션 ID: {session_id}, 사용자명: {username}")
            
            # 세션 ID로 세션 목록 조회
            sessions = await self.repository.get_session_by_id(session_id)
            if not sessions:
                self.logger.warning(f"정리할 세션을 찾을 수 없음 - 세션 ID: {session_id}")
                return {
                    "success": False,
                    "error": {
                        "code": "SESSION_NOT_FOUND",
                        "message": "Session not found"
                    }
                }
            
            # 사용자명이 지정된 경우 해당 사용자의 세션만 필터링
            if username:
                sessions = [s for s in sessions if s.username == username]
                if not sessions:
                    self.logger.warning(f"정리할 사용자 세션을 찾을 수 없음 - 세션 ID: {session_id}, 사용자명: {username}")
                    return {
                        "success": False,
                        "error": {
                            "code": "USER_SESSION_NOT_FOUND",
                            "message": "User session not found"
                        }
                    }
            
            # 세션별 구독 정리
            cleaned_cves = set()
            for session in sessions:
                # 세션의 구독 정보 복사
                session_cves = session.subscribed_cves.copy()
                
                # 구독 제거
                for cve_id in session_cves:
                    await self.repository.remove_cve_subscription(session.sid, cve_id)
                    cleaned_cves.add(cve_id)
            
            self.logger.info(f"세션 정리 처리 완료 - 세션 ID: {session_id}, 정리된 CVE 수: {len(cleaned_cves)}")
            return {
                "success": True,
                "session_id": session_id,
                "cleaned_cves_count": len(cleaned_cves)
            }
        except Exception as e:
            self.logger.error(f"세션 정리 처리 중 오류 발생: {str(e)}")
            self.logger.error(traceback.format_exc())
            return {
                "success": False,
                "error": {
                    "code": "CLEANUP_ERROR",
                    "message": str(e)
                }
            }


# 싱글톤 인스턴스
socket_service = SocketService()

# 의존성 주입을 위한 함수
def get_socket_service():
    """SocketService 인스턴스를 반환합니다."""
    global socket_service
    return socket_service


# 의존성 설정 함수
def initialize_socket_service(repository=None, notification_service=None):
    """SocketService의 의존성을 설정합니다.
    
    Args:
        repository: 소켓 저장소 인터페이스
        notification_service: 알림 서비스 인터페이스
        
    Returns:
        SocketService 인스턴스
    """
    global socket_service
    
    if repository:
        socket_service.repository = repository
    
    if notification_service:
        socket_service._notification_service = notification_service
    
    logger.info("SocketService 의존성이 설정되었습니다.")
    return socket_service



