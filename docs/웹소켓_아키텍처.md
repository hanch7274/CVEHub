# CVEHub 웹소켓 아키텍처 문서

## 개요

CVEHub 프로젝트는 실시간 데이터 처리를 위해 웹소켓 기반의 통신 시스템을 구현하고 있습니다. 이 문서에서는 현재 구현된 웹소켓 아키텍처의 동작 방식, 백엔드와 프론트엔드의 주요 컴포넌트, 그리고 데이터 흐름에 대해 설명합니다.

## 주요 컴포넌트

현재 웹소켓 아키텍처는 백엔드와 프론트엔드 영역으로 나뉘어져 있으며, 각 영역은 다음과 같은 주요 컴포넌트로 구성됩니다:

## 백엔드 컴포넌트

백엔드의 웹소켓 아키텍처는 모듈화된 구조로 리팩토링되어 관심사 분리(Separation of Concerns) 원칙에 따라 구성되어 있습니다.

### 1. `socketio.models` (models.py)

웹소켓 통신에 사용되는 데이터 모델과 메시지 타입을 정의합니다.

- **역할**:
  - 웹소켓 메시지 타입 정의 (enum)
  - 소켓 세션 정보 모델링
  - 오류 및 응답 형식 정의
  - 세션 정리 요청 모델 정의

- **주요 구성요소**:
  - `WSMessageType`: 웹소켓 메시지 타입 열거형
  - `SocketSession`: 소켓 세션 정보 모델
  - `SocketError`: 소켓 오류 모델
  - `SocketMessage`: 소켓 메시지 모델
  - `SessionCleanupRequest`: 세션 정리 요청 모델

### 2. `socketio.repository` (repository.py)

소켓 세션 및 구독 정보를 관리하는 저장소 클래스를 제공합니다.

- **역할**:
  - 소켓 세션 저장 및 조회
  - 사용자 세션 관리
  - CVE 구독 상태 관리
  - 세션 통계 정보 제공

- **주요 기능**:
  - `add_session()`: 새로운 소켓 세션 추가
  - `get_session()`: 세션 정보 조회
  - `remove_session()`: 세션 제거
  - `add_cve_subscription()`: CVE 구독 추가
  - `remove_cve_subscription()`: CVE 구독 제거
  - `get_cve_subscribers()`: CVE 구독자 목록 조회
  - `get_user_sessions()`: 사용자의 세션 목록 조회

### 3. `socketio.service` (service.py)

웹소켓 통신의 비즈니스 로직을 담당하는 서비스 클래스를 제공합니다.

- **역할**:
  - 웹소켓 이벤트 처리
  - 알림 생성 및 전송
  - 구독 관리 비즈니스 로직
  - 멘션 처리 및 알림 생성

- **주요 기능**:
  - `handle_event()`: 이벤트 처리 라우팅
  - `broadcast_to_users()`: 사용자들에게 메시지 브로드캐스트
  - `broadcast_to_cve_subscribers()`: CVE 구독자에게 메시지 브로드캐스트
  - `create_and_deliver_notification()`: 알림 생성 및 전송
  - `process_mentions()`: 멘션 추출 및 알림 생성
  - `handle_session_cleanup()`: 세션 구독 정리

### 4. `socketio.manager` (manager.py)

Socket.IO 서버를 초기화하고 관리하는 클래스를 제공합니다.

- **역할**:
  - Socket.IO 서버 초기화 및 구성
  - 소켓 연결 및 인증 관리
  - 이벤트 핸들러 등록 및 호출
  - 메시지 직렬화/역직렬화

- **주요 기능**:
  - `_handle_connect()`: 클라이언트 연결 처리
  - `_handle_disconnect()`: 클라이언트 연결 해제 처리
  - `emit()`: 이벤트 발신
  - `_setup_event_handlers()`: 기본 이벤트 핸들러 설정

### 5. `socketio.router` (router.py)

소켓 관련 HTTP 엔드포인트를 제공합니다.

- **역할**:
  - 세션 관리를 위한 REST API 제공
  - 소켓 상태 정보 제공

- **주요 엔드포인트**:
  - `/socket/cleanup_subscriptions`: 세션 구독 정리 API
  - `/socket/status`: 소켓 서버 상태 조회 API

## 프론트엔드 컴포넌트

### 1. `SocketIOWithStoreService` (socketioWithStore.ts)

Socket.IO 클라이언트 라이브러리와 Zustand 상태 관리를 통합한 서비스입니다.

- **역할**: 
  - 소켓 연결 관리 (연결, 재연결, 연결 종료)
  - 이벤트 구독 및 발생
  - 연결 상태 모니터링 및 오류 처리
  - 케이스 변환 (스네이크 케이스 <-> 카멜 케이스)
  - 성능 측정 및 모니터링

- **주요 기능**:
  - `connect()`: 서버에 연결
  - `disconnect()`: 연결 종료
  - `emit()`: 이벤트 발생
  - `on()`: 이벤트 구독
  - `off()`: 이벤트 구독 해제

### 2. `SocketStoreAdapter` (socketStoreAdapter.ts)

Socket.IO 서비스와 Zustand 스토어 간의 어댑터 역할을 하는 클래스입니다.

- **역할**:
  - Socket.IO 서비스의 이벤트와 상태를 Zustand 스토어에 동기화
  - 소켓 인스턴스 등록 및 이벤트 리스너 설정
  - 네트워크 상태 모니터링 및 재연결 관리

- **주요 기능**:
  - `registerSocket()`: 소켓 인스턴스를 스토어에 등록
  - `setupSocketListeners()`: 소켓 이벤트 리스너 설정
  - `handleReconnection()`: 재연결 로직 처리
  - `handleNetworkStatusChange()`: 네트워크 상태 변화 감지

### 3. `useSocketStore` (socketStore.ts)

소켓 상태 관리를 위한 Zustand 스토어입니다.

- **역할**:
  - 소켓 인스턴스 및 연결 상태 저장
  - 이벤트 구독 관리
  - 액션 정의 (상태 변경)

- **주요 상태**:
  - `socket`: 현재 소켓 인스턴스
  - `connected`: 연결 상태
  - `connectionState`: 상세 연결 상태 (CONNECTING, CONNECTED, DISCONNECTED, ERROR)
  - `connectionError`: 연결 오류
  - `eventSubscriptions`: 이벤트 구독 맵

- **주요 액션**:
  - `setSocket`: 소켓 인스턴스 설정
  - `setConnected`: 연결 상태 설정
  - `addEventHandler`: 이벤트 핸들러 추가
  - `removeEventHandler`: 이벤트 핸들러 제거
  - `emitEvent`: 이벤트 발생

### 4. `SocketRxService` (socketRxService.ts)

Socket.IO 이벤트를 RxJS Observable로 변환하는 서비스입니다.

- **역할**:
  - 이벤트 스트림 생성 및 관리
  - 연결 상태 Observable 제공
  - 이벤트 스트림 변환 및 처리

- **주요 기능**:
  - `fromEvent()`: 지정된 이벤트에 대한 Observable 생성
  - `getConnectionState()`: 연결 상태 Observable 반환
  - `teardown()`: 구독 정리

### 5. `useSocketEventListener` (useSocketEventListener.ts)

컴포넌트에서 소켓 이벤트 구독을 단순화하는 훅입니다.

- **역할**:
  - 컴포넌트 수명 주기에 맞게 이벤트 구독 및 해제 관리
  - RxJS 및 기존 방식 모두 지원
  - 이벤트 필터링 및 상태 관리

- **주요 기능**:
  - 이벤트 구독 및 해제
  - 구독 상태 관리
  - 컴포넌트 ID 기반 구독 추적
  - 에러 처리 및 로깅

### 6. `useSocketMigration` (useSocketMigration.ts)

기존 코드에서 새로운 RxJS 기반 구현으로 점진적 마이그레이션을 돕는 훅입니다.

- **역할**:
  - 기존 방식과 새로운 방식 간의 호환성 제공
  - 이벤트 구독 및 발생에 대한 통합 인터페이스 제공
  
- **주요 기능**:
  - `emitToLegacyAndNew()`: 기존 방식과 새로운 방식 모두에 이벤트 발생
  - `addEventListenerWithMigration()`: 이벤트 리스너 추가 (마이그레이션 지원)
  - `removeEventListenerWithMigration()`: 이벤트 리스너 제거 (마이그레이션 지원)

### 7. `useWebSocketWithStore` (useWebSocketWithStore.ts)

Zustand 스토어를 활용한 웹소켓 통신 및 React Query 통합에 특화된 훅입니다.

- **역할**:
  - 특정 이벤트 구독 및 메시지 전송
  - React Query와의 통합을 통한 데이터 캐시 관리
  - 낙관적 업데이트 지원

- **주요 기능**:
  - `sendMessage`: 메시지 전송
  - `sendMessageDebounced`: 디바운스된 메시지 전송
  - `subscribe`: 이벤트 구독
  - 낙관적 업데이트 처리
  - 쿼리 무효화 및 데이터 업데이트

### 8. `useCVEListUpdates` (useCVEListUpdates.ts)

CVE 목록의 실시간 업데이트를 관리하는 특화된 훅입니다.

- **역할**:
  - CVE 관련 웹소켓 이벤트 구독
  - React Query 캐시 업데이트
  - 낙관적 UI 업데이트 처리

- **주요 기능**:
  - CVE 생성, 업데이트, 삭제 이벤트 처리
  - 캐시 데이터 낙관적 업데이트
  - 디바운스된 쿼리 무효화

## 웹소켓 동작 프로세스

### 1. 초기화 및 연결 과정

1. **애플리케이션 시작**:
   - `socketioWithStore` 인스턴스가 초기화됩니다.
   - `socketStore`가 초기화되고 기본 상태가 설정됩니다.
   - `socketRxService`가 초기화되고 연결 상태 Observable이 설정됩니다.

2. **연결 시작**:
   - 사용자 로그인 시, 인증 토큰을 가져옵니다.
   - `socketioWithStore.connect()`가 호출되어 서버에 연결을 시도합니다.
   - 연결 시도 중 `socketStore`의 `connectionState`가 `CONNECTING`으로 설정됩니다.

3. **연결 성공/실패**:
   - 연결 성공: 
     - `socketStore`의 `connected`가 `true`로 설정됩니다.
     - `connectionState`가 `CONNECTED`로 설정됩니다.
     - 연결 성공 이벤트가 발생하고 관련 UI가 업데이트됩니다.
   - 연결 실패:
     - `connectionState`가 `ERROR`로 설정됩니다.
     - 재연결 로직이 시작됩니다.
     - 오류 알림이 표시됩니다.

### 2. 이벤트 구독 과정

1. **컴포넌트 마운트**:
   - 컴포넌트에서 `useSocketEventListener`, `useWebSocketWithStore` 또는 `useCVEListUpdates`와 같은 특화된 훅을 사용합니다.
   - 각 훅은 내부적으로 이벤트 구독을 설정하며, 컴포넌트 ID를 통해 구독을 추적합니다.

2. **이벤트 구독**:
   - RxJS 방식: `socketRxService.fromEvent()`를 통해 Observable 생성 및 구독
   - 기존 방식: `socketIOWithStore.on()`을 통해 이벤트 리스너 등록
   - `socketStore`에 이벤트 구독 정보 저장

3. **컴포넌트 언마운트**:
   - 훅의 `useEffect` 클린업 함수에서 구독 해제 처리
   - RxJS 구독 해제 및 이벤트 리스너 제거
   - 컴포넌트 ID 기반 추적을 통해 메모리 누수 방지

### 3. 이벤트 발생 과정

1. **이벤트 발생 요청**:
   - 컴포넌트에서 `emitToLegacyAndNew()` 또는 각 훅이 제공하는 `sendMessage` 함수 호출
   - 데이터가 필요한 경우 camelCase에서 snake_case로 변환

2. **이벤트 전송**:
   - `socketIOWithStore.emit()`을 통해 서버에 이벤트 전송
   - `socketStore.emitEvent()`를 통해 발생 이벤트 기록

3. **서버 응답 처리**:
   - 서버에서 응답 이벤트 수신
   - 등록된 이벤트 리스너를 통해 응답 처리
   - 필요한 경우 snake_case에서 camelCase로 변환
   - React Query 캐시 업데이트 또는 쿼리 무효화

### 4. React Query 통합 과정

1. **쿼리 키 정의**:
   - `queryKeys.ts`에서 각 데이터 유형에 대한 쿼리 키 구조 정의
   - 컴포넌트별 쿼리 관리를 위한 함수형 쿼리 키 제공

2. **웹소켓 이벤트에 따른 쿼리 무효화**:
   - 웹소켓 이벤트 수신 시 관련 쿼리 무효화
   - 디바운스 또는 쓰로틀을 적용하여 성능 최적화
   - `useCVEListUpdates`와 같은 특화된 훅에서 자동 처리

3. **낙관적 업데이트**:
   - 웹소켓 이벤트 수신 시 `queryClient.setQueryData()`를 사용하여 캐시 직접 업데이트
   - 사용자 액션 즉시 반영하여 UX 향상
   - 백그라운드에서 데이터 재검증 수행

### 5. 연결 상태 관리 과정

1. **연결 상태 모니터링**:
   - 정기적인 핑/퐁을 통한 연결 상태 확인
   - 연결 문제 감지 시 재연결 로직 수행

2. **UI 연결 상태 표시**:
   - Header 컴포넌트에서 연결 상태에 따라 와이파이 아이콘 표시
   - 연결 상태 변경 시 알림 표시

3. **재연결 처리**:
   - 연결 끊김 감지 시 자동 재연결 시도
   - 백오프 전략을 사용하여 무한 재연결 방지
   - 재연결 성공 시 필요한 데이터 다시 가져오기

### 6. 중첩 데이터 구조 처리

1. **데이터 캐싱 변환**:
   - 서버로부터 받은 중첩 데이터 구조를 효율적으로 처리
   - lodash의 `get` 함수를 활용하여 다양한 중첩 레벨의 데이터에 안전하게 접근
   - 여러 가능한 경로를 시도하여 필요한 데이터를 추출

2. **이벤트 데이터 정규화**:
   - 특정 이벤트 타입에 대한 특별 처리 로직 구현
   - 일관된 데이터 형식으로 변환하여 컴포넌트에서 쉽게 사용 가능

## 데이터 흐름 및 아키텍처 다이어그램

### 백엔드 아키텍처 다이어그램

```
+---------------------+      +----------------------+      +-------------------+
|                     |      |                      |      |                   |
|  Socket.IO Router   |----->|   Socket Service     |----->|  Socket Repository|
|  (HTTP Endpoints)   |      | (Business Logic)     |      | (Session Storage) |
|                     |      |                      |      |                   |
+---------------------+      +----------------------+      +-------------------+
                                      ^   |   ^
                                      |   |   |
                                      |   v   |
+---------------------+      +----------------------+      +-------------------+
|                     |      |                      |      |                   |
|   Client Browsers   |<---->|    Socket Manager    |----->|   Models & Types  |
|   (WebSocket)      |      | (Socket.IO Server)    |      |                   |
|                     |      |                      |      |                   |
+---------------------+      +----------------------+      +-------------------+
```

### 데이터 흐름 예시 (백엔드)

1. **연결 흐름**:
   - 클라이언트가 Socket.IO 연결 요청
   - `SocketManager._handle_connect()` 메서드가 호출됨
   - 토큰과 사용자 ID를 기반으로 인증 수행
   - `SocketRepository.add_session()`을 통해 세션 등록
   - 클라이언트에게 연결 결과 응답 (CONNECT_ACK 또는 CONNECTED 이벤트)

2. **구독 흐름**:
   - 클라이언트가 CVE 구독 요청 (subscribe_cve 이벤트)
   - `SocketService.handle_event()`에서 WSMessageType.SUBSCRIBE_CVE 이벤트 처리
   - `SocketService._handle_cve_subscribe()`에서 비즈니스 로직 처리
   - `SocketRepository.add_cve_subscription()`을 통해 구독 정보 저장
   - 구독 결과를 클라이언트에게 응답 (SUBSCRIPTION_STATUS 이벤트)
   - 다른 구독자들에게 구독자 수 업데이트 알림 (CVE_SUBSCRIBERS_UPDATED 이벤트)

3. **알림 흐름**:
   - 댓글 작성 등 알림 트리거 이벤트 발생
   - `SocketService.create_and_deliver_notification()`을 통해 알림 생성
   - 데이터베이스에 알림 저장
   - `SocketManager.emit()`을 통해 수신자에게 알림 전송 (NOTIFICATION 이벤트)
   - 알림 전송 상태 업데이트

4. **멘션 처리 흐름**:
   - 댓글에서 멘션(예: @username) 감지
   - `SocketService.process_mentions()`에서 멘션된 사용자 추출
   - 각 멘션된 사용자에 대해 알림 생성 및 전송 (병렬 처리)
   - 멘션 처리 결과 반환

## 데이터 흐름 최적화

CVEHub 웹소켓 아키텍처는 다음과 같은 최적화 패턴을 적용하고 있습니다:

### 1. 참조(Ref)를 활용한 상태 관리
- 연결 상태, 이벤트 핸들러 등 자주 변경되는 값은 `useRef`로 관리
- 불필요한 리렌더링 방지를 위해 상태 변화 감지 로직과 UI 업데이트 로직 분리

### 2. 이벤트 핸들러 최적화
- 동일한 핸들러의 중복 등록 방지 메커니즘 구현
- 핸들러 제거 시 참조 동일성 보장
- 이벤트 발생 시 불필요한 상태 업데이트 최소화

### 3. useEffect 의존성 최소화
- 의존성 배열을 최소화하여 불필요한 effect 재실행 방지
- 이벤트 구독/해제는 컴포넌트 마운트/언마운트 시점에만 수행
- 상태 업데이트는 실제 변경이 있을 때만 수행 (이전 값과 비교)

### 4. WebSocket + React Query 통합 최적화
- 웹소켓 이벤트에 따른 쿼리 무효화 중앙화
- 낙관적 UI 업데이트 패턴 적용
- 로컬 업데이트 콜백 활용

### 5. 데이터 구조 처리 최적화
- lodash 라이브러리를 활용한 중첩 데이터 구조의 효율적인 처리
- 다양한 데이터 경로에 대한 접근 시도로 더 강건한 데이터 처리
- 사전 정의된 데이터 타입에 대한 변환 로직 적용

### 6. 백엔드 메모리 최적화
- 메모리 내 세션 저장소 사용으로 빠른 조회 및 응답 시간 확보
- 인메모리 데이터 구조를 통한 효율적인 구독 관리
- 중복 작업 방지를 위한 비즈니스 로직 캐싱

## 개선된 아키텍처의 장점

### 프론트엔드 영역

1. **중앙화된 연결 관리**: 
   - 모든 웹소켓 관련 로직이 전용 서비스로 중앙화되어 일관된 관리 가능
   - 컴포넌트는 UI 렌더링에만 집중 가능

2. **상태 관리 분리**: 
   - Zustand 스토어를 통한 효율적인 소켓 상태 관리
   - 상태 변경 시 필요한 컴포넌트만 리렌더링

3. **선언적 이벤트 처리**: 
   - RxJS를 활용한 선언적 이벤트 스트림 처리
   - 복잡한 이벤트 변환, 필터링, 결합 가능

4. **점진적 마이그레이션**: 
   - 기존 코드와 새로운 코드 간의 호환성 제공
   - 리팩토링 위험 최소화

5. **실시간 연결 상태 피드백**: 
   - 연결 상태를 와이파이 아이콘으로 직관적 표시
   - 연결 문제 발생 시 사용자에게 즉시 피드백 제공

6. **데이터 일관성 보장**:
   - 중첩된 데이터 구조를 일관되게 처리
   - 다양한 API 응답 형식에 대응 가능

### 백엔드 영역

1. **모듈화된 아키텍처**: 
   - 관심사 분리 원칙에 따른 명확한 책임 분리
   - 각 컴포넌트가 단일 책임만 갖도록 설계
   - 코드 유지보수 및 확장성 향상

2. **DI(의존성 주입) 패턴 적용**: 
   - 싱글톤 인스턴스와 게터 함수를 통한 의존성 주입
   - 컴포넌트 간 느슨한 결합 유지
   - 테스트 용이성 향상

3. **비동기 처리 최적화**: 
   - 비동기 병렬 처리로 성능 향상 (asyncio)
   - 이벤트 핸들러의 비차단(non-blocking) 구현

4. **강화된 오류 처리**: 
   - 세분화된 예외 처리 및 로깅
   - 각 계층에서의 적절한 오류 전파 방식
   - 클라이언트에 적합한 오류 메시지 제공

5. **세션 관리 개선**:
   - 메모리 기반 세션 저장소를 통한 빠른 응답성
   - 사용자 별 여러 장치 세션 지원
   - 고아 세션 정리 메커니즘 구현

## 결론

CVEHub의 웹소켓 아키텍처는 프론트엔드에서는 Zustand 스토어와 RxJS 기반 이벤트 처리를, 백엔드에서는 모듈화된 관심사 분리 패턴을 중심으로 발전했습니다. 이 현대적인 아키텍처는 코드의 유지보수성, 성능, 그리고 사용자 경험을 크게 향상시켰습니다. 특히 실시간 데이터 처리와 연결 상태 관리 측면에서 더 강력하고 효율적인 구현을 제공합니다.

백엔드에서는 단일 책임 원칙(SRP)에 맞춰 코드를 모듈화하여 각 컴포넌트가 명확한 역할을 수행하도록 했으며, 의존성 주입 패턴을 통해 컴포넌트 간의 느슨한 결합을 유지하면서도 효율적인 협력이 가능하게 되었습니다. 프론트엔드에서는 Zustand와 RxJS의 강력한 기능을 활용하여 선언적이고 반응형인 UI 업데이트를 구현했습니다.

각 컴포넌트가 자신의 역할에만 집중하면서도 전체 시스템은 일관된 방식으로 동작하는 이벤트 기반 아키텍처를 통해 확장성과 유연성이 뛰어난 실시간 애플리케이션을 구현할 수 있게 되었습니다. 또한 lodash나 asyncio와 같은 검증된 라이브러리를 활용하여 복잡한 데이터 구조와 비동기 처리를 효율적으로 수행할 수 있게 되었습니다.

이번 리팩토링을 통해 백엔드 코드는 더욱 모듈화되고, 가독성이 향상되었으며, 향후 확장이나 유지보수가 용이해졌습니다. 프론트엔드와 백엔드 간의 일관된 메시지 타입 정의를 통해 안정적인 통신 프로토콜이 보장되며, 개발자가 시스템의 특정 부분을 수정하거나 확장할 때 다른 부분에 미치는 영향을 최소화할 수 있게 되었습니다.
