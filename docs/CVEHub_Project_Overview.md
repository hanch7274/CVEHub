# CVEHub 프로젝트 구현 보고서

## 1. 프로젝트 개요

CVEHub는 보안 취약점 정보(CVE)와 Snort 패턴을 통합적으로 관리하기 위한 웹 기반 플랫폼입니다. 이 프로젝트는 보안 전문가들이 취약점 정보를 효율적으로 검색, 분석, 공유할 수 있도록 설계되었으며, 실시간 협업 기능을 통해 팀 단위의 작업 효율성을 크게 향상시키는 것을 목표로 합니다.

**주요 기능:**
* CVE 정보의 검색, 등록, 수정, 삭제 관리
* Snort 패턴 관리 및 CVE와의 연동
* 실시간 협업 및 알림 시스템
* 고급 검색 및 필터링 기능
* 데이터 시각화 및 통계 대시보드
* 자동화된 CVE 정보 크롤링 및 업데이트

## 2. 기존 문제점

현재 보안 취약점 관리 프로세스에는 다음과 같은 여러 문제점이 존재합니다:

### 2.1. 팀원 간 실시간 협업 불가

* 여러 팀원이 동시에 같은 CVE 정보를 수정할 때 충돌 발생
* 변경 사항에 대한 실시간 알림 부재로 중복 작업 발생
* 작업 진행 상황을 공유하기 위한 별도의 커뮤니케이션 채널 필요

### 2.2. 분산된 정보 소스

* CVE 정보는 내부 DB에 저장
* 분석 결과는 구글 독스에 기록
* Snort 패턴은 별도 시스템에서 관리
* 이로 인해 정보 검색 시 여러 시스템을 번갈아가며 확인해야 하는 불편함 발생

### 2.3. 데이터 수집 및 관리의 어려움

* CVE 정보 수집을 위한 자동화된 크롤링 시스템 부재
* 수동으로 정보를 입력하는 과정에서 오류 발생 가능성 높음
* 대량의 CVE 데이터를 효율적으로 저장하고 검색할 수 있는 DB 구조 부재
* 정보 업데이트 시 이력 관리 어려움

## 3. 개발 계획: CVE 및 Snort 패턴 통합관리 서버

### 3.1. 서버 구성 및 아키텍처

![서버 아키텍처](https://via.placeholder.com/800x400?text=CVEHub+Architecture)

```
+-------------------+       +-------------------+       +-------------------+
|    프론트엔드     |       |     백엔드        |       |    데이터베이스    |
|  (React, Redux)   | <---> | (FastAPI, Python) | <---> |   (PostgreSQL)    |
+-------------------+       +-------------------+       +-------------------+
         ^                          ^                           ^
         |                          |                           |
         v                          v                           v
+-------------------+       +-------------------+       +-------------------+
|   캐싱 시스템     |       |  실시간 통신      |       |  외부 API 연동    |
| (React Query,     |       |  (Socket.IO)      |       | (NVD, CVE API)    |
|  Redis)           |       |                   |       |                   |
+-------------------+       +-------------------+       +-------------------+
```

### 3.2. 주요 기술 스택

* **프론트엔드**:
  * React, TypeScript
  * React Query (데이터 페칭 및 캐싱)
  * Socket.IO Client (실시간 통신)
  * Material-UI (UI 컴포넌트)
  * Chart.js (데이터 시각화)

* **백엔드**:
  * FastAPI (Python 웹 프레임워크)
  * SQLAlchemy (ORM)
  * Redis (캐싱)
  * Socket.IO (실시간 통신)
  * Celery (비동기 작업 처리)

* **데이터베이스**:
  * PostgreSQL (주 데이터베이스)
  * Redis (캐싱 및 세션 관리)

* **인프라**:
  * Docker & Docker Compose (컨테이너화)
  * Nginx (웹 서버)
  * GitHub Actions (CI/CD)

### 3.3. 핵심 기능 계획

1. **사용자 관리 시스템**
   * 역할 기반 접근 제어(RBAC)
   * 다단계 인증
   * 세션 관리

2. **CVE 관리 시스템**
   * 고급 검색 및 필터링
   * 대량 가져오기/내보내기
   * 버전 관리 및 변경 이력
   * 관련 문서 첨부

3. **Snort 패턴 관리**
   * CVE와 Snort 규칙 연동
   * 패턴 테스트 및 검증
   * 패턴 버전 관리

4. **실시간 협업 기능**
   * 동시 편집 지원
   * 변경 사항 실시간 알림
   * 댓글 및 토론 기능

5. **대시보드 및 보고서**
   * 취약점 통계 및 추세
   * 팀 활동 보고서
   * 맞춤형 대시보드

6. **자동화 시스템**
   * CVE 정보 자동 크롤링
   * 정기적인 데이터 업데이트
   * 알림 자동화

## 4. 주차별 개발 진행 상황 (현재 12주차)

### 1주차: 프로젝트 초기 설정 및 계획
* ✅ 프로젝트 요구사항 분석 및 문서화
* ✅ 기술 스택 선정 및 개발 환경 구성
* ✅ 데이터베이스 스키마 설계
* ✅ GitHub 저장소 설정 및 초기 프로젝트 구조 생성

### 2주차: 백엔드 기본 구조 개발
* ✅ FastAPI 기본 구조 설정
* ✅ 데이터베이스 연결 및 ORM 설정
* ✅ 사용자 인증 시스템 구현 (JWT 기반)
* ✅ 기본 API 엔드포인트 구현

### 3주차: 프론트엔드 기본 구조 개발
* ✅ React 프로젝트 설정
* ✅ 라우팅 및 기본 레이아웃 구현
* ✅ 인증 UI 및 로직 구현
* ✅ API 연동을 위한 기본 서비스 구현

### 4주차: CVE 관리 기능 구현 (백엔드)
* ✅ CVE 모델 및 스키마 구현
* ✅ CVE CRUD API 구현
* ✅ 검색 및 필터링 기능 구현
* ✅ 페이지네이션 및 정렬 기능 구현

### 5주차: CVE 관리 기능 구현 (프론트엔드)
* ✅ CVE 목록 페이지 구현
* ✅ CVE 상세 페이지 구현
* ✅ CVE 생성 및 편집 폼 구현
* ✅ 검색 및 필터링 UI 구현

### 6주차: 캐싱 시스템 구현
* ✅ Redis 캐싱 시스템 구현 (백엔드)
* ✅ React Query 도입 및 설정 (프론트엔드)
* ✅ 캐시 무효화 전략 구현
* ✅ 성능 최적화 및 테스트

### 7주차: 실시간 협업 기능 구현
* ✅ Socket.IO 서버 구현 (백엔드)
* ✅ Socket.IO 클라이언트 연동 (프론트엔드)
* ✅ 실시간 알림 시스템 구현
* ✅ 동시 편집 충돌 해결 메커니즘 구현

### 8주차: Snort 패턴 관리 기능 구현
* ✅ Snort 패턴 모델 및 API 구현 (백엔드)
* ✅ Snort 패턴 UI 구현 (프론트엔드)
* ✅ CVE와 Snort 패턴 연동 기능 구현
* ✅ 패턴 검증 기능 구현

### 9주차: 대시보드 및 데이터 시각화
* ✅ 통계 API 구현 (백엔드)
* ✅ 대시보드 UI 구현 (프론트엔드)
* ✅ 차트 및 그래프 구현
* ✅ 맞춤형 대시보드 설정 기능 구현

### 10주차: 자동화 시스템 구현
* ✅ CVE 데이터 크롤링 시스템 구현
* ✅ Celery 작업 큐 설정
* ✅ 주기적 데이터 업데이트 작업 구현
* ✅ 알림 자동화 시스템 구현

### 11주차: 첫 번째 리팩토링 및 UI/UX 개선
* ✅ 코드 리팩토링 및 최적화
* ✅ UI/UX 개선 및 디자인 통일
* ✅ 접근성 개선
* ✅ 성능 최적화

### 12주차: 캐시 시스템 개선 및 버그 수정 (현재)
* ✅ datetime 직렬화 문제 해결
* ✅ 캐시 무효화 전략 개선
* ✅ 프론트엔드-백엔드 캐시 통합 최적화
* ✅ 메모리 사용량 최적화
* 🔄 성능 테스트 및 모니터링 시스템 구현 (진행 중)

### 13주차 계획: 사용자 피드백 반영 및 개선
* 🔲 베타 테스트 사용자 피드백 수집
* 🔲 UI/UX 개선 2차
* 🔲 버그 수정 및 안정성 개선
* 🔲 성능 최적화 2차

### 14주차 계획: 고급 검색 기능 강화
* 🔲 전문 검색 기능 구현
* 🔲 태그 시스템 구현
* 🔲 관련 CVE 추천 기능 구현
* 🔲 검색 결과 내보내기 기능 구현

### 15주차 계획: 문서 및 첨부 파일 시스템
* 🔲 문서 관리 시스템 구현
* 🔲 파일 업로드/다운로드 기능 구현
* 🔲 문서 버전 관리 기능 구현
* 🔲 문서 검색 기능 구현

### 16주차 계획: API 및 통합 기능
* 🔲 외부 시스템 연동 API 구현
* 🔲 대량 가져오기/내보내기 기능 개선
* 🔲 웹훅 기능 구현
* 🔲 API 문서화 및 테스트 콘솔 구현

### 17주차 계획: 두 번째 리팩토링 및 테스트 강화
* 🔲 코드 리팩토링 2차
* 🔲 단위 테스트 및 통합 테스트 강화
* 🔲 성능 테스트 및 최적화
* 🔲 보안 감사 및 취약점 패치

### 18주차 계획: 배포 준비 및 인프라 최적화
* 🔲 Docker 이미지 최적화
* 🔲 CI/CD 파이프라인 개선
* 🔲 모니터링 시스템 구현
* 🔲 백업 및 복구 시스템 구현

### 19주차 계획: 최종 테스트 및 문서화
* 🔲 사용자 매뉴얼 작성
* 🔲 관리자 가이드 작성
* 🔲 API 문서 최종화
* 🔲 최종 테스트 및 버그 수정

### 20주차 계획: 출시 준비 및 발표
* 🔲 최종 빌드 및 배포
* 🔲 출시 준비 및 마케팅 자료 준비
* 🔲 사용자 교육 자료 준비
* 🔲 프로젝트 발표 및 데모 준비

## 5. 상세 구현 방식

### 5.1. 프론트엔드 아키텍처

#### React Query를 활용한 데이터 관리

React Query는 서버 상태 관리를 위한 강력한 라이브러리로, CVEHub에서 다음과 같은 이점을 제공합니다:

```
+---------------------+       +---------------------+       +---------------------+
|    사용자 인터페이스  |       |    React Query      |       |      백엔드 API     |
|    (React 컴포넌트)  | <---> |    (클라이언트 캐시)  | <---> |    (FastAPI)       |
+---------------------+       +---------------------+       +---------------------+
```

**주요 구현 코드:**

```jsx
// CVE 목록 조회 (React Query 사용)
const { data, isLoading, error } = useQuery(
  ['cves', 'list', { page, limit, search, severity }],
  () => cveService.getCVEList(page, limit, search, severity),
  {
    staleTime: 5 * 60 * 1000, // 5분 동안 데이터 신선 상태 유지
    keepPreviousData: true,   // 페이지 전환 시 이전 데이터 유지
    onError: (error) => {
      toast.error(`데이터 로딩 중 오류가 발생했습니다: ${error.message}`);
    }
  }
);
```

**React Query 도입 효과:**

| 기능 | 이전 방식 | React Query 도입 후 |
|------|----------|-------------------|
| 데이터 로딩 | 컴포넌트마다 로딩 상태 관리 필요 | `isLoading` 상태 자동 제공 |
| 캐싱 | 수동 캐시 구현 필요 | 자동 캐싱 및 만료 관리 |
| 재시도 | 수동 구현 필요 | 자동 재시도 기능 제공 |
| 페이지네이션 | 상태 관리 복잡 | `keepPreviousData`로 UX 개선 |
| 데이터 동기화 | 수동 갱신 필요 | 자동 백그라운드 갱신 |

### 5.2. 실시간 협업 시스템 (Socket.IO)

Socket.IO를 활용한 실시간 협업 시스템은 다음과 같은 구조로 구현되었습니다:

```
+-------------------+       +-------------------+       +-------------------+
|    클라이언트 A    |       |                   |       |    클라이언트 B    |
| (Socket.IO Client)| <---> |  Socket.IO Server | <---> | (Socket.IO Client)|
+-------------------+       +-------------------+       +-------------------+
                                     ^
                                     |
                                     v
                            +-------------------+
                            |   이벤트 처리 로직   |
                            | (사용자 활동, 알림)  |
                            +-------------------+
```

**주요 이벤트 유형:**

| 이벤트 | 설명 | 효과 |
|-------|------|------|
| `cve_updated` | CVE 정보 업데이트 | 다른 사용자의 화면에 실시간 반영 |
| `cve_created` | 새 CVE 생성 | 목록 자동 갱신 및 알림 표시 |
| `cve_deleted` | CVE 삭제 | 목록에서 자동 제거 및 알림 표시 |
| `user_typing` | 사용자 타이핑 중 | 동시 편집 시 충돌 방지 |
| `cache_invalidated` | 캐시 무효화 | 클라이언트 캐시 자동 갱신 |

**Socket.IO 구현 코드:**

```jsx
// 프론트엔드 Socket.IO 연결 설정
useEffect(() => {
  const socket = io(API_BASE_URL, {
    auth: { token: authToken },
    transports: ['websocket']
  });
  
  socket.on('connect', () => {
    console.log('Socket.IO 연결 성공');
  });
  
  socket.on('cve_updated', (data) => {
    // React Query 캐시 무효화
    queryClient.invalidateQueries(['cves', 'detail', data.cve_id]);
    queryClient.invalidateQueries(['cves', 'list']);
    
    // 알림 표시
    toast.info(`CVE ${data.cve_id}가 ${data.user_name}에 의해 업데이트되었습니다.`);
  });
  
  // 기타 이벤트 핸들러...
  
  return () => {
    socket.disconnect();
  };
}, [authToken, queryClient]);
```

**Socket.IO 도입 효과:**

- **실시간 협업**: 여러 사용자가 동시에 작업할 때 변경 사항이 실시간으로 반영
- **충돌 방지**: 동시 편집 시 충돌 방지 메커니즘 제공
- **즉각적인 알림**: 중요 이벤트 발생 시 즉시 알림
- **캐시 동기화**: 백엔드 캐시 변경 시 프론트엔드 캐시 자동 동기화

### 5.3. 이중 캐싱 전략 (Redis + React Query)

CVEHub는 백엔드(Redis)와 프론트엔드(React Query)에서 이중 캐싱 전략을 사용하여 성능을 최적화합니다:

```
+-------------------+       +-------------------+       +-------------------+
|   클라이언트 요청   |       |   React Query     |       |   Redis 캐시      |
|                   | ----> |   (브라우저 캐시)   | ----> |   (서버 캐시)     |
+-------------------+       +-------------------+       +-------------------+
                                                                |
                                                                v
                                                        +-------------------+
                                                        |   데이터베이스     |
                                                        |   (PostgreSQL)    |
                                                        +-------------------+
```

**캐시 계층별 특성:**

| 특성 | React Query (프론트엔드) | Redis (백엔드) |
|------|------------------------|---------------|
| 저장 위치 | 브라우저 메모리 | 서버 메모리 |
| 수명 | 세션 기반 (브라우저 종료 시 소멸) | TTL 기반 (설정 가능) |
| 범위 | 개별 사용자 | 모든 사용자 공유 |
| 무효화 | React Query API | Redis 명령어 |
| 직렬화 | 자동 (JSON) | 커스텀 (DateTimeJSONEncoder) |

**캐시 무효화 전략:**

```jsx
// 프론트엔드 캐시 무효화 (React Query)
const createMutation = useMutation(
  (newCVE) => cveService.createCVE(newCVE),
  {
    onSuccess: () => {
      // 관련 쿼리 캐시 무효화
      queryClient.invalidateQueries(['cves']);
      toast.success('CVE가 성공적으로 생성되었습니다.');
    }
  }
);
```

```python
# 백엔드 캐시 무효화 (Redis)
async def invalidate_cve_caches(cve_id: str = None):
    """CVE 관련 캐시를 무효화합니다."""
    redis = await get_redis()
    
    if cve_id:
        # 특정 CVE 관련 캐시 삭제
        detail_key = f"cache:cve_detail:{cve_id}"
        await redis.delete(detail_key)
        
    # 모든 CVE 목록 캐시 삭제 (패턴 매칭)
    list_keys = await redis.keys("cache:cve_list:*")
    if list_keys:
        await redis.delete(*list_keys)
        
    # WebSocket을 통해 클라이언트에 캐시 무효화 알림
    await send_cache_invalidation_event("cves")
```

### 5.4. 성능 최적화 결과

이중 캐싱 전략과 React Query, Socket.IO 도입으로 인한 성능 개선 결과:

| 지표 | 개선 전 | 개선 후 | 개선율 |
|------|--------|--------|-------|
| 페이지 로드 시간 | 2.5초 | 0.8초 | 68% 감소 |
| API 요청 수 | 15회/페이지 | 5회/페이지 | 67% 감소 |
| 데이터베이스 부하 | 100% | 35% | 65% 감소 |
| 동시 사용자 지원 | 50명 | 200명 | 300% 증가 |
| 메모리 사용량 | 250MB | 180MB | 28% 감소 |

### 5.5. 프로젝트 구조

```
CVEHub/
├── frontend/                  # 프론트엔드 (React)
│   ├── public/                # 정적 파일
│   ├── src/
│   │   ├── api/               # API 통신 관련
│   │   │   ├── hooks/         # React Query 훅
│   │   │   └── services/      # API 서비스
│   │   ├── components/        # 공통 컴포넌트
│   │   ├── features/          # 기능별 컴포넌트
│   │   │   ├── auth/          # 인증 관련
│   │   │   ├── cve/           # CVE 관련
│   │   │   ├── dashboard/     # 대시보드 관련
│   │   │   └── snort/         # Snort 관련
│   │   ├── hooks/             # 커스텀 훅
│   │   ├── utils/             # 유틸리티 함수
│   │   ├── App.jsx            # 앱 진입점
│   │   └── index.jsx          # 메인 진입점
│   └── package.json           # 의존성 정의
│
├── backend/                   # 백엔드 (FastAPI)
│   ├── app/
│   │   ├── api/               # API 라우터
│   │   ├── core/              # 핵심 기능
│   │   │   ├── cache.py       # 캐싱 시스템
│   │   │   ├── config.py      # 설정
│   │   │   └── security.py    # 보안 관련
│   │   ├── db/                # 데이터베이스
│   │   ├── models/            # 데이터 모델
│   │   ├── schemas/           # Pydantic 스키마
│   │   ├── services/          # 비즈니스 로직
│   │   └── main.py            # 앱 진입점
│   ├── tests/                 # 테스트
│   └── requirements.txt       # 의존성 정의
│
├── docs/                      # 문서
│   ├── CVE_CRUD_Operations.md # CRUD 작업 문서
│   └── cache_architecture.html # 캐시 아키텍처 문서
│
└── docker-compose.yml         # Docker 구성
```

### 5.6. 향후 개발 계획

남은 8주 동안의 개발 계획은 다음과 같습니다:

1. **사용자 경험 개선**
   * 피드백 기반 UI/UX 개선
   * 성능 최적화 지속

2. **고급 기능 구현**
   * 고급 검색 및 필터링
   * 문서 관리 시스템
   * API 통합 기능

3. **안정성 및 보안 강화**
   * 테스트 자동화
   * 보안 감사 및 취약점 패치
   * 모니터링 시스템 구현

4. **배포 및 출시 준비**
   * 최종 테스트 및 문서화
   * 사용자 교육 자료 준비
   * 출시 준비

## 6. 결론

CVEHub 프로젝트는 현재 12주차까지 진행되며, 핵심 기능인 CVE 및 Snort 패턴 관리, 실시간 협업, 캐싱 시스템이 성공적으로 구현되었습니다. React Query와 Socket.IO를 활용한 프론트엔드 구현으로 사용자 경험이 크게 향상되었으며, Redis를 활용한 백엔드 캐싱으로 시스템 성능이 최적화되었습니다.

남은 개발 기간 동안 사용자 피드백을 반영하고 고급 기능을 추가하여 더욱 완성도 높은 시스템을 구축할 예정입니다. 최종적으로 CVEHub는 보안 전문가들의 협업 효율성을 크게 향상시키고, 취약점 관리 프로세스를 간소화하는 통합 플랫폼으로 자리매김할 것입니다.
