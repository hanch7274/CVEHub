<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVEHub 캐시 아키텍처</title>
    <style>
        body {
            font-family: 'Noto Sans KR', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        
        h1, h2, h3, h4 {
            color: #333;
            margin-top: 1.5em;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        .container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 25px;
            margin-bottom: 30px;
        }
        
        .architecture-overview {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .frontend-cache, .backend-cache {
            width: 48%;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .frontend-cache {
            background-color: #e3f2fd;
            border: 1px solid #bbdefb;
        }
        
        .backend-cache {
            background-color: #ffebee;
            border: 1px solid #ffcdd2;
        }
        
        .cache-item {
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .data-flow {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
            text-align: center;
        }
        
        .flow-item {
            width: 30%;
            padding: 10px;
            border-radius: 5px;
        }
        
        .flow-arrow {
            font-size: 24px;
            margin-top: 20px;
            color: #888;
        }
        
        .code-block {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow-x: auto;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        
        .operation-container {
            margin-top: 30px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .operation-title {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ddd;
        }
        
        .read-operation { color: #2e7d32; }
        .create-operation { color: #1565c0; }
        .update-operation { color: #f57c00; }
        .delete-operation { color: #d32f2f; }
        
        .step-container {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 1px 5px rgba(0,0,0,0.1);
        }
        
        .step-title {
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        
        .feature-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .feature-item {
            width: 48%;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .feature-title {
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        
        .error-box {
            background-color: #ffebee;
            padding: 10px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #d32f2f;
        }
        
        @media (max-width: 768px) {
            .frontend-cache, .backend-cache, .feature-item {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>CVEHub 캐시 아키텍처</h1>
    
    <div class="container">
        <h2>캐시 아키텍처 개요</h2>
        <p>CVEHub 시스템에서는 프론트엔드의 React Query와 백엔드의 Redis를 활용한 이중 캐싱 전략을 사용하고 있습니다. 이를 통해 데이터베이스 부하를 줄이고, 사용자 경험을 향상시킵니다.</p>
        
        <div class="architecture-overview">
            <!-- 프론트엔드 섹션 -->
            <div class="frontend-cache">
                <h3 style="color: #1565c0; text-align: center;">프론트엔드 (React Query)</h3>
                <div class="cache-item">
                    <strong>캐시 키:</strong> ['cves', 'list', {page, limit, search}]
                </div>
                <div class="cache-item">
                    <strong>캐시 무효화:</strong> queryClient.invalidateQueries(['cves'])
                </div>
                <div class="cache-item">
                    <strong>스토리지:</strong> 메모리 (브라우저 세션 동안 유지)
                </div>
                <div class="cache-item">
                    <strong>갱신 전략:</strong> staleTime, cacheTime 기반 자동 갱신
                </div>
            </div>
            
            <!-- 백엔드 섹션 -->
            <div class="backend-cache">
                <h3 style="color: #c62828; text-align: center;">백엔드 (Redis)</h3>
                <div class="cache-item">
                    <strong>캐시 키:</strong> cache:cve_list:limit=10&page=1&search=
                </div>
                <div class="cache-item">
                    <strong>캐시 무효화:</strong> redis.delete(key) 및 WebSocket 알림
                </div>
                <div class="cache-item">
                    <strong>스토리지:</strong> Redis 서버 (영구적, TTL 기반)
                </div>
                <div class="cache-item">
                    <strong>직렬화:</strong> JSON (datetime → ISO 문자열)
                </div>
            </div>
        </div>
        
        <!-- 통신 흐름 -->
        <h3>데이터 흐름</h3>
        <div class="data-flow">
            <div class="flow-item" style="background-color: #e8f5e9;">
                사용자 요청
                <div class="flow-arrow">↓</div>
            </div>
            <div class="flow-item" style="background-color: #e3f2fd;">
                React Query 캐시
                <div class="flow-arrow">↓</div>
            </div>
            <div class="flow-item" style="background-color: #ffebee;">
                Redis 캐시
                <div class="flow-arrow">↓</div>
            </div>
        </div>
        <div style="text-align: center;">
            <div style="background-color: #f5f5f5; padding: 10px; border-radius: 5px; display: inline-block; min-width: 200px;">데이터베이스</div>
        </div>
    </div>
    
    <!-- READ 작업 -->
    <div class="operation-container">
        <h3 class="operation-title read-operation">1. READ (조회) 작업</h3>
        
        <div class="step-container">
            <h4 class="step-title" style="color: #1565c0;">프론트엔드 요청 (React Query)</h4>
            <div class="code-block">
const { data, isLoading } = useQuery(['cves', 'list', { page, limit, search }], 
  () => cveService.getCVEList(page, limit, search),
  { staleTime: 5 * 60 * 1000 } // 5분
);
            </div>
            <ol>
                <li>React Query는 먼저 내부 캐시에서 <code>['cves', 'list', { page, limit, search }]</code> 키로 데이터를 찾습니다.</li>
                <li>캐시된 데이터가 있고 staleTime(5분) 내라면 API 호출 없이 캐시된 데이터를 즉시 반환합니다.</li>
                <li>캐시된 데이터가 없거나 stale 상태라면 백엔드 API를 호출합니다.</li>
            </ol>
        </div>
        
        <div class="step-container">
            <h4 class="step-title" style="color: #c62828;">백엔드 처리 (Redis)</h4>
            <div class="code-block">
@router.get("/list", response_model=CVEListResponse)
async def get_cve_list(page: int = 1, limit: int = 10, ...):
    # 캐시 키 생성
    cache_key = f"cache:cve_list:page={page}&limit={limit}&search={search}"
    
    # 캐시 확인
    cached_data = await get_cache(cache_key)
    if cached_data:
        return cached_data
        
    # DB 조회
    result = await cve_service.get_cve_list(...)
    
    # 캐시 저장
    await set_cache(cache_key, result, cache_type="cve_list")
    return result
            </div>
            <ol>
                <li>백엔드는 먼저 Redis에서 해당 쿼리 파라미터에 맞는 캐시 키로 데이터를 찾습니다.</li>
                <li>캐시된 데이터가 있으면 DB 조회 없이 캐시된 데이터를 즉시 반환합니다.</li>
                <li>캐시된 데이터가 없으면 DB에서 조회한 후, 결과를 Redis에 캐시하고 반환합니다.</li>
                <li>캐시 데이터는 TTL(기본 5분)에 따라 자동으로 만료됩니다.</li>
            </ol>
        </div>
    </div>
    
    <!-- CREATE 작업 -->
    <div class="operation-container">
        <h3 class="operation-title create-operation">2. CREATE (생성) 작업</h3>
        
        <div class="step-container">
            <h4 class="step-title" style="color: #1565c0;">프론트엔드 요청 (React Query)</h4>
            <div class="code-block">
const createMutation = useMutation(
  (newCVE) => cveService.createCVE(newCVE),
  {
    onSuccess: () => {
      // 캐시 무효화
      queryClient.invalidateQueries(['cves']);
      // 알림 표시
      toast.success('CVE가 성공적으로 생성되었습니다.');
    }
  }
);

// 사용 예시
const handleCreateSubmit = (data) => {
  createMutation.mutate(data);
};
            </div>
            <ol>
                <li>useMutation을 사용하여 CVE 생성 요청을 보냅니다.</li>
                <li>생성 성공 시 <code>queryClient.invalidateQueries(['cves'])</code>를 호출하여 관련된 모든 CVE 쿼리 캐시를 무효화합니다.</li>
                <li>이로 인해 다음 조회 시 최신 데이터를 가져오게 됩니다.</li>
            </ol>
        </div>
        
        <div class="step-container">
            <h4 class="step-title" style="color: #c62828;">백엔드 처리 (Redis)</h4>
            <div class="code-block">
@router.post("/", response_model=CVEOperationResponse)
async def create_cve(cve_data: CVECreate, current_user: User = Depends(get_current_user)):
    # CVE 생성
    created = await cve_service.create_cve(cve_data, current_user)
    
    # 웹소켓 알림 전송
    await send_cve_notification("create", cve_id=created.cve_id)
    
    # 캐시 무효화
    await invalidate_cve_caches()
    
    return {"success": True, "message": "CVE 생성 성공", "cve_id": created.cve_id}
            </div>
            <ol>
                <li>백엔드는 CVE를 생성한 후 <code>invalidate_cve_caches()</code> 함수를 호출합니다.</li>
                <li>이 함수는 Redis에서 CVE 목록 관련 모든 캐시를 패턴 매칭으로 찾아 삭제합니다.</li>
                <li>또한 WebSocket을 통해 <code>cache_invalidated</code> 이벤트를 클라이언트에 전송합니다.</li>
                <li>프론트엔드는 이 이벤트를 수신하면 자동으로 React Query 캐시를 무효화하고 데이터를 다시 로드합니다.</li>
            </ol>
        </div>
    </div>
    
    <!-- UPDATE 작업 -->
    <div class="operation-container">
        <h3 class="operation-title update-operation">3. UPDATE (수정) 작업</h3>
        
        <div class="step-container">
            <h4 class="step-title" style="color: #1565c0;">프론트엔드 요청 (React Query)</h4>
            <div class="code-block">
const updateMutation = useMutation(
  ({cveId, data}) => cveService.updateCVE(cveId, data),
  {
    onSuccess: (data, variables) => {
      // 특정 CVE 상세 캐시 무효화
      queryClient.invalidateQueries(['cves', 'detail', variables.cveId]);
      // 목록 캐시 무효화
      queryClient.invalidateQueries(['cves', 'list']);
      toast.success('CVE가 성공적으로 수정되었습니다.');
    }
  }
);

// 사용 예시
const handleUpdateSubmit = (cveId, data) => {
  updateMutation.mutate({cveId, data});
};
            </div>
            <ol>
                <li>useMutation을 사용하여 CVE 수정 요청을 보냅니다.</li>
                <li>수정 성공 시 해당 CVE의 상세 정보 캐시와 목록 캐시를 모두 무효화합니다.</li>
                <li>이로 인해 다음 조회 시 최신 데이터를 가져오게 됩니다.</li>
            </ol>
        </div>
        
        <div class="step-container">
            <h4 class="step-title" style="color: #c62828;">백엔드 처리 (Redis)</h4>
            <div class="code-block">
@router.put("/{cve_id}", response_model=CVEOperationResponse)
async def update_cve(cve_id: str, cve_data: CVEUpdate, current_user: User = Depends(get_current_user)):
    # CVE 수정
    updated = await cve_service.update_cve(cve_id, cve_data, current_user)
    
    # 웹소켓 알림 전송
    await send_cve_notification("update", cve_id=cve_id)
    
    # 특정 CVE 관련 캐시 무효화
    await invalidate_cve_caches(cve_id)
    
    return {"success": True, "message": "CVE 수정 성공", "cve_id": cve_id}
            </div>
            <ol>
                <li>백엔드는 CVE를 수정한 후 <code>invalidate_cve_caches(cve_id)</code> 함수를 호출합니다.</li>
                <li>이 함수는 해당 CVE의 상세 정보 캐시와 모든 CVE 목록 캐시를 삭제합니다.</li>
                <li>또한 WebSocket을 통해 <code>cache_invalidated</code> 이벤트를 클라이언트에 전송합니다.</li>
                <li>프론트엔드는 이 이벤트를 수신하면 자동으로 React Query 캐시를 무효화하고 데이터를 다시 로드합니다.</li>
            </ol>
        </div>
    </div>
    
    <!-- DELETE 작업 -->
    <div class="operation-container">
        <h3 class="operation-title delete-operation">4. DELETE (삭제) 작업</h3>
        
        <div class="step-container">
            <h4 class="step-title" style="color: #1565c0;">프론트엔드 요청 (React Query)</h4>
            <div class="code-block">
const deleteMutation = useMutation(
  (cveId) => cveService.deleteCVE(cveId),
  {
    onSuccess: (data, cveId) => {
      // 특정 CVE 상세 캐시 무효화
      queryClient.invalidateQueries(['cves', 'detail', cveId]);
      // 목록 캐시 무효화
      queryClient.invalidateQueries(['cves', 'list']);
      toast.success('CVE가 성공적으로 삭제되었습니다.');
    }
  }
);

// 사용 예시
const handleDelete = (cveId) => {
  if (window.confirm('정말로 이 CVE를 삭제하시겠습니까?')) {
    deleteMutation.mutate(cveId);
  }
};
            </div>
            <ol>
                <li>useMutation을 사용하여 CVE 삭제 요청을 보냅니다.</li>
                <li>삭제 성공 시 해당 CVE의 상세 정보 캐시와 목록 캐시를 모두 무효화합니다.</li>
                <li>이로 인해 다음 조회 시 최신 데이터를 가져오게 됩니다.</li>
            </ol>
        </div>
        
        <div class="step-container">
            <h4 class="step-title" style="color: #c62828;">백엔드 처리 (Redis)</h4>
            <div class="code-block">
@router.delete("/{cve_id}", response_model=CVEOperationResponse)
async def delete_cve(cve_id: str, current_user: User = Depends(get_current_admin_user)):
    # CVE 삭제
    deleted = await cve_service.delete_cve(cve_id)
    
    # 웹소켓 알림 전송
    await send_cve_notification("delete", cve_id=cve_id)
    
    # 특정 CVE 관련 캐시 무효화
    await invalidate_cve_caches(cve_id)
    
    return {"success": True, "message": "CVE 삭제 성공", "cve_id": cve_id}
            </div>
            <ol>
                <li>백엔드는 CVE를 삭제한 후 <code>invalidate_cve_caches(cve_id)</code> 함수를 호출합니다.</li>
                <li>이 함수는 해당 CVE의 상세 정보 캐시와 모든 CVE 목록 캐시를 삭제합니다.</li>
                <li>또한 WebSocket을 통해 <code>cache_invalidated</code> 이벤트를 클라이언트에 전송합니다.</li>
                <li>프론트엔드는 이 이벤트를 수신하면 자동으로 React Query 캐시를 무효화하고 데이터를 다시 로드합니다.</li>
            </ol>
        </div>
        
        <div class="step-container">
            <h4 class="step-title" style="color: #d32f2f;">문제점: datetime 직렬화 오류</h4>
            <div class="error-box">
                <code>ERROR - 캐시 저장 실패 (cache:cve_list:limit=10&page=1&search=&severity=): Object of type datetime is not JSON serializable</code>
            </div>
            <p>이 오류는 Python의 datetime 객체가 기본적으로 JSON으로 직렬화될 수 없기 때문에 발생합니다. 이를 해결하기 위해 <code>DateTimeJSONEncoder</code> 클래스를 추가하여 datetime 객체를 ISO 형식 문자열로 변환하도록 수정했습니다.</p>
            <div class="code-block">
# JSON 인코더 - datetime 객체를 ISO 포맷 문자열로 변환
class DateTimeJSONEncoder(json.JSONEncoder):
    """datetime 객체를 ISO 포맷 문자열로 변환하는 JSON 인코더"""
    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.isoformat()
        return super().default(obj)

# 수정된 set_cache 함수
async def set_cache(key: str, value: Any, expire: int = None, cache_type: str = None) -> bool:
    try:
        # ... 기존 코드 ...
        
        # datetime 객체를 처리할 수 있는 인코더 사용
        serialized = json.dumps(value, cls=DateTimeJSONEncoder)
        await redis.set(key, serialized, ex=expire)
        return True
    except Exception as e:
        logger.error(f"캐시 저장 실패 ({key}): {str(e)}")
        return False
            </div>
        </div>
    </div>
    
    <!-- 캐시 시스템의 주요 특징 -->
    <div class="container">
        <h2>캐시 시스템의 주요 특징</h2>
        
        <div class="feature-grid">
            <!-- 이중 캐싱 전략 -->
            <div class="feature-item">
                <h4 class="feature-title" style="color: #1565c0;">이중 캐싱 전략</h4>
                <p>프론트엔드(React Query)와 백엔드(Redis) 모두에서 캐싱을 수행하여 다양한 수준에서 성능을 최적화합니다. 프론트엔드 캐시는 네트워크 요청을 줄이고, 백엔드 캐시는 데이터베이스 부하를 줄입니다.</p>
            </div>
            
            <!-- 캐시 무효화 메커니즘 -->
            <div class="feature-item">
                <h4 class="feature-title" style="color: #c62828;">캐시 무효화 메커니즘</h4>
                <p>데이터가 변경되면(생성, 수정, 삭제) 관련된 모든 캐시를 자동으로 무효화합니다. 이를 통해 사용자는 항상 최신 데이터를 볼 수 있습니다. WebSocket을 통한 실시간 캐시 무효화 알림도 지원합니다.</p>
            </div>
            
            <!-- TTL 기반 캐시 만료 -->
            <div class="feature-item">
                <h4 class="feature-title" style="color: #f57c00;">TTL 기반 캐시 만료</h4>
                <p>각 캐시 유형별로 적절한 TTL(Time To Live)을 설정하여 오래된 데이터가 자동으로 만료되도록 합니다. 예를 들어, CVE 목록은 5분, CVE 상세 정보는 1시간 동안 캐시됩니다.</p>
            </div>
            
            <!-- 직렬화 처리 -->
            <div class="feature-item">
                <h4 class="feature-title" style="color: #2e7d32;">직렬화 처리</h4>
                <p>백엔드에서는 <code>DateTimeJSONEncoder</code>를 사용하여 datetime 객체를 ISO 형식 문자열로 변환합니다. 프론트엔드에서는 <code>dateUtils.js</code>의 유틸리티 함수를 사용하여 이 문자열을 다시 적절한 형식으로 표시합니다.</p>
            </div>
        </div>
    </div>
    
    <footer style="text-align: center; margin-top: 50px; color: #777; font-size: 0.9em;">
        <p>© 2025 CVEHub - 캐시 아키텍처 문서</p>
        <p>작성일: 2025-03-14</p>
    </footer>
</body>
</html>
