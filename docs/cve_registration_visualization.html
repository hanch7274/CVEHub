<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CVEHub 등록 프로세스 시각화</title>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
  <style>
    body {
      font-family: 'Noto Sans KR', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f9f9f9;
    }
    h1, h2, h3 {
      color: #2c3e50;
    }
    .process-container {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      padding: 20px;
      margin-bottom: 30px;
      width: 100%;
    }
    .tabs {
      display: flex;
      flex-wrap: wrap;
      border-bottom: 1px solid #ddd;
      margin-bottom: 20px;
    }
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      background-color: #f1f1f1;
      border: 1px solid #ddd;
      border-bottom: none;
      border-radius: 5px 5px 0 0;
      margin-right: 5px;
      margin-bottom: 5px;
    }
    .tab.active {
      background-color: white;
      border-bottom: 1px solid white;
      margin-bottom: -1px;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .comparison {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
    }
    .comparison-column {
      flex: 1;
      min-width: 300px;
      padding: 15px;
      border-radius: 5px;
    }
    .before {
      background-color: #ffeeee;
      border: 1px solid #ffcccc;
    }
    .after {
      background-color: #eeffee;
      border: 1px solid #ccffcc;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px 12px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    /* 다이어그램 영역의 오버플로우 및 최대 너비 설정 */
    .mermaid, pre.mermaid {
      margin: 20px 0;
      overflow-x: auto;
      max-width: 100%;
    }
    .mermaid svg, pre.mermaid svg {
      max-width: 100%;
    }
    .process-section {
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px dashed #ddd;
    }
  </style>
</head>
<body>
  <h1>CVEHub 등록 프로세스 시각화</h1>
  
  <div class="process-container">
    <div class="tabs">
      <div class="tab active" onclick="openTab(event, 'manualProcess')">수동 등록 프로세스</div>
      <div class="tab" onclick="openTab(event, 'crawlerProcess')">크롤러 등록 프로세스</div>
      <div class="tab" onclick="openTab(event, 'frontendBackend')">프론트엔드/백엔드 통합 관점</div>
      <div class="tab" onclick="openTab(event, 'architectureComparison')">아키텍처 비교</div>
    </div>

    <div id="manualProcess" class="tab-content active">
      <h3>수동 CVE 등록 프로세스</h3>
      <div class="mermaid">flowchart TB
UI[사용자 UI] --> |CVE 데이터 제출| API[API 엔드포인트]
API --> |요청 검증| Router[CVE Router]
Router --> |create_cve| CVEService[CVE Service]
CVEService --> |유효성 검증| Validation{데이터 유효?}
Validation -->|Yes| CreateCVE[create_cve 메서드]
CreateCVE --> DB[(MongoDB)]
DB --> Response[응답 생성]
Response --> UI
Validation -->|No| Error[오류 응답]
Error --> UI

classDef primary fill:#d1e7dd,stroke:#75b798,color:#0f5132;
classDef secondary fill:#e2e3e5,stroke:#c4c8cb,color:#41464b;
classDef success fill:#d1e7dd,stroke:#75b798,color:#0f5132;
classDef danger fill:#f8d7da,stroke:#f1aeb5,color:#b02a37;

class UI,API secondary;
class Router,CVEService,CreateCVE primary;
class DB success;
class Error danger;
      </div>
      
      <div class="process-section">
        <h3>WebSocket을 통한 실시간 업데이트</h3>
        <div class="mermaid">sequenceDiagram
participant Client as 프론트엔드(React)
participant WSClient as Socket.IO 클라이언트
participant WSServer as Socket.IO 서버
participant SIOManager as SocketIOManager
participant CVEService as CVE Service
participant DB as MongoDB

Client->>WSClient: 웹소켓 연결 요청
WSClient->>WSServer: 연결 요청(token 포함)
WSServer->>SIOManager: connect 이벤트
SIOManager->>WSServer: 인증 확인
WSServer->>WSClient: connect_ack 이벤트
WSClient->>Client: 연결 성공

Client->>WSClient: CVE 구독 요청(cve_id)
WSClient->>WSServer: subscribe_cve 이벤트
WSServer->>SIOManager: subscribe_cve 메서드
SIOManager->>SIOManager: 구독 정보 저장
SIOManager->>WSClient: 구독 성공 응답

Note over CVEService,DB: CVE 데이터 변경 발생

CVEService->>SIOManager: broadcast_cve_update 호출
SIOManager->>SIOManager: 구독자 확인
SIOManager->>WSServer: CVE 업데이트 이벤트 전송
WSServer->>WSClient: cve_updated 이벤트
WSClient->>Client: React Query 캐시 무효화
Client->>Client: UI 업데이트
        </div>
      </div>
    </div>

    <div id="crawlerProcess" class="tab-content">
      <h3>크롤러 CVE 등록 프로세스</h3>
      <div class="mermaid">flowchart TB
Start[크롤러 시작] --> Fetch[fetch_data]
Fetch --> Parse[parse_data]
Parse --> Process[process_data]
Process --> BaseCrawler[BaseCrawlerService.update_cve]
BaseCrawler --> CheckExisting{기존 CVE 존재?}
CheckExisting --> |Yes| UpdateCVE[CVEService.update_cve]
CheckExisting --> |No| CreateCVE[CVEService.create_cve]
UpdateCVE --> DB[(MongoDB)]
CreateCVE --> DB
DB --> ReportProgress[report_progress 메서드]
ReportProgress --> WebSocket[웹소켓 전송]
WebSocket --> Complete[크롤링 완료]

classDef primary fill:#d1e7dd,stroke:#75b798,color:#0f5132;
classDef secondary fill:#e2e3e5,stroke:#c4c8cb,color:#41464b;
classDef info fill:#cff4fc,stroke:#9eeaf9,color:#055160;
classDef warning fill:#fff3cd,stroke:#ffe69c,color:#997404;

class Start,Parse,Fetch,Process secondary;
class BaseCrawler,CheckExisting primary;
class UpdateCVE,CreateCVE info;
class DB,ReportProgress,Complete,WebSocket warning;
      </div>
      
      <div class="process-section">
        <h3>크롤러 진행 상황 실시간 보고</h3>
        <div class="mermaid">sequenceDiagram
participant UserUI as 사용자 UI
participant Frontend as 프론트엔드(React)
participant CrawlerUpdateBtn as CrawlerUpdateButton
participant WSClient as 웹소켓 클라이언트
participant WSServer as 웹소켓 서버
participant Crawler as 크롤러 서비스

UserUI->>Frontend: 크롤러 실행 요청
Frontend->>CrawlerUpdateBtn: 이벤트 전달
CrawlerUpdateBtn->>WSClient: CRAWLER_UPDATE_PROGRESS 이벤트 구독
CrawlerUpdateBtn->>Crawler: 크롤러 실행 API 호출
Crawler->>Crawler: fetch_data() 시작
Crawler->>WSServer: report_progress("준비", 0, "...")
WSServer->>WSClient: crawler_update_progress 이벤트
WSClient->>CrawlerUpdateBtn: processWebSocketData 함수 호출
CrawlerUpdateBtn->>CrawlerUpdateBtn: CRAWLER_STAGES 기준 상태 확인
CrawlerUpdateBtn->>UserUI: 진행률 0% 표시

Crawler->>Crawler: 데이터 수집 진행
Crawler->>WSServer: report_progress("수집중", 30, "...")
WSServer->>WSClient: crawler_update_progress 이벤트
WSClient->>CrawlerUpdateBtn: processWebSocketData 함수 호출
CrawlerUpdateBtn->>UserUI: 진행률 30% 표시

Crawler->>Crawler: 데이터 분석
Crawler->>WSServer: report_progress("분석중", 60, "...")
WSServer->>WSClient: crawler_update_progress 이벤트
WSClient->>CrawlerUpdateBtn: processWebSocketData 함수 호출
CrawlerUpdateBtn->>UserUI: 진행률 60% 표시

Crawler->>Crawler: DB 업데이트
Crawler->>WSServer: report_progress("저장중", 90, "...")
WSServer->>WSClient: crawler_update_progress 이벤트
WSClient->>CrawlerUpdateBtn: processWebSocketData 함수 호출
CrawlerUpdateBtn->>UserUI: 진행률 90% 표시

Crawler->>WSServer: report_progress("완료", 100, "완료 처리 중...")
WSServer->>WSClient: crawler_update_progress 이벤트
WSClient->>CrawlerUpdateBtn: processWebSocketData 함수 호출
CrawlerUpdateBtn->>CrawlerUpdateBtn: completedValues.includes() 검사
CrawlerUpdateBtn->>CrawlerUpdateBtn: handleCrawlerComplete 호출
CrawlerUpdateBtn->>UserUI: 진행률 100% 표시
        </div>
      </div>
    </div>

    <div id="frontendBackend" class="tab-content">
      <div class="process-section">
        <h3>프론트엔드/백엔드 통합 데이터 흐름</h3>
        <div class="mermaid">flowchart TB
subgraph Frontend[프론트엔드]
  ReactComponent[React 컴포넌트]
  QueryHook[useQuery 훅]
  MutationHook[useMutation 훅]
  QueryCache[React Query 캐시]
end

subgraph Backend[백엔드]
  APILayer[API 계층]
  Redis[(Redis 캐시)]
  ServiceLayer[서비스 계층]
  MongoDB[(MongoDB)]
end

ReactComponent --> QueryHook
QueryHook --> QueryCache
QueryCache --> APILayer
ReactComponent --> MutationHook
MutationHook --> APILayer

APILayer --> Redis
Redis --> ServiceLayer
ServiceLayer --> MongoDB

classDef frontend fill:#f8d7da,stroke:#f1aeb5,color:#b02a37;
classDef backend fill:#d1e7dd,stroke:#75b798,color:#0f5132;

class Frontend frontend;
class Backend backend;
        </div>
      </div>

<!-- Mutation 동작 프로세스 영역 -->
<div class="process-section">
    <h3>Mutation 동작 프로세스</h3>
    <div class="mermaid">sequenceDiagram
      participant Component as React 컴포넌트
      participant Mutation as useMutation 훅
      participant QueryClient as QueryClient
      participant API as API 엔드포인트
      participant Service as 서비스 계층
      participant DB as MongoDB
      participant Redis as Redis 캐시
      participant Socket as Socket.IO
  
      Component->>Mutation: mutate(newData) 호출
      Mutation->>API: POST/PUT/DELETE 요청
      API->>Service: 요청 처리
      Service->>DB: 데이터 변경
      Service->>Redis: 관련 캐시 무효화
      DB-->>Service: 변경 완료
      Service-->>API: 응답
      Service->>Socket: 변경 이벤트 발행
      API-->>Mutation: 성공 응답
      Mutation->>QueryClient: invalidateQueries() 호출
      QueryClient->>Component: onSuccess 콜백 실행
      Socket->>QueryClient: 소켓 이벤트로 캐시 무효화
      QueryClient->>Component: 자동 리페치
    </div>
  </div>
  
  <!-- CVE 등록 - 엔드 투 엔드 관점 영역 -->
  <div class="process-section">
    <h3>CVE 등록 - 엔드 투 엔드 관점</h3>
    <!-- pre 태그를 사용하여 코드 블록 앞뒤의 불필요한 들여쓰기를 제거 -->
    <pre class="mermaid">flowchart TB
  Form[등록 폼] --> Validation[유효성 검증]
  Validation --> useMutation[useMutation]
  useMutation --> APIRouter[API 라우터]
  APIRouter --> CVEService[CVE 서비스]
  CVEService --> MongoDB[(MongoDB)]
  CVEService --> Redis[(Redis)]
  CVEService --> SocketIO[Socket.IO]
  SocketIO --> QueryCache[Query 캐시]
  QueryCache --> UIUpdate[UI 업데이트]
  
  classDef frontend fill:#f8d7da,stroke:#f1aeb5,color:#b02a37;
  classDef backend fill:#d1e7dd,stroke:#75b798,color:#0f5132;
  classDef storage fill:#fff3cd,stroke:#ffe69c,color:#997404;
  
  class Form,Validation,useMutation,QueryCache,UIUpdate frontend;
  class APIRouter,CVEService,SocketIO backend;
  class MongoDB,Redis storage;
    </pre>
  </div>
    
    <div id="architectureComparison" class="tab-content">
      <h3>아키텍처 비교: 리팩토링 전후</h3>
      
      <div class="comparison">
        <div class="comparison-column before">
          <h4>리팩토링 전</h4>
          <div class="mermaid">flowchart TB
NucleiCrawler[NucleiCrawler] --> NucleiUpdate[직접 CVE 업데이트]
EmergingCrawler[EmergingThreats] --> EmergingUpdate[직접 CVE 업데이트]
OtherCrawler[기타 크롤러] --> OtherUpdate[직접 CVE 업데이트]

NucleiUpdate --> DB[(MongoDB)]
EmergingUpdate --> DB
OtherUpdate --> DB

APIRouter[API Router] --> DirectUpdate[직접 CVE 업데이트]
DirectUpdate --> DB

classDef crawler fill:#f8d7da,stroke:#f1aeb5,color:#b02a37;
classDef duplicate fill:#f8d7da,stroke:#f1aeb5,color:#b02a37;
classDef db fill:#d1e7dd,stroke:#75b798,color:#0f5132;

class NucleiCrawler,EmergingCrawler,OtherCrawler crawler;
class NucleiUpdate,EmergingUpdate,OtherUpdate,DirectUpdate duplicate;
class DB db;
          </div>
          <p>
            <strong>문제점:</strong>
            <ul>
              <li>각 크롤러마다 CVE 업데이트 로직 중복</li>
              <li>시간 처리 방식 불일치</li>
              <li>코드 중복으로 유지보수 어려움</li>
              <li>필드명 변경 시 모든 크롤러 수정 필요</li>
            </ul>
          </p>
        </div>
        
        <div class="comparison-column after">
          <h4>리팩토링 후</h4>
          <div class="mermaid">flowchart TB
NucleiCrawler[NucleiCrawler] --> BaseCrawler[BaseCrawlerService]
EmergingCrawler[EmergingThreats] --> BaseCrawler
OtherCrawler[기타 크롤러] --> BaseCrawler

BaseCrawler --> CVEService[CVE 서비스]
APIRouter[API Router] --> CVEService

CVEService --> DB[(MongoDB)]

classDef crawler fill:#cff4fc,stroke:#9eeaf9,color:#055160;
classDef service fill:#d1e7dd,stroke:#75b798,color:#0f5132;
classDef db fill:#d1e7dd,stroke:#75b798,color:#0f5132;

class NucleiCrawler,EmergingCrawler,OtherCrawler crawler;
class BaseCrawler,CVEService service;
class DB db;
          </div>
          <p>
            <strong>개선사항:</strong>
            <ul>
              <li>공통 로직 중앙화로 코드 중복 제거</li>
              <li>get_utc_now()로 시간 처리 일관성 유지</li>
              <li>CVEService로 데이터 처리 표준화</li>
              <li>확장성 향상 및 유지보수 용이</li>
            </ul>
          </p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Mermaid 자동 렌더링 비활성화 (startOnLoad: false)
    mermaid.initialize({ 
      startOnLoad: false, 
      theme: 'neutral',
      securityLevel: 'loose',
      flowchart: {
        useMaxWidth: false,
        htmlLabels: true,
        curve: 'basis'
      },
      sequence: {
        diagramMarginX: 20,
        diagramMarginY: 20,
        actorMargin: 20,
        messageMargin: 10,
        width: 600
      },
      themeCSS: '.label { font-family: Source Sans Pro,Helvetica Neue,Arial,sans-serif; }'
    });

    // 활성 탭 내의 Mermaid 요소 초기화 (이미 렌더링된 경우 건너뜀)
    function initMermaidForTab(tabElement) {
      var diagrams = tabElement.querySelectorAll('.mermaid, pre.mermaid');
      diagrams.forEach(function(diagram) {
        if (!diagram.querySelector('svg')) {
          mermaid.init(undefined, diagram);
        }
      });
    }

    // 탭 전환 함수
    function openTab(evt, tabName) {
      var tabcontent = document.getElementsByClassName("tab-content");
      for (var i = 0; i < tabcontent.length; i++) {
        tabcontent[i].classList.remove("active");
      }
      var tablinks = document.getElementsByClassName("tab");
      for (var i = 0; i < tablinks.length; i++) {
        tablinks[i].classList.remove("active");
      }
      var activeTab = document.getElementById(tabName);
      activeTab.classList.add("active");
      evt.currentTarget.classList.add("active");
      initMermaidForTab(activeTab);
    }

    // 페이지 로드 후 활성 탭의 다이어그램 초기화
    window.addEventListener('load', function() {
      var activeTab = document.querySelector('.tab-content.active');
      if (activeTab) {
        initMermaidForTab(activeTab);
      }
    });
  </script>
</body>
</html>
