import axios from 'axios';
import { getAccessToken, clearAuthStorage } from '../../utils/storage/tokenStorage';
import { camelToSnake, snakeToCamel } from '../../utils/caseConverter';
import { refreshToken as refreshAuthToken } from '../../services/authService';
import { formatWithTimeZone, prepareDataForAPI, convertDateStrToKST, TIME_ZONES } from '../../utils/dateUtils';
import { 
  API_BASE_URL, 
  CASE_CONVERSION_CONFIG, 
  PUBLIC_ENDPOINTS,
  TOKEN_REFRESH_CONFIG
} from '../../config';
import { DATE_FORMATS } from '../../utils/dateUtils';

// ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏ ÏÑ§Ï†ï
const DEBUG_ENABLED = TOKEN_REFRESH_CONFIG.DEBUG || false;

// ÎßàÏßÄÎßâ ÌÜ†ÌÅ∞ Í∞±Ïã† ÏãúÍ∞Ñ Ï∂îÏ†Å
let lastTokenRefreshTime = 0;
let tokenRefreshRetryCount = 0;

// ÎîîÎ≤ÑÍ∑∏ Î°úÍ∑∏ Ìï®Ïàò
const debugLog = (...args) => {
  if (DEBUG_ENABLED) {
    console.log(...args);
  }
};

const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000, // 30Ï¥à ÌÉÄÏûÑÏïÑÏõÉ
  headers: {
    'Content-Type': 'application/json'
  }
});

// Ï∫êÏãú Ï†ÄÏû•ÏÜå
const cache = new Map();

// Î≥ÄÌôòÏóêÏÑú Ï†úÏô∏Ìï† ÌïÑÎìú Î™©Î°ù (configÏóêÏÑú Í∞ÄÏ†∏Ïò¥)
const EXCLUDED_FIELDS = CASE_CONVERSION_CONFIG.EXCLUDED_FIELDS;

// Î°úÍ∑∏ Ï∂úÎ†•ÏóêÏÑú Ï†úÏô∏Ìï† URL Ìå®ÌÑ¥
const URL_NO_LOG_PATTERNS = [
  '/static/',
  '/assets/',
  '/health'
];

// ÎÇ†Ïßú Ï≤òÎ¶¨ÏóêÏÑú Ï†úÏô∏Ìï† URL Ìå®ÌÑ¥
const URL_NO_DATE_PROCESSING_PATTERNS = [
  '/static/',
  '/assets/'
];

// Î°úÍπÖ Ï†úÏô∏Ìï† ÏóîÎìúÌè¨Ïù∏Ìä∏ Î™©Î°ù
const EXCLUDED_LOG_ENDPOINTS = [
  '/notifications/unread/count',
  '/user/status'
];

// ÎÇ†Ïßú ÌïÑÎìú Ï≤òÎ¶¨Í∞Ä ÌïÑÏöîÌïòÏßÄ ÏïäÏùÄ ÏóîÎìúÌè¨Ïù∏Ìä∏ Î™©Î°ù
const DATE_PROCESSING_EXCLUDED_ENDPOINTS = [
  '/users/search',
  '/users/profile',
  '/auth/login',
  '/auth/register'
];

// URL Ìå®ÌÑ¥Ïóê Îî∞Îùº Î°úÍ∑∏ Ï∂úÎ†• Ïó¨Î∂Ä Í≤∞Ï†ï
const isExcludedFromLogging = (url) => {
  return URL_NO_LOG_PATTERNS.some(pattern => url.includes(pattern));
};

// URL Ìå®ÌÑ¥Ïóê Îî∞Îùº ÎÇ†Ïßú Ï≤òÎ¶¨ Ïó¨Î∂Ä Í≤∞Ï†ï
const shouldProcessDates = (url) => {
  // Ï†úÏô∏ Ìå®ÌÑ¥Í≥º ÏùºÏπòÌïòÎäî Í≤ΩÏö∞ ÎÇ†Ïßú Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùå
  return !URL_NO_DATE_PROCESSING_PATTERNS.some(pattern => url.includes(pattern));
};

// Request Interceptor
api.interceptors.request.use(
  async (config) => {
    try {
      // Î°úÍπÖ Ï†úÏô∏ ÎåÄÏÉÅ ÌôïÏù∏
      const shouldLog = !isExcludedFromLogging(config.url);
      
      if (shouldLog) {
        debugLog('=== Request Interceptor Debug [Start] ===');
        debugLog('1. ======= API ÏöîÏ≤≠ ÏãúÏûë =======', {
          url: config.url,
          method: config.method,
          timestamp: formatWithTimeZone(new Date(), DATE_FORMATS.DISPLAY.FULL, TIME_ZONES.KST)
        });
      }

      // Ïù∏Ï¶ùÏù¥ ÌïÑÏöîÌïòÏßÄ ÏïäÏùÄ ÏóîÎìúÌè¨Ïù∏Ìä∏ Ï≤¥ÌÅ¨ (Î°úÍ∑∏Ïù∏, ÌöåÏõêÍ∞ÄÏûÖ Îì±)
      const isPublicEndpoint = PUBLIC_ENDPOINTS.some(endpoint => config.url.includes(endpoint));

      if (shouldLog) {
        debugLog('2. Public Endpoint Check:', {
          url: config.url,
          isPublic: isPublicEndpoint
        });
      }

      if (!isPublicEndpoint) {
        if (shouldLog) {
          debugLog('3. Starting Auth Process');
        }
        
        const token = getAccessToken();
        
        if (shouldLog) {
          debugLog('4. Token Check:', {
            exists: !!token,
            preview: token ? `${token.substring(0, 20)}...` : 'No token'
          });
        }
        
        if (token) {
          try {
            if (shouldLog) {
              debugLog('5. Token Validation Start');
            }
            
            const [headerPart, payloadPart] = token.split('.');
            const payload = JSON.parse(atob(payloadPart));
            const now = Math.floor(Date.now() / 1000);
            
            if (shouldLog) {
              debugLog('6. Token Details:', {
                exp: payload.exp,
                currentTime: now,
                timeUntilExp: payload.exp - now,
                currentTimeISO: formatWithTimeZone(new Date(), DATE_FORMATS.DISPLAY.FULL, TIME_ZONES.KST)
              });
            }
            
            // skipAuthRefresh ÌîåÎûòÍ∑∏Í∞Ä ÏûàÎäî Í≤ΩÏö∞ ÌÜ†ÌÅ∞ Í∞±Ïã† Î°úÏßÅ Í±¥ÎÑàÎõ∞Í∏∞
            if (config.skipAuthRefresh) {
              if (shouldLog) {
                debugLog('7. Skipping token refresh due to skipAuthRefresh flag');
              }
              config.headers.Authorization = `Bearer ${token}`;
            }
            // ÌÜ†ÌÅ∞ ÎßåÎ£å Ï≤¥ÌÅ¨ (ÎßåÎ£å ÏÑ§Ï†ïÎêú ÏãúÍ∞Ñ Ï†ÑÎ∂ÄÌÑ∞ Í∞±Ïã† ÏãúÎèÑ)
            else if (payload.exp && (payload.exp - now < TOKEN_REFRESH_CONFIG.REFRESH_BEFORE_EXPIRY)) {
              if (shouldLog) {
                debugLog('7. Token Refresh Needed');
                debugLog('8. Starting Token Refresh');
              }
              
              try {
                // ÌÜ†ÌÅ∞ Í∞±Ïã† Ï§ë ÌîåÎûòÍ∑∏ ÏÑ§Ï†ï (Ï§ëÎ≥µ Í∞±Ïã† Î∞©ÏßÄ)
                if (window._tokenRefreshInProgress) {
                  if (shouldLog) {
                    debugLog('Token refresh already in progress, using current token');
                  }
                  config.headers.Authorization = `Bearer ${token}`;
                } 
                // ÌÜ†ÌÅ∞ Í∞±Ïã† ÏµúÏÜå Í∞ÑÍ≤© ÌôïÏù∏
                else if (Date.now() - lastTokenRefreshTime < TOKEN_REFRESH_CONFIG.MIN_REFRESH_INTERVAL) {
                  if (shouldLog) {
                    debugLog('Token refresh attempted too frequently, using current token');
                  }
                  config.headers.Authorization = `Bearer ${token}`;
                }
                // ÌÜ†ÌÅ∞ Í∞±Ïã† ÏµúÎåÄ Ïû¨ÏãúÎèÑ ÌöüÏàò ÌôïÏù∏
                else if (tokenRefreshRetryCount >= TOKEN_REFRESH_CONFIG.MAX_RETRY_COUNT) {
                  if (shouldLog) {
                    debugLog('Maximum token refresh retry count reached, using current token');
                  }
                  config.headers.Authorization = `Bearer ${token}`;
                  
                  // ÏùºÏ†ï ÏãúÍ∞Ñ ÌõÑ Ïû¨ÏãúÎèÑ Ïπ¥Ïö¥Ìä∏ Ï¥àÍ∏∞Ìôî (10Î∂Ñ)
                  setTimeout(() => {
                    tokenRefreshRetryCount = 0;
                  }, 10 * 60 * 1000);
                } else {
                  window._tokenRefreshInProgress = true;
                  tokenRefreshRetryCount++;
                  
                  try {
                    const refreshResult = await refreshAuthToken();
                    
                    // Í∞±Ïã† ÏôÑÎ£å ÌõÑ ÌîåÎûòÍ∑∏ Ìï¥Ï†ú Î∞è ÏãúÍ∞Ñ Í∏∞Î°ù
                    window._tokenRefreshInProgress = false;
                    lastTokenRefreshTime = Date.now();
                    
                    // ÏÑ±Í≥µ Ïãú Ïû¨ÏãúÎèÑ Ïπ¥Ïö¥Ìä∏ Ï¥àÍ∏∞Ìôî
                    tokenRefreshRetryCount = 0;
                    
                    if (shouldLog) {
                      debugLog('9. Refresh Result:', !!refreshResult);
                    }
                    
                    if (refreshResult) {
                      const newToken = getAccessToken();
                      if (newToken) {
                        config.headers.Authorization = `Bearer ${newToken}`;
                        
                        if (shouldLog) {
                          debugLog('10. New Token Set:', {
                            preview: `${newToken.substring(0, 20)}...`
                          });
                        }
                      } else {
                        console.error('%c üî¥ Token Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', '11. New Token Missing After Refresh');
                        clearAuthStorage();
                        window.location.href = '/login';
                        return Promise.reject(new Error('Token refresh failed'));
                      }
                    }
                  } catch (refreshError) {
                    // Í∞±Ïã† Ïã§Ìå® Ïãú ÌîåÎûòÍ∑∏ Ìï¥Ï†ú
                    window._tokenRefreshInProgress = false;
                    
                    console.error('%c üî¥ Token Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', '12. Token Refresh Failed:', refreshError);
                    if (refreshError.response?.status === 401) {
                      clearAuthStorage();
                      window.location.href = '/login';
                      return Promise.reject(refreshError);
                    }
                    config.headers.Authorization = `Bearer ${token}`;
                    
                    if (shouldLog) {
                      debugLog('13. Using Existing Token:', {
                        preview: `${token.substring(0, 20)}...`
                      });
                    }
                  }
                }
              } catch (e) {
                console.error('%c üî¥ Token Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', '15. Token Validation Error:', {
                  error: e.message,
                  stack: e.stack
                });
                clearAuthStorage();
                window.location.href = '/login';
                return Promise.reject(e);
              }
            } else {
              if (shouldLog) {
                debugLog('14. Using Current Token');
              }
              
              config.headers.Authorization = `Bearer ${token.trim()}`;
            }
          } catch (e) {
            console.error('%c üî¥ Token Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', '15. Token Validation Error:', {
              error: e.message,
              stack: e.stack
            });
            clearAuthStorage();
            window.location.href = '/login';
            return Promise.reject(e);
          }
        } else {
          if (shouldLog) {
            debugLog('17. No Token Available');
          }
          
          clearAuthStorage();
          window.location.href = '/login';
          return Promise.reject(new Error('Authentication required'));
        }
      } else {
        if (shouldLog) {
          debugLog('18. Skipping Auth (Public Endpoint)');
        }
      }

      // Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò: ÏöîÏ≤≠ Îç∞Ïù¥ÌÑ∞ÏôÄ ÏøºÎ¶¨ ÌååÎùºÎØ∏ÌÑ∞Î•º Ïä§ÎÑ§Ïù¥ÌÅ¨ ÏºÄÏù¥Ïä§Î°ú Î≥ÄÌôò
      if (config.data && 
          config.headers['Content-Type'] !== 'application/x-www-form-urlencoded') {
        try {
          // ÎÇ†Ïßú ÌïÑÎìú UTC Î≥ÄÌôò Ï≤òÎ¶¨
          config.data = prepareDataForAPI(config.data);
          // ÏºÄÏù¥Ïä§ Î≥ÄÌôò
          config.data = camelToSnake(config.data, { excludeFields: EXCLUDED_FIELDS });
        } catch (transformError) {
          console.error('%c üî¥ Transform Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', 'Request data transform error:', transformError);
          // Î≥ÄÌôò Ïã§Ìå® Ïãú ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ Ïú†ÏßÄ
        }
      }
      
      if (config.params) {
        try {
          config.params = camelToSnake(config.params, { excludeFields: EXCLUDED_FIELDS });
        } catch (transformError) {
          console.error('%c üî¥ Transform Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', 'Request params transform error:', transformError);
          // Î≥ÄÌôò Ïã§Ìå® Ïãú ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ Ïú†ÏßÄ
        }
      }

      if (!isPublicEndpoint && !config.headers.Authorization) {
        console.error('%c üî¥ Auth Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', 'Authorization header is missing in the final config');
        return Promise.reject(new Error('Authorization header is missing'));
      }

      if (shouldLog && DEBUG_ENABLED) {
        debugLog('=== Final Request Config ===');
        debugLog('URL:', config.url);
        debugLog('Method:', config.method);
        // Ï§ëÏöî ÏöîÏ≤≠Îßå ÏÉÅÏÑ∏ Î°úÍπÖ
        if (config.url.includes('/auth/') || config.url.includes('/cve/') || config.method !== 'get') {
          debugLog('Headers:', config.headers);
          debugLog('Data:', config.data);
          debugLog('Params:', config.params);
        }
        debugLog('Timestamp:', formatWithTimeZone(new Date(), DATE_FORMATS.DISPLAY.FULL, TIME_ZONES.KST));
      }

      // GET ÏöîÏ≤≠ Ï∫êÏã±
      if (config.method === 'get') {
        const url = config.url;
        if (cache.has(url)) {
          const cachedData = cache.get(url);
          // Ï∫êÏãúÍ∞Ä Ïã†ÏÑ†ÌïúÏßÄ ÌôïÏù∏ (Ïòà: 5Î∂Ñ)
          if (Date.now() - cachedData.timestamp < 5 * 60 * 1000) {
            return Promise.resolve({
              ...config,
              cachedData: cachedData.data
            });
          }
        }
      }

      // ÏöîÏ≤≠ ÏãúÍ∞Ñ Í∏∞Î°ù
      config.metadata = config.metadata || {};
      config.metadata.requestTime = new Date();

      return config;
    } catch (error) {
      console.error('%c üî¥ Critical Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', '=== Request Interceptor Critical Error ===');
      console.error('%c üî¥ Critical Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', 'Error:', error);
      console.error('%c üî¥ Critical Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', 'Stack:', error.stack);
      return Promise.reject(error);
    }
  },
  (error) => {
    console.error('%c üî¥ Request Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', 'Request Interceptor Error:', error);
    return Promise.reject(error);
  }
);

// Response Interceptor
api.interceptors.response.use(
  (response) => {
    // Î°úÍπÖ Ï†úÏô∏ ÎåÄÏÉÅ ÌôïÏù∏
    const shouldLog = !isExcludedFromLogging(response.config.url);
    
    try {
      // ÏùëÎãµ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Í≤ΩÏö∞ÏóêÎßå Ï≤òÎ¶¨
      if (response.data) {
        // ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÌòïÏãù ÌôïÏù∏ (Î∞∞Ïó¥ ÎòêÎäî Í∞ùÏ≤¥)
        if (Array.isArray(response.data)) {
          // Ïä§ÎÑ§Ïù¥ÌÅ¨ ÏºÄÏù¥Ïä§ÏóêÏÑú Ïπ¥Î©ú ÏºÄÏù¥Ïä§Î°ú Î≥ÄÌôò
          response.data = response.data.map(item => snakeToCamel(item, EXCLUDED_FIELDS));
          
          // ÎÇ†Ïßú ÌïÑÎìú Ï≤òÎ¶¨
          if (shouldProcessDates(response.config.url)) {
            response.data = convertDateStrToKST(response.data);
          }
        } else if (typeof response.data === 'object' && response.data !== null) {
          // Ïä§ÎÑ§Ïù¥ÌÅ¨ ÏºÄÏù¥Ïä§ÏóêÏÑú Ïπ¥Î©ú ÏºÄÏù¥Ïä§Î°ú Î≥ÄÌôò
          response.data = snakeToCamel(response.data, EXCLUDED_FIELDS);
          
          // ÎÇ†Ïßú ÌïÑÎìú Ï≤òÎ¶¨
          if (shouldProcessDates(response.config.url)) {
            response.data = convertDateStrToKST(response.data);
          }
        }
      }

      // ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ (Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑúÎßå)
      if (shouldLog && process.env.NODE_ENV === 'development') {
        const requestTime = response.config.metadata?.requestTime;
        const responseTime = new Date();
        const elapsedTime = requestTime ? responseTime - requestTime : 0;
        
        debugLog('=== Response Interceptor Debug ===');
        debugLog('1. Response Status:', response.status);
        debugLog('2. Response Time:', elapsedTime, 'ms');
        
        // ÏùëÎãµ ÏãúÍ∞ÑÏù¥ 1Ï¥à Ïù¥ÏÉÅÏù∏ Í≤ΩÏö∞ Í≤ΩÍ≥† Î°úÍ∑∏
        if (elapsedTime > 1000) {
          console.warn('%c ‚ö†Ô∏è Slow Response', 'background: #ff9800; color: white; padding: 2px 4px; border-radius: 2px;', {
            url: response.config.url,
            method: response.config.method,
            elapsedTime: `${elapsedTime}ms`
          });
        }
      }
      
      // Ïù∏Ï¶ù Í¥ÄÎ†® ÏóîÎìúÌè¨Ïù∏Ìä∏ Ï≤¥ÌÅ¨ (ÏõêÎ≥∏ ÌïÑÎìú Î≥¥Ï°¥ÏùÑ ÏúÑÌï¥)
      const isAuthEndpoint = response.config?.url && (
        response.config?.url.includes('/auth/token') || 
        response.config?.url.includes('/auth/refresh') ||
        response.config?.url.includes('/auth/login') ||
        response.config?.url.includes('/auth/signup')
      );

      // ÏùëÎãµ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Í≤ΩÏö∞ Ïä§ÎÑ§Ïù¥ÌÅ¨ ÏºÄÏù¥Ïä§ÏóêÏÑú Ïπ¥Î©ú ÏºÄÏù¥Ïä§Î°ú Î≥ÄÌôò
      if (response.data) {
        try {
          // detail ÌïÑÎìúÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ ÏõêÎ≥∏ Í∞í Ï†ÄÏû•
          const originalDetail = response.data.detail;
          
          // Ïù∏Ï¶ù Í¥ÄÎ†® ÏõêÎ≥∏ ÌïÑÎìú Ï†ÄÏû• (Ïù∏Ï¶ù ÏóîÎìúÌè¨Ïù∏Ìä∏Ïù∏ Í≤ΩÏö∞)
          const originalAuthFields = {};
          if (isAuthEndpoint && typeof response.data === 'object') {
            // ÏõêÎ≥∏ Ïù∏Ï¶ù ÌïÑÎìú Ï†ÄÏû•
            ['access_token', 'refresh_token', 'token_type'].forEach(field => {
              if (response.data[field] !== undefined) {
                originalAuthFields[field] = response.data[field];
              }
            });
          }
          
          // Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò Ï†ÅÏö© (Ï†úÏô∏ ÌïÑÎìú Î™©Î°ù Ï†ÑÎã¨)
          response.data = snakeToCamel(response.data, { excludeFields: EXCLUDED_FIELDS });
          
          // detail ÌïÑÎìú Î≥¥Ï°¥ (Î≥ÄÌôò ÌõÑÏóêÎèÑ ÏõêÎ≥∏ Í∞í Ïú†ÏßÄ)
          if (originalDetail) {
            response.data.detail = originalDetail;
          }
          
          // Ïù∏Ï¶ù ÏóîÎìúÌè¨Ïù∏Ìä∏Ïù∏ Í≤ΩÏö∞ ÏõêÎ≥∏ ÌïÑÎìúÎèÑ Ìï®Íªò Î≥¥Ï°¥
          if (isAuthEndpoint && Object.keys(originalAuthFields).length > 0) {
            debugLog('Preserving original auth fields alongside camelCase versions');
            // Ïπ¥Î©úÏºÄÏù¥Ïä§ Î≥ÄÌôò ÌõÑÏóêÎèÑ ÏõêÎ≥∏ ÌïÑÎìú Ïú†ÏßÄ (Îëò Îã§ ÏÇ¨Ïö© Í∞ÄÎä•ÌïòÎèÑÎ°ù)
            Object.assign(response.data, originalAuthFields);
          }
        } catch (transformError) {
          console.error('%c üî¥ Transform Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', 'Response transform error:', transformError);
          // Î≥ÄÌôò Ïã§Ìå® Ïãú ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ Ïú†ÏßÄ
        }
      }

      // Ï∫êÏãú Ï†ÄÏû•
      if (response.config?.method === 'get') {
        cache.set(response.config.url, {
          data: response.data,
          timestamp: Date.now()
        });
      }

      return response;
    } catch (error) {
      console.error('%c üî¥ Response Transform Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', error);
      return response;
    }
  },
  async (error) => {
    // ÏóêÎü¨ ÎîîÎ≤ÑÍπÖ Ï†ïÎ≥¥ Ï∂úÎ†• (Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑúÎßå)
    if (process.env.NODE_ENV === 'development') {
      console.error('%c üî¥ Response Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', '=== Response Error Debug ===');
      
      // Í∏∞Î≥∏ ÏóêÎü¨ Ï†ïÎ≥¥ Íµ¨ÏÑ± (ÏïàÏ†ÑÌïòÍ≤å Ï†ëÍ∑º)
      const errorInfo = {
        url: error?.config?.url || 'unknown',
        method: error?.config?.method || 'unknown',
        status: error?.response?.status || 'unknown',
        timestamp: formatWithTimeZone(new Date(), DATE_FORMATS.DISPLAY.FULL, TIME_ZONES.KST)
      };
      
      console.error('%c üî¥ Response Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', 'Error Config:', errorInfo);
    }

    // ÏóêÎü¨ Í∞ùÏ≤¥ ÌëúÏ§ÄÌôî - configÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í Ï†úÍ≥µ
    if (!error.config) {
      // config Í∞ùÏ≤¥Í∞Ä ÏóÜÎäî Í≤ΩÏö∞ Í∏∞Î≥∏ config ÏÉùÏÑ±
      error.config = {
        skipAuthRefresh: true, // Ïù∏Ï¶ù Í∞±Ïã† ÏãúÎèÑÌïòÏßÄ ÏïäÏùå
        url: error?.request?.responseURL || 'unknown',
        method: 'unknown',
        headers: {}
      };
    }

    // response Í∞ùÏ≤¥Í∞Ä ÏóÜÎäî Í≤ΩÏö∞ ÏÉùÏÑ±
    if (!error.response) {
      // HTTP ÏÉÅÌÉú ÏΩîÎìú Ï∂îÏ∂ú ÏãúÎèÑ
      let statusCode = 500;
      if (error.message) {
        const statusMatch = error.message.match(/status code (\d+)/i);
        if (statusMatch && statusMatch[1]) {
          statusCode = parseInt(statusMatch[1], 10);
        }
      }
      
      // response Í∞ùÏ≤¥ ÏÉùÏÑ±
      error.response = {
        status: statusCode,
        data: {
          detail: error.message || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.',
          errorCode: 'NETWORK_ERROR'
        }
      };
    }

    // ÏóêÎü¨ ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ÎèÑ Î≥ÄÌôò Ï≤òÎ¶¨
    if (error?.response?.data) {
      try {
        // detail ÌïÑÎìúÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ ÏõêÎ≥∏ Í∞í Ï†ÄÏû•
        const originalDetail = error?.response?.data?.detail;
        const originalErrorCode = error?.response?.data?.error_code || error?.response?.data?.errorCode;
        
        // Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò Ï†ÅÏö©
        error.response.data = snakeToCamel(error.response.data, { excludeFields: EXCLUDED_FIELDS });
        
        // detail ÌïÑÎìú Î≥¥Ï°¥ (Î≥ÄÌôò ÌõÑÏóêÎèÑ ÏõêÎ≥∏ Í∞í Ïú†ÏßÄ)
        if (originalDetail) {
          error.response.data.detail = originalDetail;
        }
        
        // errorCode ÌïÑÎìú Î≥¥Ï°¥
        if (originalErrorCode) {
          error.response.data.errorCode = originalErrorCode;
        }
      } catch (transformError) {
        // Î≥ÄÌôò Ïã§Ìå® Ïãú ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ Ïú†ÏßÄÌïòÍ≥† Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ ÌôïÎ≥¥
        if (!error.response.data.detail) {
          error.response.data.detail = error.message || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';
        }
        if (!error.response.data.errorCode) {
          error.response.data.errorCode = 'TRANSFORM_ERROR';
        }
      }
    } else if (error.response) {
      // response.dataÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
      error.response.data = {
        detail: error.message || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.',
        errorCode: `HTTP_${error.response.status}`
      };
    }

    // 401 ÏóêÎü¨ Ï≤òÎ¶¨ (Ïù∏Ï¶ù Ïã§Ìå®)
    if (error?.response?.status === 401) {
      debugLog('=== Auth Error Debug ===');
      
      // configÍ∞Ä ÏóÜÍ±∞ÎÇò Ïù∏Ï¶ù ÏóîÎìúÌè¨Ïù∏Ìä∏Ïù∏ Í≤ΩÏö∞ ÌÜ†ÌÅ∞ Í∞±Ïã† ÏãúÎèÑÌïòÏßÄ ÏïäÏùå
      if (!error.config || error.config.url.includes('/auth/token')) {
        debugLog('Login attempt failed or config missing, skipping token refresh');
        clearAuthStorage();
        return Promise.reject(error);
      }

      const token = getAccessToken();
      debugLog('Current Token:', {
        exists: !!token,
        preview: token ? `${token.substring(0, 20)}...` : 'No token'
      });

      // skipAuthRefresh ÏòµÏÖò ÌôïÏù∏ (undefinedÏù∏ Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í false ÏÇ¨Ïö©)
      // config Í∞ùÏ≤¥Í∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨Ìï®Ïù¥ Î≥¥Ïû•Îê®
      const skipAuthRefresh = error.config.skipAuthRefresh === true;
      
      if (token && !error.config.url.includes('/auth/refresh') && !skipAuthRefresh) {
        try {
          // ÌÜ†ÌÅ∞ Í∞±Ïã† Ï§ë ÌîåÎûòÍ∑∏ ÌôïÏù∏ (Ï§ëÎ≥µ Í∞±Ïã† Î∞©ÏßÄ)
          if (window._tokenRefreshInProgress) {
            debugLog('Token refresh already in progress, rejecting request');
            return Promise.reject(error);
          }
          
          // ÌÜ†ÌÅ∞ Í∞±Ïã† ÏµúÏÜå Í∞ÑÍ≤© ÌôïÏù∏
          if (Date.now() - lastTokenRefreshTime < TOKEN_REFRESH_CONFIG.MIN_REFRESH_INTERVAL) {
            debugLog('Token refresh attempted too frequently, rejecting request');
            return Promise.reject(error);
          }
          
          // ÌÜ†ÌÅ∞ Í∞±Ïã† ÏµúÎåÄ Ïû¨ÏãúÎèÑ ÌöüÏàò ÌôïÏù∏
          if (tokenRefreshRetryCount >= TOKEN_REFRESH_CONFIG.MAX_RETRY_COUNT) {
            debugLog('Maximum token refresh retry count reached, rejecting request');
            clearAuthStorage();
            window.location.href = '/login';
            return Promise.reject(error);
          }
          
          window._tokenRefreshInProgress = true;
          tokenRefreshRetryCount++;
          debugLog('Attempting final token refresh...');
          
          const refreshResult = await refreshAuthToken();
          
          // Í∞±Ïã† ÏôÑÎ£å ÌõÑ ÌîåÎûòÍ∑∏ Ìï¥Ï†ú Î∞è ÏãúÍ∞Ñ Í∏∞Î°ù
          window._tokenRefreshInProgress = false;
          lastTokenRefreshTime = Date.now();
          
          // ÏÑ±Í≥µ Ïãú Ïû¨ÏãúÎèÑ Ïπ¥Ïö¥Ìä∏ Ï¥àÍ∏∞Ìôî
          tokenRefreshRetryCount = 0;
          
          if (refreshResult) {
            debugLog('Final refresh successful, retrying request...');
            const originalRequest = error.config;
            const newToken = getAccessToken();
            
            // ÏõêÎ≥∏ ÏöîÏ≤≠ Ïû¨ÏãúÎèÑ Ï†Ñ Ìó§Îçî ÌôïÏù∏
            if (!originalRequest.headers) {
              originalRequest.headers = {};
            }
            
            originalRequest.headers.Authorization = `Bearer ${newToken}`;
            // Ïû¨ÏãúÎèÑ Ïãú skipAuthRefresh ÌîåÎûòÍ∑∏ ÏÑ§Ï†ïÌïòÏó¨ Î¨¥Ìïú Î£®ÌîÑ Î∞©ÏßÄ
            originalRequest.skipAuthRefresh = true;
            return axios(originalRequest);
          }
        } catch (refreshError) {
          // Í∞±Ïã† Ïã§Ìå® Ïãú ÌîåÎûòÍ∑∏ Ìï¥Ï†ú
          window._tokenRefreshInProgress = false;
          
          console.error('%c üî¥ Auth Error', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', 'Final refresh failed:', refreshError);
          clearAuthStorage();
          window.location.href = '/login';
          return Promise.reject(refreshError);
        }
      } else {
        clearAuthStorage();
        if (!error.config.url.includes('/auth/token')) {
          window.location.href = '/login';
        }
      }
    }
    
    // --- ÏóêÎü¨ ÏùëÎãµ Ìè¨Îß∑ ÌôïÏû•: ÏóêÎü¨ ÏΩîÎìúÏôÄ ÏÑ∏Î∂Ä Î©îÏãúÏßÄÎ•º Ìè¨Ìï®Ìïú Í∞ùÏ≤¥Î°ú ÎûòÌïë ---
    const formattedError = {
      code: error?.response?.status || 500,
      message: error?.response?.data?.message || error?.message || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§',
      data: error?.response?.data || null,
      originalError: error,
      config: {
        url: error?.config?.url || 'unknown',
        method: error?.config?.method || 'unknown',
        skipAuthRefresh: error?.config?.skipAuthRefresh || false
      }
    };
    
    return Promise.reject(formattedError);
  }
);

export default api;
