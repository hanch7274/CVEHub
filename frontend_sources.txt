============================================================
File: /home/CVEHub/frontend/webpack.config.js
------------------------------------------------------------
// 번들 분석 및 최적화
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  // 기존 설정...
  plugins: [
    // 개발 모드에서만 사용
    process.env.ANALYZE && new BundleAnalyzerPlugin()
  ].filter(Boolean),
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  }
}; 


============================================================
File: /home/CVEHub/frontend/src/App.jsx
------------------------------------------------------------
import React, { useState, useCallback, useEffect, lazy, Suspense } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useParams } from 'react-router-dom';
import { Box } from '@mui/material';
import { Alert, Snackbar } from '@mui/material';
import Header from './layout/Header';
import Sidebar from './layout/Sidebar';
import CVEList from './features/cve/CVEList';
import CreateCVE from './features/cve/CreateCVE';
import SignUp from './features/auth/SignUp';
import Login from './features/auth/Login.tsx';
import PrivateRoute from './features/auth/PrivateRoute';
import AuthRoute from 'features/auth/AuthRoute';
import { AuthProvider } from 'features/auth/contexts/AuthContext';
import { SnackbarProvider } from 'notistack';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import theme from './theme';
import { injectErrorHandler, injectQueryClient } from 'features/auth/services/authService';
import { ErrorProvider, useError } from 'shared/contexts/ErrorContext';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import WebSocketQueryBridge from 'core/socket/bridge/WebSocketQueryBridge';
import { getAccessToken } from 'shared/utils/storage/tokenStorage';
import socketService from 'core/socket/services/socketService';  // Socket.IO 서비스 임포트
import { HelmetProvider } from 'react-helmet-async';
import { setQueryClient } from 'shared/utils/reactQuery';

// CVEDetail 컴포넌트를 lazy 로딩으로 가져옵니다
const CVEDetail = lazy(() => import('./features/cve/CVEDetail'));
// CacheVisualization 컴포넌트를 lazy 로딩으로 가져옵니다
const CacheVisualization = lazy(() => import('./features/cache/CacheVisualization'));
// ActivitiesPage 컴포넌트를 lazy 로딩으로 가져옵니다
const ActivitiesPage = lazy(() => import('./features/activities/pages/ActivitiesPage'));

// URL 파라미터를 가져와 CVEDetail에 전달하는 래퍼 컴포넌트
const CVEDetailWrapper = () => {
  const params = useParams();
  const cveId = params.cveId;
  const [isOpen, setIsOpen] = useState(true);
  
  // 디버깅을 위한 로깅 추가
  useEffect(() => {
    console.log('[CVEDetailWrapper] 마운트됨, cveId:', cveId);
  }, [cveId]);
  
  const handleClose = useCallback(() => {
    console.log('[CVEDetailWrapper] 닫기 이벤트 발생');
    setIsOpen(false);
    // 닫기 후 목록 페이지로 이동
    window.history.back();
  }, []);

  if (!cveId) {
    console.error('[CVEDetailWrapper] cveId가 없습니다!');
    return <div>CVE ID가 필요합니다</div>;
  }

  console.log('[CVEDetailWrapper] 렌더링:', { cveId, isOpen });
  
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <CVEDetail 
        cveId={cveId}
        open={isOpen}
        onClose={handleClose}
      />
    </Suspense>
  );
};

const MainLayout = React.memo(({ children }) => {
  const [selectedCVE, setSelectedCVE] = useState(null);
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'info'
  });

  const handleSnackbarClose = useCallback(() => {
    setSnackbar(prev => ({ ...prev, open: false }));
  }, []);

  const handleOpenCVEDetail = useCallback((cveId, commentId) => {
    setSelectedCVE(cveId);
  }, []);

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh' }}>
      <Header onOpenCVEDetail={handleOpenCVEDetail} />
      <Box sx={{ display: 'flex', flexGrow: 1, height: 'calc(100vh - 64px)', mt: '64px' }}>
        <Sidebar />
        <Box
          component="main"
          sx={{
            flexGrow: 1,
            p: { xs: 2, md: 4 },
            backgroundColor: '#F8F9FA',
            overflow: 'auto',
            position: 'relative',
            zIndex: 0
          }}
        >
          {React.cloneElement(children, { selectedCVE, setSelectedCVE })}
        </Box>
      </Box>
      <Snackbar
        open={snackbar.open}
        autoHideDuration={5000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
      >
        <Alert 
          onClose={handleSnackbarClose} 
          severity={snackbar.severity} 
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
});

const AuthLayout = ({ children }) => (
  <Box
    sx={{
      minHeight: '100vh',
      backgroundColor: '#F8F9FA'
    }}
  >
    {children}
  </Box>
);

const ErrorHandlerSetup = ({ children }) => {
  const { handleError } = useError();
  
  useEffect(() => {
    injectErrorHandler(handleError);
  }, [handleError]);
  
  return children;
};

const MainRoutes = ({ setSelectedCVE, selectedCVE }) => {
  return (
    <Routes>
      {/* Authentication Routes */}
      <Route
        path="/signup"
        element={
          <AuthRoute>
            <AuthLayout>
              <SignUp />
            </AuthLayout>
          </AuthRoute>
        }
      />
      <Route
        path="/login"
        element={
          <AuthRoute>
            <AuthLayout>
              <Login />
            </AuthLayout>
          </AuthRoute>
        }
      />

      {/* Protected Routes */}
      <Route
        path="/cves"
        element={
          <PrivateRoute>
            <MainLayout>
              <CVEList />
            </MainLayout>
          </PrivateRoute>
        }
      />
      <Route
        path="/cves/:cveId"
        element={
          <PrivateRoute>
            <MainLayout>
              <CVEDetailWrapper />
            </MainLayout>
          </PrivateRoute>
        }
      />
      <Route
        path="/create-cve"
        element={
          <PrivateRoute>
            <MainLayout>
              <CreateCVE />
            </MainLayout>
          </PrivateRoute>
        }
      />
      <Route
        path="/cache"
        element={
          <PrivateRoute>
            <MainLayout>
              <Suspense fallback={<div>로딩 중...</div>}>
                <CacheVisualization />
              </Suspense>
            </MainLayout>
          </PrivateRoute>
        }
      />
      <Route
        path="/activities"
        element={
          <PrivateRoute>
            <MainLayout>
              <Suspense fallback={<div>로딩 중...</div>}>
                <ActivitiesPage />
              </Suspense>
            </MainLayout>
          </PrivateRoute>
        }
      />

      {/* Default Route */}
      <Route
        path="/"
        element={
          getAccessToken() ? <Navigate to="/cves" replace /> : <Navigate to="/login" replace />
        }
      />

      {/* Catch-all Route */}
      <Route path="*" element={<Navigate to="/" replace />} />
      
      {/* Render CVEDetail as modal when selectedCVE is set */}
      {selectedCVE && (
        <Route
          path="*"
          element={
            <Suspense fallback={<div>로딩 중...</div>}>
              <CVEDetail 
                cveId={selectedCVE}
                open={true}
                onClose={() => setSelectedCVE(null)}
              />
            </Suspense>
          }
        />
      )}
    </Routes>
  );
};

// React Query Client 생성
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
      staleTime: 1000 * 60 * 5,  // 5분 스테일 타임
    },
  },
});

// 전역 QueryClient 인스턴스 설정
setQueryClient(queryClient);

// auth.js에 queryClient 주입
injectQueryClient(queryClient);

// Socket.IO 디버깅을 위한 전역 객체 노출
window._socketDebug = socketService;

const App = () => {
  const [selectedCVE, setSelectedCVE] = useState(null);

  // 현재 경로 확인을 위한 추가 상태
  const [currentPath, setCurrentPath] = useState(window.location.pathname);

  // 현재 경로 업데이트 함수
  useEffect(() => {
    // 초기 경로 설정
    setCurrentPath(window.location.pathname);

    // 경로 변경 감지
    const handleRouteChange = () => {
      setCurrentPath(window.location.pathname);
    };

    // popstate 이벤트 리스너 등록 (뒤로가기/앞으로가기 감지)
    window.addEventListener('popstate', handleRouteChange);

    // 정리 함수
    return () => {
      window.removeEventListener('popstate', handleRouteChange);
    };
  }, []);

  // 앱 시작 시 소켓 연결 초기화 (로그인/회원가입 페이지 제외)
  useEffect(() => {
    console.log('[App] Socket connection initialization, current path:', currentPath);
    
    // 로그인/회원가입 페이지인지 확인
    const isAuthPage = currentPath === '/login' || currentPath === '/signup';
    
    // 인증 토큰 확인
    const token = getAccessToken();
    
    if (token && !isAuthPage) {
      console.log('[App] Token exists and not on auth page, connecting socket');
      socketService.connect(token);
    } else if (token && isAuthPage) {
      console.log('[App] On auth page, not connecting socket despite token presence');
      // 인증 페이지에 있을 때는 연결하지 않음
      socketService.disconnect();
    } else {
      console.log('[App] No token, not connecting socket');
    }

    // 앱 종료 시 소켓 연결 정리
    return () => {
      console.log('[App] Cleaning up socket connection');
      socketService.disconnect();
    };
  }, [currentPath]);

  // 인증 상태 변경 감지 및 소켓 연결 업데이트
  useEffect(() => {
    // AuthContext에서 인증 상태 변경 이벤트 구독
    const handleAuthChange = (e) => {
      const isAuthenticated = e.detail.isAuthenticated;
      console.log('[App] Auth state changed:', isAuthenticated);
      
      // 로그인/회원가입 페이지인지 확인
      const isAuthPage = currentPath === '/login' || currentPath === '/signup';
      
      if (isAuthenticated && !isAuthPage) {
        // 인증되었고 인증 페이지가 아닌 경우에만 연결
        socketService.handleAuthStateChange(isAuthenticated);
      } else if (!isAuthenticated) {
        // 인증되지 않은 경우 연결 해제
        socketService.disconnect();
      }
    };

    // 이벤트 리스너 등록
    window.addEventListener('auth-state-changed', handleAuthChange);

    // 정리 함수
    return () => {
      window.removeEventListener('auth-state-changed', handleAuthChange);
    };
  }, [currentPath]);

  // 페이지 가시성 변경 감지
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        console.log('[App] Page visibility changed to visible');
        const token = getAccessToken();
        // 로그인/회원가입 페이지인지 확인
        const isAuthPage = currentPath === '/login' || currentPath === '/signup';
        
        if (token && !socketService.isSocketConnected() && !isAuthPage) {
          console.log('[App] Reconnecting socket on visibility change (not on auth page)');
          socketService.connect(token);
        }
      }
    };

    // 온라인/오프라인 상태 감지
    const handleOnline = () => {
      console.log('[App] Browser went online');
      const token = getAccessToken();
      // 로그인/회원가입 페이지인지 확인
      const isAuthPage = currentPath === '/login' || currentPath === '/signup';
      
      if (token && !socketService.isSocketConnected() && !isAuthPage) {
        console.log('[App] Reconnecting socket on online state (not on auth page)');
        socketService.connect(token);
      }
    };

    // 이벤트 리스너 등록
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('online', handleOnline);

    // 정리 함수
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('online', handleOnline);
    };
  }, [currentPath]);

  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider theme={theme}>
        <HelmetProvider>
          <SnackbarProvider
            maxSnack={3}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
            autoHideDuration={3000}
          >
            <AuthProvider>
              <Router>
                <ErrorProvider>
                  <ErrorHandlerSetup>
                    <CssBaseline />
                    <WebSocketQueryBridge />
                    <MainRoutes setSelectedCVE={setSelectedCVE} selectedCVE={selectedCVE} />
                  </ErrorHandlerSetup>
                </ErrorProvider>
              </Router>
            </AuthProvider>
          </SnackbarProvider>
        </HelmetProvider>
      </ThemeProvider>
    {process.env.NODE_ENV === 'development' && <ReactQueryDevtools />}
    </QueryClientProvider>
  );
};

export default App;


============================================================
File: /home/CVEHub/frontend/src/layout/Navbar_bak.jsx
------------------------------------------------------------
import React, { memo } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
  AppBar,
  Box,
  Toolbar,
  Typography,
  Button,
  IconButton,
  Tooltip
} from '@mui/material';
import { Menu as MenuIcon, ExitToApp as LogoutIcon } from '@mui/icons-material';
import api from 'shared/api/config/axios';
import NotificationBell from './NotificationBell';
import { clearAuthStorage } from 'shared/utils/utils/storage/tokenStorage';

const Navbar = memo(() => {
  const navigate = useNavigate();

  const handleLogout = async () => {
    try {
      // 백엔드 로그아웃 API 호출
      await api.post('/auth/logout');
      
      // 모든 인증 관련 데이터 제거
      clearAuthStorage();
      
      // 로그인 페이지로 리다이렉트
      navigate('/login', { 
        state: { message: 'Successfully logged out' }
      });
    } catch (error) {
      console.error('Logout error:', error);
      // 에러가 발생하더라도 인증 데이터는 클리어하고 로그인 페이지로 이동
      clearAuthStorage();
      navigate('/login');
    }
  };

  return (
    <Box sx={{ flexGrow: 1 }}>
      <AppBar position="static">
        <Toolbar>
          <IconButton
            size="large"
            edge="start"
            color="inherit"
            aria-label="menu"
            sx={{ mr: 2 }}
          >
            <MenuIcon />
          </IconButton>
          
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            CVE Hub
          </Typography>

          <Button
            color="inherit"
            onClick={() => navigate('/cves')}
          >
            CVE List
          </Button>
          
          <Button
            color="inherit"
            onClick={() => navigate('/create-cve')}
          >
            Create CVE
          </Button>

          <NotificationBell />

          <Tooltip title="Logout">
            <IconButton
              color="inherit"
              onClick={handleLogout}
              edge="end"
            >
              <LogoutIcon />
            </IconButton>
          </Tooltip>
        </Toolbar>
      </AppBar>
    </Box>
  );
});

// displayName 추가
Navbar.displayName = 'Navbar';

export default Navbar;



============================================================
File: /home/CVEHub/frontend/src/layout/Sidebar.jsx
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import {
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Box,
  Typography,
  IconButton,
  ListItemButton,
  alpha
} from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import SecurityIcon from '@mui/icons-material/Security';
import StorageIcon from '@mui/icons-material/Storage';
import HistoryIcon from '@mui/icons-material/History';
import MenuIcon from '@mui/icons-material/Menu';
import ChevronLeftIcon from '@mui/icons-material/ChevronLeft';
import { useTheme } from '@mui/material/styles';
import { Link, useLocation } from 'react-router-dom';

const drawerWidth = 240;

const Sidebar = () => {
  const theme = useTheme();
  const location = useLocation();
  // PC 환경에서는 기본적으로 사이드바 오픈
  const [open, setOpen] = useState(true);

  const handleDrawerToggle = () => {
    setOpen(!open);
  };

  return (
    <Drawer
      variant="permanent"
      sx={{
        width: open ? drawerWidth : 64,
        flexShrink: 0,
        '& .MuiDrawer-paper': {
          width: open ? drawerWidth : 64,
          boxSizing: 'border-box',
          background: 'rgba(255, 255, 255, 0.2)',
          backdropFilter: 'blur(10px)',
          borderRight: `1px solid ${alpha(theme.palette.common.white, 0.2)}`,
          overflowX: 'hidden',
          transition: theme.transitions.create('width', {
            easing: theme.transitions.easing.sharp,
            duration: theme.transitions.duration.enteringScreen,
          }),
          boxShadow: `4px 0 20px ${alpha('#000', 0.05)}`,
          mt: '64px', // Header 높이만큼 여백 추가
          height: 'calc(100% - 64px)', // Header 높이 제외
        },
      }}
    >
      <Box sx={{ 
        p: open ? 1.5 : 1, 
        display: 'flex', 
        alignItems: 'center',
        justifyContent: open ? 'flex-end' : 'center',
        borderBottom: `1px solid ${alpha(theme.palette.common.white, 0.2)}`
      }}>
        {open ? (
          <IconButton 
            onClick={handleDrawerToggle}
            sx={{
              color: theme.palette.mode === 'dark' ? '#fff' : '#333',
              '&:hover': {
                backgroundColor: alpha(theme.palette.common.white, 0.1)
              },
              transition: 'transform 0.2s ease',
              '&:hover': {
                transform: 'scale(1.1)',
                backgroundColor: alpha(theme.palette.common.white, 0.1)
              }
            }}
          >
            <ChevronLeftIcon />
          </IconButton>
        ) : (
          <IconButton 
            onClick={handleDrawerToggle} 
            sx={{ 
              color: theme.palette.mode === 'dark' ? '#fff' : '#333',
              '&:hover': {
                backgroundColor: alpha(theme.palette.common.white, 0.1)
              },
              transition: 'transform 0.2s ease',
              '&:hover': {
                transform: 'scale(1.1)',
                backgroundColor: alpha(theme.palette.common.white, 0.1)
              }
            }}
          >
            <MenuIcon />
          </IconButton>
        )}
      </Box>
      <List sx={{ mt: 2 }}>
        <ListItem disablePadding>
          <ListItemButton 
            component={Link} 
            to="/"
            selected={location.pathname === '/'}
            sx={{
              borderRadius: open ? '0 20px 20px 0' : '50%',
              mx: open ? 1 : 'auto',
              my: 0.5,
              pl: open ? 2 : 1.5,
              justifyContent: open ? 'flex-start' : 'center',
              '&.Mui-selected': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.1) 0%, rgba(255, 0, 110, 0.1) 100%)',
              },
              '&:hover': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.05) 0%, rgba(255, 0, 110, 0.05) 100%)',
              }
            }}
          >
            <ListItemIcon sx={{ 
              minWidth: open ? 40 : 'auto',
              color: location.pathname === '/' ? '#3a86ff' : alpha(theme.palette.text.primary, 0.7)
            }}>
              <DashboardIcon />
            </ListItemIcon>
            {open && (
              <ListItemText 
                primary="Dashboard" 
                primaryTypographyProps={{
                  color: location.pathname === '/' ? '#3a86ff' : theme.palette.text.primary,
                  fontWeight: location.pathname === '/' ? 500 : 400,
                  fontSize: '0.95rem'
                }}
              />
            )}
          </ListItemButton>
        </ListItem>
        <ListItem disablePadding>
          <ListItemButton 
            component={Link} 
            to="/cves"
            selected={location.pathname.startsWith('/cves')}
            sx={{
              borderRadius: open ? '0 20px 20px 0' : '50%',
              mx: open ? 1 : 'auto',
              my: 0.5,
              pl: open ? 2 : 1.5,
              justifyContent: open ? 'flex-start' : 'center',
              '&.Mui-selected': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.1) 0%, rgba(255, 0, 110, 0.1) 100%)',
              },
              '&:hover': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.05) 0%, rgba(255, 0, 110, 0.05) 100%)',
              }
            }}
          >
            <ListItemIcon sx={{ 
              minWidth: open ? 40 : 'auto',
              color: location.pathname.startsWith('/cves') ? '#3a86ff' : alpha(theme.palette.text.primary, 0.7)
            }}>
              <SecurityIcon />
            </ListItemIcon>
            {open && (
              <ListItemText 
                primary="CVEs" 
                primaryTypographyProps={{
                  color: location.pathname.startsWith('/cves') ? '#3a86ff' : theme.palette.text.primary,
                  fontWeight: location.pathname.startsWith('/cves') ? 500 : 400,
                  fontSize: '0.95rem'
                }}
              />
            )}
          </ListItemButton>
        </ListItem>
        <ListItem disablePadding>
          <ListItemButton 
            component={Link} 
            to="/cache"
            selected={location.pathname.startsWith('/cache')}
            sx={{
              borderRadius: open ? '0 20px 20px 0' : '50%',
              mx: open ? 1 : 'auto',
              my: 0.5,
              pl: open ? 2 : 1.5,
              justifyContent: open ? 'flex-start' : 'center',
              '&.Mui-selected': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.1) 0%, rgba(255, 0, 110, 0.1) 100%)',
              },
              '&:hover': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.05) 0%, rgba(255, 0, 110, 0.05) 100%)',
              }
            }}
          >
            <ListItemIcon sx={{ 
              minWidth: open ? 40 : 'auto',
              color: location.pathname.startsWith('/cache') ? '#3a86ff' : alpha(theme.palette.text.primary, 0.7)
            }}>
              <StorageIcon />
            </ListItemIcon>
            {open && (
              <ListItemText 
                primary="Cache" 
                primaryTypographyProps={{
                  color: location.pathname.startsWith('/cache') ? '#3a86ff' : theme.palette.text.primary,
                  fontWeight: location.pathname.startsWith('/cache') ? 500 : 400,
                  fontSize: '0.95rem'
                }}
              />
            )}
          </ListItemButton>
        </ListItem>
        
        {/* 변경 내역 조회 메뉴 추가 */}
        <ListItem disablePadding>
          <ListItemButton 
            component={Link} 
            to="/activities"
            selected={location.pathname.startsWith('/activities')}
            sx={{
              borderRadius: open ? '0 20px 20px 0' : '50%',
              mx: open ? 1 : 'auto',
              my: 0.5,
              pl: open ? 2 : 1.5,
              justifyContent: open ? 'flex-start' : 'center',
              '&.Mui-selected': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.1) 0%, rgba(255, 0, 110, 0.1) 100%)',
              },
              '&:hover': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.05) 0%, rgba(255, 0, 110, 0.05) 100%)',
              }
            }}
          >
            <ListItemIcon sx={{ 
              minWidth: open ? 40 : 'auto',
              color: location.pathname.startsWith('/activities') ? '#3a86ff' : alpha(theme.palette.text.primary, 0.7)
            }}>
              <HistoryIcon />
            </ListItemIcon>
            {open && (
              <ListItemText 
                primary="변경 내역" 
                primaryTypographyProps={{
                  color: location.pathname.startsWith('/activities') ? '#3a86ff' : theme.palette.text.primary,
                  fontWeight: location.pathname.startsWith('/activities') ? 500 : 400,
                  fontSize: '0.95rem'
                }}
              />
            )}
          </ListItemButton>
        </ListItem>
        
      </List>
    </Drawer>
  );
};

export default Sidebar;



============================================================
File: /home/CVEHub/frontend/src/layout/Header.tsx
------------------------------------------------------------
import React, { useEffect, useCallback, useMemo, useState } from 'react';
import {
  AppBar,
  Toolbar,
  IconButton,
  Typography,
  Avatar,
  Menu,
  MenuItem,
  Box,
  Tooltip,
  Divider,
  Button,
  useTheme,
  alpha,
  Container,
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useSnackbar } from 'notistack';
import PersonIcon from '@mui/icons-material/Person';
import SettingsIcon from '@mui/icons-material/Settings';
import LogoutIcon from '@mui/icons-material/Logout';
import WifiIcon from '@mui/icons-material/Wifi';
import WifiOffIcon from '@mui/icons-material/WifiOff';
import NotificationBell from '../features/notification/NotificationBell';
import logger from 'shared/utils/logging';
import { useAuth } from 'features/auth/contexts/AuthContext';
import useSocket from 'core/socket/hooks/useSocket';
import SOCKET_EVENTS from 'core/socket/services/constants';
import { getAnimalEmoji } from 'shared/utils/avatarUtils';

interface HeaderProps {
  onOpenCVEDetail?: (cveId: string, commentId?: string) => void;
}

const Header: React.FC<HeaderProps> = ({ onOpenCVEDetail }) => {
  const theme = useTheme();
  const { user, logout } = useAuth();
  
  // 새로운 useSocket 훅 사용
  const socket = useSocket();
  const { connected } = socket;

  const { enqueueSnackbar } = useSnackbar();
  const navigate = useNavigate();
  
  // 소켓 상태 변화 핸들러 - 간소화된 버전
  const handleSocketStateChange = useCallback((data: { state: string }) => {
    logger.debug('Header', '소켓 상태 변경 이벤트 수신', {
      state: data.state,
      connected: connected
    });
    // 핸들러는 단순 로깅만 수행. 상태 업데이트는 내부적으로 이미 처리됨
  }, [connected]);

  // 기존 useSocketEventListener 대신에 useEffect와 socket.on 사용
  useEffect(() => {
    // 이벤트 구독 설정
    const unsubscribe = socket.on(SOCKET_EVENTS.CONNECTION_STATE_CHANGE, handleSocketStateChange);
    
    // 컴포넌트 언마운트 시 구독 해제
    return () => {
      unsubscribe();
    };
  }, [handleSocketStateChange]);
  

  // 재연결 핸들러 - useSocket 사용 방식으로 업데이트
  const handleReconnect = useCallback(() => {
    if (!connected) {
      logger.info('Header', '재연결 시도');
      enqueueSnackbar('서버에 재연결 시도 중...', { variant: 'info' });
      
      // 토큰 새로 받아서 재연결 시도 
      const token = localStorage.getItem('token');
      if (token) {
        // 새로고침으로 연결 재시도
        window.location.reload();
      } else {
        enqueueSnackbar('인증 정보가 없어 재연결할 수 없습니다. 다시 로그인해주세요.', {
          variant: 'warning'
        });
        navigate('/login');
      }
    }
  }, [connected, navigate, enqueueSnackbar]);

  // 사용자 메뉴 관련 상태
  const [anchorElUser, setAnchorElUser] = useState<null | HTMLElement>(null);
  
  const handleOpenUserMenu = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorElUser(event.currentTarget);
  };
  
  const handleCloseUserMenu = () => {
    setAnchorElUser(null);
  };
  
  const handleLogout = async () => {
    handleCloseUserMenu();
    try {
      await logout();
      enqueueSnackbar('로그아웃 되었습니다.', { 
        variant: 'success',
        anchorOrigin: { vertical: 'bottom', horizontal: 'center' }
      });
      navigate('/login');
    } catch (error) {
      console.error('로그아웃 실패:', error);
      enqueueSnackbar('로그아웃 중 오류가 발생했습니다.', { 
        variant: 'error',
        anchorOrigin: { vertical: 'bottom', horizontal: 'center' }
      });
    }
  };
  
  const handleProfileClick = () => {
    handleCloseUserMenu();
    navigate('/profile');
  };
  
  const handleSettingsClick = () => {
    handleCloseUserMenu();
    navigate('/settings');
  };
  
  // 연결 상태 아이콘 - connected 직접 사용
  const connectionIcon = useMemo(() => {
    return connected ? (
      <WifiIcon color="success" fontSize="small" />
    ) : (
      <WifiOffIcon color="error" fontSize="small" />
    );
  }, [connected]);
  
  const userAvatar = useMemo(() => {
    if (!user) return '👤';
    return getAnimalEmoji(user.username || user.email || '');
  }, [user]);

  return (
    <AppBar 
      position="fixed" 
      elevation={0}
      sx={{ 
        height: 'auto',
        minHeight: '64px',
        maxHeight: '64px',
        background: 'rgba(255, 255, 255, 0.2)', 
        backdropFilter: 'blur(10px)',
        borderBottom: `1px solid ${alpha(theme.palette.common.white, 0.2)}`,
        boxShadow: `0 4px 30px ${alpha('#000', 0.1)}`,
        zIndex: theme.zIndex.drawer + 1,
      }}
    >
      <Container maxWidth={false} sx={{ px: { xs: 1, sm: 2 } }}>
        <Toolbar 
          disableGutters
          sx={{ 
            minHeight: '64px',
            py: 0,
            display: 'flex',
            justifyContent: 'space-between'
          }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <Box
              sx={{
                display: 'flex',
                alignItems: 'center',
                cursor: 'pointer',
                transition: 'transform 0.2s ease',
                '&:hover': {
                  transform: 'scale(1.05)'
                }
              }}
              onClick={() => navigate('/')}
            >
              <Box 
                component="img"
                src="/cvehub_logo.png"
                alt="CVEHub Logo"
                sx={{
                  height: '60px',
                  mr: 1
                }}
              />
            </Box>
          </Box>

          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            {/* 웹소켓 연결 상태 */}
            <Tooltip title={connected ? "서버와 실시간 연결 됨" : "서버 연결 끊김 (클릭하여 재연결)"}>
              <span>
                <IconButton
                  size="small"
                  onClick={handleReconnect}
                  disabled={connected}
                  sx={{ 
                    mr: 1,
                    backgroundColor: connected 
                      ? alpha(theme.palette.success.main, 0.1) 
                      : alpha(theme.palette.error.main, 0.1),
                    backdropFilter: 'blur(5px)',
                    border: `1px solid ${alpha(
                      connected ? theme.palette.success.main : theme.palette.error.main, 
                      0.2
                    )}`,
                    '&:hover': { 
                      backgroundColor: connected 
                        ? alpha(theme.palette.success.main, 0.2) 
                        : alpha(theme.palette.error.main, 0.2)
                    }
                  }}
                  aria-label="서버 연결 상태"
                >
                  {connectionIcon}
                </IconButton>
              </span>
            </Tooltip>

            {/* 알림 벨 */}
            {user && (
              <Box 
                sx={{ 
                  mx: 1,
                  transition: 'all 0.3s ease',
                  '& .MuiIconButton-root': {
                    color: '#ff006e'
                  },
                  '& .MuiSvgIcon-root': {
                    fontSize: '1.8rem'
                  }
                }}
              >
                {onOpenCVEDetail ? (
                  <NotificationBell onOpenCVEDetail={onOpenCVEDetail} />
                ) : (
                  <NotificationBell />
                )}
              </Box>
            )}
            
            {/* 사용자 메뉴 */}
            {user ? (
              <Tooltip title={user.displayName || user.username || ''}>
                <IconButton
                  onClick={handleOpenUserMenu}
                  sx={{ 
                    ml: 1,
                    transition: 'transform 0.2s',
                    '&:hover': { transform: 'scale(1.05)' },
                    backgroundColor: 'rgba(255, 255, 255, 0.2)',
                    backdropFilter: 'blur(5px)',
                    border: `1px solid rgba(255, 255, 255, 0.3)`,
                    padding: '4px'
                  }}
                >
                  <Avatar 
                    sx={{ 
                      background: 'linear-gradient(135deg, #3a86ff 0%, #ff006e 100%)',
                      color: theme.palette.common.white,
                      fontWeight: 'bold',
                      boxShadow: `0 0 0 2px rgba(255, 255, 255, 0.3)`
                    }}
                  >
                    {userAvatar}
                  </Avatar>
                </IconButton>
              </Tooltip>
            ) : (
              <Button 
                variant="outlined" 
                color="inherit" 
                onClick={() => navigate('/login')}
                sx={{ 
                  borderRadius: '20px',
                  px: 2,
                  backgroundColor: 'rgba(255, 255, 255, 0.1)',
                  backdropFilter: 'blur(5px)',
                  borderColor: 'rgba(255, 255, 255, 0.3)',
                  color: theme.palette.mode === 'dark' ? '#fff' : '#333',
                  '&:hover': { 
                    borderColor: 'rgba(255, 255, 255, 0.5)',
                    backgroundColor: 'rgba(255, 255, 255, 0.2)'
                  }
                }}
              >
                로그인
              </Button>
            )}
          </Box>

          <Menu
            id="menu-appbar"
            anchorEl={anchorElUser}
            open={Boolean(anchorElUser)}
            onClose={handleCloseUserMenu}
            onClick={handleCloseUserMenu}
            PaperProps={{
              elevation: 0,
              sx: {
                mt: 1.5,
                minWidth: 220,
                overflow: 'visible',
                background: 'rgba(255, 255, 255, 0.8)',
                backdropFilter: 'blur(10px)',
                border: `1px solid rgba(255, 255, 255, 0.3)`,
                borderRadius: '12px',
                boxShadow: `0 10px 30px ${alpha('#000', 0.15)}`,
                '&:before': {
                  content: '""',
                  display: 'block',
                  position: 'absolute',
                  top: 0,
                  right: 14,
                  width: 10,
                  height: 10,
                  background: 'rgba(255, 255, 255, 0.8)',
                  backdropFilter: 'blur(10px)',
                  transform: 'translateY(-50%) rotate(45deg)',
                  zIndex: 0,
                  border: `1px solid rgba(255, 255, 255, 0.3)`,
                  borderBottom: 'none',
                  borderRight: 'none'
                },
                '& .MuiMenuItem-root': {
                  px: 2,
                  py: 1.5,
                  gap: 1.5,
                  borderRadius: '8px',
                  mx: 0.5,
                  my: 0.2,
                  transition: 'all 0.2s ease',
                  '&:hover': {
                    background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.08) 0%, rgba(255, 0, 110, 0.08) 100%)',
                    transform: 'translateX(5px)'
                  }
                },
              },
            }}
            transformOrigin={{ horizontal: 'right', vertical: 'top' }}
            anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
          >
            <Box sx={{ px: 2, py: 1.5 }}>
              {user && (
                <>
                  <Typography variant="subtitle1" component="div" sx={{ fontWeight: 'bold' }}>
                    {user.displayName || user.username || '사용자'}
                  </Typography>
                  <Typography variant="body2" color="text.secondary" sx={{ wordBreak: 'break-all' }}>
                    {user.email || ''}
                  </Typography>
                </>
              )}
            </Box>
            <Divider sx={{ my: 1 }} />
            <MenuItem onClick={handleProfileClick}>
              <PersonIcon fontSize="small" sx={{ color: theme.palette.primary.main }} />
              프로필
            </MenuItem>
            <MenuItem onClick={handleSettingsClick}>
              <SettingsIcon fontSize="small" sx={{ color: theme.palette.primary.main }} />
              설정
            </MenuItem>
            <Divider sx={{ my: 1 }} />
            <MenuItem 
              onClick={handleLogout}
              sx={{ color: theme.palette.error.main }}
            >
              <LogoutIcon fontSize="small" />
              로그아웃
            </MenuItem>
          </Menu>
        </Toolbar>
      </Container>
    </AppBar>
  );
};

export default Header;


============================================================
File: /home/CVEHub/frontend/src/core/socket/types/index.ts
------------------------------------------------------------
/**
 * 웹소켓 관련 타입 정의 파일
 */

import { Socket } from 'socket.io-client';
import SOCKET_EVENTS from '../services/constants';
import { CVEDetail } from 'features/cve/types/cve';
import { User } from 'features/auth/types';

/**
 * 로그 레벨 상수
 */
export enum LOG_LEVEL {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4
}

/**
 * 소켓 설정 상수
 */
export const SOCKET_CONFIG = {
  RECONNECTION: true,
  RECONNECTION_ATTEMPTS: 10,
  RECONNECTION_DELAY: 1000,
  RECONNECTION_DELAY_MAX: 5000,
  TIMEOUT: 20000,
  AUTO_CONNECT: true
};

/**
 * 소켓 경로 상수
 */
export const SOCKET_IO_PATH = '/socket.io';

/**
 * 이벤트 핸들러 타입 정의
 */
export type EventHandler<T = any> = (data: T) => void;

/**
 * 이벤트 핸들러 저장소 인터페이스
 */
export interface EventHandlers {
  [key: string]: EventHandler[];
}

/**
 * 대기 중인 구독 인터페이스
 */
export interface PendingSubscriptions {
  [key: string]: EventHandler[];
}

/**
 * 웹소켓 연결 상태 인터페이스
 */
export interface SocketConnectionState {
  connected: boolean;
  lastConnected?: Date;
  reconnectAttempts?: number;
  error?: Error;
}

/**
 * 소켓 이벤트 콜백 함수 타입
 */
export type SocketEventCallback = (data?: any) => void;

/**
 * 소켓 이벤트 리스너 맵 타입
 */
export interface SocketEventListeners {
  [event: string]: SocketEventCallback[];
}

/**
 * 케이스 변환 옵션 타입
 */
export interface SocketCaseConverterOptions {
  excludeFields?: string[];
  isTopLevel?: boolean;
  [key: string]: any;
}

/**
 * 소켓 옵션 타입
 */
export interface SocketOptions {
  path: string;
  transports: string[];
  reconnection: boolean;
  reconnectionAttempts: number;
  reconnectionDelay: number;
  reconnectionDelayMax: number;
  timeout: number;
  autoConnect: boolean;
  auth: {
    token: string;
    userId?: string; // 인증된 사용자 ID
    username?: string; // 사용자명
    session_id?: string;
    client_id?: string;
  };
  extraHeaders: {
    Authorization: string;
  };
}

/**
 * 소켓 서비스 인터페이스
 */
export interface ISocketIOService {
  socket: Socket | null;
  isConnected: boolean;
  listeners: SocketEventListeners;
  options: SocketOptions | null;
  connect(url?: string): void;
  disconnect(): void;
  on(event: string, callback: SocketEventCallback): () => void;
  addEventListener(event: string, callback: SocketEventCallback): () => void;
  off(event: string, callback: SocketEventCallback): void;
  emit(event: string, data?: any): void;
  isSocketConnected(): boolean;
  getSocket(): Socket | null;
  getConnectionStatus(): boolean;
  handleAuthStateChange(isAuthenticated: boolean): void;
  subscribeCVE(cveId: string): void;
  unsubscribeCVE(cveId: string): void;
  convertKeysRecursive(data: any, toCamelCase: boolean, options?: SocketCaseConverterOptions): any;
}

/**
 * 웹소켓 이벤트 로깅 데이터 타입
 */
export interface WebSocketLogData {
  eventName: string;
  direction: string;
  status: string;
  error?: {
    message: string;
    [key: string]: any;
  };
  message: string;
  context: string;
  dataSummary?: string;
  origin?: string;
  timestamp?: string | number;
}

/**
 * 기본 소켓 메시지 인터페이스
 */
export interface SocketMessage {
  type: string;
  timestamp: string | Date;
  sender?: string;
}

/**
 * 연결 응답 메시지 인터페이스
 */
export interface ConnectionAckMessage {
  user_id: string;
  username: string;
  connected_at: string;
  session_id?: string;
  client_id?: string;
}

/**
 * 세션 정보 응답 메시지 인터페이스
 */
export interface SessionInfoAckMessage {
  session_id: string;
  subscribed_cves: string[];
  last_activity?: string;
}

/**
 * CVE 업데이트 메시지 인터페이스
 */
export interface CVEUpdateMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.CVE_UPDATED;
  cveId: string;
  field_key?: string;
  updateId?: string | number;
  updatedBy?: string;
  data?: Partial<CVEDetail>;
}

/**
 * 구독 상태 메시지 인터페이스
 */
export interface SubscriptionStatusMessage {
  cve_id: string;
  subscribed: boolean;
  subscriber_count: number;
  username: string;
  success: boolean;
  error?: string;
}

/**
 * 댓글 추가 메시지 인터페이스
 */
export interface CommentAddedMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.COMMENT_ADDED;
  cveId: string;
  commentId: string;
  comment: Comment;
  parentId?: string;
}

/**
 * 댓글 업데이트 메시지 인터페이스
 */
export interface CommentUpdatedMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.COMMENT_UPDATED;
  cveId: string;
  commentId: string;
  updatedContent: string;
  updatedAt: string | Date;
}

/**
 * 댓글 삭제 메시지 인터페이스
 */
export interface CommentDeletedMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.COMMENT_DELETED;
  cveId: string;
  commentId: string;
}

/**
 * 사용자 구독 메시지 인터페이스
 */
export interface UserSubscribedMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.USER_ONLINE;
  cveId: string;
  user: Pick<User, 'id' | 'username' | 'displayName' | 'profileImage'>;
}

/**
 * 사용자 구독 취소 메시지 인터페이스
 */
export interface UserUnsubscribedMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.USER_OFFLINE;
  cveId: string;
  userId: string;
}

/**
 * 알림 메시지 인터페이스
 */
export interface NotificationMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.NOTIFICATION;
  notification_id: string;
  message: string;
  related_id?: string;
  related_type?: string;
  user_id: string;
  read: boolean;
  created_at: string;
}

/**
 * 시스템 메시지 인터페이스
 */
export interface SystemMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.SYSTEM_MESSAGE;
  message: string;
  level: 'info' | 'warning' | 'error' | 'success';
  action?: string;
  data?: any;
}

/**
 * 소켓 컨텍스트 인터페이스
 */
export interface SocketContextType {
  socket: Socket | null;
  connected: boolean;
  isReady: boolean;
  error: Error | null;
  connecting: boolean;
  reconnectAttempts: number;
  connect: () => void;
  disconnect: () => void;
  subscribeEvent: <T = any>(event: string, handler: (data: T) => void) => () => void;
  unsubscribeEvent: (event: string, handler: (data: any) => void) => void;
  isSubscribed: (event: string, handler: (data: any) => void) => boolean;
  emit: <T = any>(event: string, data?: T, callback?: (response: any) => void) => boolean;
  subscribeCVEDetail: (cveId: string) => boolean;
  unsubscribeCVEDetail: (cveId: string) => boolean;
  getActiveSubscriptions: () => Record<string, number>;
  subscribeWhenReady: (event: string, handler: EventHandler) => boolean;
  handleAuthStateChange: () => void;
  publishInternalEvent: (event: string, data: any) => void; // 내부 이벤트 발행 함수
}


============================================================
File: /home/CVEHub/frontend/src/core/socket/services/socketEventBus.ts
------------------------------------------------------------
// services/socketEventBus.ts
import { Subject, Observable } from 'rxjs';
import { filter, map } from 'rxjs/operators';
import logger from 'shared/utils/logging';

/**
 * 소켓 이벤트 타입 정의
 */
export interface SocketEvent<T = any> {
  type: string;
  payload: T;
}

/**
 * 소켓 서비스 컴포넌트 간 통신을 위한 이벤트 버스
 * 
 * 이 클래스는 SocketService, SocketEventManager, SocketMetrics 간의
 * 순환 참조를 제거하기 위한 이벤트 중재자 역할을 합니다.
 */
class SocketEventBus {
  private eventSubject = new Subject<SocketEvent>();
  
  /**
   * 이벤트 발행
   * @param type 이벤트 타입
   * @param payload 이벤트 데이터
   */
  publish<T = any>(type: string, payload: T): void {
    logger.debug('SocketEventBus', `이벤트 발행: ${type}`, { type, hasPayload: !!payload });
    this.eventSubject.next({ type, payload });
  }
  
  /**
   * 특정 타입의 이벤트 구독
   * @param type 구독할 이벤트 타입
   * @returns 이벤트 스트림
   */
  on<T = any>(type: string): Observable<T> {
    return this.eventSubject.pipe(
      filter(event => event.type === type),
      map(event => event.payload as T)
    );
  }
  
  /**
   * 모든 이벤트 스트림 가져오기
   * @returns 모든 이벤트 스트림
   */
  allEvents(): Observable<SocketEvent> {
    return this.eventSubject.asObservable();
  }
}

// 싱글톤 인스턴스
const socketEventBus = new SocketEventBus();

export default socketEventBus;



============================================================
File: /home/CVEHub/frontend/src/core/socket/services/socketMetrics.ts
------------------------------------------------------------
// services/socketMetrics.ts
import { Socket } from 'socket.io-client';
import logger from 'shared/utils/logging';
import socketEventBus from './socketEventBus';

/**
 * Socket 연결 품질 및 메트릭 관리 클래스
 * 소켓 연결의 성능 및 품질을 모니터링하고 통계를 수집합니다.
 */
export class SocketMetrics {
  // 연결 진단 및 모니터링
  private pingInterval: NodeJS.Timeout | null = null;
  private pingTimeoutId: NodeJS.Timeout | null = null;
  private lastPingTime: number | null = null;
  
  // 연결 메트릭
  private connectionMetrics = {
    connectAttempts: 0,
    lastConnectTime: null as number | null,
    disconnectCount: 0,
    errorCount: 0,
    lastErrorTime: null as number | null,
    averageLatency: null as number | null,
    pingHistory: [] as number[]
  };
  
  // 소켓 인스턴스 및 상태
  private socket: Socket | null = null;
  private isConnected: boolean = false;
  private connectionState: string = '';
  
  constructor() {
    // 이벤트 버스 구독 설정
    this._setupEventBusSubscriptions();
    
    logger.debug('SocketMetrics', '메트릭 관리자 초기화 완료');
  }
  
  /**
   * 이벤트 버스 구독 설정
   */
  private _setupEventBusSubscriptions(): void {
    // 소켓 인스턴스 생성 이벤트 구독
    socketEventBus.on('socketService:socketCreated').subscribe((socket: Socket) => {
      this.socket = socket;
      logger.debug('SocketMetrics', '소켓 인스턴스 업데이트됨');
    });
    
    // 소켓 연결 이벤트 구독
    socketEventBus.on('socketService:connected').subscribe(() => {
      this.isConnected = true;
      this.startConnectionQualityMonitoring();
      logger.debug('SocketMetrics', '연결 상태 업데이트됨: 연결됨');
    });
    
    // 소켓 연결 해제 이벤트 구독
    socketEventBus.on('socketService:disconnected').subscribe(() => {
      this.isConnected = false;
      this.socket = null;
      this.stopConnectionQualityMonitoring();
      logger.debug('SocketMetrics', '연결 상태 업데이트됨: 연결 해제됨');
    });
    
    // 소켓 연결 상태 업데이트 이벤트 구독
    socketEventBus.on('socketService:connectionState').subscribe((state: string) => {
      this.connectionState = state;
      logger.debug('SocketMetrics', `연결 상태 업데이트됨: ${state}`);
    });
    
    // 소켓 모니터링 요청 이벤트 구독
    socketEventBus.on('socketService:monitorSocket').subscribe((socket: Socket) => {
      this.socket = socket;
      this.startConnectionQualityMonitoring();
    });
  }
  
  /**
   * 연결 품질 모니터링 시작
   */
  startConnectionQualityMonitoring(): void {
    // 소켓 상태 및 이미 실행 중인지 확인
    if (!this.socket || !this.isConnected || this.pingInterval) {
      return;
    }
    
    // 60초 간격으로 핑 측정
    this.pingInterval = setInterval(() => {
      this._measurePing();
    }, 60000);
    
    logger.debug('SocketMetrics', '연결 품질 모니터링 시작');
  }
  
  /**
   * 연결 품질 모니터링 중지
   */
  stopConnectionQualityMonitoring(): void {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
    
    if (this.pingTimeoutId) {
      clearTimeout(this.pingTimeoutId);
      this.pingTimeoutId = null;
    }
    
    logger.debug('SocketMetrics', '연결 품질 모니터링 중지');
  }
  
  /**
   * 핑 측정
   */
  private _measurePing(): void {
    if (!this.socket || !this.isConnected) {
      return;
    }
    
    const startTime = Date.now();
    
    // 핑-퐁 요청
    this.socket.emit('ping', () => {
      const pingTime = Date.now() - startTime;
      
      // 핑 기록 업데이트
      this.connectionMetrics.pingHistory.push(pingTime);
      
      // 최대 10개만 유지
      if (this.connectionMetrics.pingHistory.length > 10) {
        this.connectionMetrics.pingHistory.shift();
      }
      
      // 평균 지연 시간 계산
      const sum = this.connectionMetrics.pingHistory.reduce((a, b) => a + b, 0);
      this.connectionMetrics.averageLatency = 
        this.connectionMetrics.pingHistory.length > 0 
          ? sum / this.connectionMetrics.pingHistory.length 
          : null;
      
      logger.debug('SocketMetrics', '핑 측정 완료', {
        pingTime,
        averageLatency: this.connectionMetrics.averageLatency
      });
    });
    
    // 핑 타임아웃 처리
    this.pingTimeoutId = setTimeout(() => {
      logger.warn('SocketMetrics', '핑 타임아웃 발생');
      this.pingTimeoutId = null;
    }, 5000);
  }
  
  /**
   * 연결 메트릭 가져오기
   */
  getConnectionMetrics(): any {
    return {
      ...this.connectionMetrics,
      currentState: this.connectionState,
      isConnected: this.isConnected,
      socketId: this.socket?.id || null,
      timestamp: new Date().toISOString()
    };
  }
  
  /**
   * 연결 메트릭 업데이트
   * @param metrics 업데이트할 메트릭 객체
   */
  updateConnectionMetrics(metrics: Partial<typeof this.connectionMetrics>): void {
    // 메트릭 업데이트
    Object.assign(this.connectionMetrics, metrics);
    
    logger.debug('SocketMetrics', '연결 메트릭 업데이트됨', metrics);
  }
  
  /**
   * 메트릭 리셋
   */
  resetMetrics(): void {
    this.connectionMetrics = {
      connectAttempts: 0,
      lastConnectTime: null,
      disconnectCount: 0,
      errorCount: 0,
      lastErrorTime: null,
      averageLatency: null,
      pingHistory: []
    };
    
    logger.debug('SocketMetrics', '연결 메트릭 초기화');
  }
}



============================================================
File: /home/CVEHub/frontend/src/core/socket/services/socketEventManager.ts
------------------------------------------------------------
// services/socketEventManager.ts
import { Observable, Subject, fromEvent, EMPTY, throwError } from 'rxjs';
import { shareReplay, map, filter, catchError, retry, takeUntil, finalize } from 'rxjs/operators';
import _ from 'lodash';
import { LRUCache } from 'lru-cache';
import { Socket } from 'socket.io-client';
import logger from 'shared/utils/logging';
import { camelToSnake, snakeToCamel } from 'shared/utils/caseConverter';
import { SUBSCRIPTION_EVENTS } from './constants';
import socketEventBus from './socketEventBus';

import {
  SocketEventCallback,
  SocketEventListeners,
  SocketCaseConverterOptions
} from '../types';

// 변환에서 제외할 필드 목록
const EXCLUDED_FIELDS: string[] = ['id', 'uuid', 'created_at', 'updated_at', 'deleted_at'];

// 구독 관련 이벤트에서 변환이 필요한 필드 매핑
const SUBSCRIPTION_FIELD_MAPPINGS: Record<string, string> = {
  'cve_id': 'cveId',
  'cveId': 'cve_id',
  'user_id': 'userId',
  'userId': 'user_id',
  'display_name': 'displayName',
  'displayName': 'display_name',
  'profile_image': 'profileImage',
  'profileImage': 'profile_image'
};

// 변환 바이패스가 필요한 이벤트 목록
const BYPASS_CONVERSION_EVENTS: string[] = [
  SUBSCRIPTION_EVENTS.SUBSCRIBE_CVE,
  SUBSCRIPTION_EVENTS.UNSUBSCRIBE_CVE,
  SUBSCRIPTION_EVENTS.SUBSCRIPTION_STATUS,
  SUBSCRIPTION_EVENTS.CVE_SUBSCRIBERS_UPDATED
];

/**
 * Socket 이벤트 관리 클래스
 * 이벤트 등록, 발생, 처리 및 케이스 변환을 담당합니다.
 */
export class SocketEventManager {
  // 이벤트 및 리스너 관리
  private listeners: SocketEventListeners = {};
  private eventObservables: Map<string, Observable<any>> = new Map();
  private destroySubjects: Map<string, Subject<void>> = new Map();
  
  // 캐싱 및 성능 최적화
  private eventCache: LRUCache<string, { data: any, timestamp: number }>;
  private caseConversionCache: LRUCache<string, any>;
  
  // 소켓 인스턴스
  private socket: Socket | null = null;
  
  constructor() {
    // 캐시 초기화
    this.eventCache = new LRUCache<string, { data: any, timestamp: number }>({
      max: 100,          // 최대 항목 수
      ttl: 5 * 60000     // 5분 TTL
    });
    
    this.caseConversionCache = new LRUCache<string, any>({
      max: 500,          // 최대 항목 수
      ttl: 10 * 60000    // 10분 TTL
    });
    
    // 이벤트 버스 구독 설정
    this._setupEventBusSubscriptions();
    
    logger.debug('SocketEventManager', '이벤트 관리자 초기화 완료');
  }
  
  /**
   * 이벤트 버스 구독 설정
   */
  private _setupEventBusSubscriptions(): void {
    // 소켓 인스턴스 생성 이벤트 구독
    socketEventBus.on('socketService:socketCreated').subscribe((socket: Socket) => {
      this.socket = socket;
      logger.debug('SocketEventManager', '소켓 인스턴스 업데이트됨');
    });
    
    // 소켓 연결 해제 이벤트 구독
    socketEventBus.on('socketService:disconnected').subscribe(() => {
      this.socket = null;
      logger.debug('SocketEventManager', '소켓 인스턴스 제거됨');
    });
  }
  
  /**
   * 이벤트 리스너 등록
   * @param event 이벤트 이름
   * @param callback 콜백 함수
   * @returns 리스너 제거 함수
   */
  on(event: string, callback: SocketEventCallback): () => void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    
    // 이미 등록된 콜백인지 확인
    const isCallbackRegistered = this.listeners[event].some(cb => cb === callback);
    
    if (!isCallbackRegistered) {
      this.listeners[event].push(callback);
      
      // 소켓이 있는 경우 이벤트 리스너 등록
      if (this.socket) {
        this.socket.on(event, (data: any) => {
          // 데이터 케이스 변환 처리
          const convertedData = this._convertDataCasing(data, {
            direction: 'incoming',
            sourceName: `소켓이벤트[${event}]`,
            eventName: event
          });
          
          callback(convertedData);
        });
      }
      
      logger.debug('SocketEventManager', `이벤트 리스너 등록: ${event}`);
    }
    
    // 이벤트 리스너 제거 함수 반환
    return () => {
      this.off(event, callback);
    };
  }
  
  /**
   * 이벤트 리스너 제거
   * @param event 이벤트 이름
   * @param callback 콜백 함수
   */
  off(event: string, callback: SocketEventCallback): void {
    if (this.listeners[event]) {
      // 콜백 제거
      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
      
      // 소켓이 있는 경우 이벤트 리스너 제거
      if (this.socket) {
        this.socket.off(event);
      }
      
      logger.debug('SocketEventManager', `이벤트 리스너 제거: ${event}`);
    }
  }
  
  /**
   * 모든 리스너 제거
   */
  clearAllListeners(): void {
    // 모든 이벤트 리스너 제거
    for (const event in this.listeners) {
      if (Object.prototype.hasOwnProperty.call(this.listeners, event)) {
        this.listeners[event] = [];
      }
    }
    
    // 소켓 이벤트 리스너 제거
    if (this.socket) {
      this.socket.removeAllListeners();
    }
    
    // 이벤트 관찰자 정리
    this.eventObservables.clear();
    
    // 구독 해제 트리거 및 정리
    this.destroySubjects.forEach((subject) => {
      subject.next();
      subject.complete();
    });
    
    // 구독 해제 주체 정리
    this.destroySubjects.clear();
    
    logger.debug('SocketEventManager', '모든 이벤트 리스너 정리 완료');
  }
  
  /**
   * 이벤트 발생
   * @param event 이벤트 이름
   * @param data 이벤트 데이터
   * @param callback 콜백 함수 (옵션)
   */
  emit(event: string, data?: any, callback?: Function): void {
    // 스로틀링 또는 디바운싱 적용 여부 결정
    if (this._shouldThrottleEvent(event)) {
      // 스로틀링 적용하여 이벤트 발생
      _.throttle(() => this._emitImmediate(event, data, callback), 300)();
    } else if (this._shouldDebounceEvent(event)) {
      // 디바운싱 적용하여 이벤트 발생
      _.debounce(() => this._emitImmediate(event, data, callback), 300)();
    } else {
      // 즉시 이벤트 발생
      this._emitImmediate(event, data, callback);
    }
  }
  
  /**
   * 즉시 이벤트 발생 (내부 메서드)
   */
  private _emitImmediate(event: string, data: any, callback?: Function): void {
    if (!this.socket) {
      // 소켓이 연결되지 않은 경우 소켓 인스턴스 요청
      socketEventBus.publish('socketManager:getSocket', null);
      logger.warn('SocketEventManager', '소켓 연결이 없는 상태에서 이벤트 발생 시도', {
        event,
        hasData: !!data
      });
      return;
    }
    
    try {
      // 데이터 케이스 변환 처리 (서버 형식으로 변환)
      const convertedData = this._convertDataCasing(data, {
        direction: 'outgoing',
        sourceName: `emit[${event}]`,
        eventName: event
      });
      
      // 이벤트 발생
      if (callback) {
        this.socket.emit(event, convertedData, callback);
      } else {
        this.socket.emit(event, convertedData);
      }
      
      logger.debug('SocketEventManager', `이벤트 발생: ${event}`, {
        event,
        hasData: !!data
      });
    } catch (error) {
      logger.error('SocketEventManager', `이벤트 발생 중 오류: ${event}`, error);
    }
  }
  
  /**
   * 이벤트 스로틀링 적용 여부 결정
   */
  private _shouldThrottleEvent(event: string): boolean {
    // 스로틀링이 필요한 이벤트 목록
    const throttleEvents = [
      'typing',
      'cursor_position',
      'scroll_position'
    ];
    
    return throttleEvents.includes(event);
  }
  
  /**
   * 이벤트 디바운싱 적용 여부 결정
   */
  private _shouldDebounceEvent(event: string): boolean {
    // 디바운싱이 필요한 이벤트 목록
    const debounceEvents = [
      'search_query',
      'filter_change'
    ];
    
    return debounceEvents.includes(event);
  }
  
  /**
   * Observable 형태로 이벤트 구독
   * @param event 이벤트 이름
   * @returns 이벤트 스트림
   */
  fromEvent<T = any>(eventName: string, componentId: string = 'global'): Observable<T> {
    const cacheKey = `${eventName}_${componentId}`;
    const socket = this.socket as Socket;
    
    // 캐시된 Observable이 있으면 반환
    if (this.eventObservables.has(cacheKey)) {
      return this.eventObservables.get(cacheKey) as Observable<T>;
    }
    
    // 소켓 상태 및 인스턴스 확인
    if (!socket) {
      logger.warn('SocketEventManager', `소켓 인스턴스가 없어 이벤트 스트림 생성 불가: ${eventName}`);
      return EMPTY;
    }
    
    // 컴포넌트별 정리를 위한 Subject 생성 또는 가져오기
    if (!this.destroySubjects.has(componentId)) {
      this.destroySubjects.set(componentId, new Subject<void>());
    }
    const destroySubject = this.destroySubjects.get(componentId)!;
    
    // fromEvent를 사용하여 소켓 이벤트를 Observable로 변환
    const observable = fromEvent<T>(socket, eventName).pipe(
      // 데이터 케이스 변환 및 로깅
      map(data => {
        logger.debug('SocketEventManager', `이벤트 수신: ${eventName}`, data);
        // 데이터 케이스 변환 처리 (snake_case -> camelCase)
        return this._convertDataCasing(data, {
          direction: 'incoming',
          eventName: eventName
        }) as T;
      }),
      // 오류 처리
      catchError(error => {
        logger.error('SocketEventManager', `이벤트 처리 중 오류: ${eventName}`, error);
        return throwError(() => error);
      }),
      // 자동 재시도 (최대 3회)
      retry({ count: 3, delay: 1000 }),
      // 컴포넌트 언마운트 시 구독 해제
      takeUntil(destroySubject),
      // 여러 구독자가 동일한 Observable을 공유하도록 설정
      shareReplay(1),
      // 완료 시 정리
      finalize(() => {
        logger.debug('SocketEventManager', `이벤트 스트림 종료: ${eventName}`);
        this.eventObservables.delete(cacheKey);
      })
    );
    
    // 캐시에 저장
    this.eventObservables.set(cacheKey, observable);
    
    return observable;
  }
  
  /**
   * 컴포넌트 정리
   */
  cleanup(componentId: string): void {
    if (this.destroySubjects.has(componentId)) {
      const subject = this.destroySubjects.get(componentId)!;
      subject.next();
      subject.complete();
      this.destroySubjects.delete(componentId);
      
      // 해당 컴포넌트와 관련된 모든 캐시된 Observable 제거
      const keysToRemove: string[] = [];
      this.eventObservables.forEach((_, key) => {
        if (key.endsWith(`_${componentId}`)) {
          keysToRemove.push(key);
        }
      });
      
      keysToRemove.forEach(key => {
        this.eventObservables.delete(key);
      });
      
      logger.debug('SocketEventManager', `컴포넌트 정리 완료: ${componentId}`);
    }
  }
  
  /**
   * 데이터 케이스 변환 처리
   * @param data 변환할 데이터
   * @param options 변환 옵션
   * @returns 변환된 데이터
   */
  private _convertDataCasing(data: any, options?: SocketCaseConverterOptions): any {
    // 캐시 키 생성
    const cacheKey = this._createCacheKey(data, options);
    if (cacheKey && this.caseConversionCache.has(cacheKey)) {
      return this.caseConversionCache.get(cacheKey);
    }
    
    // 기본 옵션 설정
    const direction = options?.direction || 'incoming';
    const converter = direction === 'outgoing' ? camelToSnake : snakeToCamel;
    const sourceName = options?.sourceName || '알 수 없는 소스';
    const eventName = options?.eventName || '';
    
    // 구독 관련 이벤트는 특별 처리
    const isSubscriptionEvent = BYPASS_CONVERSION_EVENTS.includes(eventName);
    
    try {
      // null 처리
      if (data === null) {
        return null;
      }
      
      // 데이터 타입에 따라 변환 처리
      if (typeof data === 'object') {
        // 배열 처리
        if (Array.isArray(data)) {
          const result = data.map(item => this._convertDataCasing(item, options));
          
          // 캐시에 저장
          if (cacheKey) {
            this.caseConversionCache.set(cacheKey, result);
          }
          
          return result;
        }
        
        // 객체 처리
        const result: Record<string, any> = {};
        
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            // 구독 관련 이벤트에서 특정 필드 처리
            if (isSubscriptionEvent && (key in SUBSCRIPTION_FIELD_MAPPINGS)) {
              const mappedKey = SUBSCRIPTION_FIELD_MAPPINGS[key];
              
              // 방향에 따라 매핑된 키 또는 원래 키 사용
              result[direction === 'outgoing' ? mappedKey : key] = data[key];
              continue;
            }
            
            // 변환에서 제외할 필드 확인
            if (EXCLUDED_FIELDS.includes(key)) {
              result[key] = data[key];
              continue;
            }
            
            // 일반 필드는 케이스 변환 적용
            const convertedKey = converter(key);
            
            // 중첩된 객체나 배열은 재귀적으로 처리
            if (typeof data[key] === 'object' && data[key] !== null) {
              result[convertedKey] = this._convertDataCasing(data[key], options);
            } else {
              result[convertedKey] = data[key];
            }
          }
        }
        
        // 구독 관련 이벤트에서 특정 필드 추가 처리 (양방향 호환성 보장)
        if (isSubscriptionEvent && typeof data === 'object' && !Array.isArray(data)) {
          // cve_id와 cveId 동시 지원
          if ('cve_id' in data && !('cveId' in data)) {
            result.cveId = data.cve_id;
          } else if ('cveId' in data && !('cve_id' in data)) {
            result.cve_id = data.cveId;
          }
        }
        
        // 캐시에 저장
        if (cacheKey) {
          this.caseConversionCache.set(cacheKey, result);
        }
        
        return result;
      }
      
      // 객체나 배열이 아닌 경우 원래 값 반환
      return data;
    } catch (error) {
      logger.error('SocketEventManager', '데이터 케이스 변환 중 오류 발생', error);
      return data;
    }
  }
  
  /**
   * 캐시 키 생성
   */
  private _createCacheKey(data: any, options?: SocketCaseConverterOptions): string | null {
    if (!data || typeof data !== 'object') {
      return null;
    }
    
    try {
      const direction = options?.direction || 'incoming';
      const sourceName = options?.sourceName || '';
      
      // 간단한 객체는 직접 키 생성
      if (!Array.isArray(data) && Object.keys(data).length <= 5) {
        return `${direction}:${sourceName}:${JSON.stringify(data)}`;
      }
      
      // 복잡한 객체는 일부 프로퍼티와 길이 기반 키 생성
      const keys = Object.keys(data);
      const keyPreview = keys.slice(0, 3).join(',');
      
      if (Array.isArray(data)) {
        return `${direction}:${sourceName}:array:${data.length}:${keyPreview}`;
      }
      
      return `${direction}:${sourceName}:object:${keys.length}:${keyPreview}`;
    } catch (error) {
      return null;
    }
  }
  
  /**
   * 재귀적 키 변환 (인터페이스 구현용)
   */
  convertKeysRecursive(data: any, toCamelCase: boolean, options?: SocketCaseConverterOptions): any {
    const direction = toCamelCase ? 'incoming' : 'outgoing';
    return this._convertDataCasing(data, { ...options, direction });
  }
}



============================================================
File: /home/CVEHub/frontend/src/core/socket/services/socketService.ts
------------------------------------------------------------
// services/socketService.ts
import { io, Socket, ManagerOptions, SocketOptions as IOSocketOptions } from 'socket.io-client';
import { Observable, Subject, fromEvent, EMPTY, throwError, BehaviorSubject } from 'rxjs';
import { shareReplay, map, filter, catchError, retry, takeUntil, finalize } from 'rxjs/operators';
import _ from 'lodash';
import { getAccessToken } from 'shared/utils/storage/tokenStorage';
import logger from 'shared/utils/logging';
import socketStoreAdapter from './socketStoreAdapter';
import { socketActions } from '../state/socketStore';
import { getQueryClient } from 'shared/utils/reactQuery';
import socketEventBus from './socketEventBus';
import {
  SOCKET_EVENTS,
  SOCKET_STATE,
  CONNECTION_EVENTS
} from './constants';
import {
  SocketEventCallback,
  SocketOptions
} from '../types';
import { SocketEventManager } from 'core/socket/services/socketEventManager';
import { SocketMetrics } from 'core/socket/services/socketMetrics';

// Socket.io 경로 상수 (constants.ts에 없어서 여기에 직접 정의)
const SOCKET_IO_PATH = '/socket.io';

// 추가 소켓 상태 정의
const EXTENDED_SOCKET_STATE = {
  ...SOCKET_STATE,
  DISCONNECTING: 'disconnecting'
};

/**
 * Socket.IO 서비스 클래스
 * 
 * WebSocket 통신을 관리하고 RxJS를 통한 이벤트 스트림 처리를 제공합니다.
 * 이 클래스는 싱글톤 패턴으로 구현되어 애플리케이션 전체에서 일관된 소켓 연결을 유지합니다.
 */
class SocketService {
  // === 소켓 및 연결 상태 관리 ===
  socket: Socket | null = null;
  isConnected: boolean = false;
  private _connectionState: string = SOCKET_STATE.DISCONNECTED;
  private connectionStateSubject: BehaviorSubject<string>;
  private autoReconnectEnabled: boolean = true;
  private maxReconnectAttempts: number = 10;
  private currentReconnectAttempts: number = 0;
  
  // === 이벤트 및 리스너 관리 ===
  private options: SocketOptions | null = null;
  
  // 이벤트 관리자 및 메트릭 매니저
  private eventManager: SocketEventManager;
  private metricsManager: SocketMetrics;
  
  constructor() {
    // 상태 초기화
    this.connectionStateSubject = new BehaviorSubject<string>(SOCKET_STATE.DISCONNECTED);
    
    // 이벤트 버스에 초기 소켓 서비스 생성 이벤트 발행
    socketEventBus.publish('socketService:created', null);
    
    // 이벤트 관리자 및 메트릭 매니저 초기화 (직접 참조 없이 생성)
    this.eventManager = new SocketEventManager();
    this.metricsManager = new SocketMetrics();
    
    // 브라우저 환경에서 이벤트 리스너 설정
    if (typeof window !== 'undefined') {
      this._setupBrowserListeners();
    }
    
    // 이벤트 구독 설정
    this._setupEventBusSubscriptions();
  }
  
  /**
   * 이벤트 버스 구독 설정
   */
  private _setupEventBusSubscriptions(): void {
    // 소켓 인스턴스 요청 이벤트 구독
    socketEventBus.on('socketManager:getSocket').subscribe(() => {
      socketEventBus.publish('socketService:socket', this.socket);
    });
    
    // 연결 상태 요청 이벤트 구독
    socketEventBus.on('socketManager:getConnectionState').subscribe(() => {
      socketEventBus.publish('socketService:connectionState', this._connectionState);
    });
    
    // 연결 품질 모니터링 시작 요청 이벤트 구독
    socketEventBus.on('metrics:startMonitoring').subscribe(() => {
      // 소켓 인스턴스를 이벤트 페이로드로 전달
      if (this.socket) {
        socketEventBus.publish('socketService:monitorSocket', this.socket);
      }
    });
  }
  
  /**
   * 소켓 연결 생성
   * @param token JWT 토큰 (옵션)
   * @returns 소켓 인스턴스
   */
  connect(token?: string): Socket {
    try {
      // 이미 연결된 경우 기존 소켓 반환
      if (this.socket && this.isConnected) {
        return this.socket;
      }
      
      // 토큰이 없는 경우 토큰 가져오기 시도
      const accessToken = token || getAccessToken();
      
      // 토큰이 없으면 실패 처리
      if (!accessToken) {
        this._updateConnectionState(SOCKET_STATE.AUTH_ERROR);
        throw new Error('인증 토큰이 없어 WebSocket 연결을 시작할 수 없습니다.');
      }
      
      // 소켓 옵션 생성
      this.options = this._createOptions(accessToken);
      
      if (!this.options) {
        this._updateConnectionState(SOCKET_STATE.CONFIG_ERROR);
        throw new Error('WebSocket 설정을 생성할 수 없습니다.');
      }
      
      // 연결 상태 업데이트
      this._updateConnectionState(SOCKET_STATE.CONNECTING);
      
      // Socket.IO 인스턴스 생성
      const socketURL = this._getSocketIOURL();
      this.socket = io(socketURL, this.options);
      socketStoreAdapter.registerSocket(this.socket);
      
      // 이벤트 핸들러 설정
      this._setupEventHandlers();
      
      // 개발 환경에서 디버그 로깅 설정
      if (process.env.NODE_ENV === 'development') {
        this._setupDebugLogging();
      }
      
      // 소켓 인스턴스 생성 이벤트 발행
      if (this.socket) {
        socketEventBus.publish('socketService:socketCreated', this.socket);
      }
      
      // 메트릭 수집 시작 이벤트 발행
      socketEventBus.publish('socketService:connected', null);
      
      return this.socket;
    } catch (error) {
      this._updateConnectionState(SOCKET_STATE.ERROR);
      logger.error('SocketService', 'Socket.IO 연결 실패', error);
      throw error;
    }
  }
  
  /**
   * 소켓 연결 해제
   */
  disconnect(): void {
    if (!this.socket) {
      return;
    }
    
    try {
      logger.info('SocketService', '소켓 연결 해제 시작');
      
      // 연결 상태 업데이트
      this._updateConnectionState(EXTENDED_SOCKET_STATE.DISCONNECTING);
      
      // 연결 해제 이벤트 발행
      socketEventBus.publish('socketService:disconnecting', null);
      
      // 자동 재연결 비활성화
      this.autoReconnectEnabled = false;
      
      // 소켓 연결 해제
      this.socket.disconnect();
      this.socket = null;
      this.isConnected = false;
      
      // 연결 상태 업데이트
      this._updateConnectionState(SOCKET_STATE.DISCONNECTED);
      
      // 연결 해제 완료 이벤트 발행
      socketEventBus.publish('socketService:disconnected', null);
      
      logger.info('SocketService', '소켓 연결 해제 완료');
    } catch (error) {
      logger.error('SocketService', '소켓 연결 해제 중 오류 발생', error);
    }
  }

  /**
   * 개발 환경에서 디버그 로깅 설정
   */
  private _setupDebugLogging(): void {
    if (!this.socket || process.env.NODE_ENV !== 'development') {
      return;
    }
    
    // 디버그 모드 활성화
    this.socket.onAny((event, ...args) => {
      console.log(`[소켓 수신] ${event}:`, ...args);
    });
    
    // 원본 emit 함수 저장
    const originalEmit = this.socket.emit;
    
    // emit 함수 오버라이드 (로깅 추가)
    this.socket.emit = function (event: string, ...args: any[]): any {
      console.log(`[소켓 전송] ${event}:`, ...args);
      return originalEmit.apply(this, [event, ...args]);
    };
  }
  
  /**
   * 소켓 연결 상태 확인
   */
  isSocketConnected(): boolean {
    return this.socket !== null && this.isConnected;
  }
  
  /**
   * 소켓 인스턴스 가져오기
   */
  getSocket(): Socket | null {
    return this.socket;
  }
  
  /**
   * 연결 상태 가져오기
   */
  getConnectionStatus(): boolean {
    return this.isConnected;
  }
  
  /**
   * 인증 상태 변경 처리
   * @param isAuthenticated 인증 여부
   */
  handleAuthStateChange(isAuthenticated: boolean): void {
    if (isAuthenticated) {
      // 인증되었으면 연결 시도
      if (!this.isConnected && !this.socket) {
        this.connect();
      }
    } else {
      // 인증이 해제되었으면 연결 해제
      if (this.isConnected || this.socket) {
        this.disconnect();
      }
    }
  }
  
  /**
   * Socket.IO URL 가져오기
   */
  private _getSocketIOURL(): string {
    const host = window.location.hostname;
    const port = process.env.NODE_ENV === 'development' ? '8000' : window.location.port;
    return `${window.location.protocol}//${host}${port ? `:${port}` : ''}`;
  }
  
  /**
   * 소켓 옵션 생성
   */
  private _createOptions(token: string): SocketOptions | null {
    if (!token) {
      return null;
    }
    
    return {
      autoConnect: true,
      reconnection: true,
      reconnectionAttempts: this.maxReconnectAttempts,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      timeout: 20000,
      transports: ['websocket'],
      auth: {
        token
      },
      path: SOCKET_IO_PATH,
      extraHeaders: {
        Authorization: `Bearer ${token}`
      }
    };
  }
  
  /**
   * 연결 상태 업데이트
   */
  private _updateConnectionState(state: string): void {
    if (this._connectionState === state) {
      return;
    }
    
    this._connectionState = state;
    this.connectionStateSubject.next(state);
    
    // 상태 변경 이벤트 발생
    socketStoreAdapter.dispatch(() => {
      socketActions.updateConnectionState({
        connectionState: state,
        isConnected: state === SOCKET_STATE.CONNECTED
      });
    });
    
    // 로그 출력
    logger.debug('SocketService', '소켓 연결 상태 변경', { state });
  }
  
  /**
   * 이벤트 핸들러 설정
   */
  private _setupEventHandlers(): void {
    if (!this.socket) {
      return;
    }
    
    // 주요 연결 이벤트 설정
    this.socket.on(CONNECTION_EVENTS.CONNECT, this._handleConnect.bind(this));
    this.socket.on(CONNECTION_EVENTS.DISCONNECT, this._handleDisconnect.bind(this));
    this.socket.on(CONNECTION_EVENTS.CONNECT_ERROR, this._handleConnectError.bind(this));
    
    // 재연결 관련 이벤트
    this.socket.on(CONNECTION_EVENTS.RECONNECT_ATTEMPT, (attempt: number) => {
      this._updateConnectionState(SOCKET_STATE.RECONNECTING);
      logger.debug('SocketService', '소켓 재연결 시도', { attempt });
    });
    
    this.socket.on(CONNECTION_EVENTS.RECONNECT, () => {
      this._updateConnectionState(SOCKET_STATE.CONNECTED);
      logger.debug('SocketService', '소켓 재연결 성공');
    });
  }
  
  /**
   * 연결 이벤트 핸들러
   */
  private _handleConnect(): void {
    this.isConnected = true;
    this.currentReconnectAttempts = 0;
    this._updateConnectionState(SOCKET_STATE.CONNECTED);
    
    // 연결 메트릭 업데이트
    this.metricsManager.updateConnectionMetrics({
      lastConnectTime: Date.now(),
      connectAttempts: this.metricsManager.getConnectionMetrics().connectAttempts + 1
    });
    
    logger.info('SocketService', '소켓 연결 성공');
    
    // React Query 클라이언트 무효화 (선택적)
    if (getQueryClient()) {
      getQueryClient().invalidateQueries({ queryKey: ['socket-connected'] });
    }
    
    // 서버로 사용자 정보 전송 (필요시)
    if (this.socket) {
      this.emit('client_connected', { timestamp: new Date().toISOString() });
    }
  }
  
  /**
   * 연결 해제 이벤트 핸들러
   */
  private _handleDisconnect(reason: string): void {
    this.isConnected = false;
    this._updateConnectionState(SOCKET_STATE.DISCONNECTED);
    
    // 메트릭 업데이트
    this.metricsManager.updateConnectionMetrics({
      disconnectCount: this.metricsManager.getConnectionMetrics().disconnectCount + 1
    });
    
    logger.info('SocketService', '소켓 연결 해제', { reason });
    
    // 자동 재연결 처리
    if (this.autoReconnectEnabled && this.currentReconnectAttempts < this.maxReconnectAttempts) {
      this._attemptReconnect();
    }
  }
  
  /**
   * 연결 오류 이벤트 핸들러
   */
  private _handleConnectError(error: any): void {
    this.isConnected = false;
    this._updateConnectionState(SOCKET_STATE.ERROR);
    
    // 메트릭 업데이트
    this.metricsManager.updateConnectionMetrics({
      errorCount: this.metricsManager.getConnectionMetrics().errorCount + 1,
      lastErrorTime: Date.now()
    });
    
    // 에러 로깅
    logger.error('SocketService', '소켓 연결 오류', error);
    
    // 자동 재연결 로직
    if (this.autoReconnectEnabled && this.currentReconnectAttempts < this.maxReconnectAttempts) {
      this._attemptReconnect();
    } else if (this.currentReconnectAttempts >= this.maxReconnectAttempts) {
      logger.error('SocketService', '최대 재연결 시도 횟수 초과');
      this._updateConnectionState(SOCKET_STATE.FAILED);
    }
  }
  
  /**
   * 브라우저 이벤트 리스너 설정
   */
  private _setupBrowserListeners(): void {
    // 페이지 가시성 변경 이벤트
    document.addEventListener('visibilitychange', this._handleVisibilityChange.bind(this));
    
    // 온라인/오프라인 상태 변경 이벤트
    window.addEventListener('online', this._handleOnlineStatus.bind(this));
    window.addEventListener('offline', this._handleOfflineStatus.bind(this));
    
    // 페이지 언로드 이벤트
    window.addEventListener('beforeunload', () => {
      if (this.socket && this.isConnected) {
        this.socket.emit('client_disconnecting');
      }
    });
  }
  
  /**
   * 페이지 가시성 변경 처리
   */
  private _handleVisibilityChange(): void {
    if (document.visibilityState === 'visible') {
      // 페이지가 다시 표시되면 연결 상태 확인 및 필요시 재연결
      if (this.socket && !this.isConnected && this.autoReconnectEnabled) {
        logger.debug('SocketService', '페이지 포커스로 재연결 시도');
        this._attemptReconnect();
      }
      
      // 활성 상태 알림 (옵션)
      if (this.socket && this.isConnected) {
        this.socket.emit('client_active');
      }
    } else if (document.visibilityState === 'hidden') {
      // 페이지가 숨겨지면 활동 중지 상태 알림 (옵션)
      if (this.socket && this.isConnected) {
        this.socket.emit('client_inactive');
      }
    }
  }
  
  /**
   * 온라인 상태 처리
   */
  private _handleOnlineStatus(): void {
    logger.debug('SocketService', '네트워크 온라인 상태 감지');
    
    if (!this.isConnected && this.autoReconnectEnabled) {
      this._attemptReconnect();
    }
  }
  
  /**
   * 오프라인 상태 처리
   */
  private _handleOfflineStatus(): void {
    logger.debug('SocketService', '네트워크 오프라인 상태 감지');
    this._updateConnectionState(SOCKET_STATE.OFFLINE);
  }
  
  /**
   * 재연결 시도
   */
  private _attemptReconnect(): void {
    // 이미 연결 중이거나 재연결 중인 경우 건너뛰기
    if (
      this.isConnected || 
      this._connectionState === SOCKET_STATE.CONNECTING || 
      this._connectionState === SOCKET_STATE.RECONNECTING
    ) {
      return;
    }
    
    this.currentReconnectAttempts++;
    this._updateConnectionState(SOCKET_STATE.RECONNECTING);
    
    // 지수 백오프 사용한 재연결 지연 계산
    const delay = this._calculateReconnectDelay();
    
    logger.debug('SocketService', '소켓 재연결 시도 예약', {
      attempt: this.currentReconnectAttempts,
      delay,
      maxAttempts: this.maxReconnectAttempts
    });
    
    // 지연 후 재연결
    setTimeout(() => {
      if (!this.isConnected && this.autoReconnectEnabled) {
        this.connect();
      }
    }, delay);
  }
  
  /**
   * 지수 백오프를 사용한 재연결 지연 시간 계산
   */
  private _calculateReconnectDelay(): number {
    // 기본 지연 시간 (1초)
    const baseDelay = 1000;
    
    // 최대 지연 시간 (1분)
    const maxDelay = 60000;
    
    // 무작위성 추가 (지터)
    const jitter = 0.5 * Math.random();
    
    // 지수 백오프 계산 (2^n * 기본지연)
    const exponentialDelay = Math.min(
      maxDelay,
      baseDelay * Math.pow(2, this.currentReconnectAttempts - 1)
    );
    
    // 지터를 적용한 최종 지연 시간
    return Math.floor(exponentialDelay * (1 + jitter));
  }
  
  /**
   * 이벤트 구독
   * @param event 이벤트 이름
   * @param callback 콜백 함수
   * @returns 구독 해제 함수
   */
  on(event: string, callback: SocketEventCallback): () => void {
    return this.eventManager.on(event, callback);
  }
  
  /**
   * addEventListener는 on의 별칭으로 구현
   */
  addEventListener(event: string, callback: SocketEventCallback): () => void {
    return this.on(event, callback);
  }
  
  /**
   * 이벤트 구독 해제
   * @param event 이벤트 이름
   * @param callback 콜백 함수
   */
  off(event: string, callback: SocketEventCallback): void {
    this.eventManager.off(event, callback);
  }
  
  /**
   * removeEventListener는 off의 별칭으로 구현
   */
  removeEventListener(event: string, callback: SocketEventCallback): void {
    this.off(event, callback);
  }
  
  /**
   * 이벤트 발생
   * @param event 이벤트 이름
   * @param data 이벤트 데이터
   */
  emit(event: string, data?: any): void {
    this.eventManager.emit(event, data);
  }
  
  /**
   * Observable 형태로 이벤트 구독
   * @param event 이벤트 이름
   * @returns 이벤트 스트림
   */
  fromEvent<T = any>(event: string): Observable<T> {
    return this.eventManager.fromEvent<T>(event);
  }
  
  /**
   * 연결 상태 변경 이벤트 스트림
   */
  connectionState$(): Observable<string> {
    return this.connectionStateSubject.asObservable();
  }
  
  /**
   * 연결 품질 메트릭 가져오기
   */
  getConnectionMetrics(): any {
    return this.metricsManager.getConnectionMetrics();
  }
  
  /**
   * 특정 CVE 구독 상태 업데이트
   * @param cveId CVE ID
   * @param isSubscribed 구독 상태
   */
  updateSubscription(cveId: string, isSubscribed: boolean): void {
    try {
      const socket = this.socket;
      
      // 구독 이벤트 처리 및 전송
      if (isSubscribed) {
        // 구독 추가
        logger.debug('SocketService', `CVE 구독 업데이트: ${cveId} (구독)`, { isSubscribed });
        
        // 소켓이 연결된 경우 서버에 이벤트 전송
        if (socket && this.isConnected) {
          this.emit('subscribe_cve', { cve_id: cveId });
        }
      } else {
        // 구독 취소
        logger.debug('SocketService', `CVE 구독 업데이트: ${cveId} (구독 취소)`, { isSubscribed });
        
        // 소켓이 연결된 경우 서버에 이벤트 전송
        if (socket && this.isConnected) {
          this.emit('unsubscribe_cve', { cve_id: cveId });
        }
      }
    } catch (error) {
      logger.error('SocketService', '구독 상태 업데이트 중 오류 발생', error);
    }
  }
}

// 싱글톤 인스턴스 생성
const socketService = new SocketService();

export default socketService;


============================================================
File: /home/CVEHub/frontend/src/core/socket/services/socketStoreAdapter.ts
------------------------------------------------------------
import { Socket } from 'socket.io-client';
import { CONNECTION_EVENTS, SOCKET_STATE } from './constants';
import logger from 'shared/utils/logging';
import _ from 'lodash';
import useSocketStore, { socketActions } from '../state/socketStore';

/**
 * Socket.IO 서비스와 Zustand 스토어 간의 어댑터
 * 
 * 이 클래스는 Socket.IO 서비스의 이벤트와 상태를 Zustand 스토어에 동기화하는 역할을 합니다.
 * 소켓 연결 상태 변화, 이벤트 발생, 오류 처리 등을 감지하여 중앙화된 스토어에 반영합니다.
 * 이를 통해 애플리케이션 전체에서 일관된 소켓 상태를 유지하고 접근할 수 있습니다.
 */
class SocketStoreAdapter {
  private networkListenersAttached: boolean = false;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private connectionDiagnostics = {
    lastConnectedTime: null as Date | null,
    reconnectAttempts: 0,
    maxReconnectAttempts: 5,
    pingTimes: [] as number[]
  };

  /**
   * 생성자
   * 
   * 네트워크 상태 변화 감지 초기화를 수행합니다.
   */
  constructor() {
    // 네트워크 상태 변화 감지 초기화
    this.handleNetworkStatusChange();
  }

  /**
   * 소켓 인스턴스를 스토어에 등록합니다.
   * 
   * 새 소켓 인스턴스가 생성되면 이 메서드를 통해 Zustand 스토어에 등록합니다.
   * 소켓 이벤트 리스너를 설정하고 네트워크 상태 모니터링을 시작합니다.
   * 
   * @param socket - 등록할 Socket.IO 소켓 인스턴스
   */
  registerSocket(socket: Socket | null): void {
    socketActions.setSocket(socket);
    
    if (socket) {
      this.setupSocketListeners(socket);
      this.handleReconnection(socket);
    }
  }
  
  /**
   * 소켓 이벤트 리스너를 설정합니다.
   * 
   * 소켓의 연결, 연결 해제, 오류 등 다양한 이벤트에 대한 리스너를 등록합니다.
   * 각 이벤트 발생 시 Zustand 스토어 상태를 업데이트하여 UI에 반영됩니다.
   * 
   * @param socket - 이벤트 리스너를 설정할 Socket.IO 소켓 인스턴스
   */
  private setupSocketListeners(socket: Socket): void {
    // 연결 이벤트 리스너
    socket.on(CONNECTION_EVENTS.CONNECT, () => {
      socketActions.setConnected(true);
      socketActions.setConnectionError(null);
      
      // 연결 진단 정보 업데이트
      this.connectionDiagnostics.lastConnectedTime = new Date();
      this.connectionDiagnostics.reconnectAttempts = 0;
      
      logger.info('SocketStoreAdapter', '소켓 연결됨', {
        socketId: socket.id,
        timestamp: new Date().toISOString()
      });
      
      // 연결 품질 측정 시작
      this.startConnectionQualityMonitoring(socket);
    });
    
    // 연결 해제 이벤트 리스너
    socket.on(CONNECTION_EVENTS.DISCONNECT, (reason) => {
      socketActions.setConnected(false);
      
      // 계획된 연결 해제인지 확인
      const isPlannedDisconnect = reason === 'io client disconnect';
      
      logger.info('SocketStoreAdapter', '소켓 연결 해제됨', {
        reason,
        isPlannedDisconnect,
        timestamp: new Date().toISOString()
      });
      
      // 계획되지 않은 연결 해제인 경우 재연결 전략 실행
      if (!isPlannedDisconnect) {
        this.handleUnplannedDisconnect(reason);
      }
    });
    
    // 연결 오류 이벤트 리스너
    socket.on(CONNECTION_EVENTS.CONNECT_ERROR, (error) => {
      socketActions.setConnected(false);
      socketActions.setConnectionError(error);
      socketActions.setConnectionState(SOCKET_STATE.ERROR);
      
      // 오류 세부 정보 기록
      const errorDetails = {
        message: error.message,
        type: error.name,
        timestamp: new Date().toISOString()
      };
      
      logger.error('SocketStoreAdapter', '소켓 연결 오류', errorDetails);
      
      // 오류 유형에 따른 차별화된 처리
      this.handleConnectionError(error);
    });
  }
  
  /**
   * 액션을 디스패치하는 메서드
   * 
   * Zustand 스토어 액션을 실행하는 헬퍼 메서드입니다.
   * 
   * @param action - 실행할 스토어 액션
   */
  dispatch(action: Function): void {
    if (typeof action === 'function') {
      action();
    }
  }

  /**
   * 이벤트 핸들러 등록
   * 
   * 이벤트 이름과 핸들러 함수를 등록하여 이벤트 발생 시 호출할 수 있도록 합니다.
   * 
   * @param event - 이벤트 이름
   * @param handler - 이벤트 핸들러 함수
   */
  registerEventHandler(event: string, handler: (data: any) => void): void {
    socketActions.addEventHandler(event, handler);
    logger.debug('SocketStoreAdapter', `이벤트 핸들러 등록: ${event}`);
  }
  
  /**
   * 이벤트 핸들러 제거
   * 
   * 등록된 이벤트 핸들러를 제거하여 이벤트 발생 시 호출되지 않도록 합니다.
   * 
   * @param event - 이벤트 이름
   * @param handler - 이벤트 핸들러 함수
   */
  unregisterEventHandler(event: string, handler: (data: any) => void): void {
    socketActions.removeEventHandler(event, handler);
    logger.debug('SocketStoreAdapter', `이벤트 핸들러 제거: ${event}`);
  }
  
  /**
   * 이벤트 발생 기록
   * 
   * 소켓 이벤트가 발생할 때 이를 스토어에 기록합니다.
   * 이벤트 이름, 데이터, 타임스탬프 등을 저장하여 디버깅 및 분석에 활용할 수 있습니다.
   * 
   * @param socket - 이벤트가 발생한 Socket.IO 소켓 인스턴스
   * @param event - 발생한 이벤트 이름
   * @param data - 이벤트와 함께 전송된 데이터
   */
  recordEventEmission(socket: Socket, event: string, data: any): void {
    socketActions.emitEvent(socket, event, data);
    logger.debug('SocketStoreAdapter', `이벤트 발생 기록: ${event}`);
  }
  
  /**
   * 연결 재시도 관련 기능 강화
   * 
   * 연결이 끊어진 경우 재연결을 시도합니다.
   * 재연결 시도 횟수, 지연 시간 등을 관리하여 효율적인 재연결 전략을 구현합니다.
   * 
   * @param socket - 재연결을 시도할 Socket.IO 소켓 인스턴스
   */
  handleReconnection(socket: Socket): void {
    // 재연결 시도 이벤트
    socket.on('reconnect_attempt', (attemptNumber) => {
      this.connectionDiagnostics.reconnectAttempts = attemptNumber;
      
      // 스토어 상태 업데이트
      socketActions.setConnectionState(SOCKET_STATE.RECONNECTING);
      
      // 로그 기록
      logger.info('SocketStoreAdapter', `재연결 시도 중 (${attemptNumber}/${this.connectionDiagnostics.maxReconnectAttempts})`, {
        attemptNumber,
        maxAttempts: this.connectionDiagnostics.maxReconnectAttempts,
        timestamp: new Date().toISOString()
      });
    });
    
    // 재연결 실패 이벤트
    socket.on('reconnect_failed', () => {
      // 최대 재시도 횟수 초과
      socketActions.setConnectionState(SOCKET_STATE.ERROR);
      socketActions.setConnectionError(new Error('최대 재연결 시도 횟수를 초과했습니다.'));
      
      logger.error('SocketStoreAdapter', '재연결 실패', {
        attempts: this.connectionDiagnostics.reconnectAttempts,
        maxAttempts: this.connectionDiagnostics.maxReconnectAttempts,
        timestamp: new Date().toISOString()
      });
      
      // 백오프 전략으로 재시도 
      this.executeReconnectBackoffStrategy();
    });
    
    // 재연결 성공 이벤트
    socket.on('reconnect', (attemptNumber) => {
      socketActions.setConnected(true);
      socketActions.setConnectionState(SOCKET_STATE.CONNECTED);
      socketActions.setConnectionError(null);
      
      // 연결 진단 정보 업데이트
      this.connectionDiagnostics.lastConnectedTime = new Date();
      this.connectionDiagnostics.reconnectAttempts = 0;
      
      logger.info('SocketStoreAdapter', `재연결 성공 (${attemptNumber}회 시도)`, {
        attemptNumber,
        timestamp: new Date().toISOString()
      });
      
      // 재시도 타이머 정리
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = null;
      }
    });
  }
  
  /**
   * 계획되지 않은 연결 해제 처리
   * 
   * 연결이 끊어졌을 때 호출됩니다.
   * 연결 해제 이유에 따라 다른 상태로 업데이트합니다.
   * 예: 전송 계층 닫힘, 핑 타임아웃, 전송 오류 등
   * 이를 통해 UI에서 사용자에게 적절한 피드백을 제공할 수 있습니다.
   * 
   * @param reason - 연결 해제 이유
   */
  private handleUnplannedDisconnect(reason: string): void {
    // 원인에 따른 적절한 상태 설정
    switch (reason) {
      case 'transport close':
        socketActions.setConnectionState(SOCKET_STATE.TRANSPORT_CLOSED);
        break;
      case 'ping timeout':
        socketActions.setConnectionState(SOCKET_STATE.PING_TIMEOUT);
        break;
      case 'transport error':
        socketActions.setConnectionState(SOCKET_STATE.TRANSPORT_ERROR);
        break;
      default:
        socketActions.setConnectionState(SOCKET_STATE.DISCONNECTED);
    }
    
    // 재연결 전략 실행 여부 결정
    const shouldAttemptReconnect = !navigator.onLine ? false : 
      this.connectionDiagnostics.reconnectAttempts < this.connectionDiagnostics.maxReconnectAttempts;
    
    if (shouldAttemptReconnect) {
      logger.info('SocketStoreAdapter', '자동 재연결 시도 예약됨', {
        reason,
        reconnectAttempts: this.connectionDiagnostics.reconnectAttempts,
        delay: this.calculateReconnectDelay()
      });
    }
  }
  
  /**
   * 연결 오류 처리
   * 
   * 연결 중 오류 발생 시 호출됩니다. 오류 유형에 따라 다른 처리를 합니다.
   * 인증 오류, 타임아웃 등 특정 오류 유형에 대해 맞춤형 처리를 제공합니다.
   * 스토어에 오류 상태를 업데이트하여 UI에서 적절한 오류 메시지를 표시할 수 있게 합니다.
   * 
   * @param error - 발생한 오류 객체
   */
  private handleConnectionError(error: Error): void {
    // 오류 유형에 따른 차별화된 처리
    if (error.message.includes('auth')) {
      // 인증 관련 오류
      socketActions.setConnectionState(SOCKET_STATE.AUTH_ERROR);
      logger.error('SocketStoreAdapter', '인증 오류로 인한 연결 실패', { message: error.message });
      
      // 인증 오류는 즉시 재시도하지 않음 (사용자 개입 필요)
      return;
    }
    
    if (error.message.includes('timeout')) {
      // 타임아웃 오류
      socketActions.setConnectionState(SOCKET_STATE.TIMEOUT);
      logger.error('SocketStoreAdapter', '타임아웃으로 인한 연결 실패', { message: error.message });
    }
    
    // 기본 재연결 전략 실행
    this.executeReconnectBackoffStrategy();
  }
  
  /**
   * 백오프 전략을 사용한 재연결 실행
   * 
   * 재연결 시도 간격을 점진적으로 늘려가며 재연결을 시도합니다.
   * 최대 재시도 횟수에 도달하면 오류를 표시합니다.
   */
  private executeReconnectBackoffStrategy(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }
    
    const delay = this.calculateReconnectDelay();
    
    logger.info('SocketStoreAdapter', `${delay}ms 후 재연결 시도 예약됨`, {
      attempts: this.connectionDiagnostics.reconnectAttempts,
      delay
    });
    
    this.reconnectTimer = setTimeout(() => {
      // 재연결 시도
      this.attemptReconnect();
    }, delay);
  }
  
  /**
   * 지수 백오프 알고리즘을 사용한 재연결 지연 시간 계산
   * 
   * 재연결 시도 간격을 계산하여 점진적으로 늘려가며 재연결을 시도합니다.
   * 
   * @returns 재연결 지연 시간 (ms)
   */
  private calculateReconnectDelay(): number {
    const baseDelay = 1000; // 기본 1초
    const attempts = this.connectionDiagnostics.reconnectAttempts;
    const maxDelay = 30000; // 최대 30초
    
    // 지수 백오프: 기본 지연 * 2^시도횟수 + 랜덤 지터(0-1000ms)
    const exponentialDelay = baseDelay * Math.pow(2, Math.min(attempts, 5));
    const jitter = Math.random() * 1000;
    
    return Math.min(exponentialDelay + jitter, maxDelay);
  }
  
  /**
   * 재연결 시도
   * 
   * 재연결을 시도합니다. 재연결 성공 또는 실패 시 상태를 업데이트합니다.
   */
  private attemptReconnect(): void {
    this.connectionDiagnostics.reconnectAttempts++;
    
    logger.info('SocketStoreAdapter', '재연결 시도 중', {
      attempt: this.connectionDiagnostics.reconnectAttempts,
      maxAttempts: this.connectionDiagnostics.maxReconnectAttempts
    });
    
    socketActions.setConnectionState(SOCKET_STATE.RECONNECTING);
    
    // 재연결 로직 실행 (외부 함수 호출 필요 - socketIOService.connect)
    // 이 부분은 실제 구현 시 socketIOService를 어댑터에 주입받아 처리해야 함
    // 현재는 외부에서 처리하므로 상태만 업데이트
  }
  
  /**
   * 네트워크 상태 변화 감지 및 처리
   * 
   * 브라우저의 온라인/오프라인 이벤트를 감지하여 네트워크 상태 변화에 대응합니다.
   * 네트워크가 복구되면 자동 재연결을 시도하고, 네트워크가 끊기면 오류 상태를 표시합니다.
   * 중복 설정을 방지하기 위해 리스너 부착 여부를 추적합니다.
   */
  handleNetworkStatusChange(): void {
    if (this.networkListenersAttached) {
      return;
    }
    
    // 온라인/오프라인 상태 변화 감지
    window.addEventListener('online', this.handleOnline);
    window.addEventListener('offline', this.handleOffline);
    
    this.networkListenersAttached = true;
    logger.debug('SocketStoreAdapter', '네트워크 상태 변화 감지 시작');
  }
  
  /**
   * 네트워크 연결 복구 처리
   * 
   * 네트워크 연결이 복구되었을 때 호출됩니다.
   * 현재 연결 상태를 확인하고, 연결이 끊어진 상태라면 재연결을 시도합니다.
   * 지연 시간을 두어 네트워크 안정화를 기다린 후 재연결을 시도합니다.
   */
  private handleOnline = (): void => {
    logger.info('SocketStoreAdapter', '네트워크 연결 복구됨');
    
    // 연결이 끊어진 상태에서 네트워크가 복구되면 재연결 시도
    const { connectionState } = useSocketStore.getState();
    const isDisconnected = connectionState === SOCKET_STATE.DISCONNECTED || 
                           connectionState === SOCKET_STATE.ERROR ||
                           connectionState === SOCKET_STATE.NETWORK_ERROR;
    
    if (isDisconnected) {
      // 약간의 지연 후 재연결 시도 (네트워크 안정화를 위해)
      setTimeout(() => {
        logger.info('SocketStoreAdapter', '네트워크 복구 후 재연결 시도');
        // 소켓 연결 재시도 로직은 외부에서 처리
        this.connectionDiagnostics.reconnectAttempts = 0;
        socketActions.setConnectionState(SOCKET_STATE.RECONNECTING);
      }, 2000);
    }
  };
  
  /**
   * 네트워크 연결 끊김 처리
   * 
   * 네트워크 연결이 끊어졌을 때 호출됩니다.
   * 스토어 상태를 'NETWORK_ERROR'로 업데이트하고, 적절한 오류 메시지를 설정합니다.
   * 이를 통해 UI에서 네트워크 문제를 사용자에게 알릴 수 있습니다.
   */
  private handleOffline = (): void => {
    logger.info('SocketStoreAdapter', '네트워크 연결 끊김');
    
    // 네트워크 연결이 끊어진 상태를 스토어에 반영
    socketActions.setConnectionState(SOCKET_STATE.NETWORK_ERROR);
    socketActions.setConnectionError(new Error('네트워크 연결이 끊어졌습니다.'));
  };
  
  /**
   * 연결 품질 모니터링 시작
   * 
   * 소켓 연결 품질을 모니터링하여 평균 응답 시간을 계산합니다.
   * 이를 통해 네트워크 상태를 평가하고, 문제가 발생할 경우 조치를 취할 수 있습니다.
   * 
   * @param socket - 연결 품질을 모니터링할 Socket.IO 소켓 인스턴스
   */
  private startConnectionQualityMonitoring(socket: Socket): void {
    // 60초 간격으로 핑 측정
    const pingInterval = setInterval(() => {
      const startTime = Date.now();
      
      socket.emit('ping', () => {
        const rtt = Date.now() - startTime;
        this.connectionDiagnostics.pingTimes.push(rtt);
        
        // 최대 10개까지만 저장
        if (this.connectionDiagnostics.pingTimes.length > 10) {
          this.connectionDiagnostics.pingTimes.shift();
        }
        
        // 평균 RTT 계산
        const avgRtt = this.connectionDiagnostics.pingTimes.reduce((sum, time) => sum + time, 0) / 
                       this.connectionDiagnostics.pingTimes.length;
        
        logger.debug('SocketStoreAdapter', '연결 품질 측정', {
          rtt,
          avgRtt: Math.round(avgRtt),
          measurements: this.connectionDiagnostics.pingTimes.length
        });
      });
    }, 60000);
    
    // 연결 해제 시 정리
    socket.on(CONNECTION_EVENTS.DISCONNECT, () => {
      clearInterval(pingInterval);
    });
  }
  
  /**
   * 연결 진단 정보 가져오기
   * 
   * 현재 연결 상태, 평균 응답 시간, 네트워크 상태 등을 포함한 진단 정보를 반환합니다.
   * 이를 통해 현재 네트워크 상태를 평가하고, 문제가 발생할 경우 조치를 취할 수 있습니다.
   * 
   * @returns 연결 진단 정보
   */
  getConnectionDiagnostics(): any {
    const { connectionState, connected } = useSocketStore.getState();
    
    return {
      ...this.connectionDiagnostics,
      currentState: connectionState,
      connected,
      networkOnline: navigator.onLine,
      averagePing: this.getAveragePing(),
      connectionQuality: this.getConnectionQualityRating(),
      timestamp: new Date().toISOString()
    };
  }
  
  /**
   * 평균 핑 시간 계산
   * 
   * 최근 측정된 핑 시간의 평균을 계산하여 반환합니다.
   * 
   * @returns 평균 핑 시간
   */
  private getAveragePing(): number {
    if (this.connectionDiagnostics.pingTimes.length === 0) {
      return 0;
    }
    
    const sum = this.connectionDiagnostics.pingTimes.reduce((total, time) => total + time, 0);
    return Math.round(sum / this.connectionDiagnostics.pingTimes.length);
  }
  
  /**
   * 연결 품질 등급 가져오기
   * 
   * 평균 핑 시간을 기준으로 연결 품질 등급을 반환합니다.
   * 
   * @returns 연결 품질 등급
   */
  private getConnectionQualityRating(): string {
    const avgPing = this.getAveragePing();
    
    if (avgPing === 0) return '측정 전';
    if (avgPing < 100) return '우수';
    if (avgPing < 300) return '양호';
    if (avgPing < 600) return '보통';
    return '불량';
  }
  
  /**
   * 정리 및 리소스 해제
   * 
   * 소켓 연결을 해제하고, 리소스를 해제하여 메모리 누수를 방지합니다.
   */
  cleanup(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    
    if (this.networkListenersAttached) {
      window.removeEventListener('online', this.handleOnline);
      window.removeEventListener('offline', this.handleOffline);
      this.networkListenersAttached = false;
    }
    
    logger.debug('SocketStoreAdapter', '어댑터 정리 완료');
  }
}

// 싱글톤 인스턴스
const socketStoreAdapter = new SocketStoreAdapter();

export default socketStoreAdapter;



============================================================
File: /home/CVEHub/frontend/src/core/socket/services/constants.ts
------------------------------------------------------------
/**
 * Socket.IO 이벤트 상수 정의
 * 서버와 클라이언트 간의 일관된 이벤트 이름을 유지하기 위해 사용합니다.
 * 백엔드의 WSMessageType 열거형과 일치하도록 유지해야 합니다.
 */

// 연결 관련 이벤트
export const CONNECTION_EVENTS = {
  CONNECT: 'connect',
  DISCONNECT: 'disconnect',
  CONNECT_ERROR: 'connect_error',
  RECONNECT: 'reconnect',
  RECONNECT_ATTEMPT: 'reconnect_attempt',
  CONNECT_ACK: 'connect_ack', // 백엔드 WSMessageType.CONNECT_ACK와 일치
  CONNECTED: 'connected', // 백엔드 WSMessageType.CONNECTED와 일치
  SESSION_INFO_ACK: 'session_info_ack', // 백엔드 WSMessageType.SESSION_INFO_ACK와 일치
  CONNECTION_STATE_CHANGE: 'connection_state_change', // 프론트엔드 전용: 연결 상태 변경
};

// 핑/퐁 관련 이벤트
export const PING_PONG_EVENTS = {
  PING: 'ping', // 백엔드 WSMessageType.PING와 일치
  PONG: 'pong', // 백엔드 WSMessageType.PONG와 일치
};

// 오류 관련 이벤트
export const ERROR_EVENTS = {
  ERROR: 'error', // 백엔드 WSMessageType.ERROR와 일치
};

// CVE 관련 이벤트
export const CVE_EVENTS = {
  CVE_UPDATED: 'cve_updated', // 백엔드 WSMessageType.CVE_UPDATED와 일치
  CVE_CREATED: 'cve_created', // 백엔드 WSMessageType.CVE_CREATED와 일치
  CVE_DELETED: 'cve_deleted', // 백엔드 WSMessageType.CVE_DELETED와 일치
  CVE_DETAIL_UPDATED: 'cve_detail_updated', // 프론트엔드 전용: CVE 상세 정보 업데이트
};

// 구독 관련 이벤트
export const SUBSCRIPTION_EVENTS = {
  SUBSCRIBE_CVE: 'subscribe_cve', // 백엔드 WSMessageType.SUBSCRIBE_CVE와 일치
  UNSUBSCRIBE_CVE: 'unsubscribe_cve', // 백엔드 WSMessageType.UNSUBSCRIBE_CVE와 일치
  SUBSCRIPTION_STATUS: 'subscription_status', // 백엔드 WSMessageType.SUBSCRIPTION_STATUS와 일치
  SUBSCRIPTION_UPDATED: 'subscription_updated', // 프론트엔드 전용: 구독 상태 업데이트
  SUBSCRIBE_ACK: 'subscribe_ack', // 프론트엔드 전용: 구독 요청 확인
  UNSUBSCRIBE_ACK: 'unsubscribe_ack', // 프론트엔드 전용: 구독 취소 요청 확인
  SUBSCRIPTION_ERROR: 'subscription_error', // 프론트엔드 전용: 구독 오류
  UNSUBSCRIPTION_ERROR: 'unsubscription_error', // 프론트엔드 전용: 구독 취소 오류
  SUBSCRIBE_CVES: 'subscribe:cves', // 프론트엔드 전용: CVE 목록 구독 요청
  UNSUBSCRIBE_CVES: 'unsubscribe:cves', // 프론트엔드 전용: CVE 목록 구독 취소 요청
  GET_CVE_SUBSCRIBERS: 'get_cve_subscribers', // 프론트엔드 전용: CVE 구독자 목록 요청
  SUBSCRIBE_CVE_SUCCESS: 'subscribe_cve_success', // 프론트엔드 전용: CVE 구독 성공
  UNSUBSCRIBE_CVE_SUCCESS: 'unsubscribe_cve_success', // 프론트엔드 전용: CVE 구독 취소 성공
  CVE_SUBSCRIBERS_UPDATED: 'cve_subscribers_updated', // 백엔드 WSMessageType.CVE_SUBSCRIBERS_UPDATED와 일치
  SUBSCRIPTIONS_CHANGED: 'subscriptions_changed', // 프론트엔드 전용: 구독 목록 변경
  SUBSCRIBED_CVES_UPDATED: 'subscribed_cves_updated', // 프론트엔드 전용: 구독 중인 CVE 목록 업데이트
};

// 댓글 관련 이벤트
export const COMMENT_EVENTS = {
  COMMENT_ADDED: 'comment_added', // 백엔드 WSMessageType.COMMENT_ADDED와 일치
  COMMENT_UPDATED: 'comment_updated', // 백엔드 WSMessageType.COMMENT_UPDATED와 일치
  COMMENT_DELETED: 'comment_deleted', // 백엔드 WSMessageType.COMMENT_DELETED와 일치
  COMMENT_REACTION_ADDED: 'comment_reaction_added', // 백엔드 WSMessageType.COMMENT_REACTION_ADDED와 일치
  COMMENT_REACTION_REMOVED: 'comment_reaction_removed', // 백엔드 WSMessageType.COMMENT_REACTION_REMOVED와 일치
  COMMENT_MENTION_ADDED: 'comment_mention_added', // 백엔드 WSMessageType.COMMENT_MENTION_ADDED와 일치
  COMMENT_REPLY_ADDED: 'comment_reply_added', // 백엔드 WSMessageType.COMMENT_REPLY_ADDED와 일치
  COMMENT_COUNT_UPDATE: 'comment_count_update', // 백엔드 WSMessageType.COMMENT_COUNT_UPDATE와 일치
};

// 알림 관련 이벤트
export const NOTIFICATION_EVENTS = {
  NOTIFICATION: 'notification', // 백엔드 WSMessageType.NOTIFICATION와 일치
  NOTIFICATION_READ: 'notification_read', // 백엔드 WSMessageType.NOTIFICATION_READ와 일치
  NEW_NOTIFICATION: 'new_notification', // 백엔드 WSMessageType.NEW_NOTIFICATION와 일치
  ALL_NOTIFICATIONS_READ: 'all_notifications_read', // 백엔드 WSMessageType.ALL_NOTIFICATIONS_READ와 일치
  MENTION_ADDED: 'mention_added', // 백엔드 WSMessageType.MENTION_ADDED와 일치
};

// 사용자 활동 관련 이벤트
export const USER_EVENTS = {
  USER_ONLINE: 'user_online', // 백엔드 WSMessageType.USER_ONLINE와 일치
  USER_OFFLINE: 'user_offline', // 백엔드 WSMessageType.USER_OFFLINE와 일치
  USER_STATUS_UPDATE: 'user_status_update', // 백엔드 WSMessageType.USER_STATUS_UPDATE와 일치
  USER_ACTIVITY: 'user_activity', // 백엔드 WSMessageType.USER_ACTIVITY와 일치
  USER_ACTIVITY_UPDATED: 'user_activity_updated', // 백엔드 WSMessageType.USER_ACTIVITY_UPDATED와 일치
  TARGET_ACTIVITY_UPDATED: 'target_activity_updated', // 백엔드 WSMessageType.TARGET_ACTIVITY_UPDATED와 일치
  GLOBAL_ACTIVITY_UPDATED: 'global_activity_updated', // 백엔드 WSMessageType.GLOBAL_ACTIVITY_UPDATED와 일치
};

// 크롤러 관련 이벤트
export const CRAWLER_EVENTS = {
  CRAWLER_UPDATE_PROGRESS: 'crawler_update_progress', // 백엔드 WSMessageType.CRAWLER_UPDATE_PROGRESS와 일치
  CRAWLER_COMPLETED: 'crawler_completed', // 백엔드 WSMessageType.CRAWLER_COMPLETED와 일치
  CRAWLER_ERROR: 'crawler_error', // 백엔드 WSMessageType.CRAWLER_ERROR와 일치
};

// 시스템 상태 관련 이벤트
export const SYSTEM_EVENTS = {
  SYSTEM_MESSAGE: 'system_message', // 백엔드 WSMessageType.SYSTEM_MESSAGE와 일치
  SYSTEM_STATUS: 'system_status', // 백엔드 WSMessageType.SYSTEM_STATUS와 일치
  MAINTENANCE_NOTICE: 'maintenance_notice', // 백엔드 WSMessageType.MAINTENANCE_NOTICE와 일치
};

// 캐시 관련 이벤트
export const CACHE_EVENTS = {
  CACHE_INVALIDATED: 'cache_invalidated', // 백엔드 WSMessageType.CACHE_INVALIDATED와 일치
  CACHE_STATUS: 'cache_status', // 백엔드 WSMessageType.CACHE_STATUS와 일치
};

// 데이터 업데이트 관련 이벤트
export const DATA_EVENTS = {
  DATA_UPDATED: 'data_updated', // 프론트엔드 전용: 특정 필드 데이터 업데이트
  DATA_CREATED: 'data_created', // 프론트엔드 전용: 새로운 데이터 생성
  DATA_DELETED: 'data_deleted', // 프론트엔드 전용: 데이터 삭제
};

// 모든 이벤트를 하나의 객체로 통합 (기존 코드와의 호환성 유지)
export const SOCKET_EVENTS = {
  ...CONNECTION_EVENTS,
  ...PING_PONG_EVENTS,
  ...ERROR_EVENTS,
  ...CVE_EVENTS,
  ...SUBSCRIPTION_EVENTS,
  ...COMMENT_EVENTS,
  ...NOTIFICATION_EVENTS,
  ...USER_EVENTS,
  ...CRAWLER_EVENTS,
  ...SYSTEM_EVENTS,
  ...CACHE_EVENTS,
  ...DATA_EVENTS,
};

// WebSocket 연결 상태에 대한 상수
/**
 * 소켓 연결 상태를 나타내는 상수 집합
 * 
 * @property DISCONNECTED - 소켓 연결이 끊어진 상태
 * @property CONNECTING - 소켓 연결을 시도하는 중인 상태
 * @property CONNECTED - 소켓이 성공적으로 연결된 상태
 * @property ERROR - 일반적인 오류 상태
 * @property RECONNECTING - 재연결을 시도하는 중인 상태
 * @property TRANSPORT_CLOSED - 전송 계층이 닫힌 상태 (서버 종료, 네트워크 문제 등)
 * @property PING_TIMEOUT - 핑 요청에 대한 응답이 타임아웃된 상태
 * @property TRANSPORT_ERROR - 전송 계층에서 오류가 발생한 상태
 * @property AUTH_ERROR - 인증 관련 오류가 발생한 상태
 * @property TIMEOUT - 일반적인 타임아웃 오류가 발생한 상태
 * @property NETWORK_ERROR - 네트워크 연결 문제가 발생한 상태
 * @property OFFLINE - 네트워크 오프라인 상태
 * @property FAILED - 재연결 시도 실패 상태
 * @property CONFIG_ERROR - 설정 관련 오류 상태
 */
export const SOCKET_STATE = {
  DISCONNECTED: 'disconnected',
  CONNECTING: 'connecting',
  CONNECTED: 'connected',
  ERROR: 'error',
  RECONNECTING: 'reconnecting',
  TRANSPORT_CLOSED: 'transport_closed',
  PING_TIMEOUT: 'ping_timeout',
  TRANSPORT_ERROR: 'transport_error',
  AUTH_ERROR: 'auth_error',
  TIMEOUT: 'timeout',
  NETWORK_ERROR: 'network_error',
  OFFLINE: 'offline',
  FAILED: 'failed',
  CONFIG_ERROR: 'config_error'
};

// 웹소켓 로그 문맥
export const WS_LOG_CONTEXT = {
  CLIENT: 'client',
  SERVER: 'server',
  TRANSPORT: 'transport',
  HANDLER: 'handler',
  CONNECTION: 'connection',
  SUBSCRIPTION: 'subscription',
  EVENT: 'event'
};

// 웹소켓 메시지 방향
export const WS_DIRECTION = {
  INCOMING: 'incoming',
  OUTGOING: 'outgoing',
  INTERNAL: 'internal'
};

// 웹소켓 상태 코드
export const WS_STATUS = {
  SUCCESS: 'success',
  ERROR: 'error',
  WARNING: 'warning',
  INFO: 'info',
  FAILURE: 'failure',
  PENDING: 'pending'
};

// 타입 유틸리티: 객체의 값 타입을 추출
export type ValueOf<T> = T[keyof T];

// 각 상수에 대한 타입 정의
export type SocketEvent = ValueOf<typeof SOCKET_EVENTS>;
export type SocketState = ValueOf<typeof SOCKET_STATE>;
export type WSLogContext = ValueOf<typeof WS_LOG_CONTEXT>;
export type WSDirection = ValueOf<typeof WS_DIRECTION>;
export type WSStatus = ValueOf<typeof WS_STATUS>;

// 각 이벤트 그룹에 대한 타입 정의
export type ConnectionEvent = ValueOf<typeof CONNECTION_EVENTS>;
export type PingPongEvent = ValueOf<typeof PING_PONG_EVENTS>;
export type ErrorEvent = ValueOf<typeof ERROR_EVENTS>;
export type CVEEvent = ValueOf<typeof CVE_EVENTS>;
export type SubscriptionEvent = ValueOf<typeof SUBSCRIPTION_EVENTS>;
export type CommentEvent = ValueOf<typeof COMMENT_EVENTS>;
export type NotificationEvent = ValueOf<typeof NOTIFICATION_EVENTS>;
export type UserEvent = ValueOf<typeof USER_EVENTS>;
export type CrawlerEvent = ValueOf<typeof CRAWLER_EVENTS>;
export type SystemEvent = ValueOf<typeof SYSTEM_EVENTS>;
export type CacheEvent = ValueOf<typeof CACHE_EVENTS>;
export type DataEvent = ValueOf<typeof DATA_EVENTS>;

// 이벤트 핸들러 타입
export type SocketEventHandler<T = any> = (data: T) => void;

// ConnectionStateChangeEvent 타입 정의
export interface ConnectionStateChangeEvent {
  state: SocketState;
}

export default SOCKET_EVENTS;



============================================================
File: /home/CVEHub/frontend/src/core/socket/state/socketStore.ts
------------------------------------------------------------
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { Socket } from 'socket.io-client';
import { 
  CONNECTION_EVENTS, 
  SOCKET_STATE, 
  SocketState 
} from 'core/socket/services/constants';
import logger from 'shared/utils/logging';

/**
 * Socket.IO 상태 관리를 위한 Zustand 스토어 타입 정의
 */
interface SocketStore {
  // 상태
  socket: Socket | null;
  connected: boolean;
  connectionState: SocketState;
  connectionError: Error | null;
  lastActivity: Date | null;
  eventSubscriptions: Map<string, Set<(data: any) => void>>;
  
  // 액션
  setSocket: (socket: Socket | null) => Socket | null;
  setConnected: (connected: boolean) => void;
  setConnectionState: (state: SocketState) => void;
  setConnectionError: (error: Error | null) => void;
  updateLastActivity: () => void;
  
  // 이벤트 구독 관리
  addEventHandler: (event: string, handler: (data: any) => void) => () => void;
  removeEventHandler: (event: string, handler: (data: any) => void) => void;
  clearEventHandlers: (event: string) => void;
  clearAllSubscriptions: () => void;
  
  // 이벤트 발생 관련
  emitEvent: (socket: Socket | null, event: string, data: any) => void;
  
  // 유틸리티
  getEventHandlers: (event: string) => Set<(data: any) => void> | undefined;
  hasEventHandlers: (event: string) => boolean;
  getSubscribedEvents: () => string[];
}

/**
 * Socket.IO 상태 관리를 위한 Zustand 스토어
 * 
 * 기존 SocketIOContext와 병행하여 사용할 수 있도록 설계
 */
export const useSocketStore = create<SocketStore>()(
  devtools(
    persist(
      (set, get) => ({
        // 초기 상태
        socket: null,
        connected: false,
        connectionState: SOCKET_STATE.DISCONNECTED,
        connectionError: null,
        lastActivity: null,
        eventSubscriptions: new Map(),
        
        // 액션: 소켓 설정
        setSocket: (socket) => {
          set({ 
            socket,
            lastActivity: new Date()
          });
          return socket;
        },
        
        // 액션: 연결 상태 설정
        setConnected: (connected) => set({ 
          connected,
          connectionState: connected ? SOCKET_STATE.CONNECTED : SOCKET_STATE.DISCONNECTED,
          lastActivity: new Date()
        }),
        
        // 액션: 연결 상태 설정 (상세)
        setConnectionState: (state) => set({ 
          connectionState: state,
          connected: state === SOCKET_STATE.CONNECTED,
          lastActivity: new Date()
        }),
        
        // 액션: 연결 오류 설정
        setConnectionError: (error) => set({ 
          connectionError: error,
          connectionState: error ? SOCKET_STATE.ERROR : get().connectionState,
          lastActivity: new Date()
        }),
        
        // 액션: 마지막 활동 시간 업데이트
        updateLastActivity: () => set({ 
          lastActivity: new Date() 
        }),
        
        // 액션: 이벤트 핸들러 추가
        addEventHandler: (event, handler) => {
          const { eventSubscriptions } = get();
          const handlers = eventSubscriptions.get(event) || new Set();
          handlers.add(handler);
          
          const newSubscriptions = new Map(eventSubscriptions);
          newSubscriptions.set(event, handlers);
          
          set({ 
            eventSubscriptions: newSubscriptions,
            lastActivity: new Date()
          });
          
          logger.debug('socketStore', `이벤트 핸들러 추가: ${event}`, { 
            handlerCount: handlers.size 
          });
          
          // 클린업 함수 반환
          return () => get().removeEventHandler(event, handler);
        },
        
        // 액션: 이벤트 핸들러 제거
        removeEventHandler: (event, handler) => {
          const { eventSubscriptions } = get();
          const handlers = eventSubscriptions.get(event);
          
          if (handlers) {
            handlers.delete(handler);
            
            const newSubscriptions = new Map(eventSubscriptions);
            if (handlers.size === 0) {
              newSubscriptions.delete(event);
              logger.debug('socketStore', `이벤트 ${event}에 대한 모든 핸들러 제거`);
            } else {
              newSubscriptions.set(event, handlers);
              logger.debug('socketStore', `이벤트 ${event}에 대한 핸들러 제거`, { 
                remainingHandlers: handlers.size 
              });
            }
            
            set({ 
              eventSubscriptions: newSubscriptions,
              lastActivity: new Date()
            });
          }
        },
        
        // 액션: 특정 이벤트의 모든 핸들러 제거
        clearEventHandlers: (event) => {
          const { eventSubscriptions } = get();
          
          if (eventSubscriptions.has(event)) {
            const newSubscriptions = new Map(eventSubscriptions);
            newSubscriptions.delete(event);
            
            set({ 
              eventSubscriptions: newSubscriptions,
              lastActivity: new Date()
            });
            
            logger.debug('socketStore', `이벤트 ${event}에 대한 모든 핸들러 제거`);
          }
        },
        
        // 액션: 모든 이벤트 구독 제거
        clearAllSubscriptions: () => {
          set({ 
            eventSubscriptions: new Map(),
            lastActivity: new Date()
          });
          
          logger.debug('socketStore', '모든 이벤트 구독 제거');
        },
        
        // 액션: 이벤트 발생
        emitEvent: (socket, event, data) => {
          if (!socket) {
            logger.warn('socketStore', `소켓 없이 이벤트 발생 시도: ${event}`);
            return;
          }
          
          try {
            socket.emit(event, data);
            get().updateLastActivity();
            
            logger.debug('socketStore', `이벤트 발생: ${event}`, { 
              dataType: typeof data 
            });
          } catch (error) {
            logger.error('socketStore', `이벤트 발생 중 오류: ${event}`, error);
          }
        },
        
        // 유틸리티: 이벤트 핸들러 가져오기
        getEventHandlers: (event) => {
          return get().eventSubscriptions.get(event);
        },
        
        // 유틸리티: 이벤트 핸들러 존재 여부 확인
        hasEventHandlers: (event) => {
          const handlers = get().eventSubscriptions.get(event);
          return !!handlers && handlers.size > 0;
        },
        
        // 유틸리티: 구독 중인 이벤트 목록 가져오기
        getSubscribedEvents: () => {
          return Array.from(get().eventSubscriptions.keys());
        }
      }),
      { 
        name: 'socket-storage',
        partialize: (state) => ({
          connected: state.connected,
          connectionState: state.connectionState,
          connectionError: state.connectionError,
          lastActivity: state.lastActivity
        }),
        onRehydrateStorage: () => (state) => {
          // 재수화 시 Map 객체 초기화
          if (state) {
            // 안전하게 eventSubscriptions Map 초기화
            state.eventSubscriptions = new Map();
            
            logger.debug('socketStore', '스토어 상태 재수화 완료', {
              connected: state.connected,
              connectionState: state.connectionState
            });
          }
        }
      }
    )
  )
);

// 스토어 상태 변경 구독 함수
export const subscribeToSocketStore = (
  selector: (state: SocketStore) => any,
  callback: (selectedState: any, previousState: any) => void
) => {
  let previousState = selector(useSocketStore.getState());
  
  return useSocketStore.subscribe((state) => {
    const currentState = selector(state);
    if (currentState !== previousState) {
      callback(currentState, previousState);
      previousState = currentState;
    }
  });
};

// 스토어 상태 직접 접근 함수 (컴포넌트 외부 사용)
export const getSocketState = () => useSocketStore.getState();

// 스토어 액션 직접 접근 함수 (컴포넌트 외부 사용)
export const socketActions = {
  setSocket: (socket: Socket | null) => {
    useSocketStore.getState().setSocket(socket);
    return socket;
  },
  setConnected: (connected: boolean) => useSocketStore.getState().setConnected(connected),
  setConnectionState: (state: SocketState) => useSocketStore.getState().setConnectionState(state),
  setConnectionError: (error: Error | null) => useSocketStore.getState().setConnectionError(error),
  updateConnectionState: (data: { connectionState: SocketState; isConnected: boolean }) => {
    useSocketStore.getState().setConnectionState(data.connectionState);
    useSocketStore.getState().setConnected(data.isConnected);
  },
  emitEvent: (socket: Socket | null, event: string, data: any) => 
    useSocketStore.getState().emitEvent(socket, event, data),
  addEventHandler: (event: string, handler: (data: any) => void) => 
    useSocketStore.getState().addEventHandler(event, handler),
  removeEventHandler: (event: string, handler: (data: any) => void) => 
    useSocketStore.getState().removeEventHandler(event, handler),
  clearEventHandlers: (event: string) => 
    useSocketStore.getState().clearEventHandlers(event),
  clearAllSubscriptions: () => 
    useSocketStore.getState().clearAllSubscriptions()
};

export default useSocketStore;



============================================================
File: /home/CVEHub/frontend/src/core/socket/hooks/useSocket.ts
------------------------------------------------------------
import { useEffect, useRef, useState, useCallback } from 'react';
import { Subscription, Observable } from 'rxjs';
import { useQueryClient, QueryKey } from '@tanstack/react-query';

import { v4 as uuidv4 } from 'uuid';
import _ from 'lodash';
import useSocketStore from '../state/socketStore';
import logger from 'shared/utils/logging';
import socketService from '../services/socketService';

/**
 * 소켓 훅 옵션 인터페이스
 */
export interface SocketHookOptions<TData = any, TPayload = any> {
  /**
   * RxJS Observable 사용 여부
   */
  useRxJS?: boolean;
  
  /**
   * 연결 즉시 구독 여부
   */
  subscribeImmediately?: boolean;
  
  /**
   * 이벤트 필터링 조건
   */
  filterPredicate?: (data: TPayload) => boolean;
  
  /**
   * 컴포넌트 ID (이벤트 핸들러 관리용)
   */
  componentId?: string;
  
  /**
   * 낙관적 업데이트 사용 여부
   */
  optimisticUpdate?: boolean;
  
  /**
   * 쿼리 키
   */
  queryKey?: QueryKey;
  
  /**
   * 쿼리 무효화 대신 직접 업데이트를 수행할지 여부
   */
  directUpdate?: boolean;
  
  /**
   * 데이터 업데이트 함수 (낙관적 업데이트에 사용)
   */
  updateDataFn?: (oldData: TData, newData: TPayload) => TData;
  
  /**
   * 디바운스 지연 시간 (밀리초)
   */
  debounceDelay?: number;
  
  /**
   * 쓰로틀 지연 시간 (밀리초)
   */
  throttleDelay?: number;
  
  /**
   * 이벤트 에러 핸들러
   */
  onError?: (error: Error) => void;
  
  /**
   * 연결 상태 변경 시 호출될 콜백
   */
  onConnectionChange?: (connected: boolean) => void;
}

/**
 * 소켓 훅 반환 인터페이스
 */
export interface SocketHookResult<TPayload = any> {
  /** 이벤트 구독 여부 */
  isSubscribed: boolean;
  
  /** 이벤트 구독 함수 */
  subscribe: (event?: string) => void;
  
  /** 이벤트 구독 해제 함수 */
  unsubscribe: (event?: string) => void;
  
  /** 이벤트 리스너 등록 함수 */
  on: <T = any>(eventName: string, callback: (data: T) => void) => () => void;
  
  /** 이벤트 리스너 등록 함수 (on의 별칭) */
  addEventListener: <T = any>(eventName: string, callback: (data: T) => void) => () => void;
  
  /** 이벤트 리스너 제거 함수 */
  off: <T = any>(eventName: string, callback: (data: T) => void) => void;
  
  /** 이벤트 리스너 제거 함수 (off의 별칭) */
  removeEventListener: <T = any>(eventName: string, callback: (data: T) => void) => void;
  
  /** 일반 메시지 전송 함수 */
  emit: (messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => void;
  
  /** 디바운스된 메시지 전송 함수 */
  emitDebounced: (messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => void;
  
  /** 쓰로틀된 메시지 전송 함수 */
  emitThrottled: (messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => void;
  
  /** 소켓 연결 상태 */
  connected: boolean;
  
  /** 연결 상태 문자열 */
  connectionState: string;
  
  /** 연결 오류 */
  connectionError: Error | null;
  
  /** 소켓 인스턴스 */
  socket: any;
  
  /** 가장 최근에 수신한 데이터 */
  lastReceivedData: TPayload | null;
  
  /** 연결 상태 Observable */
  connectionState$: Observable<string>;
  
  /** 웹소켓 정리 함수 */
  cleanup: () => void;
  
  /** CVE 구독 함수 */
  subscribeCVE: (cveId: string) => void;
  
  /** CVE 구독 해제 함수 */
  unsubscribeCVE: (cveId: string) => void;
  
  /** CVE 구독 상태 확인 함수 */
  isSubscribedToCVE: (cveId: string) => boolean;
  
  /** 구독 중인 CVE 목록 */
  subscribedCVEs: string[];
}

/**
 * 통합 웹소켓 훅
 * 
 * socketService를 활용하여 웹소켓 연결 및 이벤트 처리를 간소화하는 통합 훅입니다.
 * 
 * @param event - 구독할 이벤트 이름 (옵션)
 * @param callback - 이벤트 발생 시 호출될 콜백 함수 (옵션)
 * @param deps - 콜백 함수의 의존성 배열
 * @param options - 훅 옵션
 * @returns 소켓 훅 결과
 */
export function useSocket<TData = any, TPayload = any>(
  event?: string,
  callback?: (data: TPayload) => void,
  deps: React.DependencyList = [],
  options: SocketHookOptions<TData, TPayload> = {}
): SocketHookResult<TPayload> {
  // 옵션 설정
  const {
    useRxJS = false,
    subscribeImmediately = true,
    filterPredicate,
    componentId = uuidv4(),
    optimisticUpdate = false,
    queryKey,
    directUpdate = false,
    updateDataFn,
    debounceDelay = 300,
    throttleDelay = 300,
    onError,
    onConnectionChange
  } = options;
  
  // 훅 상태
  const [isSubscribed, setIsSubscribed] = useState<boolean>(false);
  const [lastReceivedData, setLastReceivedData] = useState<TPayload | null>(null);
  
  // 쿼리 클라이언트
  const queryClient = useQueryClient();
  
  // 레퍼런스
  const callbackRef = useRef<((data: TPayload) => void) | undefined>(callback);
  const eventRef = useRef<string | undefined>(event);
  const subscriptionRef = useRef<Subscription | null>(null);
  const eventHandlersRef = useRef<Map<string, Set<(data: any) => void>>>(new Map());
  const eventNamesRef = useRef<Set<string>>(new Set());
  const debouncedFnRef = useRef<{[key: string]: _.DebouncedFunc<any>}>({});
  const throttledFnRef = useRef<{[key: string]: _.ThrottleFunc<any>}>({});
  const subscribedCVEsRef = useRef<Set<string>>(new Set());
  const onErrorRef = useRef<((error: Error) => void) | undefined>(onError);
  
  // 소켓 스토어에서 상태 가져오기
  const socketState = useSocketStore();
  const {
    connected,
    connectionState,
    connectionError
  } = socketState;
  
  // 콜백 업데이트
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);
  
  // 이벤트 업데이트
  useEffect(() => {
    eventRef.current = event;
  }, [event]);
  
  // onError 콜백 업데이트
  useEffect(() => {
    onErrorRef.current = onError;
  }, [onError]);
  
  // 필터링된 콜백 생성
  const filteredCallback = useCallback((data: TPayload) => {
    // 필터링 조건이 있고 데이터가 조건을 만족하지 않으면 무시
    if (filterPredicate && !filterPredicate(data)) {
      return;
    }
    
    // 최근 수신 데이터 업데이트
    setLastReceivedData(data);
    
    // 콜백 호출
    if (callbackRef.current) {
      callbackRef.current(data);
    }
    
    // React Query 통합 - 최적화된 로컬 업데이트 또는 무효화
    if (queryKey && data) {
      if (directUpdate && updateDataFn) {
        // 직접 업데이트
        queryClient.setQueryData(queryKey, (oldData: TData) => {
          return updateDataFn(oldData, data);
        });
      } else if (optimisticUpdate) {
        // 낙관적 업데이트 (무효화 + 로컬 업데이트)
        queryClient.invalidateQueries({ queryKey });
      } else {
        // 기본 무효화
        queryClient.invalidateQueries({ queryKey });
      }
    }
  }, [queryKey, optimisticUpdate, filterPredicate, directUpdate, updateDataFn, queryClient]);
  
  // 이벤트 구독 함수
  const subscribe = useCallback((newEvent?: string) => {
    try {
      const targetEvent = newEvent || eventRef.current;
      
      if (!targetEvent) {
        logger.warn('useSocket', '구독할 이벤트를 지정하지 않았습니다.');
        return;
      }
      
      // 이미 같은 이벤트를 구독 중이면 무시
      if (eventNamesRef.current.has(targetEvent)) {
        return;
      }
      
      // 이벤트 구독 (RxJS 사용 여부에 따라 다른 방식 적용)
      if (useRxJS) {
        if (subscriptionRef.current) {
          subscriptionRef.current.unsubscribe();
        }
        
        // RxJS 사용 시 Observable 구독
        subscriptionRef.current = socketService.fromEvent<TPayload>(targetEvent)
          .subscribe({
            next: filteredCallback,
            error: (error) => {
              if (onErrorRef.current) {
                onErrorRef.current(error);
              } else {
                logger.error('useSocket', `이벤트 [${targetEvent}] 처리 중 오류 발생`, error);
              }
            }
          });
      } else {
        // 일반 콜백 기반 구독
        const handler = (data: TPayload) => filteredCallback(data);
        
        // 콜백을 이벤트 핸들러 맵에 추가
        if (!eventHandlersRef.current.has(targetEvent)) {
          eventHandlersRef.current.set(targetEvent, new Set());
        }
        
        const handlers = eventHandlersRef.current.get(targetEvent);
        if (handlers) {
          handlers.add(handler);
        }
        
        // 이벤트 수신 시작
        socketService.on(targetEvent, handler);
      }
      
      // 이벤트 이름 추가 및 구독 상태 업데이트
      eventNamesRef.current.add(targetEvent);
      setIsSubscribed(true);
      logger.debug('useSocket', `이벤트 [${targetEvent}] 구독 시작`);
      
    } catch (error) {
      logger.error('useSocket', '이벤트 구독 중 오류 발생', error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [filteredCallback, useRxJS]);
  
  // 이벤트 구독 해제 함수
  const unsubscribe = useCallback((targetEvent?: string) => {
    try {
      // 모든 이벤트 처리 또는 특정 이벤트 처리
      const eventsToUnsubscribe = targetEvent 
        ? (eventNamesRef.current.has(targetEvent) ? [targetEvent] : [])
        : Array.from(eventNamesRef.current);
      
      if (eventsToUnsubscribe.length === 0) {
        return;
      }
      
      // 각 이벤트 구독 해제
      for (const evt of eventsToUnsubscribe) {
        // RxJS 사용 시 구독 취소
        if (useRxJS && subscriptionRef.current) {
          subscriptionRef.current.unsubscribe();
          subscriptionRef.current = null;
        } else {
          // 등록된 모든 핸들러 제거
          const handlers = eventHandlersRef.current.get(evt);
          if (handlers) {
            handlers.forEach(handler => {
              socketService.off(evt, handler);
            });
            handlers.clear();
          }
        }
        
        // 이벤트 이름 목록에서 제거
        eventNamesRef.current.delete(evt);
        eventHandlersRef.current.delete(evt);
        logger.debug('useSocket', `이벤트 [${evt}] 구독 해제`);
      }
      
      // 구독 중인 이벤트가 없으면 구독 상태 업데이트
      if (eventNamesRef.current.size === 0) {
        setIsSubscribed(false);
      }
      
    } catch (error) {
      logger.error('useSocket', '이벤트 구독 해제 중 오류 발생', error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [useRxJS]);
  
  // 이벤트 리스너 등록 함수
  const on = useCallback(<T = any>(eventName: string, callback: (data: T) => void) => {
    try {
      // 이벤트 핸들러 맵에 이벤트 추가
      if (!eventHandlersRef.current.has(eventName)) {
        eventHandlersRef.current.set(eventName, new Set());
      }
      
      // 핸들러 추가
      const handlers = eventHandlersRef.current.get(eventName);
      if (handlers) {
        handlers.add(callback as any);
      }
      
      // 이벤트 수신 시작
      socketService.on(eventName, callback);
      
      // 이벤트 이름 추가
      eventNamesRef.current.add(eventName);
      
      // 제거 함수 반환
      return () => {
        const handlers = eventHandlersRef.current.get(eventName);
        if (handlers) {
          handlers.delete(callback as any);
        }
        socketService.off(eventName, callback);
        
        // 핸들러가 없으면 이벤트 이름 제거
        if (handlers && handlers.size === 0) {
          eventNamesRef.current.delete(eventName);
          eventHandlersRef.current.delete(eventName);
        }
      };
    } catch (error) {
      logger.error('useSocket', `이벤트 리스너 등록 중 오류 발생 (${eventName})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
      // 더미 제거 함수 반환
      return () => {};
    }
  }, []);
  
  // 이벤트 리스너 제거 함수
  const off = useCallback(<T = any>(eventName: string, callback: (data: T) => void) => {
    try {
      // 핸들러 제거
      const handlers = eventHandlersRef.current.get(eventName);
      if (handlers) {
        handlers.delete(callback as any);
      }
      
      // 소켓 이벤트 리스너 제거
      socketService.off(eventName, callback);
      
      // 핸들러가 없으면 이벤트 이름 제거
      if (handlers && handlers.size === 0) {
        eventNamesRef.current.delete(eventName);
        eventHandlersRef.current.delete(eventName);
      }
      
    } catch (error) {
      logger.error('useSocket', `이벤트 리스너 제거 중 오류 발생 (${eventName})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, []);
  
  // 이벤트 리스너 등록 함수 (on의 별칭)
  const addEventListener = useCallback(<T = any>(eventName: string, callback: (data: T) => void) => {
    return on(eventName, callback);
  }, [on]);
  
  // 메시지 전송 함수
  const emit = useCallback((messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => {
    try {
      if (!connected) {
        logger.warn('useSocket', '소켓이 연결되지 않았습니다. 메시지를 전송할 수 없습니다.');
        return;
      }
      
      // 로컬 업데이트 (제공된 경우)
      if (localUpdateCallback) {
        localUpdateCallback(data);
      }
      
      // 메시지 전송
      socketService.emit(messageEvent, data);
      
    } catch (error) {
      logger.error('useSocket', `메시지 전송 중 오류 발생 (${messageEvent})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [connected]);
  
  // 디바운스된 메시지 전송 함수
  const debouncedEmit = useCallback((messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => {
    try {
      // 디바운스 함수가 없으면 생성
      if (!debouncedFnRef.current[messageEvent]) {
        debouncedFnRef.current[messageEvent] = _.debounce(
          (eventData: any, callback?: (data: any) => void) => {
            emit(messageEvent, eventData, callback);
          },
          debounceDelay
        );
      }
      
      // 디바운스된 함수 호출
      debouncedFnRef.current[messageEvent](data, localUpdateCallback);
      
    } catch (error) {
      logger.error('useSocket', `디바운스된 메시지 전송 중 오류 발생 (${messageEvent})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [emit, debounceDelay]);
  
  // 쓰로틀된 메시지 전송 함수
  const throttledEmit = useCallback((messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => {
    try {
      // 쓰로틀 함수가 없으면 생성
      if (!throttledFnRef.current[messageEvent]) {
        throttledFnRef.current[messageEvent] = _.throttle(
          (eventData: any, callback?: (data: any) => void) => {
            emit(messageEvent, eventData, callback);
          },
          throttleDelay
        );
      }
      
      // 쓰로틀된 함수 호출
      throttledFnRef.current[messageEvent](data, localUpdateCallback);
      
    } catch (error) {
      logger.error('useSocket', `쓰로틀된 메시지 전송 중 오류 발생 (${messageEvent})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [emit, throttleDelay]);
  
  // CVE 구독 관련 메서드들
  // 리팩토링: 이전 각각의 메서드 대신 socketService의 updateSubscription 메서드 사용
  const subscribeCVE = useCallback((cveId: string) => {
    try {
      if (!connected) {
        logger.warn('useSocket', '소켓이 연결되지 않았습니다. CVE를 구독할 수 없습니다.');
        return;
      }
      
      // 이미 구독 중인 경우 중복 요청 방지
      if (subscribedCVEsRef.current.has(cveId)) {
        return;
      }
      
      // 구독 상태 업데이트
      socketService.updateSubscription(cveId, true);
      
      // 로컬 상태 업데이트
      subscribedCVEsRef.current.add(cveId);
      
    } catch (error) {
      logger.error('useSocket', `CVE 구독 중 오류 발생 (${cveId})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [connected]);
  
  // CVE 구독 해제 메서드
  const unsubscribeCVE = useCallback((cveId: string) => {
    try {
      if (!connected) {
        logger.warn('useSocket', '소켓이 연결되지 않았습니다. CVE 구독을 해제할 수 없습니다.');
        return;
      }
      
      // 구독 중이 아닌 경우 중복 요청 방지
      if (!subscribedCVEsRef.current.has(cveId)) {
        return;
      }
      
      // 구독 상태 업데이트
      socketService.updateSubscription(cveId, false);
      
      // 로컬 상태 업데이트
      subscribedCVEsRef.current.delete(cveId);
      
    } catch (error) {
      logger.error('useSocket', `CVE 구독 해제 중 오류 발생 (${cveId})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [connected]);
  
  // CVE 구독 상태 확인 메서드
  const isSubscribedToCVE = useCallback((cveId: string) => {
    return subscribedCVEsRef.current.has(cveId);
  }, []);
  
  // 이벤트 리스너 함수의 연결 상태에 대한 효과
  useEffect(() => {
    // 연결 상태 변경 시 콜백 호출
    if (onConnectionChange) {
      onConnectionChange(connected);
    }
    
    // 연결됐을 때 즉시 구독 설정
    // 중요: 소켓 연결은 App.jsx에서 관리
    if (connected && subscribeImmediately && event) {
      subscribe(event);
    }
    
  }, [connected, subscribeImmediately, event, subscribe, onConnectionChange]);

  // 소켓 연결 상태 검사
  useEffect(() => {
    // 경고: 여기서는 소켓 연결을 초기화하지 않음 (최상위 App.jsx에서 관리)
    if (!socketService.isSocketConnected() && process.env.NODE_ENV === 'development') {
      logger.warn('useSocket', '소켓이 연결되지 않았습니다. 연결은 App.jsx에서 관리됩니다.');
    }
  }, []);
  
  // 정리 함수
  const cleanup = useCallback(() => {
    try {
      // 구독 상태인 경우 구독 해제
      if (isSubscribed) {
        unsubscribe();
      }
      
      // RxJS 구독 취소
      if (subscriptionRef.current) {
        subscriptionRef.current.unsubscribe();
        subscriptionRef.current = null;
      }
      
      // 이벤트 핸들러 맵 정리
      eventHandlersRef.current.clear();
      eventNamesRef.current.clear();
      setIsSubscribed(false);
      setLastReceivedData(null);
      
      // 중요: 여기서는 소켓 연결을 해제하지 않음 (최상위 App.jsx에서 관리)
      logger.debug('useSocket', '이 컴포넌트의 이벤트 구독 정리 완료');
    } catch (error) {
      logger.error('useSocket', '정리 중 오류 발생', error);
    }
  }, [isSubscribed, unsubscribe]);
  
  // 컴포넌트 언마운트 시 정리
  useEffect(() => {
    return () => {
      cleanup();
    };
  }, [cleanup]);
  
  // 소켓 연결 상태 Observable 생성 (캐싱 적용)
  const connectionState$ = useRef<Observable<string>>(
    socketService.connectionState$()
  ).current;
  
  // 훅 결과 반환
  return {
    // 기본 속성
    isSubscribed,
    subscribe,
    unsubscribe,
    on,
    addEventListener,
    off,
    removeEventListener: off,
    emit,
    emitDebounced: debouncedEmit,
    emitThrottled: throttledEmit,
    
    // 연결 상태 정보
    connected,
    connectionState,
    connectionError,
    socket: socketService.getSocket(),
    lastReceivedData,
    connectionState$,
    
    // 추가 유틸리티 함수
    cleanup,
    
    // CVE 구독 관련 메소드
    subscribeCVE,
    unsubscribeCVE,
    isSubscribedToCVE,
    subscribedCVEs: Array.from(subscribedCVEsRef.current)
  };
}

// 전역 오류 핸들러 추가
useSocket.error = function(error: Error): void {
  logger.error('useSocket.global', '소켓 오류 발생', error);
};

// export default useSocket로도 사용할 수 있도록 설정
export default useSocket;


============================================================
File: /home/CVEHub/frontend/src/core/socket/bridge/WebSocketQueryBridge.tsx
------------------------------------------------------------
import React, { useEffect, useRef, useMemo, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { useSocket } from 'core/socket/hooks/useSocket';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { 
  SOCKET_EVENTS, 
  SOCKET_STATE, 
  SUBSCRIPTION_EVENTS,
  COMMENT_EVENTS
} from 'core/socket/services/constants';
import _ from 'lodash';
import logger from 'shared/utils/logging';
import socketEventBus from 'core/socket/services/socketEventBus';
import { Subscription } from 'rxjs';

// 이벤트-쿼리 매핑 정의 (선언적 방식)
interface EventQueryMapping {
  event: string;
  queries: string[][];
  getDetailQuery?: (data: any) => string[] | null;
}

// 구독자 정보 타입 정의
interface Subscriber {
  id: string;
  userId: string;
  username: string;
  displayName: string;
  profileImage?: string;
}

// 구독 상태 이벤트 타입 정의
interface SubscriptionStatusEvent {
  cve_id: string;
  cveId?: string;
  user_id?: string;
  userId?: string;
  username?: string;
  display_name?: string;
  displayName?: string;
  profile_image?: string;
  profileImage?: string;
  subscribed: boolean;
  timestamp?: number;
  subscribers?: Subscriber[] | string[];
}

/**
 * Socket.IO와 React Query를 연결하는 브릿지 컴포넌트
 * 소켓 이벤트를 수신하여 적절한 쿼리 캐시를 무효화합니다.
 * RxJS 기반 웹소켓 구독을 사용하여 안정적인 이벤트 처리를 제공합니다.
 */
const WebSocketQueryBridge: React.FC = () => {
  // useSocket 훅을 사용하지만, 이벤트 리스너는 이벤트 버스를 통해 처리
  const { connected } = useSocket();
  
  const queryClient = useQueryClient();
  const initAttemptRef = useRef(0);
  const maxInitAttempts = 5;
  const eventHandlersSetupRef = useRef(false);
  const subscriptionsRef = useRef<Subscription[]>([]);
  
  // 처리된 구독 이벤트를 추적하기 위한 참조
  const processedSubscriptionEventsRef = useRef<Record<string, boolean>>({});
  
  // 구독자 정보를 중앙에서 관리하는 함수
  const setCVESubscribers = useCallback((cveId: string, subscribers: Subscriber[]) => {
    // 기존 구독자 정보 로드
    const subscribersKey = [QUERY_KEYS.CVE_SUBSCRIBERS, cveId];
    
    // 쿼리 클라이언트에 저장
    queryClient.setQueryData(subscribersKey, subscribers);
    logger.debug('WebSocketQueryBridge', `CVE ${cveId}의 구독자 정보 업데이트`, { subscribers });
    
    return subscribers;
  }, [queryClient]);
  
  // 구독 상태 이벤트 핸들러
  const handleSubscriptionStatus = useCallback((data: SubscriptionStatusEvent) => {
    // 로그 출력
    logger.info('WebSocketQueryBridge', '구독 상태 이벤트 수신', data);
    
    if (!data || !(data.cve_id || data.cveId)) {
      logger.warn('WebSocketQueryBridge', '구독 이벤트에 유효한 CVE ID가 없습니다');
      return;
    }
    
    // CVE ID 정규화
    const cveId = data.cve_id || data.cveId || '';
    
    // 중복 이벤트 처리 방지
    const eventId = `${cveId}_${data.timestamp || Date.now()}`;
    if (processedSubscriptionEventsRef.current[eventId]) {
      logger.debug('WebSocketQueryBridge', `이미 처리된 구독 이벤트 무시: ${eventId}`);
      return;
    }
    
    // 이벤트 처리 표시
    processedSubscriptionEventsRef.current[eventId] = true;
    
    // 구독자 목록 키
    const subscribersKey = [QUERY_KEYS.CVE_SUBSCRIBERS, cveId];
    
    // 현재 구독자 목록 가져오기
    let subscribers: Subscriber[] = queryClient.getQueryData(subscribersKey) || [];
    
    try {
      if (data.subscribed) {
        // 구독자 정보 생성
        const subscriber: Subscriber = {
          id: data.user_id || data.userId || '1', // ID가 없으면 기본값 제공
          userId: data.user_id || data.userId || '1',
          username: data.username || 'User',
          displayName: data.display_name || data.displayName || data.username || 'User',
          profileImage: data.profile_image || data.profileImage || ''
        };
        
        // 구독자 추가 (중복 방지)
        const exists = subscribers.some(s => s.userId === subscriber.userId);
        if (!exists) {
          subscribers = [...subscribers, subscriber];
          setCVESubscribers(cveId, subscribers);
        }
      } else {
        // 구독자 제거
        const userId = data.user_id || data.userId;
        if (userId) {
          subscribers = subscribers.filter(s => s.userId !== userId);
          setCVESubscribers(cveId, subscribers);
        }
      }
      
      // Subscribe/Unsubscribe 상태를 React Query 캐시를 통해 공유
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.CVE_DETAIL, cveId] });
      
    } catch (error) {
      logger.error('WebSocketQueryBridge', '구독 이벤트 처리 중 오류 발생', error);
    }
  }, [queryClient, setCVESubscribers]);
  
  // 이벤트 핸들러 생성
  const createEventHandler = useCallback((mapping: EventQueryMapping) => {
    return (data: any) => {
      try {
        // 로그 출력
        logger.debug('WebSocketQueryBridge', `이벤트 수신: ${mapping.event}`, { data });
        
        // 기본 쿼리 무효화 처리
        if (mapping.queries && mapping.queries.length > 0) {
          mapping.queries.forEach(queryKey => {
            queryClient.invalidateQueries({ queryKey });
            logger.debug('WebSocketQueryBridge', `쿼리 무효화: ${queryKey.join('.')}`, {
              queryKey
            });
          });
        }
        
        // 상세 쿼리 무효화 처리 (있는 경우)
        if (mapping.getDetailQuery && data) {
          const detailQueryKey = mapping.getDetailQuery(data);
          if (detailQueryKey) {
            queryClient.invalidateQueries({ queryKey: detailQueryKey });
            logger.debug('WebSocketQueryBridge', `상세 쿼리 무효화: ${detailQueryKey.join('.')}`, {
              detailQueryKey
            });
          }
        }
      } catch (error) {
        logger.error('WebSocketQueryBridge', `이벤트 처리 중 오류 발생: ${mapping.event}`, error);
      }
    };
  }, [queryClient]);
  
  // 이벤트-쿼리 매핑 정의 (메모이제이션)
  const eventQueryMapping = useMemo<EventQueryMapping[]>(() => [
    { 
      event: SOCKET_EVENTS.CVE_CREATED, 
      queries: [[QUERY_KEYS.CVE_LIST]]
    },
    { 
      event: SOCKET_EVENTS.CVE_UPDATED, 
      queries: [[QUERY_KEYS.CVE_LIST]],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
    { 
      event: SOCKET_EVENTS.CVE_DELETED, 
      queries: [[QUERY_KEYS.CVE_LIST]],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
    { 
      event: COMMENT_EVENTS.COMMENT_ADDED, 
      queries: [],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
    { 
      event: COMMENT_EVENTS.COMMENT_UPDATED, 
      queries: [],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
    { 
      event: COMMENT_EVENTS.COMMENT_DELETED, 
      queries: [],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
    { 
      event: SUBSCRIPTION_EVENTS.CVE_SUBSCRIBERS_UPDATED, 
      queries: [],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
  ], []);
  
  // 소켓 연결 설정 - useEffect 안에서 이벤트 리스너 등록
  useEffect(() => {
    // 연결 상태 확인
    if (!connected) {
      if (initAttemptRef.current < maxInitAttempts) {
        logger.warn('WebSocketQueryBridge', '소켓 연결 대기 중...', {
          attempt: initAttemptRef.current + 1,
          maxAttempts: maxInitAttempts,
          connectedFlag: connected,
        });
        initAttemptRef.current++;
        return;
      } else if (!eventHandlersSetupRef.current) {
        logger.error('WebSocketQueryBridge', '최대 시도 횟수 초과: 소켓 연결 불가능');
        return;
      }
    }
    
    if (!eventHandlersSetupRef.current) {
      logger.info('WebSocketQueryBridge', '이벤트 리스너 등록 시작');
      
      // 기존 구독 정리
      subscriptionsRef.current.forEach(subscription => {
        if (subscription && !subscription.closed) {
          subscription.unsubscribe();
        }
      });
      subscriptionsRef.current = [];
      
      // 각 이벤트-쿼리 매핑에 대해 이벤트 리스너 설정
      eventQueryMapping.forEach(mapping => {
        try {
          const handler = createEventHandler(mapping);
          
          // 이벤트 버스를 통한 이벤트 구독
          const subscription = socketEventBus.on(mapping.event).subscribe(handler);
          
          // 구독 객체 저장 (정리에 사용)
          subscriptionsRef.current.push(subscription);
          
          logger.debug('WebSocketQueryBridge', `이벤트 "${mapping.event}" 구독 완료`);
        } catch (error) {
          logger.error('WebSocketQueryBridge', `이벤트 "${mapping.event}" 구독 중 오류 발생`, error);
        }
      });
      
      // 구독 상태 이벤트 추가 처리
      try {
        const subscription = socketEventBus.on<SubscriptionStatusEvent>(SUBSCRIPTION_EVENTS.SUBSCRIPTION_STATUS)
          .subscribe(handleSubscriptionStatus);
        subscriptionsRef.current.push(subscription);
        logger.debug('WebSocketQueryBridge', '구독 상태 이벤트 구독 완료');
      } catch (error) {
        logger.error('WebSocketQueryBridge', '구독 상태 이벤트 구독 중 오류 발생', error);
      }
      
      eventHandlersSetupRef.current = true;
      logger.info('WebSocketQueryBridge', '모든 이벤트 리스너 등록 완료');
    }
    
    // 컴포넌트 언마운트 시 정리
    return () => {
      logger.info('WebSocketQueryBridge', '이벤트 리스너 정리');
      subscriptionsRef.current.forEach(subscription => {
        if (subscription && !subscription.closed) {
          subscription.unsubscribe();
        }
      });
      subscriptionsRef.current = [];
    };
  }, [connected, eventQueryMapping, createEventHandler, handleSubscriptionStatus]);
  
  // 소켓 연결 상태 모니터링 및 이벤트 핸들러 재설정
  useEffect(() => {
    // 연결 상태가 변경되어 연결되었을 때, 이벤트 핸들러가 설정되지 않았다면 재시도
    if (connected && !eventHandlersSetupRef.current) {
      logger.info('WebSocketQueryBridge', '소켓이 연결되어 이벤트 핸들러 설정 재시도');
      initAttemptRef.current = 0; // 시도 횟수 초기화
    }
  }, [connected]);
  
  // 브릿지 컴포넌트는 UI를 렌더링하지 않음
  return null;
};

export default WebSocketQueryBridge;


============================================================
File: /home/CVEHub/frontend/src/index.js
------------------------------------------------------------
import React from 'react';
import { createRoot } from 'react-dom/client';
import './styles/index.css';
import App from './App.jsx';  // .jsx 확장자 명시
import logger, { LOG_LEVEL } from 'shared/utils/logging';

// 로그 레벨 설정 (개발 환경에서 INFO 레벨로 설정하여 로그 양 감소)
if (process.env.NODE_ENV === 'development') {
  logger.setLogLevel(LOG_LEVEL.DEBUG);
  logger.setEnabled(true);
  console.log('[App] 로깅 시스템 초기화 - 개발 환경에서 INFO 레벨로 설정됨');
} else {
  logger.setLogLevel(LOG_LEVEL.WARN);
  logger.setEnabled(true);
  console.log('[App] 로깅 시스템 초기화 - 프로덕션 환경에서 WARN 레벨로 설정됨');
}

// 로컬 스토리지 초기화
// localStorage.clear();

const root = createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);



============================================================
File: /home/CVEHub/frontend/src/shared/api/types/api.ts
------------------------------------------------------------
/**
 * API 관련 타입 정의 파일
 */

/**
 * API 응답 기본 인터페이스
 */
export interface ApiResponse<T = any> {
    success: boolean;
    message?: string;
    data?: T;
    error?: string;
    errorCode?: string;
  }
  
  /**
   * 페이지네이션 정보 인터페이스
   */
  export interface PaginationInfo {
    page: number;
    limit: number;
    total: number;
    totalPages?: number;
  }
  
  /**
   * 페이지네이션 응답 인터페이스
   */
  export interface PaginatedResponse<T = any> {
    items: T[];
    total: number;
    page: number;
    limit: number;
    pagination?: PaginationInfo;
  }
  
  /**
   * API 요청 옵션 인터페이스
   */
  export interface ApiRequestOptions {
    skipAuthRefresh?: boolean;
    bypassCache?: boolean;
    headers?: Record<string, string>;
    meta?: Record<string, any>;
  }
  
  /**
   * API 에러 인터페이스
   */
  export interface ApiError extends Error {
    status?: number;
    code?: number | string;
    response?: {
      data?: {
        detail?: string;
        message?: string;
        errorCode?: string;
      };
      status?: number;
    };
  }
  
  /**
   * API 상태 코드 타입
   */
  export type StatusCode = 
    | 200 // OK
    | 201 // Created
    | 204 // No Content
    | 400 // Bad Request
    | 401 // Unauthorized
    | 403 // Forbidden
    | 404 // Not Found
    | 409 // Conflict
    | 422 // Unprocessable Entity
    | 500 // Internal Server Error
    | 503; // Service Unavailable


============================================================
File: /home/CVEHub/frontend/src/shared/api/types/components.ts
------------------------------------------------------------
/**
 * 컴포넌트 관련 타입 정의 파일
 */

import { ReactNode } from 'react';
import { Theme } from '@mui/material/styles';
import { SxProps } from '@mui/system';
import { CVEDetail } from 'features/cve/types/cve';
import { User } from 'features/auth/types';

/**
 * 공통 컴포넌트 프롭스 인터페이스
 */
export interface CommonComponentProps {
  children?: ReactNode;
  className?: string;
  style?: React.CSSProperties;
  sx?: SxProps<Theme>;
}

/**
 * 레이아웃 컴포넌트 프롭스 인터페이스
 */
export interface LayoutProps extends CommonComponentProps {
  title?: string;
}

/**
 * CVE 컴포넌트 관련 프롭스 인터페이스
 */

// CVE 상세 정보 컴포넌트 프롭스
export interface CVEDetailProps {
  cveId: string;
  open?: boolean;
  onClose: () => void;
  highlightCommentId?: string | null;
}

// CVE 목록 컴포넌트 프롭스
export interface CVEListProps extends CommonComponentProps {
  selectedCVE?: string;
  setSelectedCVE?: (cveId: string) => void;
}

// CVE 생성 컴포넌트 프롭스
export interface CreateCVEProps extends CommonComponentProps {
  onSuccess?: (cveId: string) => void;
  onCancel?: () => void;
}

// 인라인 수정 텍스트 컴포넌트 프롭스
export interface InlineEditTextProps {
  value?: string;
  onSave: (newValue: string) => void;
  placeholder?: string;
  multiline?: boolean;
  disabled?: boolean;
  fontSize?: string | number;
  externalEdit?: boolean;
  onEditingStart?: () => void;
  onEditingEnd?: () => void;
}

// 댓글 컴포넌트 프롭스
export interface CommentProps {
  comment: any; // Comment 타입
  cveId: string;
  currentUser: User;
  onReply?: (commentId: string) => void;
  onEdit?: (commentId: string, newContent: string) => void;
  onDelete?: (commentId: string) => void;
  sendMessage?: (type: string, data: any) => Promise<any>;
  depth?: number;
  refreshTrigger?: number;
}

// 댓글 탭 컴포넌트 프롭스
export interface CommentsTabProps {
  cve: CVEDetail;
  currentUser: User;
  refreshTrigger?: number;
  onCountChange?: (count: number) => void;
  parentSendMessage?: (type: string, data: any) => Promise<any>;
}

// 히스토리 탭 컴포넌트 프롭스
export interface HistoryTabProps {
  modificationHistory: any[]; // ModificationHistory[]
}

// 일반 데이터 탭 컴포넌트 프롭스
export interface GenericDataTabProps {
  cve: CVEDetail;
  currentUser: User;
  refreshTrigger?: number;
  tabConfig: any; // TabConfig
  onCountChange?: (count: number) => void;
  parentSendMessage?: (type: string, data: any) => Promise<any>;
}

// 태그 상태
export interface TagState {
  id: string | number;
  text: string;
}

// 멘션 입력 컴포넌트 프롭스
export interface MentionInputProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  mentions?: any[]; // User[]
  onMention?: (user: any) => void;
  onSubmit?: () => void;
}

/**
 * 알림 컴포넌트 관련 프롭스 인터페이스
 */
export interface NotificationBellProps extends CommonComponentProps {
  count?: number;
  onClick?: () => void;
  onOpenCVEDetail?: (cveId: string, commentId?: string) => void;
}

/**
 * 사용자 인증 컴포넌트 관련 프롭스 인터페이스
 */
export interface LoginFormProps extends CommonComponentProps {
  onSuccess?: () => void;
  onError?: (error: Error) => void;
}

export interface SignUpProps extends CommonComponentProps {
  onSuccess?: () => void;
  onError?: (error: Error) => void;
}

/**
 * 탭 패널 컴포넌트 프롭스 인터페이스
 */
export interface TabPanelProps {
  children?: ReactNode;
  index: number;
  value: number;
}


============================================================
File: /home/CVEHub/frontend/src/shared/api/config/endpoints.js
------------------------------------------------------------
import { WS_BASE_URL, SOCKET_IO_PATH } from 'config';
import logger from 'shared/utils/logging';


// Auth endpoints
export const AUTH = {
  LOGIN: '/auth/token',
  SIGNUP: '/auth/signup',
  REFRESH: '/auth/refresh',
  LOGOUT: '/auth/logout',
  ME: '/auth/me',
  SEARCH: '/auth/search'
};

// CVE endpoints
export const CVE = {
  BASE: '/cves',
  DETAIL: (id) => `/cves/${id}`,
  SEARCH: '/cves/search',
  COMMENTS: (id) => `/cves/${id}/comments`,
  COMMENT: (cveId, commentId) => `/cves/${cveId}/comments/${commentId}`,
  POC: (id) => `/cves/${id}/poc`,
  SNORT_RULE: (id) => `/cves/${id}/snort-rules`,
  LOCK: (id) => `/cves/${id}/lock`
};

// Notification endpoints
export const NOTIFICATION = {
  BASE: '/notifications',
  READ: (id) => `/notifications/${id}/read`,
  READ_ALL: '/notifications/read-all',
  UNREAD_COUNT: '/notifications/unread/count',
};

// WebSocket endpoints
export const WEBSOCKET = {
  BASE_URL: WS_BASE_URL || 'http://localhost:8000',
  getWebSocketURL: (token) => {
    if (!token) {
      logger.error('WEBSOCKET.CONNECT', '토큰이 제공되지 않았습니다.');
      return null;
    }
    
    try {
      // 기본 URL 설정 (config.js에서 가져옴)
      const baseUrl = WS_BASE_URL || 'http://localhost:8000';
      
      // 개발 환경에서만 로깅
      if (process.env.NODE_ENV === 'development') {
        logger.debug('WEBSOCKET.CONNECT', 'WebSocket URL 구성:', {
          baseUrl,
          socketIOPath: SOCKET_IO_PATH,
          tokenLength: token.length
        });
      }
      
      // URL 끝에 슬래시가 있는지 확인하고 적절히 처리
      const normalizedUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
      
      // 토큰 인코딩
      const encodedToken = encodeURIComponent(token);
      
      // Socket.IO 프로토콜에 맞게 URL 구성
      // 참고: Socket.IO 클라이언트는 자동으로 '/socket.io' 경로를 추가하므로
      // 여기서는 baseUrl만 반환하고 path 옵션은 socketio.js에서 설정
      return normalizedUrl;
    } catch (error) {
      logger.error('WEBSOCKET.CONNECT', 'WebSocket URL 생성 중 오류:', error);
      return null;
    }
  }
};

// 다음의 함수는 제거하거나 필요한 경우 유지할 수 있습니다
// export const getWebSocketURL = (path) => {
//     return `${WS_BASE_URL}${path}`;
// }; 


============================================================
File: /home/CVEHub/frontend/src/shared/api/config/axios.ts
------------------------------------------------------------
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, InternalAxiosRequestConfig } from 'axios';
import { getAccessToken, clearAuthStorage } from 'shared/utils/storage/tokenStorage';
import { camelToSnake, snakeToCamel } from 'shared/utils/caseConverter';
import { 
  normalizeDateFieldsForApi, 
  normalizeDateFieldsFromApi
} from '../../utils/dateUtils';
import { API_BASE_URL, CASE_CONVERSION_CONFIG, PUBLIC_ENDPOINTS, TOKEN_REFRESH_CONFIG } from 'config';
import { refreshToken } from 'features/auth/services/authService';

// 마지막 토큰 갱신 시간 추적
let lastTokenRefreshTime = 0;
let tokenRefreshRetryCount = 0;

// 개발 환경 확인 함수
const isDevelopment = (): boolean => {
  return typeof window !== 'undefined' 
    ? window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
    : false;
};

// 전역 변수 타입 정의
declare global {
  interface Window {
    _currentApiRequest?: {
      url: string;
      method: string;
      timestamp: string;
    };
  }
}

// 커스텀 Axios 요청 설정 타입 확장
export interface CustomAxiosRequestConfig extends AxiosRequestConfig {
  skipTransform?: boolean;
  useCache?: boolean;
  cacheMaxAge?: number;
  skipAuthRefresh?: boolean;
  metadata?: {
    requestTime: Date;
  };
  transformRequest?: ((data: any, headers?: any) => any)[];
  transformResponse?: ((data: any) => any)[];
}

// 커스텀 Axios 내부 요청 설정 타입 확장
export interface CustomInternalAxiosRequestConfig extends InternalAxiosRequestConfig {
  skipTransform?: boolean;
  useCache?: boolean;
  cacheMaxAge?: number;
  skipAuthRefresh?: boolean;
  metadata?: {
    requestTime: Date;
  };
}

// 캐시 항목 타입 정의
interface CacheItem {
  data: any;
  timestamp: number;
}

// 간소화된 로깅 함수 - 개발 환경에서만 로그 출력
const logDebug = (...args: any[]): void => {
  if (isDevelopment()) {
    console.log(...args);
  }
};

// Axios 인스턴스 생성
const api: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000, // 30초 타임아웃
  headers: {
    'Content-Type': 'application/json'
  }
});

// 캐시 저장소
const cache = new Map<string, CacheItem>();

// 변환에서 제외할 필드 목록 (config에서 가져옴)
const EXCLUDED_FIELDS = CASE_CONVERSION_CONFIG.EXCLUDED_FIELDS;

// 로그 출력에서 제외할 URL 패턴
const URL_NO_LOG_PATTERNS: string[] = [
  '/static/',
  '/assets/',
  '/images/',
  '/favicon.ico',
  '/manifest.json'
];

// 날짜 처리에서 제외할 URL 패턴
const URL_NO_DATE_PROCESS_PATTERNS: string[] = [
  '/auth/',
  '/static/',
  '/assets/',
  '/images/'
];

// URL 패턴에 따라 로그 출력 여부 결정
const isExcludedFromLogging = (url?: string): boolean => {
  if (!url) return true;
  return URL_NO_LOG_PATTERNS.some(pattern => url.includes(pattern));
};

// URL 패턴에 따라 날짜 처리 여부 결정
const shouldProcessDates = (url?: string): boolean => {
  if (!url) return false;
  const shouldProcess = !URL_NO_DATE_PROCESS_PATTERNS.some(pattern => url.includes(pattern));
  
  // 개발 환경에서만 날짜 처리 여부 로깅
  if (isDevelopment() && url.includes('/activities')) {
    console.log(`[axios] 날짜 처리 결정: URL=${url}, 처리여부=${shouldProcess}`);
  }
  
  return shouldProcess;
};

// Request Interceptor
api.interceptors.request.use(
  async (config: InternalAxiosRequestConfig): Promise<CustomInternalAxiosRequestConfig> => {
    try {
      // 전역 변수에 현재 API 요청 정보 저장 (caseConverter에서 URL 추적용)
      if (typeof window !== 'undefined') {
        window._currentApiRequest = {
          url: config.url || '',
          method: config.method || 'get',
          timestamp: new Date().toISOString()
        };
      }
      
      // 로깅 제외 대상 확인
      const shouldLog = !isExcludedFromLogging(config.url) && isDevelopment();
      
      // 요청 시작 시간 기록 (성능 측정용)
      const customConfig = config as CustomInternalAxiosRequestConfig;
      customConfig.metadata = {
        requestTime: new Date()
      };
      
      // 개발 환경에서 요청 로깅
      if (shouldLog) {
        console.log(`[axios] ${config.method?.toUpperCase()} ${config.url}`);
        
        // 요청 데이터가 있는 경우 로깅 (민감 정보 제외)
        if (config.data && typeof config.data === 'object') {
          // 비밀번호 필드는 마스킹 처리
          const sanitizedData = { ...config.data };
          if (sanitizedData.password) sanitizedData.password = '********';
          if (sanitizedData.currentPassword) sanitizedData.currentPassword = '********';
          if (sanitizedData.newPassword) sanitizedData.newPassword = '********';
          
          console.log('[axios] 요청 데이터:', sanitizedData);
        }
      }
      
      // 인증 토큰 처리 (공개 엔드포인트가 아닌 경우)
      if (config.url && !PUBLIC_ENDPOINTS.some(endpoint => config.url?.includes(endpoint))) {
        const token = getAccessToken();
        
        if (token) {
          try {
            // 토큰 만료 여부 확인
            const tokenData = JSON.parse(atob(token.split('.')[1]));
            const currentTime = Math.floor(Date.now() / 1000);
            
            // 토큰이 만료되었거나 만료 임박한 경우 (30초 이내) 갱신 시도
            if (tokenData.exp && tokenData.exp - currentTime < 30 && !customConfig.skipAuthRefresh) {
              const now = Date.now();
              const refreshInterval = TOKEN_REFRESH_CONFIG.MIN_REFRESH_INTERVAL || 10000; // 기본 10초
              
              // 토큰 갱신 요청 간격 제한 (너무 자주 요청하지 않도록)
              if (now - lastTokenRefreshTime > refreshInterval) {
                lastTokenRefreshTime = now;
                
                try {
                  // 토큰 갱신 시도
                  const newToken = await refreshToken();
                  if (newToken) {
                    config.headers.Authorization = `Bearer ${newToken}`;
                    tokenRefreshRetryCount = 0; // 성공 시 재시도 카운트 초기화
                  }
                } catch (refreshError) {
                  tokenRefreshRetryCount++;
                  
                  // 재시도 횟수 초과 시 로그아웃 처리
                  if (tokenRefreshRetryCount > TOKEN_REFRESH_CONFIG.MAX_RETRY || 3) {
                    clearAuthStorage();
                    tokenRefreshRetryCount = 0;
                    
                    // 개발 환경에서만 에러 로그
                    if (isDevelopment()) {
                      console.error('토큰 갱신 실패 (최대 재시도 횟수 초과):', refreshError);
                    }
                    
                    // 로그인 페이지로 리다이렉트 (선택적)
                    if (typeof window !== 'undefined' && !window.location.pathname.includes('/login')) {
                      window.location.href = '/login?session=expired';
                    }
                  }
                }
              }
            } else {
              // 토큰이 유효하면 그대로 사용
              config.headers.Authorization = `Bearer ${token}`;
            }
          } catch (e) {
            // 토큰 검증 과정에서 오류 발생 시 기존 토큰 사용
            config.headers.Authorization = `Bearer ${token}`;
            
            // 개발 환경에서만 에러 로그
            if (isDevelopment()) {
              console.error('토큰 검증 오류:', e);
            }
          }
        }
      }
      
      // 요청 데이터가 있는 경우 (POST, PUT, PATCH 등)
      if (config.data && typeof config.data === 'object' && !customConfig.skipTransform) {
        // URLSearchParams 객체는 변환하지 않음
        if (!(config.data instanceof URLSearchParams)) {
          // 날짜 필드 처리 (ISO 형식으로 변환)
          config.data = normalizeDateFieldsForApi(config.data);
          
          // 카멜 케이스를 스네이크 케이스로 변환
          config.data = camelToSnake(config.data, {
            excludeFields: EXCLUDED_FIELDS
          });
        }
      }
      
      // 캐시된 응답 확인 (GET 요청만 해당)
      if (config.method === 'get' && customConfig.useCache) {
        const cachedResponse = cache.get(config.url || '');
        
        if (cachedResponse) {
          const now = Date.now();
          const cacheAge = now - cachedResponse.timestamp;
          
          // 캐시 유효 시간 내인 경우
          if (cacheAge < (customConfig.cacheMaxAge || 60000)) { // 기본 1분
            if (shouldLog) {
              console.log(`[axios] 캐시된 응답 사용: ${config.url}`);
            }
            
            // 캐시된 응답 사용
            return Promise.resolve({
              data: cachedResponse.data,
              status: 200,
              statusText: 'OK (cached)',
              headers: {},
              config,
              cached: true
            }) as any;
          }
        }
      }
      
      return customConfig;
    } catch (error) {
      console.error('Request Interceptor Critical Error:', error);
      return Promise.reject(error);
    }
  },
  (error) => {
    console.error('Request Interceptor Error:', error);
    return Promise.reject(error);
  }
);

// Response Interceptor 
api.interceptors.response.use(
  (response: AxiosResponse): AxiosResponse => {
    // 로깅 제외 대상 확인
    const shouldLog = !isExcludedFromLogging(response.config.url) && isDevelopment();
    
    // 응답 시간 계산 (성능 측정용)
    const customConfig = response.config as CustomInternalAxiosRequestConfig;
    const requestTime = customConfig.metadata?.requestTime;
    let responseTime = 0;
    
    if (requestTime) {
      responseTime = new Date().getTime() - requestTime.getTime();
    }
    
    
    // skipTransform 옵션이 있는 경우 변환 건너뛰기
    if (customConfig.skipTransform) {
      return response;
    }
    
    // 날짜 필드 처리 (ISO 문자열을 Date 객체로 변환)
    if (response.data && 
        typeof response.data === 'object') {
      const url = response.config.url || '';
      const shouldProcess = shouldProcessDates(url);
      
      // 개발 환경에서만 로그 출력
      if (isDevelopment() && url.includes('/activities')) {
        console.log(`[axios] 응답 인터셉터 날짜 처리: URL=${url}, 처리여부=${shouldProcess}`);
        
        if (shouldProcess) {
          console.log(`[axios] 날짜 변환 전 timestamp 샘플:`, 
            Array.isArray(response.data.items) && response.data.items.length > 0 ? 
              response.data.items[0].timestamp : '샘플 없음');
        }
      }
      
      if (shouldProcess) {
        response.data = normalizeDateFieldsFromApi(response.data);
        
        // 개발 환경에서만 로그 출력
        if (isDevelopment() && url.includes('/activities')) {
          console.log(`[axios] 날짜 변환 후 timestamp 샘플:`, 
            Array.isArray(response.data.items) && response.data.items.length > 0 ? 
              response.data.items[0].timestamp : '샘플 없음');
        }
      }
    }
    
    // 스네이크 케이스를 카멜 케이스로 변환
    if (response.data && typeof response.data === 'object') {
      response.data = snakeToCamel(response.data, {
        excludeFields: EXCLUDED_FIELDS,
        processDate: shouldProcessDates(response.config.url)
      });
    }
    
    // GET 요청 결과 캐싱 (useCache 옵션이 있는 경우)
    if (response.config.method === 'get' && 
        (response.config as CustomInternalAxiosRequestConfig).useCache && 
        response.status === 200) {
      cache.set(response.config.url || '', {
        data: response.data,
        timestamp: Date.now()
      });
    }
    
    return response;
  },
  async (error) => {
    // 개발 환경에서만 에러 로깅
    const isDev = isDevelopment();
    
    // 에러 응답이 있는 경우 기본 정보 로깅
    if (error.response) {
      const { status, data, config } = error.response;
      
      // 개발 환경에서만 에러 로깅
      if (isDev) {
        console.error(`API 에러 (${status}): ${config.url}`);
        
        // 에러 데이터가 있으면 로깅
        if (data) {
          console.error('에러 상세:', data);
        }
      }
      
      // skipTransform 옵션이 있는 경우 변환 건너뛰기
      const customConfig = config as CustomInternalAxiosRequestConfig;
      if (customConfig.skipTransform) {
        return Promise.reject(error);
      }
      
      // 401 Unauthorized 에러 처리 (토큰 만료)
      if (status === 401 && config && !customConfig.skipAuthRefresh) {
        try {
          // 토큰 갱신 시도
          const newToken = await refreshToken();
          
          if (newToken) {
            // 갱신된 토큰으로 원래 요청 재시도
            const originalRequest = config;
            originalRequest.headers.Authorization = `Bearer ${newToken}`;
            return axios(originalRequest);
          }
        } catch (refreshError) {
          // 토큰 갱신 실패 시 로그아웃 처리
          clearAuthStorage();
          
          // 개발 환경에서만 에러 로그
          if (isDev) {
            console.error('토큰 갱신 실패:', refreshError);
          }
          
          // 로그인 페이지로 리다이렉트 (선택적)
          if (typeof window !== 'undefined' && !window.location.pathname.includes('/login')) {
            window.location.href = '/login?session=expired';
          }
        }
      }
      
      // 응답 데이터 형식 통일 (스네이크 케이스 -> 카멜 케이스)
      if (error.response.data && typeof error.response.data === 'object') {
        error.response.data = snakeToCamel(error.response.data, {
          excludeFields: EXCLUDED_FIELDS,
          processDate: shouldProcessDates(error.response.config.url)
        });
      }
    } else if (error.request) {
      // 요청은 전송되었으나 응답이 없는 경우 (네트워크 오류 등)
      if (isDev) {
        console.error('API 요청 오류 (응답 없음):', error.message);
      }
    } else {
      // 요청 설정 과정에서 오류 발생
      if (isDev) {
        console.error('API 요청 설정 오류:', error.message);
      }
    }
    
    return Promise.reject(error);
  }
);

// 커스텀 Axios 인스턴스 타입 확장
export type CustomAxiosInstance = AxiosInstance & {
  (config: CustomAxiosRequestConfig): Promise<AxiosResponse>;
  (url: string, config?: CustomAxiosRequestConfig): Promise<AxiosResponse>;
  defaults: AxiosRequestConfig;
  getUri(config?: CustomAxiosRequestConfig): string;
  request<T = any, R = AxiosResponse<T>>(config: CustomAxiosRequestConfig): Promise<R>;
  get<T = any, R = AxiosResponse<T>>(url: string, config?: CustomAxiosRequestConfig): Promise<R>;
  delete<T = any, R = AxiosResponse<T>>(url: string, config?: CustomAxiosRequestConfig): Promise<R>;
  head<T = any, R = AxiosResponse<T>>(url: string, config?: CustomAxiosRequestConfig): Promise<R>;
  options<T = any, R = AxiosResponse<T>>(url: string, config?: CustomAxiosRequestConfig): Promise<R>;
  post<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: CustomAxiosRequestConfig): Promise<R>;
  put<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: CustomAxiosRequestConfig): Promise<R>;
  patch<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: CustomAxiosRequestConfig): Promise<R>;
};

export default api as CustomAxiosInstance;



============================================================
File: /home/CVEHub/frontend/src/shared/api/api.js
------------------------------------------------------------
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  baseQuery: fetchBaseQuery({ 
    baseUrl: '/api',
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    } 
  }),
  
  tagTypes: ['CVE', 'CVEList', 'User'],
  
  endpoints: (builder) => ({
    getCVEList: builder.query({
      query: (params) => ({
        url: `/cve/list`,
        params: {
          ...params,
          _t: Date.now() // 캐시 버스팅용 타임스탬프 추가
        }
      }),
      providesTags: (result) => 
        result
          ? [
              ...result.items.map(({ cveId }) => ({ type: 'CVE', id: cveId })),
              { type: 'CVEList', id: 'LIST' }
            ]
          : [{ type: 'CVEList', id: 'LIST' }],
      // 30초 캐시 - 백엔드 캐시와 적절히 조율
      keepUnusedDataFor: 30,
    }),
    
    getCVEDetail: builder.query({
      query: ({ cveId, bypassCache }) => ({
        url: `/cve/${cveId}`,
        params: bypassCache ? { bypass_cache: true, _t: Date.now() } : {}
      }),
      providesTags: (result, error, arg) => 
        result ? [{ type: 'CVE', id: arg.cveId }] : [],
      // 5분 캐시
      keepUnusedDataFor: 300,
    }),
    
    // 웹소켓 이벤트에 따른 캐시 무효화 로직은 소켓 핸들러에서 처리
  })
});

export const { 
  useGetCVEListQuery, 
  useGetCVEDetailQuery,
  useLazyGetCVEDetailQuery 
} = api; 


============================================================
File: /home/CVEHub/frontend/src/shared/api/queryKeys.ts
------------------------------------------------------------
/**
 * React Query에서 사용할 query key 상수
 * 모든 query key를 한 곳에서 관리하여 일관성 유지
 */

// 필터 타입 정의
export interface CVEFilters {
  page?: number;
  limit?: number;
  status?: string;
  severity?: string;
  search?: string;
  assigned_to?: string;
  [key: string]: any;
}

// 쿼리 키 타입 정의
export type QueryKeyType = string | readonly unknown[];

// CVE 관련 쿼리 키 타입
interface CVEQueryKeys {
  all: readonly string[];
  lists: () => readonly unknown[];
  list: (filters?: CVEFilters) => readonly unknown[];
  details: () => readonly unknown[];
  detail: (id: string) => readonly unknown[];
  totalCount: () => readonly unknown[];
  stats: () => readonly unknown[];
}

// 사용자 관련 쿼리 키 타입
interface UsersQueryKeys {
  all: readonly string[];
  search: readonly string[];
  searchByQuery: (query: string) => readonly unknown[];
}

// 전체 쿼리 키 타입
interface QueryKeys {
  CVE_LIST: string;
  CVE_DETAIL: string;
  CVE_SUBSCRIBERS: string;
  CVE: CVEQueryKeys;
  USER: string;
  USER_PROFILE: string;
  USERS: UsersQueryKeys;
  SETTINGS: string;
  NOTIFICATION: string;
}

export const QUERY_KEYS: QueryKeys = {
  // CVE 관련 query keys
  CVE_LIST: 'cve-list',
  CVE_DETAIL: 'cve-detail',
  CVE_SUBSCRIBERS: 'cve-subscribers',
  
  // CVE 관련 함수형 쿼리 키 구조 (useCVEQuery.ts와 일치)
  CVE: {
    all: ['cves'] as const,
    lists: () => [...QUERY_KEYS.CVE.all, 'list'] as const,
    list: (filters?: CVEFilters) => [...QUERY_KEYS.CVE.lists(), filters] as const,
    details: () => [...QUERY_KEYS.CVE.all, 'detail'] as const,
    detail: (id: string) => [...QUERY_KEYS.CVE.details(), id] as const,
    totalCount: () => [...QUERY_KEYS.CVE.all, 'totalCount'] as const,
    stats: () => [...QUERY_KEYS.CVE.all, 'stats'] as const,
  },
  
  // 사용자 관련 query keys
  USER: 'user',
  USER_PROFILE: 'user-profile',
  
  // 사용자 검색 관련 query keys
  USERS: {
    all: ['users'] as const,
    search: ['users', 'search'] as const,
    searchByQuery: (query: string) => ['users', 'search', query] as const,
  },
  
  // 설정 관련 query keys
  SETTINGS: 'settings',
  
  // 기타 query keys
  NOTIFICATION: 'notification',
};

export default QUERY_KEYS;


============================================================
File: /home/CVEHub/frontend/src/shared/utils/storage/tokenStorage.ts
------------------------------------------------------------
import { User } from '../../../features/auth/types';

// 상수
const ACCESS_TOKEN_KEY = 'accessToken';
const REFRESH_TOKEN_KEY = 'refreshToken';
const USER_KEY = 'user';

// 액세스 토큰
export const getAccessToken = (): string | null => localStorage.getItem(ACCESS_TOKEN_KEY);
export const setAccessToken = (token: string): void => {
  if (!token) {
    console.error('[TokenStorage] 빈 액세스 토큰 저장 시도');
    return;
  }
  localStorage.setItem(ACCESS_TOKEN_KEY, token);
};
export const removeAccessToken = (): void => {
  localStorage.removeItem(ACCESS_TOKEN_KEY);
};

// 리프레시 토큰
export const getRefreshToken = (): string | null => localStorage.getItem(REFRESH_TOKEN_KEY);
export const setRefreshToken = (token: string): void => {
  if (!token) {
    console.error('[TokenStorage] 빈 리프레시 토큰 저장 시도');
    return;
  }
  localStorage.setItem(REFRESH_TOKEN_KEY, token);
};
export const removeRefreshToken = (): void => {
  localStorage.removeItem(REFRESH_TOKEN_KEY);
};

// 사용자 정보
export const getUser = (): User | null => {
  const userJson = localStorage.getItem(USER_KEY);
  return userJson ? JSON.parse(userJson) : null;
};
export const setUser = (user: User): void => {
  if (!user) {
    console.error('[TokenStorage] 빈 사용자 정보 저장 시도');
    return;
  }
  localStorage.setItem(USER_KEY, JSON.stringify(user));
};
export const removeUser = (): void => localStorage.removeItem(USER_KEY);

// 모든 인증 데이터 삭제
export const clearAuthStorage = (): void => {
  removeAccessToken();
  removeRefreshToken();
  removeUser();
};

// 토큰만 삭제
export const clearAllTokens = (): void => {
  removeAccessToken();
  removeRefreshToken();
};

// 현재 사용자 설정 (setUser의 별칭)
export const setCurrentUser = setUser;



============================================================
File: /home/CVEHub/frontend/src/shared/utils/caseConverter.ts
------------------------------------------------------------
/**
 * 케이스 변환 유틸리티
 * humps 라이브러리를 사용하여 camelCase와 snake_case 간 변환을 처리합니다.
 */
import { camelizeKeys as humpsCamelizeKeys, decamelizeKeys } from 'humps';
import { normalizeDateFieldsFromApi } from './dateUtils';

/**
 * 스네이크 케이스에서 카멜 케이스로 변환 옵션 인터페이스
 */
export interface CaseConverterOptions {
  /** 변환에서 제외할 필드 이름 목록 */
  excludeFields?: string[];
  /** 날짜 필드 자동 변환 여부 */
  processDate?: boolean;
/** 요청 URL (로깅 및 특수 처리용) */
  requestUrl?: string;
}

// camelizeKeys를 humps 라이브러리에서 직접 내보내기
export { humpsCamelizeKeys as camelizeKeys };

// decamelizeKeys를 snakeizeKeys로 별칭하여 내보내기
export { decamelizeKeys as snakeizeKeys };

/**
 * 스네이크 케이스에서 카멜 케이스로 변환
 * @param data 변환할 데이터
 * @param options 변환 옵션
 * @returns 변환된 데이터
 */
export const snakeToCamel = (data: any, options: CaseConverterOptions = {}): any => {
  const { 
    excludeFields = [],
    processDate = true,
    requestUrl = 'unknown'
  } = options;
  
  // null 또는 undefined인 경우 그대로 반환
  if (data === null || data === undefined) {
    return data;
  }
  
  // Date 객체인 경우 그대로 반환
  if (data instanceof Date) {
    return data;
  }
  
  try {
    // 1. humps 라이브러리로 카멜케이스 변환
    let camelizedData = humpsCamelizeKeys(data, (key: string, convert: (key: string) => string) => {
      // 제외 필드 목록에 있는 경우 변환하지 않음
      return excludeFields.includes(key) ? key : convert(key);
    });
    
    // 2. 날짜 필드 자동 타입 변환 처리 (processDate 옵션이 true인 경우)
    if (processDate) {
      // dateUtils.js의 normalizeDateFieldsFromApi 함수 활용
      camelizedData = normalizeDateFieldsFromApi(camelizedData, requestUrl);
    }
    
    return camelizedData;
  } catch (error) {
    console.error('[snakeToCamel] 변환 오류:', error);
    return data; // 오류 발생 시 원본 반환
  }
};

/**
 * 카멜 케이스를 스네이크 케이스로 변환
 * @param data 변환할 데이터
 * @param options 변환 옵션
 * @returns 변환된 데이터
 */
export const camelToSnake = (data: any, options: Omit<CaseConverterOptions, 'processDate'> = {}): any => {
  const { excludeFields = [] } = options;
  
  // null 또는 undefined인 경우 그대로 반환
  if (data === null || data === undefined) {
    return data;
  }
  
  // Date 객체인 경우 그대로 반환
  if (data instanceof Date) {
    return data;
  }
  
  try {
    // humps 라이브러리로 스네이크케이스 변환
    return decamelizeKeys(data, (key: string, convert: (key: string, options?: any) => string, options?: any) => {
      // 제외 필드 목록에 있는 경우 변환하지 않음
      return excludeFields.includes(key) ? key : convert(key, options);
    });
  } catch (error) {
    console.error('[camelToSnake] 변환 오류:', error);
    return data; // 오류 발생 시 원본 반환
  }
};



============================================================
File: /home/CVEHub/frontend/src/shared/utils/reactQuery.ts
------------------------------------------------------------
import { QueryClient } from '@tanstack/react-query';
import { QUERY_KEYS as API_QUERY_KEYS } from 'shared/api/queryKeys';

// 쿼리 키 재사용
export const QUERY_KEYS = {
  ...API_QUERY_KEYS,
  // 추가 키 정의
  CVE_SUBSCRIBERS: 'cve-subscribers',
};

// 글로벌 QueryClient 인스턴스 (싱글턴)
let queryClientInstance: QueryClient | null = null;

/**
 * 글로벌 QueryClient 인스턴스를 가져옵니다.
 * App 컴포넌트에서 초기화되어야 합니다.
 */
export function getQueryClient(): QueryClient | null {
  return queryClientInstance;
}

/**
 * 글로벌 QueryClient 인스턴스를 설정합니다.
 * App 컴포넌트에서 한 번만 호출해야 합니다.
 */
export function setQueryClient(client: QueryClient): void {
  queryClientInstance = client;
}



============================================================
File: /home/CVEHub/frontend/src/shared/utils/logging.ts
------------------------------------------------------------
/**
 * 중앙화된 로깅 서비스
 * 애플리케이션 전체에서 사용되는 로깅 시스템
 * 
 * 로그 레벨 가이드라인:
 * - DEBUG: 개발 중 디버깅에 필요한 상세 정보 (예: 함수 호출, 변수 값, 웹소켓 메시지 등)
 * - INFO: 정상적인 애플리케이션 흐름에 대한 정보 (예: 페이지 로드, 사용자 작업, 데이터 로드 등)
 * - WARN: 잠재적인 문제이지만 애플리케이션이 계속 실행될 수 있는 상황 (예: API 응답 지연, 재시도 등)
 * - ERROR: 애플리케이션 기능이 중단되는 심각한 문제 (예: API 오류, 렌더링 오류, 예외 발생 등)
 */

// 환경 변수에 대한 안전한 접근
const isDevMode = (): boolean => {
  return typeof window !== 'undefined' && 
         window.location && 
         (window.location.hostname === 'localhost' || 
          window.location.hostname === '127.0.0.1');
};

// 로그 레벨 정의
export const LOG_LEVEL = {
  DEBUG: 0,   // 디버그 로그 (매우 상세)
  INFO: 1,    // 정보성 로그 
  WARN: 2,    // 경고 로그
  ERROR: 3,   // 오류 로그
  NONE: 100   // 로깅 비활성화
};

export type LogLevel = typeof LOG_LEVEL[keyof typeof LOG_LEVEL];

// 로그 메서드 타입 정의
export interface LogMethod {
  (module: string, message: string, data?: any): void;
  (message: string): void;
  (message: string, data: any): void;
}

interface ExtraContext {
  [key: string]: any;
}

/**
 * 컨텍스트 정보 저장을 위한 클래스
 */
class LogContext {
  private userId: string | null = null;
  private sessionId: string | null = null;
  private requestId: string | null = null;
  private extraContext: ExtraContext = {};

  /**
   * 사용자 ID 설정
   * @param userId - 사용자 ID
   */
  setUserId(userId: string): void {
    this.userId = userId;
  }

  /**
   * 세션 ID 설정
   * @param sessionId - 세션 ID
   */
  setSessionId(sessionId: string): void {
    this.sessionId = sessionId;
  }

  /**
   * 요청 ID 설정
   * @param requestId - 요청 ID
   */
  setRequestId(requestId: string): void {
    this.requestId = requestId;
  }

  /**
   * 추가 컨텍스트 정보 설정
   * @param key - 컨텍스트 키
   * @param value - 컨텍스트 값
   */
  setContext(key: string, value: any): void {
    if (key && value !== undefined) {
      this.extraContext[key] = value;
    }
  }

  /**
   * 모든 컨텍스트 정보 가져오기
   * @returns 컨텍스트 정보
   */
  getAll(): ExtraContext {
    const context: ExtraContext = { ...this.extraContext };
    
    if (this.userId) context.userId = this.userId;
    if (this.sessionId) context.sessionId = this.sessionId;
    if (this.requestId) context.requestId = this.requestId;
    
    return context;
  }

  /**
   * 컨텍스트 초기화
   */
  clear(): void {
    this.userId = null;
    this.sessionId = null;
    this.requestId = null;
    this.extraContext = {};
  }
}

interface LogEntry {
  level: string;
  timestamp: string;
  module: string;
  message: string;
  data?: any;
  context: ExtraContext;
}

/**
 * 중앙화된 로깅 서비스 클래스
 */
class LoggingService {
  private logLevel: LogLevel;
  private enabled: boolean;
  private ignorePatterns: (string | RegExp)[];
  private recentLogs: LogEntry[];
  private maxLogHistory: number;
  private context: LogContext;

  constructor() {
    // 기본 로그 레벨을 ERROR로 설정 (ERROR 레벨만 출력)
    this.logLevel = LOG_LEVEL.DEBUG;
    this.enabled = true;
    this.ignorePatterns = [
      'ping', 
      'pong', 
      'notifications/unread/count', 
      'health', 
      'user/status',
      'socket',
      'Socket',
      'WebSocket',
      'websocket'
    ]; // 기본적으로 무시할 패턴 확장
    this.recentLogs = [];
    this.maxLogHistory = 100; // 최대 로그 기록 수
    this.context = new LogContext(); // 컨텍스트 정보
    
    // 초기화 로그 출력 (ERROR 레벨로 설정)
    if (isDevMode()) {
      console.log('%c 로깅 시스템 초기화 (ERROR 레벨)', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', {
        logLevel: this._getLogLevelName(this.logLevel),
        enabled: this.enabled,
        environment: isDevMode() ? 'development' : 'production'
      });
    }
  }

  /**
   * 로그 레벨 설정
   * @param level - 로그 레벨 (LOG_LEVEL 상수 사용)
   */
  setLogLevel(level: LogLevel): void {
    try {
      const prevLevel = this.logLevel;
      this.logLevel = level;
      
      // ERROR 레벨로 변경되거나 ERROR 레벨에서 다른 레벨로 변경될 때만 로그 출력
      if (level === LOG_LEVEL.ERROR || prevLevel === LOG_LEVEL.ERROR) {
        if (isDevMode()) {
          console.log('%c 로그 레벨 변경', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', {
            prevLevel: this._getLogLevelName(prevLevel),
            newLevel: this._getLogLevelName(level)
          });
        }
      }
    } catch (error) {
      console.error(`[안전 로깅] 로그 레벨 변경 오류: ${level}`, error);
    }
  }

  /**
   * 로그 레벨명 가져오기
   * @private
   */
  private _getLogLevelName(level: LogLevel): string {
    try {
      switch(level) {
        case LOG_LEVEL.DEBUG: return 'DEBUG';
        case LOG_LEVEL.INFO: return 'INFO';
        case LOG_LEVEL.WARN: return 'WARN';
        case LOG_LEVEL.ERROR: return 'ERROR';
        case LOG_LEVEL.NONE: return 'NONE';
        default: return 'UNKNOWN';
      }
    } catch (error) {
      return 'UNKNOWN';
    }
  }

  /**
   * 로깅 활성화/비활성화
   * @param enabled - 활성화 여부
   */
  setEnabled(enabled: boolean): void {
    try {
      this.enabled = !!enabled;
      if (isDevMode()) {
        console.log('%c 로깅 상태 변경', 'background: #2196f3; color: white; padding: 2px 4px; border-radius: 2px;', {
          enabled: this.enabled
        });
      }
    } catch (error) {
      console.log(`[안전 로깅] 로깅 ${enabled ? '활성화' : '비활성화'} 설정 중 오류 발생`);
    }
  }

  /**
   * 로그 무시 패턴 추가
   * @param pattern - 무시할 패턴
   */
  addIgnorePattern(pattern: string | RegExp): void {
    try {
      if (pattern && !this.ignorePatterns.includes(pattern)) {
        this.ignorePatterns.push(pattern);
      }
    } catch (error) {
      console.debug('[안전 로깅] 로그 무시 패턴 추가 중 오류 발생', pattern);
    }
  }

  /**
   * 로그 무시 패턴 제거
   * @param pattern - 제거할 패턴
   */
  removeIgnorePattern(pattern: string | RegExp): void {
    try {
      const index = this.ignorePatterns.indexOf(pattern);
      if (index !== -1) {
        this.ignorePatterns.splice(index, 1);
      }
    } catch (error) {
      console.debug('[안전 로깅] 로그 무시 패턴 제거 중 오류 발생', pattern);
    }
  }

  /**
   * 로그 무시 여부 검사
   * @param message - 로그 메시지
   * @returns 무시 여부
   * @private
   */
  private _shouldIgnore(message: string): boolean {
    try {
      if (!message || typeof message !== 'string') return false;
      
      for (const pattern of this.ignorePatterns) {
        if (typeof pattern === 'string') {
          if (message.includes(pattern)) return true;
        } else if (pattern instanceof RegExp) {
          if (pattern.test(message)) return true;
        }
      }
      return false;
    } catch (error) {
      // 오류 발생 시 기본적으로 무시하지 않음
      return false;
    }
  }

  /**
   * 사용자 ID 설정
   * @param userId - 사용자 ID
   */
  setUserId(userId: string): void {
    try {
      this.context.setUserId(userId);
    } catch (error) {
      console.debug(`[안전 로깅] 사용자 ID 설정: ${userId}`);
    }
  }

  /**
   * 세션 ID 설정
   * @param sessionId - 세션 ID
   */
  setSessionId(sessionId: string): void {
    try {
      this.context.setSessionId(sessionId);
    } catch (error) {
      console.debug(`[안전 로깅] 세션 ID 설정: ${sessionId}`);
    }
  }

  /**
   * 요청 ID 설정
   * @param requestId - 요청 ID
   */
  setRequestId(requestId: string): void {
    try {
      this.context.setRequestId(requestId);
    } catch (error) {
      console.debug(`[안전 로깅] 요청 ID 설정: ${requestId}`);
    }
  }

  /**
   * 추가 컨텍스트 정보 설정
   * @param key - 컨텍스트 키
   * @param value - 컨텍스트 값
   */
  setContext(key: string, value: any): void {
    try {
      this.context.setContext(key, value);
    } catch (error) {
      console.debug(`[안전 로깅] 컨텍스트 정보 설정: ${key}=${value}`);
    }
  }

  /**
   * 컨텍스트 초기화
   */
  clearContext(): void {
    try {
      this.context.clear();
    } catch (error) {
      console.debug('[안전 로깅] 컨텍스트 정보 초기화 중 오류 발생');
    }
  }

  /**
   * 로그 출력 (내부 사용)
   * @param level - 로그 레벨
   * @param module - 모듈명
   * @param message - 로그 메시지
   * @param data - 추가 데이터
   * @private
   */
  private _log(level: LogLevel, module: string, message: string, data?: any): void {
    try {
      // 로그 레벨 체크 - 설정된 레벨보다 낮으면 출력하지 않음
      if (!this.enabled || level < this.logLevel) {
        return;
      }
      
      // 무시 패턴 체크
      if (message && this._shouldIgnore(message)) {
        return;
      }
      
      const timestamp = new Date().toISOString();
      const context = this.context.getAll();
      const logEntry: LogEntry = {
        level: this._getLogLevelName(level),
        timestamp,
        module: module || 'App',
        message,
        data,
        context
      };
      
      // 로그 저장
      this.recentLogs.unshift(logEntry);
      if (this.recentLogs.length > this.maxLogHistory) {
        this.recentLogs.pop();
      }
      
      // 컨텍스트 정보 문자열 생성
      let contextStr = '';
      if (context.userId) contextStr += ` userId=${context.userId}`;
      if (context.sessionId) contextStr += ` sessionId=${context.sessionId}`;
      if (context.requestId) contextStr += ` requestId=${context.requestId}`;
      
      // 콘솔 출력
      const prefix = `[${timestamp.split('T')[1].substring(0, 8)}] [${this._getLogLevelName(level)}] [${module || 'App'}]${contextStr}`;
      
      // 로그 레벨에 따라 다른 스타일 적용
      let style = '';
      let icon = '';
      
      switch (level) {
        case LOG_LEVEL.DEBUG:
          style = 'background: #9e9e9e; color: white; padding: 2px 4px; border-radius: 2px;';
          icon = '';
          console.debug(`%c ${icon} ${prefix}`, style, message, data || '');
          break;
        case LOG_LEVEL.INFO:
          style = 'background: #2196f3; color: white; padding: 2px 4px; border-radius: 2px;';
          icon = '';
          console.info(`%c ${icon} ${prefix}`, style, message, data || '');
          break;
        case LOG_LEVEL.WARN:
          style = 'background: #ff9800; color: white; padding: 2px 4px; border-radius: 2px;';
          icon = '';
          console.warn(`%c ${icon} ${prefix}`, style, message, data || '');
          break;
        case LOG_LEVEL.ERROR:
          style = 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;';
          icon = '';
          console.error(`%c ${icon} ${prefix}`, style, message, data || '');
          break;
      }
    } catch (error) {
      // 로깅 자체에서 오류가 발생한 경우 기본 콘솔 로깅으로 폴백
      console.error('[로깅 시스템 오류]', error);
      const levelName = level === LOG_LEVEL.DEBUG ? 'DEBUG' : 
                        level === LOG_LEVEL.INFO ? 'INFO' : 
                        level === LOG_LEVEL.WARN ? 'WARN' : 'ERROR';
      
      console[levelName.toLowerCase()](`[안전 로깅] [${levelName}] [${module || 'App'}]`, message, data || '');
    }
  }

  /**
   * 디버그 로그
   */
  debug = (moduleOrMessage: string, messageOrData?: any, data?: any): void => {
    try {
      // 인자 개수에 따라 다르게 처리
      if (messageOrData === undefined && data === undefined) {
        // 인자가 1개인 경우: moduleOrMessage는 메시지로 처리
        this._log(LOG_LEVEL.DEBUG, 'App', moduleOrMessage);
      } else if (data === undefined) {
        // 인자가 2개인 경우: 첫 번째 인자가 모듈명인지 메시지인지 판단
        if (typeof messageOrData === 'string') {
          // messageOrData가 문자열이면 moduleOrMessage는 모듈명, messageOrData는 메시지로 처리
          this._log(LOG_LEVEL.DEBUG, moduleOrMessage, messageOrData);
        } else {
          // messageOrData가 문자열이 아니면 moduleOrMessage는 메시지, messageOrData는 데이터로 처리
          this._log(LOG_LEVEL.DEBUG, 'App', moduleOrMessage, messageOrData);
        }
      } else {
        // 인자가 3개인 경우: 모두 그대로 사용
        this._log(LOG_LEVEL.DEBUG, moduleOrMessage, messageOrData, data);
      }
    } catch (error) {
      // 디버그 로그는 오류 시 출력하지 않음
    }
  };

  /**
   * 정보 로그
   */
  info = (moduleOrMessage: string, messageOrData?: any, data?: any): void => {
    try {
      // 인자 개수에 따라 다르게 처리
      if (messageOrData === undefined && data === undefined) {
        // 인자가 1개인 경우: moduleOrMessage는 메시지로 처리
        this._log(LOG_LEVEL.INFO, 'App', moduleOrMessage);
      } else if (data === undefined) {
        // 인자가 2개인 경우: 첫 번째 인자가 모듈명인지 메시지인지 판단
        if (typeof messageOrData === 'string') {
          // messageOrData가 문자열이면 moduleOrMessage는 모듈명, messageOrData는 메시지로 처리
          this._log(LOG_LEVEL.INFO, moduleOrMessage, messageOrData);
        } else {
          // messageOrData가 문자열이 아니면 moduleOrMessage는 메시지, messageOrData는 데이터로 처리
          this._log(LOG_LEVEL.INFO, 'App', moduleOrMessage, messageOrData);
        }
      } else {
        // 인자가 3개인 경우: 모두 그대로 사용
        this._log(LOG_LEVEL.INFO, moduleOrMessage, messageOrData, data);
      }
    } catch (error) {
      // INFO 로그는 오류 시 출력하지 않음
    }
  };

  /**
   * 경고 로그
   */
  warn = (moduleOrMessage: string, messageOrData?: any, data?: any): void => {
    try {
      // 인자 개수에 따라 다르게 처리
      if (messageOrData === undefined && data === undefined) {
        // 인자가 1개인 경우: moduleOrMessage는 메시지로 처리
        this._log(LOG_LEVEL.WARN, 'App', moduleOrMessage);
      } else if (data === undefined) {
        // 인자가 2개인 경우: 첫 번째 인자가 모듈명인지 메시지인지 판단
        if (typeof messageOrData === 'string') {
          // messageOrData가 문자열이면 moduleOrMessage는 모듈명, messageOrData는 메시지로 처리
          this._log(LOG_LEVEL.WARN, moduleOrMessage, messageOrData);
        } else {
          // messageOrData가 문자열이 아니면 moduleOrMessage는 메시지, messageOrData는 데이터로 처리
          this._log(LOG_LEVEL.WARN, 'App', moduleOrMessage, messageOrData);
        }
      } else {
        // 인자가 3개인 경우: 모두 그대로 사용
        this._log(LOG_LEVEL.WARN, moduleOrMessage, messageOrData, data);
      }
    } catch (error) {
      console.warn(`[안전 로깅] [WARN] [${moduleOrMessage}]`, messageOrData, data || '');
    }
  };

  /**
   * 오류 로그
   */
  error = (moduleOrMessage: string, messageOrData?: any, error?: any): void => {
    try {
      // 인자 개수에 따라 다르게 처리
      let actualModule = 'App';
      let actualMessage = '';
      let actualError: any = null;

      if (messageOrData === undefined && error === undefined) {
        // 인자가 1개인 경우: moduleOrMessage는 메시지로 처리
        actualMessage = moduleOrMessage;
      } else if (error === undefined) {
        // 인자가 2개인 경우: 첫 번째 인자가 모듈명인지 메시지인지 판단
        if (typeof messageOrData === 'string' || messageOrData === undefined) {
          // messageOrData가 문자열이면 moduleOrMessage는 모듈명, messageOrData는 메시지로 처리
          actualModule = moduleOrMessage;
          actualMessage = messageOrData || '';
        } else {
          // messageOrData가 문자열이 아니면 moduleOrMessage는 메시지, messageOrData는 오류로 처리
          actualMessage = moduleOrMessage;
          actualError = messageOrData;
        }
      } else {
        // 인자가 3개인 경우: 모두 그대로 사용
        actualModule = moduleOrMessage;
        actualMessage = messageOrData;
        actualError = error;
      }

      // 오류 객체 처리를 위한 인터페이스 정의
      interface ErrorLike {
        message: string;
        stack?: string;
        name?: string;
      }

      // 오류 객체 타입 가드
      const isErrorLike = (obj: any): obj is ErrorLike => {
        return obj && typeof obj === 'object' && 'message' in obj;
      };

      // 오류 객체가 Error 인스턴스인 경우 구조화된 객체로 변환
      let formattedError: any = actualError;
      
      if (actualError && isErrorLike(actualError)) {
        formattedError = {
          message: actualError.message,
          stack: actualError.stack || '',
          name: actualError.name || 'Error'
        };
      } else if (actualError !== null) {
        // 이미 객체인 경우 그대로 사용
        formattedError = actualError;
      }
      
      this._log(LOG_LEVEL.ERROR, actualModule, actualMessage, formattedError);
    } catch (logError) {
      // 오류 객체 처리를 위한 인터페이스 정의
      interface ErrorLike {
        message: string;
        stack?: string;
        name?: string;
      }

      // 오류 객체 타입 가드
      const isErrorLike = (obj: any): obj is ErrorLike => {
        return obj && typeof obj === 'object' && 'message' in obj;
      };

      let formattedError: any = error;
      
      if (error && isErrorLike(error)) {
        formattedError = { 
          message: error.message, 
          stack: error.stack || '' 
        };
      }
      
      console.error(`[안전 로깅] [ERROR]`, moduleOrMessage, messageOrData || '', formattedError || '');
    }
  };

  /**
   * 최근 로그 가져오기
   * @param count - 가져올 로그 수
   * @returns 최근 로그 배열
   */
  getRecentLogs(count = 10): LogEntry[] {
    return this.recentLogs.slice(0, Math.min(count, this.recentLogs.length));
  }

  /**
   * 로그 내보내기 (객체 배열)
   * @returns 로그 객체 배열
   */
  exportLogs(): LogEntry[] {
    try {
      return [...this.recentLogs];
    } catch (error) {
      console.error('[안전 로깅] 로그 내보내기 실패', error);
      return [];
    }
  }

  /**
   * 로그 내보내기 (문자열)
   * @returns JSON 문자열
   */
  exportLogsAsString(): string {
    try {
      return JSON.stringify(this.recentLogs, null, 2);
    } catch (error) {
      console.error('[안전 로깅] 로그 문자열 내보내기 실패', error);
      return '[]';
    }
  }

  /**
   * 로그 다운로드
   */
  downloadLogs(): void {
    try {
      const logs = this.exportLogsAsString();
      const blob = new Blob([logs], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cvehub-logs-${new Date().toISOString().replace(/:/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('[안전 로깅] [ERROR] [LoggingService]', '로그 다운로드 실패', error);
    }
  }
}

// 싱글톤 인스턴스 생성
const logger = new LoggingService();

export default logger;



============================================================
File: /home/CVEHub/frontend/src/shared/utils/mentionUtils.js
------------------------------------------------------------
// 멘션된 사용자를 하이라이트하는 유틸리티 함수
export const highlightMentions = (content) => {
  if (!content) return '';
  
  // @username 패턴을 찾아서 하이라이트된 스팬으로 변환
  // 한글, 영문, 숫자를 포함하는 패턴으로 수정
  const parts = content.split(/(@[가-힣a-zA-Z0-9]+)/g);
  
  return parts.map((part, index) => {
    if (part.match(/^@[가-힣a-zA-Z0-9]+$/)) {
      // 멘션인 경우 하이라이트 처리
      return `<span class="mention" style="color: #1976d2; font-weight: 500; background-color: rgba(25, 118, 210, 0.08); padding: 2px 4px; border-radius: 4px;">${part}</span>`;
    }
    return part;
  }).join('');
};

// 텍스트에서 멘션된 사용자 목록 추출
export const extractMentions = (content) => {
  if (!content) return [];
  
  const mentions = content.match(/@[가-힣a-zA-Z0-9]+/g) || [];
  return mentions.map(mention => mention.slice(1)); // @ 제거
};



============================================================
File: /home/CVEHub/frontend/src/shared/utils/dateUtils.ts
------------------------------------------------------------
import { format, parseISO, isValid } from 'date-fns';
import { formatInTimeZone, utcToZonedTime } from 'date-fns-tz';
import { ko } from 'date-fns/locale';

// 날짜 포맷 상수
export const DATE_FORMATS = {
  API: "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", // API 통신용 ISO 포맷 (모든 문자를 작은따옴표로 이스케이프)
  DISPLAY: {
    DEFAULT: 'yyyy-MM-dd HH:mm',
    DATE_ONLY: 'yyyy-MM-dd',
    TIME_ONLY: 'HH:mm:ss',
    FULL: 'yyyy-MM-dd HH:mm:ss',
    YEAR_MONTH: 'yyyy-MM'
  }
} as const;

// 시간대 상수
export const TIME_ZONES = {
  UTC: 'UTC',
  KST: 'Asia/Seoul',
  DEFAULT: 'Asia/Seoul'
} as const;

// 타입 정의
export type DateFormatType = typeof DATE_FORMATS.DISPLAY[keyof typeof DATE_FORMATS.DISPLAY] | typeof DATE_FORMATS.API;
export type TimeZoneType = typeof TIME_ZONES[keyof typeof TIME_ZONES];
export type DateValueType = string | Date | number | null | undefined;

/**
 * 현재 UTC 시간을 Date 객체로 반환합니다.
 * 백엔드의 get_utc_now()와 유사한 기능을 제공합니다.
 * @returns UTC 시간의 Date 객체
 */
export const getUtcNow = (): Date => {
  return new Date();
};

/**
 * 현재 UTC 시간을 ISO 8601 형식의 문자열로 반환합니다.
 * @returns ISO 8601 형식의 UTC 시간 문자열 (예: "2025-03-28T06:46:44.123Z")
 */
export const getUtcTimestamp = (): string => {
  return new Date().toISOString();
};

/**
 * 현재 KST 시간을 Date 객체로 반환합니다.
 * 백엔드의 get_kst_now()와 유사한 기능을 제공합니다.
 * date-fns-tz의 utcToZonedTime을 사용하여 UTC 시간을 KST로 변환합니다.
 * @returns KST 시간대의 Date 객체
 */
export const getKstNow = (): Date => {
  // date-fns-tz의 utcToZonedTime 함수로 UTC -> KST 변환
  return utcToZonedTime(new Date(), TIME_ZONES.KST);
};

/**
 * 날짜 값을 파싱하여 Date 객체로 변환합니다.
 * 다양한 형식의 입력(ISO 문자열, Date 객체, 타임스탬프 등)을 처리할 수 있습니다.
 * @param dateValue - 변환할 날짜 값
 * @returns 변환된 Date 객체 또는 변환 실패 시 null
 */
export const parseDate = (dateValue: DateValueType): Date | null => {
  if (!dateValue) {
    return null;
  }

  try {
    // 이미 Date 객체인 경우
    if (dateValue instanceof Date) {
      return isValid(dateValue) ? dateValue : null;
    }

    // 숫자(타임스탬프)인 경우
    if (typeof dateValue === 'number') {
      const date = new Date(dateValue);
      return isValid(date) ? date : null;
    }

    // 문자열인 경우
    if (typeof dateValue === 'string') {
      // ISO 8601 형식 문자열 처리
      if (dateValue.includes('T') || dateValue.includes('Z')) {
        const date = parseISO(dateValue);
        return isValid(date) ? date : null;
      }

      // MongoDB 형식 문자열 처리 (ISODate("2023-01-01T00:00:00.000Z"))
      if (dateValue.startsWith('ISODate(') && dateValue.endsWith(')')) {
        const isoString = dateValue.substring(9, dateValue.length - 2);
        const date = parseISO(isoString);
        return isValid(date) ? date : null;
      }

      // 일반 문자열 처리
      const date = new Date(dateValue);
      return isValid(date) ? date : null;
    }
  } catch (error) {
    console.error('날짜 파싱 오류:', error);
  }

  return null;
};

/**
 * 날짜를 지정된 형식으로 포맷팅합니다.
 * UTC 시간을 지정된 시간대(기본값: KST)로 변환하여 포맷팅합니다.
 * @param dateValue - 포맷팅할 날짜 값 (ISO 문자열, Date 객체, 타임스탬프 등)
 * @param formatStr - 출력 포맷 (기본값: yyyy-MM-dd HH:mm)
 * @param timeZone - 시간대 (기본값: Asia/Seoul)
 * @returns 포맷팅된 문자열
 */
export const formatDateTime = (
  dateValue: DateValueType,
  formatStr: string = DATE_FORMATS.DISPLAY.DEFAULT,
  timeZone: TimeZoneType = TIME_ZONES.KST
): string => {
  if (!dateValue) {
    return '-';
  }

  try {
    const date = parseDate(dateValue);
    if (!date) {
      return '-';
    }
    
    // date-fns-tz의 formatInTimeZone 함수로 포맷팅 처리
    return formatInTimeZone(date, timeZone, formatStr, { locale: ko });
  } catch (error) {
    return '-';
  }
};

/**
 * 날짜를 ISO 8601 형식의 문자열로 직렬화합니다.
 * 백엔드의 serialize_datetime()과 유사한 기능을 제공합니다.
 * @param dateValue - 직렬화할 날짜 값
 * @returns ISO 8601 형식의 문자열 또는 null
 */
export const serializeDateTime = (dateValue: DateValueType): string | null => {
  if (!dateValue) {
    return null;
  }

  try {
    const date = parseDate(dateValue);
    if (!date) {
      return null;
    }

    return date.toISOString();
  } catch (error) {
    console.error('날짜 직렬화 오류:', error);
    return null;
  }
};

/**
 * API 요청 데이터에서 날짜 필드를 자동으로 UTC로 변환합니다.
 * @param data - API로 전송할 데이터
 * @param dateFields - 날짜 필드 이름 배열
 * @returns 날짜 필드가 UTC로 변환된 데이터
 */
export const normalizeDateFieldsForApi = <T>(
  data: T | null | undefined,
  dateFields: string[] = ['created_at', 'last_modified_at', 'dateAdded']
): T | null | undefined => {
  if (!data) {
    return data;
  }

  const result = { ...data } as any;

  for (const field of dateFields) {
    if (field in result && result[field]) {
      try {
        const date = parseDate(result[field]);
        if (date) {
          result[field] = date.toISOString();
        }
      } catch (error) {
        console.error(`필드 ${field} 정규화 오류:`, error);
      }
    }
  }

  return result as T;
};

/**
 * API 응답 데이터의 날짜 필드를 자동으로 Date 객체로 변환합니다.
 * @param data - API 응답 데이터 (객체 또는 배열)
 * @param requestUrl - 요청 URL (디버깅 용도)
 * @returns 날짜 필드가 Date 객체로 변환된 데이터
 */
export const normalizeDateFieldsFromApi = <T>(data: T, requestUrl: string = ''): T => {
  if (!data || shouldSkipDateProcessing(requestUrl)) {
    return data;
  }

  // 날짜 필드 후보 (카멜케이스와 스네이크케이스 모두 포함)
  const DATE_FIELD_CANDIDATES = [
    // 카멜케이스
    'createdAt', 'lastModifiedAt', 'updatedAt', 'publishedAt', 
    'expiresAt', 'deletedAt', 'dateAdded', 'dateModified', 'date',
    'timestamp', // 활동 이력의 timestamp 필드 추가
    // 스네이크케이스 (백엔드 일관성)
    'created_at', 'last_modified_at', 'updated_at', 'published_at',
    'expires_at', 'deleted_at', 'date_added', 'date_modified',
    'timestamp' // 활동 이력의 timestamp 필드 추가 (스네이크케이스)
  ];

  const processValue = (value: any): any => {
    if (!value) {
      return value;
    }

    // 배열 처리
    if (Array.isArray(value)) {
      return value.map(item => processValue(item));
    }

    // 객체 처리
    if (typeof value === 'object' && value !== null) {
      // Date 객체는 그대로 반환
      if (value instanceof Date) {
        return value;
      }

      // 일반 객체 처리
      const result: any = {};
      for (const [key, val] of Object.entries(value)) {
        // 날짜 필드 후보인 경우 Date 객체로 변환 시도 (UTC->KST 변환 고려)
        if (DATE_FIELD_CANDIDATES.includes(key) && typeof val === 'string') {
          try {
                                    // 백엔드에서 전송된 날짜를 간단하게 처리
            let date;
            
            // MongoDB 문자열을 ISO 형식으로 예상하고 처리
            // MongoDB ISODate 문자열은 Z가 없어도 UTC 시간임
            try {
              // 1. 문자열에 Z가 없으면 추가
              if (typeof val === 'string' && val.includes('T') && !val.includes('Z') && !val.includes('+')) {
                const isoString = val.replace(/(\.\d+)?$/, 'Z');
                date = parseISO(isoString);
              } else {
                // 2. 기본 파싱 시도
                date = parseDate(val);
              }
              
              if (date && isValid(date)) {
                // 유효한 날짜라면 그대로 사용
                result[key] = date;
            
              } else {
                result[key] = val;
              }
            } catch (e) {
              // 오류 발생 시 원본 값 그대로 사용
              result[key] = val;
            }
          } catch (error) {
            console.error(`[ERROR] 날짜 변환 오류 (${key}):`, error);
            result[key] = val;
          }
        } else {
          // 재귀적으로 처리
          result[key] = processValue(val);
        }
      }
      return result;
    }

    return value;
  };

  return processValue(data);
};

/**
 * 특정 URL 패턴에 대해 날짜 처리를 건너뛸지 결정하는 함수
 * @param url - 요청 URL
 * @returns 날짜 처리를 건너뛸지 여부
 */
export const shouldSkipDateProcessing = (url: string = ''): boolean => {
  const SKIP_PATTERNS = [
    '/auth/', 
    '/config/',
    '/health',
    '/metrics'
  ];
  
  return SKIP_PATTERNS.some(pattern => url.includes(pattern));
};

/**
 * 주어진 타임스탬프로부터 경과된 시간을 한국어로 표시합니다.
 * @param timestamp - 비교할 타임스탬프
 * @returns 경과 시간 문자열 (예: '5초', '10분', '2시간', '3일')
 */
export const timeAgo = (timestamp: DateValueType): string => {
  if (!timestamp) {
    return '-';
  }

  try {
    const date = parseDate(timestamp);
    if (!date) {
      return '-';
    }

    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHour = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHour / 24);
    const diffMonth = Math.floor(diffDay / 30);
    const diffYear = Math.floor(diffMonth / 12);

    if (diffSec < 60) return `${diffSec}초 전`;
    if (diffMin < 60) return `${diffMin}분 전`;
    if (diffHour < 24) return `${diffHour}시간 전`;
    if (diffDay < 30) return `${diffDay}일 전`;
    if (diffMonth < 12) return `${diffMonth}개월 전`;
    return `${diffYear}년 전`;
  } catch (error) {
    console.error('timeAgo 오류:', error);
    return '-';
  }
};

// date-fns의 isValid 함수 재내보내기
export { isValid };



============================================================
File: /home/CVEHub/frontend/src/shared/utils/avatarUtils.js
------------------------------------------------------------
const ANIMAL_EMOJIS = [
  '🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼',
  '🐨', '🐯', '🦁', '🐮', '🐷', '🐸', '🐙', '🐵'
];

export const getAnimalEmoji = (username) => {
  // 사용자 이름을 기반으로 일관된 이모지를 반환
  const charSum = username.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  return ANIMAL_EMOJIS[charSum % ANIMAL_EMOJIS.length];
};

export const getInitials = (name) => {
  return name
    .split(' ')
    .map(part => part[0])
    .join('')
    .toUpperCase();
};



============================================================
File: /home/CVEHub/frontend/src/shared/contexts/ErrorContext.tsx
------------------------------------------------------------
import React, { createContext, useContext, useState, useCallback, ReactNode, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { clearAuthStorage } from '../utils/storage/tokenStorage';
import { AxiosError } from 'axios';
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
import { useAuthQuery } from 'features/auth/hooks/useAuthQuery';

// 응답 데이터 타입 정의
interface ErrorResponseData {
  message?: string;
  [key: string]: any;
}

interface ErrorState {
  type: 'error';
  message: string;
}

interface ErrorContextValue {
  error: ErrorState | null;
  handleError: (error: AxiosError | Error | any) => void;
  clearError: () => void;
}

const ErrorContext = createContext<ErrorContextValue | null>(null);

interface ErrorProviderProps {
  children: ReactNode;
}

export const ErrorProvider: React.FC<ErrorProviderProps> = ({ children }) => {
  const [error, setError] = useState<ErrorState | null>(null);
  const navigate = useNavigate();
  const { logout } = useAuthQuery();

  // 디바운스된 에러 상태 업데이트 함수
  const debouncedSetError = useCallback(
    debounce((newError: ErrorState | null) => {
      setError(newError);
    }, 300),
    []
  );

  // 스로틀된 에러 처리 함수
  const handleError = useCallback(
    throttle((err: AxiosError | Error | any) => {
      const error = err as AxiosError<ErrorResponseData>; // 타입 assertion 수정
      const status = error?.response?.status;
      const message = error?.response?.data?.message || error?.message || '알 수 없는 오류가 발생했습니다.';

      // 401 Unauthorized 에러 처리
      if (status === 401) {
        // 토큰 만료 또는 인증 실패
        clearAuthStorage();
        logout();
        navigate('/login', {
          state: {
            from: window.location.pathname,
            message: '세션이 만료되었습니다. 다시 로그인해주세요.',
          },
        });
        return;
      }

      // 403 Forbidden 에러 처리
      if (status === 403) {
        debouncedSetError({
          type: 'error',
          message: '접근 권한이 없습니다.',
        });
        return;
      }

      // 404 Not Found 에러 처리
      if (status === 404) {
        debouncedSetError({
          type: 'error',
          message: '요청하신 리소스를 찾을 수 없습니다.',
        });
        return;
      }

      // 500 Internal Server Error 처리
      if (status >= 500) {
        debouncedSetError({
          type: 'error',
          message: '서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요.',
        });
        return;
      }

      // 기타 오류 처리
      debouncedSetError({
        type: 'error',
        message,
      });
    }, 500, { leading: true, trailing: false }),
    [navigate, logout, debouncedSetError]
  );

  const clearError = useCallback(() => {
    debouncedSetError(null);
  }, [debouncedSetError]);

  // 메모이제이션된 컨텍스트 값
  const contextValue = useMemo<ErrorContextValue>(
    () => ({
      error,
      handleError,
      clearError,
    }),
    [error, handleError, clearError]
  );

  return (
    <ErrorContext.Provider value={contextValue}>
      {children}
    </ErrorContext.Provider>
  );
};

export const useError = () => {
  const context = useContext(ErrorContext);
  if (!context) {
    throw new Error('useError must be used within an ErrorProvider');
  }
  return context;
};

export default ErrorContext;


============================================================
File: /home/CVEHub/frontend/src/theme.js
------------------------------------------------------------
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
    },
    secondary: {
      main: '#9c27b0',
      light: '#ba68c8',
      dark: '#7b1fa2',
    },
    error: {
      main: '#d32f2f',
      light: '#ef5350',
      dark: '#c62828',
    },
    warning: {
      main: '#ed6c02',
      light: '#ff9800',
      dark: '#e65100',
    },
    info: {
      main: '#0288d1',
      light: '#03a9f4',
      dark: '#01579b',
    },
    success: {
      main: '#2e7d32',
      light: '#4caf50',
      dark: '#1b5e20',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
  },
  typography: {
    fontFamily: [
      '-apple-system',
      'BlinkMacSystemFont',
      '"Segoe UI"',
      'Roboto',
      '"Helvetica Neue"',
      'Arial',
      'sans-serif',
    ].join(','),
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
        },
      },
    },
  },
});

export default theme; 


============================================================
File: /home/CVEHub/frontend/src/config.js
------------------------------------------------------------
/**
 * 애플리케이션 전역 설정
 * 
 * 이 파일은 애플리케이션 전체에서 사용되는 설정값을 정의합니다.
 * 환경 변수는 .env 파일 또는 docker-compose.yml에서 관리됩니다.
 */

// 브라우저 환경에서 현재 호스트 기반 URL 가져오기
const getCurrentOrigin = () => {
  if (typeof window !== 'undefined') {
    return window.location.origin;
  }
  return null;
};

// API 기본 URL - 우선순위: 환경변수 > 현재 호스트 > 기본값
export const API_BASE_URL = process.env.REACT_APP_API_URL || getCurrentOrigin() || 'http://localhost:8000';

// WebSocket 기본 URL - 우선순위: 환경변수 > 현재 호스트 > 기본값
// Socket.IO 연결에 사용됨
export const WS_BASE_URL = process.env.REACT_APP_WS_URL || getCurrentOrigin() || 'http://localhost:8000';

// Socket.IO 경로 설정 - 백엔드의 마운트 경로와 일치해야 함
export const SOCKET_IO_PATH = '/socket.io';

// WebSocket 연결 설정
export const SOCKET_CONFIG = {
  RECONNECTION: true,
  RECONNECTION_ATTEMPTS: parseInt(process.env.REACT_APP_WS_RECONNECTION_ATTEMPTS) || 10,
  RECONNECTION_DELAY: parseInt(process.env.REACT_APP_WS_RECONNECTION_DELAY) || 1000,
  RECONNECTION_DELAY_MAX: parseInt(process.env.REACT_APP_WS_RECONNECTION_DELAY_MAX) || 30000,
  TIMEOUT: parseInt(process.env.REACT_APP_WS_TIMEOUT) || 20000,
  LOG_PING_PONG: process.env.REACT_APP_WS_LOG_PING_PONG === 'true' || false,
  AUTO_CONNECT: false, // 수동으로 연결 관리
  CONNECTION_CHECK_INTERVAL: 5000, // 연결 상태 체크 간격 (ms)
  CONNECTION_CHECK_TIMEOUT: 10000, // 연결 체크 타임아웃 (ms)
};

// 인증이 필요하지 않은 공개 엔드포인트 목록
export const PUBLIC_ENDPOINTS = [
    '/auth/token',
    '/auth/login',
    '/auth/signup',
    '/auth/refresh',
    '/auth/verify',
    '/auth/password/reset',
    '/auth/password/reset/verify',
    '/health'
];

// API 엔드포인트 설정
export const API_ENDPOINTS = {
    /**
     * 인증 관련 엔드포인트
     */
    AUTH: {
        LOGIN: '/auth/token',
        SIGNUP: '/auth/signup',
        REFRESH: '/auth/refresh',
        LOGOUT: '/auth/logout',
        ME: '/auth/me'
    },
    /**
     * 알림 관련 엔드포인트
     */
    NOTIFICATION: {
        BASE: '/notifications',
        READ: (id) => `/notifications/${id}/read`,
        READ_ALL: '/notifications/read-all',
        UNREAD_COUNT: '/notifications/unread/count'
    },
    /**
     * 취약점 관련 엔드포인트
     */
    CVE: {
        BASE: '/cves',
        DETAIL: (id) => `/cves/${id}`,
        SEARCH: '/cves/search',
        COMMENTS: (id) => `/cves/${id}/comments`,
        COMMENT: (cveId, commentId) => `/cves/${cveId}/comments/${commentId}`,
        POC: (id) => `/cves/${id}/poc`,
        SNORT_RULE: (id) => `/cves/${id}/snort-rules`,
        LOCK: (id) => `/cves/${id}/lock`
    },
    /**
     * 사용자 관련 엔드포인트
     */
    USER: {
        SEARCH: '/auth/search'
    },
    /**
     * WebSocket 관련 엔드포인트
     */
    WEBSOCKET: {
        CONNECT: (token) => `/socket.io?token=${encodeURIComponent(token)}`
    }
};

// 케이스 변환 관련 설정
export const CASE_CONVERSION_CONFIG = {
    // 변환 활성화 여부
    ENABLED: true,
    
    // 디버그 모드 (변환 전후 로깅)
    DEBUG: true, // 항상 디버그 모드 활성화
    
    // 변환에서 제외할 필드 목록 (필요한 경우 추가)
    EXCLUDED_FIELDS: []//['access_token', 'refresh_token', 'token_type', 'expires_in']
};

// 기타 설정
export const DEFAULT_ERROR_MESSAGE = '오류가 발생했습니다. 잠시 후 다시 시도해주세요.';
export const TOKEN_REFRESH_THRESHOLD = 5 * 60 * 1000; // 5분 (밀리초) 

// 토큰 갱신 관련 설정
export const TOKEN_REFRESH_CONFIG = {
    // 토큰 만료 전 갱신 시작 시간 (초)
    REFRESH_BEFORE_EXPIRY: 300, // 5분
    
    // 토큰 갱신 최대 재시도 횟수
    MAX_RETRY_COUNT: 3,
    
    // 토큰 갱신 요청 간 최소 간격 (밀리초)
    MIN_REFRESH_INTERVAL: 10 * 1000, // 10초
    
    // 디버그 모드
    DEBUG: false
};


============================================================
File: /home/CVEHub/frontend/src/features/auth/types/index.ts
------------------------------------------------------------
import { AxiosRequestConfig } from 'axios';

/**
 * 인증 관련 타입 정의 파일
 */

/**
 * 사용자 인터페이스
 */
export interface User {
  id: string;
  username: string;
  email: string;
  displayName?: string;
  profileImage?: string;
  role?: string;
  createdAt?: string | Date;
  lastLogin?: string | Date;
}

/**
 * 로그인 요청 인터페이스
 */
export interface LoginRequest {
  username: string;
  password: string;
  rememberMe?: boolean;
}

/**
 * 로그인 응답 인터페이스
 */
export interface LoginResponse {
  user: User;
  tokens: {
    accessToken: string;
    refreshToken: string;
  };
  expiresIn?: number;
}

/**
 * 로그인 응답 데이터 인터페이스
 */
export interface LoginResponseData {
  access_token?: string;
  accessToken?: string;
  refresh_token?: string;
  refreshToken?: string;
  user?: User;
}

/**
 * 회원가입 요청 인터페이스
 */
export interface SignUpRequest {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
  displayName?: string;
}

/**
 * 토큰 갱신 요청 인터페이스
 */
export interface RefreshTokenRequest {
  refreshToken: string;
}

/**
 * 토큰 갱신 응답 인터페이스
 */
export interface RefreshTokenResponse {
  accessToken: string;
  refreshToken?: string;
  expiresIn?: number;
}

/**
 * 인증 컨텍스트 인터페이스
 */
export interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: Error | null;
  login: (credentials: LoginRequest) => Promise<LoginResponse>;
  loginAsync: (credentials: LoginRequest) => Promise<LoginResponse>;
  logout: () => Promise<void>;
  logoutAsync: () => Promise<void>;
  refreshToken: (refreshToken?: string) => Promise<void>;
  refreshTokenAsync: (refreshToken?: string) => Promise<void>;
  accessToken: string | null;
}

/**
 * 토큰 페이로드 인터페이스
 */
export interface TokenPayload {
  sub: string; // 사용자 ID
  username: string;
  exp: number; // 만료 시간 (timestamp)
  iat: number; // 발급 시간 (timestamp)
  role?: string;
}

/**
 * 사용자 정보 업데이트 인터페이스
 */
export interface UserUpdate {
  email?: string;
  displayName?: string;
  profileImage?: string;
  password?: string;
  currentPassword?: string;
}

/**
 * 커스텀 Axios 요청 설정 인터페이스
 */
export interface CustomAxiosRequestConfig extends AxiosRequestConfig {
  skipTransform?: boolean;
  useCache?: boolean;
  cacheMaxAge?: number;
  skipAuthRefresh?: boolean;
  metadata?: {
    requestTime: Date;
  };
}


============================================================
File: /home/CVEHub/frontend/src/features/auth/AuthRoute.jsx
------------------------------------------------------------
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { CircularProgress, Box } from '@mui/material';

const AuthRoute = ({ children }) => {
  const location = useLocation();
  const { isAuthenticated, loading } = useAuth();
  const from = location.state?.from?.pathname || '/cves';
  
  if (loading) {
    return (
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh'
        }}
      >
        <CircularProgress />
      </Box>
    );
  }

  if (isAuthenticated) {
    return <Navigate to={from} replace />;
  }

  return children;
};

export default AuthRoute;



============================================================
File: /home/CVEHub/frontend/src/features/auth/Login.tsx
------------------------------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import { useSnackbar } from 'notistack';
import { 
  Container,
  Box,
  Typography,
  TextField,
  Button,
  FormControlLabel,
  Checkbox,
  IconButton,
  InputAdornment,
  Paper,
  CircularProgress,
  Alert,
  Divider,
  Link
} from '@mui/material';
import { Email, Lock, Visibility, VisibilityOff } from '@mui/icons-material';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { LoginRequest, AuthContextType, LoginResponse } from 'features/auth/types';

interface FormData {
  email: string;
  password: string;
}

const Login: React.FC = () => {
  const navigate = useNavigate();
  const { enqueueSnackbar } = useSnackbar();
  const auth = useAuth();
  const { loginAsync, loading: authLoading, error: authError } = auth as AuthContextType;
  
  const [formData, setFormData] = useState<FormData>({
    email: '',
    password: ''
  });
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>('');
  const [saveId, setSaveId] = useState<boolean>(false);
  const [showPassword, setShowPassword] = useState<boolean>(false);
  
  // 컴포넌트 마운트 상태를 추적하는 ref
  const isMounted = useRef<boolean>(true);
  // 타이머 참조를 저장하는 ref
  const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // 컴포넌트 마운트 시 초기화
  useEffect(() => {
    // 컴포넌트 마운트 시 이벤트 리스너 정리
    window.addEventListener('beforeunload', cleanupBeforeUnload);
    
    const savedEmail = localStorage.getItem('savedEmail');
    if (savedEmail) {
      setFormData(prev => ({ ...prev, email: savedEmail }));
      setSaveId(true);
    }
    
    return () => {
      isMounted.current = false;
      window.removeEventListener('beforeunload', cleanupBeforeUnload);
      
      // 타이머가 있으면 정리
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, []);

  // 페이지 언로드 전 정리 함수
  const cleanupBeforeUnload = (): void => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
  };

  // 입력 필드 변경 핸들러
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // 입력 시 에러 메시지 초기화
    if (error) setError('');
  };

  // 아이디 저장 체크박스 변경 핸들러
  const handleSaveIdChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    setSaveId(e.target.checked);
  };

  // 비밀번호 표시 토글 핸들러
  const handleTogglePasswordVisibility = (): void => {
    setShowPassword(prev => !prev);
  };

  // 로그인 폼 제출 핸들러
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>): Promise<void> => {
    e.preventDefault();
    
    // 필수 입력 필드 검증
    if (!formData.email || !formData.password) {
      setError('이메일과 비밀번호를 모두 입력해주세요.');
      return;
    }
    
    // 이메일 형식 검증
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(formData.email)) {
      setError('유효한 이메일 주소를 입력해주세요.');
      return;
    }
    
    setLoading(true);
    setError('');
    
    try {
      // 로그인 요청
      const loginRequest: LoginRequest = {
        username: formData.email, // API는 이메일을 username으로 받음
        password: formData.password
      };

      const response: LoginResponse = await loginAsync(loginRequest);
      
      // 아이디 저장 설정에 따라 저장 또는 삭제
      if (saveId) {
        localStorage.setItem('savedEmail', formData.email);
      } else {
        localStorage.removeItem('savedEmail');
      }
      
      // 로그인 성공 메시지 표시
      enqueueSnackbar('로그인에 성공했습니다.', { 
        variant: 'success',
        autoHideDuration: 3000
      });
      
      // 메인 페이지로 이동 (지연 적용)
      timerRef.current = setTimeout(() => {
        if (isMounted.current) {
          navigate('/');
        }
      }, 1000);
      
    } catch (err) {
      console.error('로그인 오류:', err);
      
      // 오류 메시지 설정
      const error = err as any; // 타입 단언
      
      if (error.response) {
        // 서버 응답이 있는 경우
        const status = error.response.status;
        
        if (status === 401) {
          setError('이메일 또는 비밀번호가 올바르지 않습니다.');
        } else if (status === 429) {
          setError('너무 많은 로그인 시도가 있었습니다. 잠시 후 다시 시도해주세요.');
        } else {
          setError(error.response.data?.message || '로그인 중 오류가 발생했습니다.');
        }
      } else if (error.request) {
        // 요청은 보냈지만 응답이 없는 경우
        setError('서버에 연결할 수 없습니다. 네트워크 연결을 확인해주세요.');
      } else {
        // 요청 설정 중 오류 발생
        setError('로그인 요청을 처리할 수 없습니다.');
      }
      
      // 오류 알림 표시
      enqueueSnackbar('로그인에 실패했습니다.', { 
        variant: 'error',
        autoHideDuration: 5000
      });
    } finally {
      if (isMounted.current) {
        setLoading(false);
      }
    }
  };

  return (
    <Container maxWidth="sm" sx={{ 
      display: 'flex', 
      flexDirection: 'column',
      justifyContent: 'center',
      minHeight: '100vh',
      py: 4
    }}>
      <Paper 
        elevation={3} 
        sx={{ 
          p: 4, 
          display: 'flex', 
          flexDirection: 'column',
          borderRadius: 2
        }}
      >
        <Box sx={{ mb: 3, textAlign: 'center' }}>
          <Typography variant="h4" component="h1" gutterBottom>
            로그인
          </Typography>
          <Typography variant="body2" color="text.secondary">
            CVE Hub에 오신 것을 환영합니다
          </Typography>
        </Box>
        
        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            {error}
          </Alert>
        )}
        
        <Box component="form" onSubmit={handleSubmit} noValidate>
          <TextField
            margin="normal"
            required
            fullWidth
            id="email"
            label="이메일"
            name="email"
            autoComplete="email"
            autoFocus
            value={formData.email}
            onChange={handleChange}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <Email />
                </InputAdornment>
              ),
            }}
          />
          
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="비밀번호"
            type={showPassword ? 'text' : 'password'}
            id="password"
            autoComplete="current-password"
            value={formData.password}
            onChange={handleChange}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <Lock />
                </InputAdornment>
              ),
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton
                    aria-label="toggle password visibility"
                    onClick={handleTogglePasswordVisibility}
                    edge="end"
                  >
                    {showPassword ? <VisibilityOff /> : <Visibility />}
                  </IconButton>
                </InputAdornment>
              )
            }}
          />
          
          <FormControlLabel
            control={
              <Checkbox 
                value="remember" 
                color="primary" 
                checked={saveId}
                onChange={handleSaveIdChange}
              />
            }
            label="아이디 저장"
          />
          
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2, py: 1.5 }}
            disabled={loading || authLoading}
          >
            {(loading || authLoading) ? (
              <CircularProgress size={24} color="inherit" />
            ) : (
              '로그인'
            )}
          </Button>
          
          <Divider sx={{ my: 3 }}>
            <Typography variant="body2" color="text.secondary">
              또는
            </Typography>
          </Divider>
          
          <Box sx={{ mt: 1, textAlign: 'center' }}>
            <RouterLink to="/signup" style={{ textDecoration: 'none' }}>
              <Button
                fullWidth
                variant="outlined"
                color="primary"
              >
                회원가입
              </Button>
            </RouterLink>
            
            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
              <RouterLink to="/forgot-password" style={{ color: 'inherit' }}>
                비밀번호를 잊으셨나요?
              </RouterLink>
            </Typography>
          </Box>
        </Box>
      </Paper>
    </Container>
  );
};

export default Login;


============================================================
File: /home/CVEHub/frontend/src/features/auth/SignUp.jsx
------------------------------------------------------------
import React, { useState } from 'react';
import {
  Box,
  Container,
  Typography,
  TextField,
  Button,
  Paper,
  Alert,
  IconButton,
  InputAdornment,
  Snackbar,
  Checkbox,
  FormControlLabel
} from '@mui/material';
import {
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { register } from 'features/auth/services/authService';

const SignUp = () => {
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    is_admin: false
  });
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [errors, setErrors] = useState({});
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (event) => {
    event.preventDefault();
    
    // 폼 검증 실행
    if (!validateForm()) {
      return;
    }
    
    setLoading(true);

    try {
      const userData = {
        email: formData.email,
        username: formData.username,
        password: formData.password,
        confirmPassword: formData.confirmPassword,
        is_admin: formData.is_admin
      };

      await register(userData);
      
      setSnackbar({
        open: true,
        message: '회원가입이 완료되었습니다. 로그인 페이지로 이동합니다.',
        severity: 'success'
      });

      // 회원가입 성공 후 로그인 페이지로 이동
      setTimeout(() => {
        navigate('/login');
      }, 1000);
    } catch (error) {
      console.error('회원가입 에러:', error);
      
      // 서버에서 반환한 에러 메시지가 있는 경우 해당 메시지 표시
      const errorMessage = error.response?.data?.detail || error.message || '회원가입 중 오류가 발생했습니다.';
      
      // 필드별 에러 메시지 처리
      if (error.response?.data?.errors) {
        const fieldErrors = {};
        Object.entries(error.response.data.errors).forEach(([field, message]) => {
          fieldErrors[field] = Array.isArray(message) ? message[0] : message;
        });
        setErrors(fieldErrors);
      }
      
      setSnackbar({
        open: true,
        message: errorMessage,
        severity: 'error'
      });
    } finally {
      setLoading(false);
    }
  };

  const validateForm = () => {
    const newErrors = {};
    
    // 사용자 이름 검증
    if (!formData.username.trim()) {
      newErrors.username = '사용자 이름을 입력해주세요';
    } else if (formData.username.length < 3) {
      newErrors.username = '사용자 이름은 최소 3자 이상이어야 합니다';
    } else if (formData.username.length > 30) {
      newErrors.username = '사용자 이름은 최대 30자까지 가능합니다';
    }

    // 이메일 검증
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!formData.email) {
      newErrors.email = '이메일을 입력해주세요';
    } else if (!emailRegex.test(formData.email)) {
      newErrors.email = '올바른 이메일 형식이 아닙니다';
    }

    // 비밀번호 검증
    if (!formData.password) {
      newErrors.password = '비밀번호를 입력해주세요';
    }

    // 비밀번호 확인 검증
    if (!formData.confirmPassword) {
      newErrors.confirmPassword = '비밀번호 확인을 입력해주세요';
    } else if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = '비밀번호가 일치하지 않습니다';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // 입력 시 해당 필드의 에러 메시지 제거
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: ''
      }));
    }
  };

  const handleCheckboxChange = (e) => {
    setFormData(prev => ({
      ...prev,
      is_admin: e.target.checked
    }));
  };

  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({
      ...prev,
      open: false
    }));
  };

  return (
    <Container maxWidth="sm">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Paper 
          elevation={3}
          sx={{
            padding: 4,
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
          }}
        >
          <Typography
            component="h1"
            variant="h4"
            sx={{
              mb: 4,
              fontWeight: 'bold',
              background: 'linear-gradient(45deg, #2196F3 30%, #21CBF3 90%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent'
            }}
          >
            회원가입
          </Typography>

          <Box component="form" onSubmit={handleSubmit} sx={{ width: '100%' }}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="username"
              label="사용자 이름"
              name="username"
              autoComplete="username"
              autoFocus
              value={formData.username}
              onChange={handleChange}
              error={!!errors.username}
              helperText={errors.username}
              sx={{ mb: 2 }}
            />

            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="이메일"
              name="email"
              autoComplete="email"
              value={formData.email}
              onChange={handleChange}
              error={!!errors.email}
              helperText={errors.email}
              sx={{ mb: 2 }}
            />

            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="비밀번호"
              type={showPassword ? 'text' : 'password'}
              id="password"
              autoComplete="new-password"
              value={formData.password}
              onChange={handleChange}
              error={!!errors.password}
              helperText={errors.password}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={() => setShowPassword(!showPassword)}
                      edge="end"
                    >
                      {showPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
              sx={{ mb: 2 }}
            />

            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="비밀번호 확인"
              type={showConfirmPassword ? 'text' : 'password'}
              id="confirmPassword"
              autoComplete="new-password"
              value={formData.confirmPassword}
              onChange={handleChange}
              error={!!errors.confirmPassword}
              helperText={errors.confirmPassword}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                      edge="end"
                    >
                      {showConfirmPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
              sx={{ mb: 2 }}
            />

            <FormControlLabel
              control={
                <Checkbox
                  checked={formData.is_admin}
                  onChange={handleCheckboxChange}
                  name="is_admin"
                />
              }
              label="관리자 계정으로 가입"
            />

            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{
                mt: 2,
                mb: 2,
                py: 1.5,
                fontSize: '1.1rem',
                background: 'linear-gradient(45deg, #2196F3 30%, #21CBF3 90%)',
                '&:hover': {
                  background: 'linear-gradient(45deg, #1976D2 30%, #21CBF3 90%)',
                }
              }}
            >
              회원가입
            </Button>

            <Button
              fullWidth
              onClick={() => navigate('/login')}
              sx={{
                color: 'text.secondary',
                textDecoration: 'underline',
                '&:hover': {
                  backgroundColor: 'transparent',
                  color: 'primary.main',
                }
              }}
            >
              이미 계정이 있으신가요? 로그인하기
            </Button>
          </Box>
        </Paper>
      </Box>

      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={handleCloseSnackbar}
          severity={snackbar.severity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Container>
  );
};

export default SignUp;



============================================================
File: /home/CVEHub/frontend/src/features/auth/LoginForm.tsx
------------------------------------------------------------
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Container, Grid, Paper, TextField, Button, Typography, Box, CircularProgress } from '@mui/material';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { AuthContextType, LoginRequest } from 'features/auth/types';
import { useSocket } from 'core/socket/hooks/useSocket';
import logger from 'shared/utils/logging';


interface LoginFormProps {
  username: string;
  password: string;
  setUsername: (username: string) => void;
  setPassword: (password: string) => void;
}

const LoginForm: React.FC<LoginFormProps> = ({ 
  username, 
  password, 
  setUsername, 
  setPassword 
}) => {
  const navigate = useNavigate();
  const auth: AuthContextType = useAuth();
  const socket = useSocket();
  const { connected } = socket;
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>): Promise<void> => {
    event.preventDefault();
    if (isSubmitting) return;
    
    setIsSubmitting(true);
    try {
      const loginRequest: LoginRequest = {
        username,
        password
      };
      
      await auth.loginAsync(loginRequest);
      logger.info('Auth', '로그인 성공', { username });
      
      // 소켓 연결 상태 확인 - RxJS 기반 소켓은 자동으로 연결됨
      if (!connected) {
        logger.info('Auth', '소켓 연결 대기 중', {});
        // 소켓 연결은 자동으로 이루어지므로 별도 연결 요청 불필요
      }
      
      // 로그인 성공 후 대시보드로 이동
      navigate('/dashboard');
    } catch (error) {
      logger.error('Auth', '로그인 실패', error);
      // 오류 처리는 상위 컴포넌트에서 수행
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="form-group">
        <button 
          type="submit" 
          className="btn btn-primary btn-block" 
          disabled={isSubmitting}
        >
          {isSubmitting ? '로그인 중...' : '로그인'}
        </button>
      </div>
    </form>
  );
};

export default LoginForm;


============================================================
File: /home/CVEHub/frontend/src/features/auth/services/userService.js
------------------------------------------------------------
import api from 'shared/api/config/axios';
import { AUTH } from 'shared/api/config/endpoints';

export const userService = {
  // 사용자 등록
  register: async (data) => {
    const response = await api.post(AUTH.REGISTER, data);
    return response.data;
  },

  // 사용자 로그인
  login: async (data) => {
    const response = await api.post(AUTH.LOGIN, data);
    return response.data;
  },

  // 현재 사용자 정보 조회
  getCurrentUser: async () => {
    const response = await api.get(AUTH.ME);
    return response.data;
  },

  // 현재 사용자 정보 수정
  updateCurrentUser: async (data) => {
    const response = await api.patch(AUTH.ME, data);
    return response.data;
  },

  // 현재 사용자 계정 삭제
  deleteCurrentUser: async () => {
    const response = await api.delete(AUTH.ME);
    return response.data;
  },
}; 


============================================================
File: /home/CVEHub/frontend/src/features/auth/services/authService.ts
------------------------------------------------------------
import axios from 'axios';
import {
  User,
  LoginRequest,
  LoginResponse,
  RefreshTokenRequest,
  RefreshTokenResponse,
  SignUpRequest,
  TokenPayload,
  CustomAxiosRequestConfig,
  LoginResponseData
} from '../types';
import { QueryClient } from '@tanstack/react-query';
import api from 'shared/api/config/axios';
import { getRefreshToken, getUser, setUser } from 'shared/utils/storage/tokenStorage';
import { API_BASE_URL, API_ENDPOINTS } from 'config'
import {setAccessToken, setRefreshToken, clearAuthStorage, getAccessToken } from 'shared/utils/storage/tokenStorage'

// 전역 오류 핸들러와 QueryClient 참조 저장
let globalErrorHandler: ((error: Error, context?: string) => void) | null = null;
let globalQueryClient: QueryClient | null = null;

/**
 * 오류 핸들러 주입 - API 오류 처리를 위한 전역 핸들러 설정
 * @param handler - 오류 처리 함수 (error) => void
 */
export const injectErrorHandler = (handler: (error: Error, context?: string) => void): void => {
  if (typeof handler !== 'function') {
    console.warn('유효하지 않은 오류 핸들러입니다. 함수를 전달해주세요.');
    return;
  }
  
  globalErrorHandler = handler;
  console.log('오류 핸들러가 성공적으로 주입되었습니다.');
};

/**
 * React Query Client 주입 - 인증 관련 쿼리 캐시 관리
 * @param queryClient - React Query의 QueryClient 인스턴스
 */
export const injectQueryClient = (queryClient: QueryClient): void => {
  if (!queryClient || typeof queryClient.invalidateQueries !== 'function') {
    console.warn('유효하지 않은 QueryClient입니다. React Query의 QueryClient 인스턴스를 전달해주세요.');
    return;
  }
  
  globalQueryClient = queryClient;
  console.log('QueryClient가 성공적으로 주입되었습니다.');
};

/**
 * 내부용 오류 처리 함수
 * @param error - 처리할 오류 객체
 * @param context - 오류 발생 컨텍스트
 */
const handleError = (error: Error, context = ''): void => {
  // 개발 환경에서는 콘솔 로그 출력
  if (process.env.NODE_ENV === 'development') {
    console.error(`Auth 오류 [${context}]:`, error);
  }
  
  // 글로벌 오류 핸들러가 있으면 호출
  if (globalErrorHandler) {
    try {
      globalErrorHandler(error, context);
    } catch (handlerError) {
      console.error('오류 핸들러 실행 중 예외 발생:', handlerError);
    }
  }
  
  // 401 오류는 자동으로 인증 관련 캐시 무효화
  const apiError = error as any;
  if (apiError?.response?.status === 401 && globalQueryClient) {
    globalQueryClient.invalidateQueries({queryKey: ['auth']});
  }
};

/**
 * 현재 사용자 정보 조회
 * @returns 사용자 정보
 */
export const getCurrentUser = async (): Promise<User | null> => {
  try {
    // 액세스 토큰이 없으면 API 호출하지 않고 null 반환
    const accessToken = getAccessToken();
    if (!accessToken) {
      return null;
    }
    
    // 로컬 스토리지에서 사용자 정보 확인
    const cachedUser = getUser();
    
    // 캐시된 사용자 정보가 있으면 반환
    if (cachedUser) {
      return cachedUser as User;
    }
    
    // 서버에서 사용자 정보 조회
    const response = await api.get<User>('/auth/me');
    
    // 사용자 정보 캐시 업데이트
    if (response.data) {
      setUser(response.data);
    }
    
    return response.data;
  } catch (error) {
    handleError(error as Error, 'getCurrentUser');
    throw error;
  }
};

/**
 * 토큰 갱신 (자동 갱신 로직 적용)
 * @returns 새로 발급된 액세스 토큰
 */
export const refreshToken = async (): Promise<RefreshTokenResponse> => {
  const currentRefreshToken = getRefreshToken();
  
  if (!currentRefreshToken) {
    const error = new Error('사용 가능한 리프레시 토큰이 없습니다');
    handleError(error, 'refreshToken');
    throw error;
  }

  try {
    // api 인스턴스 대신 기본 axios 사용하여 순환 참조 방지
    const response = await axios.post<RefreshTokenResponse>(
      `${API_BASE_URL}${API_ENDPOINTS.AUTH.REFRESH}`, 
      {
        refresh_token: currentRefreshToken
      },
      {
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );

    // 카멜케이스/스네이크케이스 필드명 모두 지원
    const accessToken = response.data.accessToken || (response.data as any).access_token;
    const refreshTokenValue = response.data.refreshToken || (response.data as any).refresh_token;
    const user = (response.data as any).user as User | undefined;
    
    if (!accessToken) {
      const error = new Error('응답에 새 액세스 토큰이 없습니다');
      handleError(error, 'refreshToken');
      throw error;
    }

    setAccessToken(accessToken);
    if (refreshTokenValue) {
      setRefreshToken(refreshTokenValue);
    }
    if (user) {
      setUser(user);
    }

    // QueryClient가 있으면 관련 쿼리 갱신
    if (globalQueryClient) {
      globalQueryClient.invalidateQueries({queryKey: ['auth', 'user']});
    }

    return {
      accessToken,
      refreshToken: refreshTokenValue,
      expiresIn: (response.data as any).expiresIn
    };
  } catch (error) {
    handleError(error as Error, 'refreshToken');

    const apiError = error as any;
    if (apiError.response?.status === 401 || apiError.response?.status === 403) {
      clearAuthStorage();
      
      if (typeof window !== 'undefined') {
        const currentPath = window.location.pathname + window.location.search;
        sessionStorage.setItem('redirectAfterLogin', currentPath);
      }
    }

    throw error;
  }
};

/**
 * 로그인 함수 타입 정의
 */
export type LoginFunction = (credentials: LoginRequest) => Promise<LoginResponse>;

/**
 * 사용자 로그인
 * @param credentials - 로그인 정보 (username, password)
 * @returns 로그인 결과 및 사용자 정보
 */
export const login = async (credentials: LoginRequest): Promise<LoginResponse> => {
  try {
    // 디버깅용 로그 추가
    console.log('로그인 요청 데이터:', {
      username: credentials.username,
      password: '********' // 보안상 실제 비밀번호는 로깅하지 않음
    });

    // 로그인 요청 시 x-www-form-urlencoded 형식 사용
    // URLSearchParams 사용 (백엔드 API 요구사항)
    const formData = new URLSearchParams();
    formData.append('username', credentials.username);
    formData.append('password', credentials.password);
    // grant_type 필드 추가 (OAuth2 표준)
    formData.append('grant_type', 'password');
    
    // 요청 형식 로깅
    console.log('요청 형식:', formData.toString());
    console.log('요청 헤더:', {
      'Content-Type': 'application/x-www-form-urlencoded',
    });

    // 로그인 요청 전송 (axios 인터셉터 우회)
    const axiosConfig = {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json'
      },
      skipTransform: true,
      transformRequest: [(data: any) => data], // 데이터 변환 방지
      transformResponse: [(data: any) => {
        // 응답 데이터가 문자열인 경우 JSON으로 파싱
        if (typeof data === 'string') {
          try {
            return JSON.parse(data);
          } catch (e) {
            return data;
          }
        }
        return data;
      }]
    } as CustomAxiosRequestConfig;

    const response = await axios.post<LoginResponseData>(
      `${API_BASE_URL}/auth/token`, 
      formData, 
      axiosConfig
    );

    // 응답 데이터 로깅 (토큰 마스킹 처리)
    const responseData = response.data as LoginResponseData;
    console.log('로그인 응답 데이터:', {
      ...responseData,
      access_token: responseData.access_token ? '********' : undefined,
      accessToken: responseData.accessToken ? '********' : undefined,
      refresh_token: responseData.refresh_token ? '********' : undefined,
      refreshToken: responseData.refreshToken ? '********' : undefined,
      user: responseData.user || null
    });

    // 토큰 저장 (스네이크 케이스 또는 카멜 케이스 처리)
    const accessToken = responseData.access_token || responseData.accessToken;
    const refreshToken = responseData.refresh_token || responseData.refreshToken;

    if (!accessToken) {
      throw new Error('액세스 토큰이 응답에 없습니다.');
    }

    // 토큰 저장
    setAccessToken(accessToken);
    if (refreshToken) {
      setRefreshToken(refreshToken);
    }

    // 사용자 정보 저장
    const user = responseData.user;
    if (user) {
      setUser(user);
    }

    // 로그인 응답 반환
    return {
      user: user || {} as User,
      tokens: {
        accessToken,
        refreshToken: refreshToken || ''
      }
    };
  } catch (error) {
    // 에러 처리
    console.error('로그인 오류:', error);
    
    // HTTP 에러 처리
    if (axios.isAxiosError(error) && error.response) {
      const status = error.response.status;
      
      // 401 Unauthorized: 인증 실패 (잘못된 자격 증명)
      if (status === 401) {
        throw new Error('아이디 또는 비밀번호가 올바르지 않습니다.');
      }
      
      // 422 Unprocessable Entity: 필수 필드 누락 또는 잘못된 형식
      if (status === 422) {
        throw new Error('로그인 요청 형식이 올바르지 않습니다. 필수 필드가 누락되었거나 형식이 잘못되었습니다.');
      }
      
      // 기타 HTTP 에러
      throw new Error(`로그인 요청 실패 (${status}): ${error.response.data?.message || error.message}`);
    }
    
    // 네트워크 오류 등 기타 예외
    throw new Error(`로그인 중 오류가 발생했습니다: ${(error as Error).message}`);
  }
};

/**
 * 사용자 로그아웃
 */
export const logout = async (): Promise<void> => {
  try {
    const refreshToken = getRefreshToken();
    // 서버에 로그아웃 요청 (토큰 무효화)
    await api.post('/auth/logout', { refresh_token: refreshToken });
    
    // 로컬 스토리지 초기화
    clearAuthStorage();
    
    // QueryClient가 있으면 관련 쿼리 초기화
    if (globalQueryClient) {
      globalQueryClient.clear();
    }
  } catch (error) {
    handleError(error as Error, 'logout');
    // 오류가 발생해도 로컬 스토리지는 초기화
    clearAuthStorage();
    throw error;
  }
};

/**
 * 인증 상태 확인
 * @returns 인증 여부
 */
export const isAuthenticated = (): boolean => {
  return !!getAccessToken();
};

/**
 * 사용자 토큰 확인 및 유효성 검증
 * @returns 디코딩된 토큰 정보 또는 null
 */
export const checkTokenValidity = (): TokenPayload | null => {
  try {
    const token = getAccessToken();
    
    if (!token) {
      return null;
    }
    
    // JWT 토큰 파싱 (헤더.페이로드.서명)
    const parts = token.split('.');
    if (parts.length !== 3) {
      console.warn('유효하지 않은 토큰 형식');
      return null;
    }
    
    // Base64 디코딩 및 JSON 파싱
    const payload = JSON.parse(atob(parts[1])) as TokenPayload;
    const now = Math.floor(Date.now() / 1000);
    
    // 만료 시간 확인
    if (payload.exp && payload.exp < now) {
      console.warn('토큰이 만료되었습니다');
      return null;
    }
    
    return payload;
  } catch (error) {
    handleError(error as Error, 'checkTokenValidity');
    return null;
  }
};

/**
 * 사용자 회원가입
 * @param userData - 회원가입 정보
 * @returns 회원가입 결과
 */
export const register = async (userData: SignUpRequest): Promise<User> => {
  try {
    const response = await api.post<User>('/auth/signup', userData);
    return response.data;
  } catch (error) {
    handleError(error as Error, 'register');
    const apiError = error as any;
    throw apiError.response?.data?.detail || apiError.message || '회원가입 중 오류가 발생했습니다.';
  }
};

/**
 * 사용자 권한 확인
 * @param requiredRoles - 필요한 권한 목록
 * @returns 권한 보유 여부
 */
export const hasPermission = (requiredRoles: string[] = []): boolean => {
  try {
    const user = getUser() as User | null;
    
    // 사용자 정보가 없으면 권한 없음
    if (!user || !user.role) {
      return false;
    }
    
    // 필요한 권한이 지정되지 않았으면 인증만 확인
    if (!requiredRoles.length) {
      return isAuthenticated();
    }
    
    // 사용자가 필요한 권한을 하나라도 가지고 있는지 확인
    return requiredRoles.includes(user.role);
  } catch (error) {
    handleError(error as Error, 'hasPermission');
    return false;
  }
};

/**
 * 비밀번호 재설정 요청
 * @param email - 사용자 이메일
 * @returns 요청 결과
 */
export const requestPasswordReset = async (email: string): Promise<{ success: boolean; message: string }> => {
  try {
    const response = await api.post<{ success: boolean; message: string }>('/auth/reset-password', { email });
    return response.data;
  } catch (error) {
    handleError(error as Error, 'requestPasswordReset');
    const apiError = error as any;
    throw apiError.response?.data?.detail || apiError.message || '비밀번호 재설정 요청 중 오류가 발생했습니다.';
  }
};

/**
 * 비밀번호 변경
 * @param data - 비밀번호 변경 데이터 (token, password)
 * @returns 요청 결과
 */
export const resetPassword = async (data: { token: string; password: string }): Promise<{ success: boolean; message: string }> => {
  try {
    const response = await api.post<{ success: boolean; message: string }>('/auth/confirm-reset-password', data);
    return response.data;
  } catch (error) {
    handleError(error as Error, 'resetPassword');
    const apiError = error as any;
    throw apiError.response?.data?.detail || apiError.message || '비밀번호 변경 중 오류가 발생했습니다.';
  }
};

// 통합된 인증 서비스 내보내기
export default {
  injectErrorHandler,
  injectQueryClient,
  getCurrentUser,
  refreshToken,
  login,
  logout,
  isAuthenticated,
  register,
  checkTokenValidity,
  hasPermission,
  requestPasswordReset,
  resetPassword
};


============================================================
File: /home/CVEHub/frontend/src/features/auth/PrivateRoute.jsx
------------------------------------------------------------
import React, { useEffect } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { CircularProgress, Box, Typography } from '@mui/material';
import logger from 'shared/utils/logging';
import { getAccessToken } from 'shared/utils/storage/tokenStorage';

const PrivateRoute = ({ children }) => {
  const location = useLocation();
  const { isAuthenticated, loading } = useAuth();
  const hasToken = !!getAccessToken();
  
  useEffect(() => {
    logger.info('PrivateRoute', '인증 상태 확인', { 
      isAuthenticated, 
      loading, 
      hasToken,
      path: location.pathname
    });
  }, [isAuthenticated, loading, hasToken, location.pathname]);
  
  // 토큰이 없으면 즉시 로그인 페이지로 리다이렉트
  if (!hasToken) {
    logger.info('PrivateRoute', '토큰 없음, 로그인 페이지로 리다이렉트');
    return <Navigate to="/login" state={{ from: location }} />;
  }
  
  // 로딩 중인 경우 로딩 표시
  if (loading) {
    return (
      <Box
        sx={{
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh'
        }}
      >
        <CircularProgress size={40} />
        <Typography variant="body2" sx={{ mt: 2 }}>
          인증 정보를 확인하는 중입니다...
        </Typography>
      </Box>
    );
  }

  // 인증되지 않은 경우 로그인 페이지로 리다이렉트
  if (!isAuthenticated) {
    logger.info('PrivateRoute', '인증되지 않음, 로그인 페이지로 리다이렉트');
    return <Navigate to="/login" state={{ from: location }} />;
  }

  return children;
};

export default PrivateRoute;



============================================================
File: /home/CVEHub/frontend/src/features/auth/contexts/AuthContext.tsx
------------------------------------------------------------
import React, { createContext, useContext, useEffect, useState, useRef, ReactNode, useCallback, useMemo } from 'react';
import { getAccessToken, getRefreshToken } from 'shared/utils/storage/tokenStorage';
import logger from 'shared/utils/logging';
import socketService from 'core/socket/services/socketService';
import { useAuthQuery } from 'features/auth/hooks/useAuthQuery';
import { TOKEN_REFRESH_THRESHOLD } from 'config';
import { User, LoginRequest, LoginResponse, RefreshTokenResponse, AuthContextType } from 'features/auth/types';
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
import isEqual from 'lodash/isEqual';
import memoize from 'lodash/memoize';

// Provider Props 인터페이스
interface AuthProviderProps {
  children: ReactNode;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const { 
    user, 
    isAuthenticated, 
    isLoading, 
    error, 
    login, 
    loginAsync, 
    logout, 
    logoutAsync, 
    refreshToken: refreshTokenMutation, 
    refreshTokenAsync: refreshTokenAsyncMutation 
  } = useAuthQuery();
  
  // 로컬 상태 추가
  const [loading, setLoading] = useState<boolean>(true);
  const [accessToken, setAccessToken] = useState<string | null>(getAccessToken());
  const initRef = useRef<boolean>(false);
  const prevUserRef = useRef<User | null>(null);

  // JWT 토큰 디코딩 함수 메모이제이션
  const decodeToken = useMemo(() => memoize((token: string) => {
    try {
      return JSON.parse(atob(token.split('.')[1]));
    } catch (e) {
      logger.error('AuthContext', '토큰 디코딩 실패', e);
      return null;
    }
  }), []);

  // 초기 인증 상태 확인
  useEffect(() => {
    const checkInitialAuth = async (): Promise<void> => {
      try {
        const hasAccessToken = !!getAccessToken()?.trim();
        const hasRefreshToken = !!getRefreshToken()?.trim();
        
        logger.info('AuthContext', '초기 인증 상태 확인', { 
          hasAccessToken, 
          hasRefreshToken,
          isLoading,
          isAuthenticated
        });
        
        // 토큰이 없으면 로딩 상태 즉시 해제
        if (!hasAccessToken) {
          setLoading(false);
          return;
        }
        
        // 토큰이 있으면 사용자 정보 로딩 상태 유지
        // useAuthQuery의 쿼리가 완료되면 isLoading이 false가 됨
        if (!isLoading) {
          setLoading(false);
        }
      } catch (error) {
        logger.error('AuthContext', '초기 인증 상태 확인 중 오류', error);
        setLoading(false);
      }
    };
    
    checkInitialAuth();
  }, [isLoading, isAuthenticated]);

  // 디바운스된 토큰 상태 업데이트 함수
  const debouncedSetAccessToken = useCallback(
    debounce((newToken: string | null) => {
      setAccessToken(newToken);
    }, 300),
    []
  );

  // 토큰 상태 정기 확인 (1초마다)
  useEffect(() => {
    if (initRef.current) return;
    
    logger.info('AuthContext', '초기화됨', {});
    initRef.current = true;
    
    // 정기적으로 토큰 상태 확인
    const tokenCheckInterval = setInterval(() => {
      const currentAccessToken = getAccessToken();
      if (currentAccessToken !== accessToken) {
        logger.info('AuthContext', '토큰 상태 변경 감지', {});
        debouncedSetAccessToken(currentAccessToken);
      }
    }, 1000);
    
    return () => {
      clearInterval(tokenCheckInterval);
    };
  }, [accessToken, debouncedSetAccessToken]);

  // 스로틀된 토큰 갱신 함수
  const throttledRefreshToken = useCallback(
    throttle(async () => {
      try {
        logger.info('AuthContext', '토큰 갱신 시도 (스로틀)', {});
        await refreshTokenAsyncMutation();
      } catch (error) {
        logger.error('AuthContext', '토큰 갱신 중 오류 발생', error);
      }
    }, 10000, { leading: true, trailing: false }),
    [refreshTokenAsyncMutation]
  );

  // 토큰 자동 갱신 설정
  useEffect(() => {
    if (!isAuthenticated) return;
    
    logger.info('AuthContext', '토큰 자동 갱신 설정', {});
    
    // 토큰 만료 시간 확인 및 갱신 함수
    const checkTokenExpiration = async (): Promise<void> => {
      try {
        const token = getAccessToken();
        if (!token) return;
        
        // JWT 토큰에서 만료 시간 추출 (메모이제이션 활용)
        const tokenData = decodeToken(token);
        if (!tokenData) return;
        
        const expirationTime = tokenData.exp * 1000; // 초 -> 밀리초
        const currentTime = Date.now();
        const timeUntilExpiration = expirationTime - currentTime;
        
        // 만료 임계값(5분) 이내면 토큰 갱신
        if (timeUntilExpiration < TOKEN_REFRESH_THRESHOLD) {
          logger.info('AuthContext', '토큰 만료 임박, 갱신 시도', {
            expiresIn: Math.floor(timeUntilExpiration / 1000)
          });
          throttledRefreshToken();
        }
      } catch (error) {
        logger.error('AuthContext', '토큰 갱신 중 오류 발생', error);
      }
    };
    
    // 초기 실행 및 주기적 실행 설정 (1분마다)
    checkTokenExpiration();
    const refreshInterval = setInterval(checkTokenExpiration, 60 * 1000);
    
    return () => {
      clearInterval(refreshInterval);
    };
  }, [isAuthenticated, throttledRefreshToken, decodeToken]);

  // Socket.IO 연결 관리 (사용자 변경 시에만 재연결)
  useEffect(() => {
    // isEqual을 사용하여 깊은 비교 수행
    if (!isEqual(prevUserRef.current, user)) {
      prevUserRef.current = user;
      
      if (isAuthenticated && user) {
        logger.info('AuthContext', 'Socket.IO 연결 요청', {});
        // 직접 연결하지 않고 SocketIOContext에 인증 상태 변경을 알림
        if (socketService && socketService.handleAuthStateChange) {
          socketService.handleAuthStateChange(true);
        }
      } else {
        logger.info('AuthContext', 'Socket.IO 연결 해제 요청', {});
        // 직접 연결 해제하지 않고 SocketIOContext에 인증 상태 변경을 알림
        if (socketService && socketService.handleAuthStateChange) {
          socketService.handleAuthStateChange(false);
        }
      }
    }
    
    return () => {
      // 컴포넌트 언마운트 시 연결 해제 요청
      if (socketService && socketService.handleAuthStateChange) {
        socketService.handleAuthStateChange(false);
      }
    };
  }, [isAuthenticated, user]);

  // 로그인 핸들러 (useCallback으로 메모이제이션)
  const handleLogin = useCallback(async (credentials: LoginRequest): Promise<LoginResponse> => {
    setLoading(true);
    try {
      const result = await loginAsync(credentials);
      logger.info('AuthContext', '로그인 성공', {});
      return result;
    } catch (error) {
      logger.error('AuthContext', '로그인 실패', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [loginAsync]);

  // 로그아웃 핸들러 (useCallback으로 메모이제이션)
  const handleLogout = useCallback(async (): Promise<void> => {
    setLoading(true);
    try {
      await logoutAsync();
      logger.info('AuthContext', '로그아웃 성공', {});
    } catch (error) {
      logger.error('AuthContext', '로그아웃 실패', error);
    } finally {
      setLoading(false);
    }
  }, [logoutAsync]);

  // refreshToken 래퍼 함수 (useCallback으로 메모이제이션)
  const handleRefreshToken = useCallback(async (refreshToken?: string): Promise<void> => {
    try {
      // refreshTokenMutation은 매개변수를 사용하지 않지만, 인터페이스 일관성을 위해 래퍼 함수 제공
      await refreshTokenMutation();
    } catch (error) {
      logger.error('AuthContext', '토큰 갱신 실패', error);
      throw error;
    }
  }, [refreshTokenMutation]);

  // refreshTokenAsync 래퍼 함수 (useCallback으로 메모이제이션)
  const handleRefreshTokenAsync = useCallback(async (refreshToken?: string): Promise<void> => {
    try {
      // refreshTokenAsyncMutation은 매개변수를 사용하지 않지만, 인터페이스 일관성을 위해 래퍼 함수 제공
      await refreshTokenAsyncMutation();
    } catch (error) {
      logger.error('AuthContext', '토큰 갱신 실패', error);
      throw error;
    }
  }, [refreshTokenAsyncMutation]);

  // Context 값 (useMemo로 메모이제이션)
  const value = useMemo<AuthContextType>(() => ({
    user: user || null,
    isAuthenticated,
    loading: loading || isLoading,
    error,
    login: handleLogin,
    logout: handleLogout,
    accessToken: getAccessToken(),
    loginAsync,
    logoutAsync,
    refreshToken: handleRefreshToken,
    refreshTokenAsync: handleRefreshTokenAsync
  }), [
    user, 
    isAuthenticated, 
    loading, 
    isLoading, 
    error, 
    handleLogin, 
    handleLogout, 
    loginAsync, 
    logoutAsync, 
    handleRefreshToken, 
    handleRefreshTokenAsync
  ]);

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export default AuthContext;



============================================================
File: /home/CVEHub/frontend/src/features/auth/hooks/useAuthQuery.ts
------------------------------------------------------------
import { useMutation, useQueryClient } from '@tanstack/react-query';

import debounce from 'lodash/debounce';
import { useCallback, useEffect, useRef } from 'react';
import { LoginRequest, LoginResponse, RefreshTokenResponse } from '../types';
import { refreshToken, login, logout } from 'features/auth/services/authService';
import { getAccessToken, setAccessToken, setRefreshToken, clearAuthStorage } from 'shared/utils/storage/tokenStorage';
import logger from 'shared/utils/logging';
import { useCurrentUser } from './useUsersQuery';

/**
 * 인증 관련 React Query 훅
 */
export const useAuthQuery = () => {
  const queryClient = useQueryClient();
  
  // 현재 사용자 정보 조회 쿼리 (useUsersQuery에서 가져옴)
  const userQuery = useCurrentUser();

  // 로그인 뮤테이션
  const loginMutation = useMutation({
    mutationFn: (credentials: LoginRequest) => login(credentials),
    onSuccess: (data: LoginResponse) => {
      logger.info('AuthQuery', '로그인 성공', data);
      
      // 토큰 저장
      if (data.tokens?.accessToken) setAccessToken(data.tokens.accessToken);
      if (data.tokens?.refreshToken) setRefreshToken(data.tokens.refreshToken);
    }
  });

  // 로그아웃 뮤테이션
  const logoutMutation = useMutation({
    mutationFn: logout,
    onSuccess: () => {
      logger.info('AuthQuery', '로그아웃 성공', null);
      
      // 인증 정보 초기화
      clearAuthStorage();
      
      // 쿼리 캐시 초기화
      queryClient.setQueryData(['auth', 'user'], null);
      queryClient.invalidateQueries();
    }
  });

  // 토큰 갱신 뮤테이션
  const refreshTokenMutation = useMutation({
    mutationFn: refreshToken,
    onSuccess: (data: RefreshTokenResponse) => {
      logger.info('AuthQuery', '토큰 갱신 성공', data);
      
      // 토큰 저장
      if (data.accessToken) setAccessToken(data.accessToken);
      if (data.refreshToken) setRefreshToken(data.refreshToken);
    }
  });

  // 토큰 갱신 요청 중인지 추적하는 플래그
  const isRefreshingRef = useRef(false);

  // 디바운스된 토큰 갱신 함수 (300ms)
  const debouncedRefreshToken = useCallback(
    debounce((callback?: () => void) => {
      // 이미 갱신 중이면 중복 요청 방지
      if (isRefreshingRef.current) {
        logger.info('AuthQuery', '토큰 갱신 이미 진행 중, 요청 무시');
        return;
      }

      isRefreshingRef.current = true;
      logger.info('AuthQuery', '디바운스된 토큰 갱신 요청 실행');
      
      refreshTokenMutation.mutate(undefined, {
        onSuccess: () => {
          isRefreshingRef.current = false;
          if (callback) callback();
        },
        onError: () => {
          isRefreshingRef.current = false;
        }
      });
    }, 300),
    [refreshTokenMutation]
  );
  
  // 컴포넌트 언마운트 시 디바운스 함수 취소
  useEffect(() => {
    return () => {
      // @ts-ignore - TypeScript에서 cancel 메서드를 인식하지 못할 수 있음
      debouncedRefreshToken.cancel && debouncedRefreshToken.cancel();
    };
  }, [debouncedRefreshToken]);

  // 인증 상태 확인
  const isAuthenticated = !!getAccessToken() && !!userQuery.data;
  
  // 로딩 상태 확인
  const isLoading = 
    userQuery.isLoading || 
    loginMutation.isPending || 
    logoutMutation.isPending || 
    refreshTokenMutation.isPending;

  return {
    user: userQuery.data,
    isAuthenticated,
    isLoading,
    error: userQuery.error || loginMutation.error || logoutMutation.error,
    login: loginMutation.mutate,
    loginAsync: loginMutation.mutateAsync,
    logout: logoutMutation.mutate,
    logoutAsync: logoutMutation.mutateAsync,
    refreshToken: debouncedRefreshToken,
    refreshTokenAsync: refreshTokenMutation.mutateAsync, // 비동기 버전은 그대로 유지
    isRefreshingToken: isRefreshingRef.current
  } as const;
};


============================================================
File: /home/CVEHub/frontend/src/features/auth/hooks/useUsersQuery.ts
------------------------------------------------------------
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'shared/api/config/axios';
import { userService } from '../services/userService';
import { getCurrentUser } from '../services/authService';
import { getAccessToken } from 'shared/utils/storage/tokenStorage';
import { User, UserUpdate } from '../types/index';

/**
 * 사용자 목록 조회 응답 타입
 */
export interface UserListResponse {
  items: User[];
  total: number;
}

/**
 * 현재 사용자 정보 조회 훅
 * 
 * @returns 현재 사용자 정보 쿼리 결과
 */
export const useCurrentUser = () => {
  // 액세스 토큰이 있는지 확인
  const hasToken = Boolean(getAccessToken());
  
  return useQuery({
    queryKey: ['auth', 'user'],
    queryFn: getCurrentUser,
    staleTime: 5 * 60 * 1000, // 5분
    retry: 1,
    // 토큰이 있을 때만 쿼리 실행
    enabled: hasToken
  });
};

/**
 * 전체 사용자 목록을 조회하는 훅
 * 
 * @returns 사용자 목록 쿼리 결과
 */
export const useUsers = () => {
  return useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      try {
        const { data } = await axios.get('/auth/');
        return data;
      } catch (error) {
        console.error('사용자 목록 조회 중 오류 발생:', error);
        throw error;
      }
    },
    staleTime: 5 * 60 * 1000, // 5분
    retry: 1
  });
};

/**
 * 사용자 검색을 위한 훅
 * 
 * @param query 검색어
 * @returns 검색 결과 쿼리
 */
export const useSearchUsers = (query: string) => {
  return useQuery({
    queryKey: ['users', 'search', query],
    queryFn: async () => {
      try {
        if (!query || query.length < 2) {
          return { items: [] };
        }
        
        const { data } = await axios.get(`/auth/search`, {
          params: { query }
        });
        return data;
      } catch (error) {
        console.error('사용자 검색 중 오류 발생:', error);
        throw error;
      }
    },
    enabled: !!query && query.length >= 2,
    staleTime: 60 * 1000, // 1분
    retry: 1
  });
};

/**
 * 사용자 정보 업데이트 훅
 * 
 * @returns 사용자 정보 업데이트 뮤테이션
 */
export const useUpdateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (userData: UserUpdate) => userService.updateCurrentUser(userData),
    onSuccess: (updatedUser) => {
      // 사용자 정보 캐시 업데이트
      queryClient.setQueryData(['auth', 'user'], updatedUser);
      // 사용자 목록 캐시 무효화
      queryClient.invalidateQueries({ queryKey: ['users'] });
    }
  });
};

/**
 * 사용자 계정 삭제 훅
 * 
 * @returns 사용자 계정 삭제 뮤테이션
 */
export const useDeleteUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: () => userService.deleteCurrentUser(),
    onSuccess: () => {
      // 사용자 정보 캐시 초기화
      queryClient.setQueryData(['auth', 'user'], null);
      // 사용자 목록 캐시 무효화
      queryClient.invalidateQueries({ queryKey: ['users'] });
    }
  });
};

export default useUsers;



============================================================
File: /home/CVEHub/frontend/src/features/auth/Register.jsx
------------------------------------------------------------
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import {
  Container,
  Paper,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  CircularProgress,
  FormControlLabel,
  Checkbox,
  InputAdornment,
  IconButton
} from '@mui/material';
import { Visibility, VisibilityOff } from '@mui/icons-material';
import { api } from '../../utils/auth';

const Register = () => {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
  });
  const [isAdmin, setIsAdmin] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      await api.post('/auth/register', {
        username: formData.username,
        password: formData.password,
        is_admin: isAdmin
      });

      // 회원가입 성공 시 로그인 페이지로 이동
      navigate('/login', {
        state: { message: 'Registration successful! Please login.' }
      });
    } catch (err) {
      setError(err.response?.data?.detail || 'Registration failed');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Paper elevation={3} sx={{ p: 4, width: '100%' }}>
          <Typography component="h1" variant="h4" align="center" gutterBottom>
            CVE Hub
          </Typography>
          <Typography component="h2" variant="h6" align="center" gutterBottom>
            Create Account
          </Typography>

          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}

          <form onSubmit={handleSubmit}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="username"
              label="Username"
              name="username"
              autoComplete="username"
              autoFocus
              value={formData.username}
              onChange={handleChange}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email Address"
              name="email"
              autoComplete="email"
              type="email"
              value={formData.email}
              onChange={handleChange}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type={showPassword ? 'text' : 'password'}
              id="password"
              autoComplete="new-password"
              value={formData.password}
              onChange={handleChange}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      onClick={() => setShowPassword(!showPassword)}
                      edge="end"
                    >
                      {showPassword ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirm Password"
              type={showPassword ? 'text' : 'password'}
              id="confirmPassword"
              autoComplete="new-password"
              value={formData.confirmPassword}
              onChange={handleChange}
            />

            <FormControlLabel
              control={
                <Checkbox
                  checked={isAdmin}
                  onChange={(e) => setIsAdmin(e.target.checked)}
                  color="primary"
                />
              }
              label="Register as Admin"
              sx={{ mt: 1 }}
            />

            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2 }}
              disabled={loading}
            >
              {loading ? <CircularProgress size={24} /> : 'Register'}
            </Button>

            <Box sx={{ textAlign: 'center' }}>
              <Link to="/login" style={{ textDecoration: 'none' }}>
                <Typography variant="body2" color="primary">
                  Already have an account? Login
                </Typography>
              </Link>
            </Box>
          </form>
        </Paper>
      </Box>
    </Container>
  );
};

export default Register;



============================================================
File: /home/CVEHub/frontend/src/features/notification/types/index.ts
------------------------------------------------------------
/**
 * 알림 관련 타입 정의 파일
 */

/**
 * 알림 타입 열거형
 */
export enum NotificationType {
  CVE_CREATED = 'CVE_CREATED',
  CVE_UPDATED = 'CVE_UPDATED',
  COMMENT_ADDED = 'COMMENT_ADDED',
  MENTION = 'MENTION',
  SYSTEM = 'SYSTEM',
}

/**
 * 알림 우선순위 열거형
 */
export enum NotificationPriority {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
}

/**
 * 기본 알림 인터페이스
 */
export interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  message: string;
  createdAt: string | Date;
  isRead: boolean;
  priority?: NotificationPriority;
  targetUrl?: string;
  data?: Record<string, any>;
}

/**
 * CVE 관련 알림 인터페이스
 */
export interface CVENotification extends Notification {
  type: NotificationType.CVE_CREATED | NotificationType.CVE_UPDATED;
  data: {
    cveId: string;
    title?: string;
    fieldUpdated?: string;
    updatedBy?: string;
  };
}

/**
 * 댓글 관련 알림 인터페이스
 */
export interface CommentNotification extends Notification {
  type: NotificationType.COMMENT_ADDED;
  data: {
    cveId: string;
    commentId: string;
    commentAuthor: string;
  };
}

/**
 * 언급 알림 인터페이스
 */
export interface MentionNotification extends Notification {
  type: NotificationType.MENTION;
  data: {
    cveId: string;
    commentId: string;
    mentionedBy: string;
    commentText?: string;
  };
}

/**
 * 시스템 알림 인터페이스
 */
export interface SystemNotification extends Notification {
  type: NotificationType.SYSTEM;
  data?: {
    severity?: 'info' | 'warning' | 'error';
    action?: string;
  };
}

/**
 * 알림 필터 옵션 인터페이스
 */
export interface NotificationFilterOptions {
  isRead?: boolean;
  type?: NotificationType;
  priority?: NotificationPriority;
  fromDate?: string | Date;
  toDate?: string | Date;
}

/**
 * 알림 업데이트 요청 인터페이스
 */
export interface NotificationUpdateRequest {
  isRead?: boolean;
}

/**
 * 알림 설정 인터페이스
 */
export interface NotificationSettings {
  emailNotifications: boolean;
  browserNotifications: boolean;
  notifyOnCveCreated: boolean;
  notifyOnCveUpdated: boolean;
  notifyOnCommentAdded: boolean;
  notifyOnMention: boolean;
  notifyOnSystem: boolean;
}


============================================================
File: /home/CVEHub/frontend/src/features/notification/NotificationBell.tsx
------------------------------------------------------------
import React, { useEffect, useState, useCallback, memo } from 'react';
import {
  Badge,
  IconButton,
  Menu,
  MenuItem,
  Typography,
  Box,
  Divider,
  Button,
  Snackbar,
  Alert,
  CircularProgress
} from '@mui/material';
import NotificationsIcon from '@mui/icons-material/Notifications';
import { useNotifications, useUnreadCount, useMarkAsRead, useMarkAllAsRead } from '../../features/notification/hooks/useNotifications';
import CVEDetail from '../cve/CVEDetail';
import { NotificationBellProps } from '../../shared/api/types/components';
/**
 * 알림 종 컴포넌트 - RxJS 마이그레이션 버전
 * 
 * 웹 알림을 표시하고 관리하는 컴포넌트입니다.
 * CVE 관련 알림을 받으면 사용자에게 표시하고, 클릭 시 상세 정보를 보여줍니다.
 */
const NotificationBell: React.FC<NotificationBellProps> = memo(({ onOpenCVEDetail }) => {
  const [anchorEl, setAnchorEl] = useState<HTMLElement | null>(null);
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'info' as 'info' | 'error' | 'success' | 'warning'
  });
  const [dialogOpen, setDialogOpen] = useState(false);
  const [selectedCVE, setSelectedCVE] = useState<string | null>(null);
  const [selectedCommentId, setSelectedCommentId] = useState<string | null>(null);

  const ITEMS_PER_PAGE = 5;
  const skip = page * ITEMS_PER_PAGE;
  
  // React Query 훅 사용
  const { data: unreadCountData } = useUnreadCount({
    refetchOnWindowFocus: true,
    refetchInterval: 60000, // 1분마다 갱신
  });
  
  const { 
    data: notificationsData, 
    isLoading: notificationsLoading,
    refetch: refetchNotifications
  } = useNotifications(
    { skip, limit: ITEMS_PER_PAGE },
    { 
      enabled: Boolean(anchorEl),
      keepPreviousData: true
    }
  );
  
  const markAsReadMutation = useMarkAsRead();
  const markAllAsReadMutation = useMarkAllAsRead();
  
  const notifications = notificationsData?.notifications || [];
  const totalCount = notificationsData?.total || 0;
  const unreadCount = unreadCountData?.count || 0;
  
  const loadNotifications = useCallback((newPage: number) => {
    setPage(newPage);
    setHasMore((newPage + 1) * ITEMS_PER_PAGE < totalCount);
  }, [totalCount]);
  
  const loadMoreNotifications = useCallback(() => {
    if (hasMore && !notificationsLoading) {
      loadNotifications(page + 1);
    }
  }, [hasMore, notificationsLoading, loadNotifications, page]);
  
  // 알림 목록 가져오기
  useEffect(() => {
    if (Boolean(anchorEl)) {
      loadNotifications(0);
    }
  }, [anchorEl, loadNotifications]);
  
  // 알림 ID 추출 헬퍼 함수
  const getNotificationId = useCallback((notification: any): string | null => {
    if (!notification) return null;
    
    // MongoDB ObjectId 또는 일반 ID 처리
    if (notification._id) return notification._id;
    if (notification.id) return notification.id;
    
    return null;
  }, []);
  
  const handleClick = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };
  
  const handleClose = () => {
    setAnchorEl(null);
  };
  
  const handleMarkAllAsRead = async () => {
    try {
      await markAllAsReadMutation.mutateAsync();
      
      setSnackbar({
        open: true,
        message: '모든 알림을 읽음 처리했습니다.',
        severity: 'success'
      });
      
      // 알림 목록 새로고침
      refetchNotifications();
    } catch (error: any) {
      console.error('모든 알림 읽음 처리 오류:', error);
      
      setSnackbar({
        open: true,
        message: '모든 알림을 읽음 처리하는 중 오류가 발생했습니다.',
        severity: 'error'
      });
    }
  };
  
  const formatNotificationContent = useCallback((notification: any) => {
    const { type, content, metadata } = notification;
    
    switch (type) {
      case 'cve_update':
        return (
          <Typography variant="body1">
            <strong>CVE 업데이트:</strong> {content}
          </Typography>
        );
      
      case 'comment':
        return (
          <Typography variant="body1">
            <strong>댓글:</strong> {content}
          </Typography>
        );
      
      case 'system':
        return (
          <Typography variant="body1">
            {content}
          </Typography>
        );
      
      default:
        return (
          <Typography variant="body1">
            {content}
          </Typography>
        );
    }
  }, []);
  
  const handleNotificationClick = async (notification: any) => {
    try {
      const id = getNotificationId(notification);
      
      if (!id) {
        console.error('%c ❌ 알림 ID 오류', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', '유효하지 않은 알림 ID');
        return;
      }
      
      // 읽음 처리
      await markAsReadMutation.mutateAsync(id);
      
      // CVE 관련 알림인 경우 상세 정보 표시
      if (notification.metadata && notification.metadata.cve_id) {
        const cveId = notification.metadata.cve_id;
        const commentId = notification.metadata.comment_id || null;
        
        // 외부에서 전달된 onOpenCVEDetail 함수가 있으면 사용
        if (onOpenCVEDetail) {
          handleClose(); // 메뉴 닫기
          onOpenCVEDetail(cveId, commentId);
        } else {
          // 내부 다이얼로그 사용
          setSelectedCVE(cveId);
          setSelectedCommentId(commentId);
          setDialogOpen(true);
        }
      }
    } catch (error: any) {
      console.error('%c ❌ 알림 읽음 처리 오류', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', {
        message: error.message,
        code: error.code
      });
      setSnackbar({
        open: true,
        message: '알림을 읽음 처리하는 중 오류가 발생했습니다.',
        severity: 'error'
      });
    }
  };
  
  const handleDialogClose = () => {
    setDialogOpen(false);
    setSelectedCVE(null);
    setSelectedCommentId(null);
  };
  
  const handleSnackbarClose = useCallback(() => {
    setSnackbar(prev => ({ ...prev, open: false }));
  }, []);
  
  const formatDate = (dateString: string) => {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHour = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHour / 24);
    
    if (diffDay > 7) {
      return date.toLocaleDateString('ko-KR', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      });
    } else if (diffDay > 0) {
      return `${diffDay}일 전`;
    } else if (diffHour > 0) {
      return `${diffHour}시간 전`;
    } else if (diffMin > 0) {
      return `${diffMin}분 전`;
    } else {
      return '방금 전';
    }
  };
  
  return (
    <>
      <IconButton
        color="inherit"
        onClick={handleClick}
        aria-label="알림"
      >
        <Badge badgeContent={unreadCount} color="error">
          <NotificationsIcon />
        </Badge>
      </IconButton>
      
      <Menu
        id="notification-menu"
        anchorEl={anchorEl}
        keepMounted
        open={Boolean(anchorEl)}
        onClose={handleClose}
        PaperProps={{
          style: {
            width: '320px',
            maxHeight: '70vh',
          },
        }}
      >
        <Box sx={{ p: 1, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
            알림
            {unreadCount > 0 && (
              <Typography component="span" color="error" sx={{ ml: 1 }}>
                ({unreadCount}개 안 읽음)
              </Typography>
            )}
          </Typography>
          
          {unreadCount > 0 && (
            <Button 
              size="small" 
              color="primary" 
              onClick={handleMarkAllAsRead}
              disabled={markAllAsReadMutation.isLoading}
            >
              {markAllAsReadMutation.isLoading ? (
                <CircularProgress size={16} />
              ) : (
                '모두 읽음'
              )}
            </Button>
          )}
        </Box>
        
        <Divider />
        
        {notificationsLoading && (
          <Box sx={{ p: 2, textAlign: 'center' }}>
            <CircularProgress size={24} />
          </Box>
        )}
        
        {!notificationsLoading && notifications.length === 0 && (
          <Box sx={{ p: 2, textAlign: 'center' }}>
            <Typography variant="body2" color="text.secondary">
              알림이 없습니다.
            </Typography>
          </Box>
        )}
        
        {notifications.map((notification: any, index: number) => (
          <React.Fragment key={getNotificationId(notification) || index}>
            <MenuItem 
              onClick={() => handleNotificationClick(notification)}
              sx={{ 
                py: 1.5,
                px: 2,
                borderLeft: notification.read ? 'none' : '4px solid',
                borderColor: 'primary.main',
                backgroundColor: notification.read ? 'transparent' : 'rgba(0, 0, 0, 0.04)',
                '&:hover': {
                  backgroundColor: notification.read ? 'rgba(0, 0, 0, 0.08)' : 'rgba(0, 0, 0, 0.1)',
                }
              }}
            >
              <Box sx={{ width: '100%' }}>
                {formatNotificationContent(notification)}
                
                <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mt: 0.5 }}>
                  {formatDate(notification.createdAt)}
                </Typography>
              </Box>
            </MenuItem>
            {index < notifications.length - 1 && <Divider />}
          </React.Fragment>
        ))}
        
        {hasMore && (
          <Box sx={{ p: 1, textAlign: 'center' }}>
            <Button 
              size="small" 
              onClick={loadMoreNotifications}
              disabled={notificationsLoading}
            >
              더 보기
            </Button>
          </Box>
        )}
      </Menu>
      
      {/* CVE 상세 다이얼로그 */}
      {dialogOpen && selectedCVE && (
        <CVEDetail
          cveId={selectedCVE}
          open={dialogOpen}
          onClose={handleDialogClose}
          highlightCommentId={selectedCommentId}
        />
      )}
      
      {/* 알림 스낵바 */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={5000}
        onClose={handleSnackbarClose}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbar.severity}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </>
  );
});

export default NotificationBell;



============================================================
File: /home/CVEHub/frontend/src/features/notification/services/notificationService.js
------------------------------------------------------------
import api from 'shared/api/config/axios';
import { NOTIFICATION, WEBSOCKET } from 'shared/api/config/endpoints';

export const notificationService = {
  // 알림 목록 조회
  getNotifications: async (params) => {
    const response = await api.get(NOTIFICATION.BASE, { params });
    return response.data;
  },

  // 읽지 않은 알림 개수 조회
  getUnreadCount: async () => {
    const response = await api.get(NOTIFICATION.UNREAD_COUNT);
    return response.data;
  },

  // 알림 읽음 처리
  markAsRead: async (id) => {
    const response = await api.patch(NOTIFICATION.READ(id));
    return response.data;
  },

  // 모든 알림 읽음 처리
  markAllAsRead: async () => {
    const response = await api.patch(NOTIFICATION.READ_ALL);
    return response.data;
  },

  // WebSocket 연결 URL 생성
  getWebSocketUrl: (userId, token) => {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsHost = process.env.REACT_APP_API_URL || `${window.location.protocol}//${window.location.hostname}:8000`;
    const cleanHost = wsHost.replace(/^https?:\/\//, '');
    return `${wsProtocol}//${cleanHost}${WEBSOCKET.CONNECT(userId, token)}`;
  },
}; 


============================================================
File: /home/CVEHub/frontend/src/features/notification/hooks/useNotifications.js
------------------------------------------------------------
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { notificationService } from '../services/notificationService';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { useSocket } from 'core/socket/hooks/useSocket';
import { useEffect, useCallback } from 'react';
import logger from 'shared/utils/logging';

/**
 * 알림 목록을 조회하는 훅
 * @param {Object} params - 페이지네이션 파라미터 (skip, limit)
 * @param {Object} options - React Query 옵션
 * @returns {Object} 쿼리 결과
 */
export const useNotifications = (params = {}, options = {}) => {
  return useQuery({
    queryKey: [QUERY_KEYS.NOTIFICATION, 'list', params],
    queryFn: () => notificationService.getNotifications(params),
    ...options,
  });
};

/**
 * 읽지 않은 알림 개수를 조회하는 훅
 * @param {Object} options - React Query 옵션
 * @returns {Object} 쿼리 결과
 */
export const useUnreadCount = (options = {}) => {
  const queryClient = useQueryClient();
  // useSocket 훅 사용 - 함수 시그니처에 맞게 수정
  const { on } = useSocket(
    undefined, // 이벤트 이름은 지정하지 않음
    undefined, // 콜백 함수는 지정하지 않음
    [], // 의존성 배열
    {
      componentId: 'notifications-unread-count',
      useRxJS: true
    }
  );
  
  // 실시간 알림 수신 시 카운트 업데이트
  useEffect(() => {
    // 새 알림 이벤트 리스너
    const unsubNewNotification = on('NEW_NOTIFICATION', () => {
      logger.info('새 알림 이벤트 수신');
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'] });
    });
    
    // 컴포넌트 언마운트 시 이벤트 리스너 제거
    return () => {
      unsubNewNotification();
    };
  }, [on, queryClient]);
  
  return useQuery({
    queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'],
    queryFn: () => notificationService.getUnreadCount(),
    ...options,
  });
};

/**
 * 알림을 읽음 처리하는 훅
 * @returns {Object} 뮤테이션 결과
 */
export const useMarkAsRead = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (id) => notificationService.markAsRead(id),
    onSuccess: () => {
      // 알림 목록과 읽지 않은 알림 개수 갱신
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'list'] });
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'] });
    },
  });
};

/**
 * 모든 알림을 읽음 처리하는 훅
 * @returns {Object} 뮤테이션 결과
 */
export const useMarkAllAsRead = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: () => notificationService.markAllAsRead(),
    onSuccess: () => {
      // 알림 목록과 읽지 않은 알림 개수 갱신
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'list'] });
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'] });
    },
  });
};

/**
 * 실시간 알림 업데이트를 구독하는 훅
 * @returns {Object} 구독 상태
 */
export const useNotificationUpdates = () => {
  const queryClient = useQueryClient();
  // useSocket 훅 사용 - 함수 시그니처에 맞게 수정
  const { connected, on } = useSocket(
    undefined, // 이벤트 이름은 지정하지 않음
    undefined, // 콜백 함수는 지정하지 않음
    [], // 의존성 배열
    {
      componentId: 'notification-updates',
      useRxJS: true
    }
  );
  
  // 새 알림 이벤트 핸들러
  const handleNewNotification = useCallback((notification) => {
    logger.info('새 알림 수신:', notification);
    
    // 알림 목록과 읽지 않은 알림 개수 갱신
    queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'list'] });
    queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'] });
  }, [queryClient]);
  
  // 읽음 처리 이벤트 핸들러
  const handleNotificationRead = useCallback((data) => {
    logger.info('알림 읽음 이벤트 수신:', data);
    
    // 알림 목록과 읽지 않은 알림 개수 갱신
    queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'list'] });
    queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'] });
  }, [queryClient]);
  
  // 소켓 이벤트 구독 설정
  useEffect(() => {
    if (connected) {
      // 이벤트 구독 설정
      const unsubNew = on('NEW_NOTIFICATION', handleNewNotification);
      const unsubRead = on('NOTIFICATION_READ', handleNotificationRead);
      const unsubAllRead = on('ALL_NOTIFICATIONS_READ', handleNotificationRead);
      
      // 컴포넌트 언마운트 시 정리 작업
      return () => {
        unsubNew();
        unsubRead();
        unsubAllRead();
      };
    }
  }, [connected, on, handleNewNotification, handleNotificationRead, queryClient]);
  
  return { isConnected: connected };
};

export default {
  useNotifications,
  useUnreadCount,
  useMarkAsRead,
  useMarkAllAsRead,
  useNotificationUpdates
};


============================================================
File: /home/CVEHub/frontend/src/features/cache/services/cacheService.js
------------------------------------------------------------
/**
 * 캐시 관련 API 서비스
 */
import axios from 'axios';
import { API_BASE_URL } from 'config';

/**
 * Redis 캐시 서버 정보 조회
 * @returns {Promise<Object>} 캐시 서버 정보
 */
export const getCacheInfo = async () => {
  try {
    const response = await axios.get(`${API_BASE_URL}/cache/info`);
    return response.data;
  } catch (error) {
    console.error('캐시 서버 정보 조회 실패:', error);
    throw error;
  }
};

/**
 * Redis 캐시 통계 정보 조회
 * @returns {Promise<Object>} 캐시 통계 정보
 */
export const getCacheStats = async () => {
  try {
    const response = await axios.get(`${API_BASE_URL}/cache/stats`);
    return response.data;
  } catch (error) {
    console.error('캐시 통계 정보 조회 실패:', error);
    throw error;
  }
};

/**
 * Redis 캐시 키 목록 조회
 * @param {Object} params 조회 파라미터
 * @param {string} [params.prefix] 캐시 키 프리픽스
 * @param {string} [params.pattern] 검색 패턴
 * @param {number} [params.limit] 최대 조회 개수
 * @returns {Promise<Object>} 캐시 키 목록
 */
export const getCacheKeys = async (params = {}) => {
  try {
    const response = await axios.get(`${API_BASE_URL}/cache/keys`, { params });
    return response.data;
  } catch (error) {
    console.error('캐시 키 목록 조회 실패:', error);
    throw error;
  }
};

/**
 * Redis 캐시 값 조회
 * @param {Object} params 조회 파라미터
 * @param {string} [params.prefix] 캐시 키 프리픽스
 * @param {string} [params.pattern] 검색 패턴
 * @param {number} [params.limit] 최대 조회 개수
 * @returns {Promise<Object>} 캐시 값 목록
 */
export const getCacheValues = async (params = {}) => {
  try {
    const response = await axios.get(`${API_BASE_URL}/cache/values`, { params });
    return response.data;
  } catch (error) {
    console.error('캐시 값 조회 실패:', error);
    throw error;
  }
};

/**
 * Redis 캐시 삭제
 * @param {Object} params 삭제 파라미터
 * @param {string} [params.prefix] 캐시 키 프리픽스
 * @param {string} [params.pattern] 삭제할 키 패턴
 * @returns {Promise<Object>} 삭제 결과
 */
export const clearCache = async (params = {}) => {
  try {
    const response = await axios.delete(`${API_BASE_URL}/cache/clear`, { params });
    return response.data;
  } catch (error) {
    console.error('캐시 삭제 실패:', error);
    throw error;
  }
};



============================================================
File: /home/CVEHub/frontend/src/features/cache/CacheVisualization.jsx
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Container, 
  Typography, 
  Paper, 
  Grid, 
  Tabs, 
  Tab, 
  CircularProgress,
  Divider,
  useTheme
} from '@mui/material';
import { 
  useCacheInfoQuery, 
  useCacheStatsQuery, 
  useReactQueryCache 
} from './hooks/useCacheQuery';
import RedisOverview from './components/RedisOverview';
import RedisKeysList from './components/RedisKeysList';
import RedisValuesViewer from './components/RedisValuesViewer';
import ReactQueryViewer from './components/ReactQueryViewer';
import CacheDashboard from './components/CacheDashboard';

/**
 * 캐시 시각화 페이지 컴포넌트
 */
const CacheVisualization = () => {
  const theme = useTheme();
  const [tabValue, setTabValue] = useState(0);
  const { data: cacheInfo, isLoading: isInfoLoading } = useCacheInfoQuery();
  const { data: cacheStats, isLoading: isStatsLoading } = useCacheStatsQuery();
  const { getQueryCache } = useReactQueryCache();
  const [queryCache, setQueryCache] = useState([]);

  // React Query 캐시 정보 주기적 업데이트
  useEffect(() => {
    const updateQueryCache = () => {
      setQueryCache(getQueryCache());
    };

    // 초기 로드
    updateQueryCache();

    // 1초마다 업데이트
    const interval = setInterval(updateQueryCache, 1000);
    return () => clearInterval(interval);
  }, []); // getQueryCache 의존성 제거

  // 탭 변경 핸들러
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  // 로딩 중 표시
  if (isInfoLoading || isStatsLoading) {
    return (
      <Box 
        sx={{ 
          display: 'flex', 
          justifyContent: 'center', 
          alignItems: 'center', 
          minHeight: '80vh' 
        }}
      >
        <CircularProgress size={60} thickness={4} />
      </Box>
    );
  }

  return (
    <Container maxWidth="xl" sx={{ mt: 4, mb: 8 }}>
      <Paper 
        elevation={3} 
        sx={{ 
          p: 3, 
          borderRadius: 2, 
          background: `linear-gradient(135deg, ${theme.palette.background.paper} 0%, ${theme.palette.background.default} 100%)`,
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)'
        }}
      >
        <Typography 
          variant="h4" 
          component="h1" 
          gutterBottom 
          sx={{ 
            fontWeight: 700, 
            color: theme.palette.primary.main,
            textShadow: '0px 2px 4px rgba(0, 0, 0, 0.05)',
            mb: 3
          }}
        >
          캐시 시각화 대시보드
        </Typography>
        
        <Divider sx={{ mb: 4 }} />
        
        {/* 대시보드 요약 정보 */}
        <CacheDashboard 
          cacheInfo={cacheInfo} 
          cacheStats={cacheStats} 
          queryCache={queryCache} 
        />
        
        {/* 탭 네비게이션 */}
        <Box sx={{ mt: 6, mb: 3, borderBottom: 1, borderColor: 'divider' }}>
          <Tabs 
            value={tabValue} 
            onChange={handleTabChange} 
            variant="scrollable"
            scrollButtons="auto"
            sx={{
              '& .MuiTab-root': {
                fontWeight: 600,
                fontSize: '1rem',
                transition: 'all 0.2s',
                '&:hover': {
                  color: theme.palette.primary.main,
                  opacity: 0.8,
                },
              },
              '& .Mui-selected': {
                color: theme.palette.primary.main,
              },
              '& .MuiTabs-indicator': {
                backgroundColor: theme.palette.primary.main,
                height: 3,
                borderRadius: '3px 3px 0 0',
              },
            }}
          >
            <Tab label="Redis 개요" />
            <Tab label="Redis 키 목록" />
            <Tab label="Redis 값 뷰어" />
            <Tab label="React Query 캐시" />
          </Tabs>
        </Box>
        
        {/* 탭 컨텐츠 */}
        <Box sx={{ py: 2 }}>
          {tabValue === 0 && <RedisOverview cacheInfo={cacheInfo} cacheStats={cacheStats} />}
          {tabValue === 1 && <RedisKeysList />}
          {tabValue === 2 && <RedisValuesViewer />}
          {tabValue === 3 && <ReactQueryViewer queryCache={queryCache} />}
        </Box>
      </Paper>
    </Container>
  );
};

export default CacheVisualization;



============================================================
File: /home/CVEHub/frontend/src/features/cache/components/CacheDashboard.jsx
------------------------------------------------------------
import React from 'react';
import { 
  Box, 
  Grid, 
  Paper, 
  Typography, 
  useTheme,
  Tooltip,
  Chip
} from '@mui/material';
import { 
  Storage as StorageIcon, 
  Memory as MemoryIcon, 
  Speed as SpeedIcon, 
  QueryStats as QueryStatsIcon 
} from '@mui/icons-material';
import { 
  BarChart, 
  Bar, 
  PieChart, 
  Pie, 
  Cell, 
  ResponsiveContainer,
  Tooltip as RechartsTooltip,
  Legend
} from 'recharts';

/**
 * 캐시 대시보드 컴포넌트
 * @param {Object} props 컴포넌트 속성
 * @param {Object} props.cacheInfo Redis 서버 정보
 * @param {Object} props.cacheStats Redis 캐시 통계
 * @param {Array} props.queryCache React Query 캐시 정보
 */
const CacheDashboard = ({ cacheInfo, cacheStats, queryCache }) => {
  const theme = useTheme();
  
  // 색상 팔레트
  const colors = [
    theme.palette.primary.main,
    theme.palette.secondary.main,
    theme.palette.success.main,
    theme.palette.warning.main,
    theme.palette.error.main,
    theme.palette.info.main,
  ];
  
  // 메모리 사용량 데이터 (MB 단위)
  const memoryData = [
    { name: '사용 메모리', value: parseFloat((cacheInfo.used_memory / (1024 * 1024)).toFixed(2)) },
    { name: '피크 메모리', value: parseFloat((cacheInfo.used_memory_peak / (1024 * 1024)).toFixed(2)) },
  ];
  
  // 키 타입 데이터
  const keyTypesData = Object.entries(cacheStats.key_types || {}).map(([type, count], index) => ({
    name: type,
    value: count,
    color: colors[index % colors.length]
  }));
  
  // 히트/미스 데이터
  const hitMissData = [
    { name: '히트', value: cacheStats.keyspace_hits || 0 },
    { name: '미스', value: cacheStats.keyspace_misses || 0 },
  ];
  
  // 히트율 계산
  const hitRate = hitMissData[0].value + hitMissData[1].value > 0
    ? ((hitMissData[0].value / (hitMissData[0].value + hitMissData[1].value)) * 100).toFixed(2)
    : 0;
  
  // React Query 캐시 상태 데이터
  const queryStatusData = [
    { name: '활성', value: queryCache.filter(q => q.isActive).length },
    { name: '오래됨', value: queryCache.filter(q => q.isStale).length },
    { name: '비활성', value: queryCache.filter(q => !q.isActive).length },
  ];

  // 통계 카드 스타일
  const statCardStyle = {
    p: 3,
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    borderRadius: 2,
    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
    transition: 'transform 0.3s, box-shadow 0.3s',
    '&:hover': {
      transform: 'translateY(-5px)',
      boxShadow: '0 8px 30px rgba(0, 0, 0, 0.12)',
    }
  };

  // 아이콘 스타일
  const iconStyle = {
    fontSize: 40,
    mb: 2,
    p: 1,
    borderRadius: '50%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: 64,
    height: 64,
  };

  return (
    <Box sx={{ mb: 6 }}>
      <Grid container spacing={3}>
        {/* Redis 서버 정보 */}
        <Grid item xs={12} md={6} lg={3}>
          <Paper sx={statCardStyle}>
            <Box sx={{ 
              ...iconStyle, 
              bgcolor: 'rgba(25, 118, 210, 0.1)', 
              color: 'primary.main' 
            }}>
              <StorageIcon fontSize="large" />
            </Box>
            <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
              Redis 서버
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              버전: {cacheInfo.redis_version}
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              업타임: {Math.floor(cacheInfo.uptime_in_seconds / 86400)}일 {Math.floor((cacheInfo.uptime_in_seconds % 86400) / 3600)}시간
            </Typography>
            <Typography variant="body2" color="text.secondary">
              연결 클라이언트: {cacheInfo.connected_clients}
            </Typography>
            <Box sx={{ mt: 'auto', pt: 2 }}>
              <Chip 
                label={cacheInfo.redis_mode === 'standalone' ? '단독 모드' : cacheInfo.redis_mode} 
                size="small" 
                color="primary" 
                variant="outlined" 
              />
            </Box>
          </Paper>
        </Grid>

        {/* 메모리 사용량 */}
        <Grid item xs={12} md={6} lg={3}>
          <Paper sx={statCardStyle}>
            <Box sx={{ 
              ...iconStyle, 
              bgcolor: 'rgba(156, 39, 176, 0.1)', 
              color: 'secondary.main' 
            }}>
              <MemoryIcon fontSize="large" />
            </Box>
            <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
              메모리 사용량
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              사용 메모리: {(cacheInfo.used_memory / (1024 * 1024)).toFixed(2)} MB
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              피크 메모리: {(cacheInfo.used_memory_peak / (1024 * 1024)).toFixed(2)} MB
            </Typography>
            <Typography variant="body2" color="text.secondary">
              메모리 단편화: {cacheInfo.mem_fragmentation_ratio?.toFixed(2) || 'N/A'}
            </Typography>
            
            <Box sx={{ mt: 2, height: 100 }}>
              <ResponsiveContainer width="100%" height="100%">
                <BarChart data={memoryData} layout="vertical">
                  <RechartsTooltip 
                    formatter={(value) => [`${value} MB`, '메모리']}
                    labelFormatter={() => ''}
                  />
                  <Bar 
                    dataKey="value" 
                    fill={theme.palette.secondary.main}
                    radius={[0, 4, 4, 0]}
                  >
                    {memoryData.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={colors[index % colors.length]} />
                    ))}
                  </Bar>
                </BarChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>

        {/* 캐시 성능 */}
        <Grid item xs={12} md={6} lg={3}>
          <Paper sx={statCardStyle}>
            <Box sx={{ 
              ...iconStyle, 
              bgcolor: 'rgba(76, 175, 80, 0.1)', 
              color: 'success.main' 
            }}>
              <SpeedIcon fontSize="large" />
            </Box>
            <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
              캐시 성능
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              키스페이스 히트: {cacheStats.keyspace_hits?.toLocaleString() || 0}
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              키스페이스 미스: {cacheStats.keyspace_misses?.toLocaleString() || 0}
            </Typography>
            <Typography variant="h5" color="success.main" sx={{ mt: 1, fontWeight: 700 }}>
              히트율: {hitRate}%
            </Typography>
            
            <Box sx={{ mt: 2, height: 100 }}>
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={hitMissData}
                    cx="50%"
                    cy="50%"
                    innerRadius={25}
                    outerRadius={40}
                    paddingAngle={5}
                    dataKey="value"
                  >
                    <Cell fill={theme.palette.success.main} />
                    <Cell fill={theme.palette.error.main} />
                  </Pie>
                  <RechartsTooltip 
                    formatter={(value, name) => [value.toLocaleString(), name]}
                  />
                </PieChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>

        {/* React Query 캐시 */}
        <Grid item xs={12} md={6} lg={3}>
          <Paper sx={statCardStyle}>
            <Box sx={{ 
              ...iconStyle, 
              bgcolor: 'rgba(0, 150, 136, 0.1)', 
              color: 'info.main' 
            }}>
              <QueryStatsIcon fontSize="large" />
            </Box>
            <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
              React Query 캐시
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              총 쿼리 수: {queryCache.length}
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              활성 쿼리: {queryCache.filter(q => q.isActive).length}
            </Typography>
            <Typography variant="body2" color="text.secondary">
              오래된 쿼리: {queryCache.filter(q => q.isStale).length}
            </Typography>
            
            <Box sx={{ mt: 2, height: 100 }}>
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={queryStatusData}
                    cx="50%"
                    cy="50%"
                    innerRadius={25}
                    outerRadius={40}
                    paddingAngle={5}
                    dataKey="value"
                  >
                    {queryStatusData.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={colors[index % colors.length]} />
                    ))}
                  </Pie>
                  <RechartsTooltip 
                    formatter={(value, name) => [value, name]}
                  />
                </PieChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
};

export default CacheDashboard;



============================================================
File: /home/CVEHub/frontend/src/features/cache/components/RedisOverview.jsx
------------------------------------------------------------
import React from 'react';
import { 
  Box, 
  Grid, 
  Paper, 
  Typography, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Divider,
  useTheme,
  Chip,
  LinearProgress,
  Tooltip
} from '@mui/material';
import { 
  AreaChart, 
  Area, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip as RechartsTooltip, 
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
  Legend
} from 'recharts';

/**
 * Redis 서버 개요 컴포넌트
 * @param {Object} props 컴포넌트 속성
 * @param {Object} props.cacheInfo Redis 서버 정보
 * @param {Object} props.cacheStats Redis 캐시 통계
 */
const RedisOverview = ({ cacheInfo, cacheStats }) => {
  const theme = useTheme();
  
  // 색상 팔레트
  const colors = [
    theme.palette.primary.main,
    theme.palette.secondary.main,
    theme.palette.success.main,
    theme.palette.warning.main,
    theme.palette.error.main,
    theme.palette.info.main,
  ];
  
  // 명령어 통계 데이터
  const commandStatsData = Object.entries(cacheStats.commandstats || {})
    .map(([cmd, stats]) => ({
      name: cmd.replace('cmdstat_', ''),
      calls: stats.calls,
      usec: stats.usec,
      usec_per_call: stats.usec_per_call,
    }))
    .sort((a, b) => b.calls - a.calls)
    .slice(0, 10);
  
  // 메모리 사용량 데이터
  const memoryData = [
    { name: '사용 메모리', value: cacheInfo.used_memory },
    { name: '피크 메모리', value: cacheInfo.used_memory_peak },
    { name: 'RSS 메모리', value: cacheInfo.used_memory_rss },
    { name: 'Lua 메모리', value: cacheInfo.used_memory_lua },
  ];
  
  // 메모리 사용량 차트 데이터
  const memoryChartData = [
    { name: '현재', 사용: parseFloat((cacheInfo.used_memory / (1024 * 1024)).toFixed(2)) },
    { name: '피크', 사용: parseFloat((cacheInfo.used_memory_peak / (1024 * 1024)).toFixed(2)) },
    { name: 'RSS', 사용: parseFloat((cacheInfo.used_memory_rss / (1024 * 1024)).toFixed(2)) },
    { name: 'Lua', 사용: parseFloat((cacheInfo.used_memory_lua / (1024 * 1024)).toFixed(2)) },
  ];
  
  // 키 타입 데이터
  const keyTypesData = Object.entries(cacheStats.key_types || {})
    .map(([type, count], index) => ({
      name: type,
      value: count,
      color: colors[index % colors.length]
    }));
  
  // 키 만료 데이터
  const keyExpiryData = [
    { name: '만료 설정됨', value: cacheStats.expires || 0 },
    { name: '만료 없음', value: (cacheStats.keys || 0) - (cacheStats.expires || 0) },
  ];
  
  // 메모리 사용률
  const memoryUsagePercent = cacheInfo.used_memory_peak > 0 
    ? (cacheInfo.used_memory / cacheInfo.used_memory_peak) * 100 
    : 0;
  
  // 서버 정보 항목
  const serverInfoItems = [
    { label: 'Redis 버전', value: cacheInfo.redis_version },
    { label: '운영 모드', value: cacheInfo.redis_mode },
    { label: '프로세스 ID', value: cacheInfo.process_id },
    { label: 'TCP 포트', value: cacheInfo.tcp_port },
    { label: '업타임', value: `${Math.floor(cacheInfo.uptime_in_seconds / 86400)}일 ${Math.floor((cacheInfo.uptime_in_seconds % 86400) / 3600)}시간` },
    { label: '연결 클라이언트', value: cacheInfo.connected_clients },
    { label: '거부된 연결', value: cacheInfo.rejected_connections },
    { label: '실행 명령어', value: cacheInfo.total_commands_processed?.toLocaleString() },
    { label: '키스페이스 히트', value: cacheStats.keyspace_hits?.toLocaleString() },
    { label: '키스페이스 미스', value: cacheStats.keyspace_misses?.toLocaleString() },
  ];
  
  // 메모리 정보 항목
  const memoryInfoItems = [
    { label: '사용 메모리', value: `${(cacheInfo.used_memory / (1024 * 1024)).toFixed(2)} MB` },
    { label: '피크 메모리', value: `${(cacheInfo.used_memory_peak / (1024 * 1024)).toFixed(2)} MB` },
    { label: 'RSS 메모리', value: `${(cacheInfo.used_memory_rss / (1024 * 1024)).toFixed(2)} MB` },
    { label: 'Lua 메모리', value: `${(cacheInfo.used_memory_lua / (1024 * 1024)).toFixed(2)} MB` },
    { label: '메모리 단편화 비율', value: cacheInfo.mem_fragmentation_ratio?.toFixed(2) || 'N/A' },
    { label: '메모리 할당자', value: cacheInfo.mem_allocator || 'N/A' },
  ];
  
  // 통계 정보 항목
  const statsInfoItems = [
    { label: '총 키 개수', value: cacheStats.keys?.toLocaleString() || 0 },
    { label: '만료 설정된 키', value: cacheStats.expires?.toLocaleString() || 0 },
    { label: '만료된 키', value: cacheStats.expired_keys?.toLocaleString() || 0 },
    { label: '제거된 키', value: cacheStats.evicted_keys?.toLocaleString() || 0 },
    { label: '히트율', value: `${((cacheStats.keyspace_hits / (cacheStats.keyspace_hits + cacheStats.keyspace_misses || 1)) * 100).toFixed(2)}%` },
    { label: '초당 명령어 처리', value: (cacheInfo.instantaneous_ops_per_sec || 0).toLocaleString() },
  ];

  return (
    <Box>
      <Grid container spacing={4}>
        {/* 서버 정보 및 키 타입 분포 */}
        <Grid item xs={12} lg={6}>
          <Paper 
            elevation={0} 
            sx={{ 
              p: 3, 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%'
            }}
          >
            <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
              서버 정보
            </Typography>
            
            <Grid container spacing={2}>
              {serverInfoItems.map((item, index) => (
                <Grid item xs={6} key={index}>
                  <Box sx={{ mb: 2 }}>
                    <Typography variant="body2" color="text.secondary">
                      {item.label}
                    </Typography>
                    <Typography variant="body1" sx={{ fontWeight: 500 }}>
                      {item.value}
                    </Typography>
                  </Box>
                </Grid>
              ))}
            </Grid>
            
            <Divider sx={{ my: 3 }} />
            
            <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
              키 타입 분포
            </Typography>
            
            <Box sx={{ height: 300 }}>
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={keyTypesData}
                    cx="50%"
                    cy="50%"
                    labelLine={true}
                    outerRadius={100}
                    fill="#8884d8"
                    dataKey="value"
                    label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                  >
                    {keyTypesData.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={entry.color} />
                    ))}
                  </Pie>
                  <RechartsTooltip 
                    formatter={(value, name) => [value, name]}
                  />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>
        
        {/* 메모리 사용량 및 키 만료 */}
        <Grid item xs={12} lg={6}>
          <Paper 
            elevation={0} 
            sx={{ 
              p: 3, 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%'
            }}
          >
            <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
              메모리 사용량
            </Typography>
            
            <Box sx={{ mb: 4 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="body2">
                  사용 메모리 / 피크 메모리
                </Typography>
                <Typography variant="body2" fontWeight={600}>
                  {memoryUsagePercent.toFixed(2)}%
                </Typography>
              </Box>
              <LinearProgress 
                variant="determinate" 
                value={memoryUsagePercent} 
                sx={{ 
                  height: 10, 
                  borderRadius: 5,
                  bgcolor: 'rgba(0, 0, 0, 0.05)',
                  '& .MuiLinearProgress-bar': {
                    borderRadius: 5,
                    background: `linear-gradient(90deg, ${theme.palette.primary.main} 0%, ${theme.palette.secondary.main} 100%)`,
                  }
                }}
              />
            </Box>
            
            <Box sx={{ height: 200, mb: 4 }}>
              <ResponsiveContainer width="100%" height="100%">
                <AreaChart
                  data={memoryChartData}
                  margin={{ top: 10, right: 30, left: 0, bottom: 0 }}
                >
                  <CartesianGrid strokeDasharray="3 3" stroke="rgba(0,0,0,0.1)" />
                  <XAxis dataKey="name" />
                  <YAxis unit=" MB" />
                  <RechartsTooltip formatter={(value) => [`${value} MB`, '메모리']} />
                  <Area 
                    type="monotone" 
                    dataKey="사용" 
                    stroke={theme.palette.primary.main} 
                    fill={`${theme.palette.primary.main}40`} 
                  />
                </AreaChart>
              </ResponsiveContainer>
            </Box>
            
            <Divider sx={{ my: 3 }} />
            
            <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
              키 만료 상태
            </Typography>
            
            <Box sx={{ height: 200 }}>
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={keyExpiryData}
                    cx="50%"
                    cy="50%"
                    innerRadius={60}
                    outerRadius={80}
                    fill="#8884d8"
                    paddingAngle={5}
                    dataKey="value"
                  >
                    <Cell fill={theme.palette.warning.main} />
                    <Cell fill={theme.palette.info.main} />
                  </Pie>
                  <RechartsTooltip 
                    formatter={(value, name) => [value, name]}
                  />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>
        
        {/* 명령어 통계 */}
        <Grid item xs={12}>
          <Paper 
            elevation={0} 
            sx={{ 
              p: 3, 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)'
            }}
          >
            <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
              상위 명령어 통계
            </Typography>
            
            <TableContainer>
              <Table sx={{ minWidth: 650 }} size="medium">
                <TableHead>
                  <TableRow>
                    <TableCell>명령어</TableCell>
                    <TableCell align="right">호출 횟수</TableCell>
                    <TableCell align="right">총 소요 시간 (μs)</TableCell>
                    <TableCell align="right">호출당 평균 시간 (μs)</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {commandStatsData.map((row, index) => (
                    <TableRow
                      key={row.name}
                      sx={{ '&:last-child td, &:last-child th': { border: 0 } }}
                    >
                      <TableCell component="th" scope="row">
                        <Chip 
                          label={row.name} 
                          size="small" 
                          sx={{ 
                            bgcolor: `${colors[index % colors.length]}20`,
                            color: colors[index % colors.length],
                            fontWeight: 500
                          }} 
                        />
                      </TableCell>
                      <TableCell align="right">{row.calls.toLocaleString()}</TableCell>
                      <TableCell align="right">{row.usec.toLocaleString()}</TableCell>
                      <TableCell align="right">{row.usec_per_call.toFixed(2)}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
};

export default RedisOverview;



============================================================
File: /home/CVEHub/frontend/src/features/cache/components/ReactQueryViewer.jsx
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Paper, 
  Typography, 
  TextField, 
  InputAdornment,
  Divider,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Chip,
  useTheme,
  Tooltip,
  IconButton,
  Button,
  CircularProgress,
  Grid,
  Card,
  CardContent,
  Tabs,
  Tab,
  Alert
} from '@mui/material';
import { 
  Search as SearchIcon, 
  ExpandMore as ExpandMoreIcon,
  ContentCopy as CopyIcon,
  Refresh as RefreshIcon,
  DeleteOutline as DeleteIcon,
  DataUsage as DataUsageIcon,
  QueryStats as QueryStatsIcon,
  Cached as CachedIcon,
  AccessTime as AccessTimeIcon
} from '@mui/icons-material';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';
import { useReactQueryCache } from 'features/cache/hooks/useCacheQuery';

/**
 * React Query 캐시 뷰어 컴포넌트
 * @param {Object} props 컴포넌트 속성
 * @param {Array} props.queryCache React Query 캐시 정보
 */
const ReactQueryViewer = ({ queryCache }) => {
  const theme = useTheme();
  const [searchTerm, setSearchTerm] = useState('');
  const [activeTab, setActiveTab] = useState('all');
  const { queryClient } = useReactQueryCache();
  
  // 필터링된 쿼리 캐시
  const filteredQueries = queryCache.filter(query => {
    const matchesSearch = searchTerm === '' || 
      query.queryKey.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesTab = activeTab === 'all' || 
      (activeTab === 'active' && query.isActive) ||
      (activeTab === 'stale' && query.isStale) ||
      (activeTab === 'inactive' && !query.isActive);
    
    return matchesSearch && matchesTab;
  });
  
  // 검색어 변경 핸들러
  const handleSearchChange = (e) => {
    setSearchTerm(e.target.value);
  };
  
  // 탭 변경 핸들러
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  
  // 쿼리 무효화 핸들러
  const handleInvalidateQuery = (queryKey) => {
    try {
      const parsedKey = JSON.parse(queryKey);
      queryClient.invalidateQueries({ queryKey: parsedKey });
    } catch (error) {
      console.error('쿼리 무효화 실패:', error);
    }
  };
  
  // 쿼리 삭제 핸들러
  const handleRemoveQuery = (queryKey) => {
    try {
      const parsedKey = JSON.parse(queryKey);
      queryClient.removeQueries({ queryKey: parsedKey });
    } catch (error) {
      console.error('쿼리 삭제 실패:', error);
    }
  };
  
  // 모든 쿼리 무효화 핸들러
  const handleInvalidateAll = () => {
    queryClient.invalidateQueries();
  };
  
  // 모든 쿼리 삭제 핸들러
  const handleClearAll = () => {
    queryClient.clear();
  };
  
  // 쿼리 상태에 따른 색상
  const getStatusColor = (query) => {
    if (!query.isActive) return theme.palette.grey[500];
    if (query.isStale) return theme.palette.warning.main;
    return theme.palette.success.main;
  };
  
  // 쿼리 상태 레이블
  const getStatusLabel = (query) => {
    if (!query.isActive) return '비활성';
    if (query.isStale) return '오래됨';
    return '활성';
  };
  
  // 쿼리 키 포맷팅
  const formatQueryKey = (queryKey) => {
    try {
      const parsedKey = JSON.parse(queryKey);
      if (Array.isArray(parsedKey)) {
        return parsedKey.map(item => 
          typeof item === 'object' ? JSON.stringify(item) : String(item)
        ).join(' / ');
      } 
      return typeof parsedKey === 'object' ? JSON.stringify(parsedKey) : String(parsedKey);
    } catch (error) {
      return queryKey;
    }
  };
  
  // 통계 데이터
  const stats = {
    total: queryCache.length,
    active: queryCache.filter(q => q.isActive).length,
    stale: queryCache.filter(q => q.isStale).length,
    inactive: queryCache.filter(q => !q.isActive).length,
  };

  return (
    <Box>
      {/* 통계 카드 */}
      <Grid container spacing={3} sx={{ mb: 4 }}>
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            elevation={0}
            sx={{ 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%',
              transition: 'transform 0.3s',
              '&:hover': {
                transform: 'translateY(-5px)',
              }
            }}
          >
            <CardContent sx={{ p: 3 }}>
              <Box 
                sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2 
                }}
              >
                <Box 
                  sx={{ 
                    bgcolor: `${theme.palette.primary.main}20`, 
                    color: theme.palette.primary.main,
                    borderRadius: '50%',
                    p: 1,
                    mr: 2,
                    display: 'flex'
                  }}
                >
                  <QueryStatsIcon />
                </Box>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  총 쿼리
                </Typography>
              </Box>
              <Typography variant="h4" sx={{ fontWeight: 700, mb: 1 }}>
                {stats.total}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                React Query 캐시에 저장된 총 쿼리 수
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            elevation={0}
            sx={{ 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%',
              transition: 'transform 0.3s',
              '&:hover': {
                transform: 'translateY(-5px)',
              }
            }}
          >
            <CardContent sx={{ p: 3 }}>
              <Box 
                sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2 
                }}
              >
                <Box 
                  sx={{ 
                    bgcolor: `${theme.palette.success.main}20`, 
                    color: theme.palette.success.main,
                    borderRadius: '50%',
                    p: 1,
                    mr: 2,
                    display: 'flex'
                  }}
                >
                  <CachedIcon />
                </Box>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  활성 쿼리
                </Typography>
              </Box>
              <Typography variant="h4" sx={{ fontWeight: 700, mb: 1 }}>
                {stats.active}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                현재 활성 상태인 쿼리 수
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            elevation={0}
            sx={{ 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%',
              transition: 'transform 0.3s',
              '&:hover': {
                transform: 'translateY(-5px)',
              }
            }}
          >
            <CardContent sx={{ p: 3 }}>
              <Box 
                sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2 
                }}
              >
                <Box 
                  sx={{ 
                    bgcolor: `${theme.palette.warning.main}20`, 
                    color: theme.palette.warning.main,
                    borderRadius: '50%',
                    p: 1,
                    mr: 2,
                    display: 'flex'
                  }}
                >
                  <DataUsageIcon />
                </Box>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  오래된 쿼리
                </Typography>
              </Box>
              <Typography variant="h4" sx={{ fontWeight: 700, mb: 1 }}>
                {stats.stale}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                오래된(stale) 상태인 쿼리 수
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            elevation={0}
            sx={{ 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%',
              transition: 'transform 0.3s',
              '&:hover': {
                transform: 'translateY(-5px)',
              }
            }}
          >
            <CardContent sx={{ p: 3 }}>
              <Box 
                sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2 
                }}
              >
                <Box 
                  sx={{ 
                    bgcolor: `${theme.palette.grey[500]}20`, 
                    color: theme.palette.grey[500],
                    borderRadius: '50%',
                    p: 1,
                    mr: 2,
                    display: 'flex'
                  }}
                >
                  <AccessTimeIcon />
                </Box>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  비활성 쿼리
                </Typography>
              </Box>
              <Typography variant="h4" sx={{ fontWeight: 700, mb: 1 }}>
                {stats.inactive}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                비활성 상태인 쿼리 수
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
      
      {/* 검색 및 필터 */}
      <Paper 
        elevation={0} 
        sx={{ 
          p: 3, 
          borderRadius: 2, 
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
          mb: 4
        }}
      >
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6" sx={{ fontWeight: 600 }}>
            React Query 캐시 관리
          </Typography>
          
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button 
              variant="outlined" 
              color="warning" 
              startIcon={<RefreshIcon />}
              onClick={handleInvalidateAll}
              size="small"
            >
              모두 무효화
            </Button>
            <Button 
              variant="outlined" 
              color="error" 
              startIcon={<DeleteIcon />}
              onClick={handleClearAll}
              size="small"
            >
              모두 삭제
            </Button>
          </Box>
        </Box>
        
        <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
          <TextField
            fullWidth
            placeholder="쿼리 키 검색..."
            value={searchTerm}
            onChange={handleSearchChange}
            variant="outlined"
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
          />
        </Box>
        
        <Tabs 
          value={activeTab} 
          onChange={handleTabChange}
          sx={{
            borderBottom: 1,
            borderColor: 'divider',
            mb: 2,
            '& .MuiTab-root': {
              minWidth: 100,
              fontWeight: 600,
            },
          }}
        >
          <Tab 
            value="all" 
            label={`전체 (${stats.total})`} 
          />
          <Tab 
            value="active" 
            label={`활성 (${stats.active})`} 
            sx={{ color: theme.palette.success.main }}
          />
          <Tab 
            value="stale" 
            label={`오래됨 (${stats.stale})`} 
            sx={{ color: theme.palette.warning.main }}
          />
          <Tab 
            value="inactive" 
            label={`비활성 (${stats.inactive})`} 
            sx={{ color: theme.palette.grey[500] }}
          />
        </Tabs>
      </Paper>
      
      {/* 쿼리 목록 */}
      {filteredQueries.length === 0 ? (
        <Alert severity="info">
          검색 조건에 맞는 쿼리가 없습니다.
        </Alert>
      ) : (
        filteredQueries.map((query) => (
          <Accordion 
            key={query.queryHash} 
            sx={{ 
              mb: 2, 
              boxShadow: '0 2px 8px rgba(0, 0, 0, 0.05)',
              borderRadius: '8px !important',
              '&:before': {
                display: 'none',
              },
              overflow: 'hidden'
            }}
          >
            <AccordionSummary
              expandIcon={<ExpandMoreIcon />}
              aria-controls={`panel-${query.queryHash}-content`}
              id={`panel-${query.queryHash}-header`}
              sx={{ 
                bgcolor: 'background.default',
                borderBottom: '1px solid',
                borderColor: 'divider'
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                <Box 
                  sx={{ 
                    width: 12, 
                    height: 12, 
                    borderRadius: '50%', 
                    bgcolor: getStatusColor(query),
                    mr: 2
                  }} 
                />
                
                <Box sx={{ flexGrow: 1 }}>
                  <Typography variant="body1" sx={{ fontWeight: 500 }}>
                    {formatQueryKey(query.queryKey)}
                  </Typography>
                  
                  <Box sx={{ display: 'flex', alignItems: 'center', mt: 0.5 }}>
                    <Chip 
                      label={getStatusLabel(query)} 
                      size="small" 
                      sx={{ 
                        mr: 1,
                        bgcolor: `${getStatusColor(query)}20`,
                        color: getStatusColor(query),
                        fontWeight: 500,
                        fontSize: '0.7rem'
                      }} 
                    />
                    
                    <Typography variant="caption" color="text.secondary">
                      마지막 업데이트: {query.lastUpdated}
                    </Typography>
                  </Box>
                </Box>
                
                <Box sx={{ display: 'flex' }}>
                  <Tooltip title="쿼리 무효화">
                    <IconButton 
                      size="small" 
                      onClick={(e) => {
                        e.stopPropagation();
                        handleInvalidateQuery(query.queryKey);
                      }}
                      sx={{ color: theme.palette.warning.main }}
                    >
                      <RefreshIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                  
                  <Tooltip title="쿼리 삭제">
                    <IconButton 
                      size="small" 
                      onClick={(e) => {
                        e.stopPropagation();
                        handleRemoveQuery(query.queryKey);
                      }}
                      sx={{ color: theme.palette.error.main }}
                    >
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </Box>
              </Box>
            </AccordionSummary>
            <AccordionDetails sx={{ p: 0 }}>
              <Box sx={{ p: 2 }}>
                <Grid container spacing={2}>
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle2" sx={{ mb: 1, fontWeight: 600 }}>
                      쿼리 키
                    </Typography>
                    <Paper 
                      variant="outlined" 
                      sx={{ 
                        p: 2, 
                        borderRadius: 1, 
                        bgcolor: 'background.default',
                        maxHeight: 200,
                        overflow: 'auto'
                      }}
                    >
                      <SyntaxHighlighter
                        language="json"
                        style={vscDarkPlus}
                        customStyle={{ 
                          borderRadius: 8,
                          fontSize: '0.85rem',
                          background: 'transparent',
                          margin: 0
                        }}
                      >
                        {query.queryKey}
                      </SyntaxHighlighter>
                    </Paper>
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle2" sx={{ mb: 1, fontWeight: 600 }}>
                      상태 정보
                    </Typography>
                    <Paper 
                      variant="outlined" 
                      sx={{ 
                        p: 2, 
                        borderRadius: 1, 
                        bgcolor: 'background.default',
                        height: '100%'
                      }}
                    >
                      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                          <Typography variant="body2" color="text.secondary">
                            상태:
                          </Typography>
                          <Chip 
                            label={getStatusLabel(query)} 
                            size="small" 
                            sx={{ 
                              bgcolor: `${getStatusColor(query)}20`,
                              color: getStatusColor(query),
                              fontWeight: 500,
                              fontSize: '0.7rem'
                            }} 
                          />
                        </Box>
                        
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                          <Typography variant="body2" color="text.secondary">
                            활성 여부:
                          </Typography>
                          <Typography variant="body2">
                            {query.isActive ? '활성' : '비활성'}
                          </Typography>
                        </Box>
                        
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                          <Typography variant="body2" color="text.secondary">
                            오래됨 여부:
                          </Typography>
                          <Typography variant="body2">
                            {query.isStale ? '오래됨' : '최신'}
                          </Typography>
                        </Box>
                        
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                          <Typography variant="body2" color="text.secondary">
                            마지막 업데이트:
                          </Typography>
                          <Typography variant="body2">
                            {query.lastUpdated}
                          </Typography>
                        </Box>
                        
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                          <Typography variant="body2" color="text.secondary">
                            쿼리 해시:
                          </Typography>
                          <Typography variant="body2" sx={{ maxWidth: 200, overflow: 'hidden', textOverflow: 'ellipsis' }}>
                            {query.queryHash}
                          </Typography>
                        </Box>
                      </Box>
                    </Paper>
                  </Grid>
                  
                  <Grid item xs={12}>
                    <Typography variant="subtitle2" sx={{ mb: 1, fontWeight: 600 }}>
                      데이터
                    </Typography>
                    <Paper 
                      variant="outlined" 
                      sx={{ 
                        p: 2, 
                        borderRadius: 1, 
                        bgcolor: 'background.default',
                        maxHeight: 300,
                        overflow: 'auto'
                      }}
                    >
                      <SyntaxHighlighter
                        language="json"
                        style={vscDarkPlus}
                        customStyle={{ 
                          borderRadius: 8,
                          fontSize: '0.85rem',
                          background: 'transparent',
                          margin: 0
                        }}
                      >
                        {JSON.stringify(query.state.data || {}, null, 2)}
                      </SyntaxHighlighter>
                    </Paper>
                  </Grid>
                </Grid>
              </Box>
            </AccordionDetails>
          </Accordion>
        ))
      )}
    </Box>
  );
};

export default ReactQueryViewer;



============================================================
File: /home/CVEHub/frontend/src/features/cache/components/RedisValuesViewer.jsx
------------------------------------------------------------
import React, { useState } from 'react';
import { 
  Box, 
  Paper, 
  Typography, 
  TextField, 
  Button, 
  IconButton,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  InputAdornment,
  Divider,
  CircularProgress,
  Alert,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Chip,
  useTheme,
  Tooltip,
  Tabs,
  Tab
} from '@mui/material';
import { 
  Search as SearchIcon, 
  Refresh as RefreshIcon,
  ExpandMore as ExpandMoreIcon,
  ContentCopy as CopyIcon,
  Code as CodeIcon,
  DataObject as DataObjectIcon,
  FormatListBulleted as ListIcon,
  TextFields as TextIcon
} from '@mui/icons-material';
import { useCacheValuesQuery } from '../hooks/useCacheQuery';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';

/**
 * Redis 값 뷰어 컴포넌트
 */
const RedisValuesViewer = () => {
  const theme = useTheme();
  const [searchParams, setSearchParams] = useState({
    prefix: '',
    pattern: '*',
    limit: 20
  });
  const [viewMode, setViewMode] = useState('formatted');
  
  // 캐시 값 조회
  const { 
    data: valuesData, 
    isLoading, 
    isError, 
    error, 
    refetch 
  } = useCacheValuesQuery(searchParams);
  
  // 검색 파라미터 변경 핸들러
  const handleSearchParamChange = (e) => {
    const { name, value } = e.target;
    setSearchParams(prev => ({ ...prev, [name]: value }));
  };
  
  // 검색 핸들러
  const handleSearch = () => {
    refetch();
  };
  
  // 값 복사 핸들러
  const handleCopyValue = (value) => {
    navigator.clipboard.writeText(typeof value === 'object' ? JSON.stringify(value, null, 2) : value.toString());
  };
  
  // 문자열 또는 객체를 안전하게 표시하는 함수
  const safeStringify = (value) => {
    if (value === null || value === undefined) {
      return String(value);
    }
    
    if (typeof value === 'object') {
      try {
        return JSON.stringify(value, null, 2);
      } catch (e) {
        return String(value);
      }
    }
    
    return String(value);
  };
  
  // 뷰 모드 변경 핸들러
  const handleViewModeChange = (event, newValue) => {
    setViewMode(newValue);
  };
  
  // 값 렌더링 함수
  const renderValue = (key, value, type) => {
    // 문자열인 경우 JSON 파싱 시도
    let parsedValue = value;
    let valueType = type;
    
    if (type === 'string' && typeof value === 'string') {
      try {
        const parsed = JSON.parse(value);
        if (typeof parsed === 'object') {
          parsedValue = parsed;
          valueType = 'json';
        }
      } catch (e) {
        // JSON 파싱 실패 시 원래 값 사용
      }
    }
    
    // 뷰 모드에 따라 렌더링
    if (viewMode === 'raw') {
      return (
        <SyntaxHighlighter
          language="json"
          style={vscDarkPlus}
          customStyle={{ 
            borderRadius: 8,
            fontSize: '0.85rem',
            maxHeight: 300
          }}
        >
          {typeof parsedValue === 'object' ? JSON.stringify(parsedValue, null, 2) : String(parsedValue)}
        </SyntaxHighlighter>
      );
    }
    
    // 포맷팅된 뷰
    switch (valueType) {
      case 'json':
        return (
          <Box sx={{ 
            maxHeight: 300, 
            overflow: 'auto', 
            bgcolor: 'background.default', 
            borderRadius: 2,
            p: 2
          }}>
            <SyntaxHighlighter
              language="json"
              style={vscDarkPlus}
              customStyle={{ 
                borderRadius: 8,
                fontSize: '0.85rem',
                background: 'transparent'
              }}
            >
              {JSON.stringify(parsedValue, null, 2)}
            </SyntaxHighlighter>
          </Box>
        );
        
      case 'list':
        return (
          <Box sx={{ maxHeight: 300, overflow: 'auto' }}>
            {Array.isArray(parsedValue) && parsedValue.map((item, idx) => (
              <Box 
                key={idx} 
                sx={{ 
                  p: 1, 
                  borderBottom: '1px solid', 
                  borderColor: 'divider',
                  '&:last-child': { borderBottom: 'none' }
                }}
              >
                <Typography variant="body2">
                  {safeStringify(item)}
                </Typography>
              </Box>
            ))}
          </Box>
        );
        
      case 'hash':
        return (
          <Box sx={{ maxHeight: 300, overflow: 'auto' }}>
            {Object.entries(parsedValue).map(([field, val], idx) => (
              <Box 
                key={idx} 
                sx={{ 
                  p: 1, 
                  borderBottom: '1px solid', 
                  borderColor: 'divider',
                  '&:last-child': { borderBottom: 'none' },
                  display: 'flex'
                }}
              >
                <Typography variant="body2" sx={{ fontWeight: 600, minWidth: 120 }}>
                  {field}:
                </Typography>
                <Typography variant="body2">
                  {safeStringify(val)}
                </Typography>
              </Box>
            ))}
          </Box>
        );
        
      default:
        return (
          <Typography 
            variant="body2" 
            sx={{ 
              p: 2, 
              bgcolor: 'background.default', 
              borderRadius: 2,
              fontFamily: 'monospace',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-all',
              maxHeight: 300,
              overflow: 'auto'
            }}
          >
            {safeStringify(parsedValue)}
          </Typography>
        );
    }
  };
  
  // 값 타입에 따른 아이콘 및 색상
  const getTypeIconAndColor = (type) => {
    switch (type) {
      case 'string':
        return { icon: <TextIcon />, color: theme.palette.primary.main };
      case 'list':
        return { icon: <ListIcon />, color: theme.palette.success.main };
      case 'hash':
        return { icon: <DataObjectIcon />, color: theme.palette.warning.main };
      case 'json':
        return { icon: <CodeIcon />, color: theme.palette.info.main };
      default:
        return { icon: <TextIcon />, color: theme.palette.grey[500] };
    }
  };

  return (
    <Box>
      <Paper 
        elevation={0} 
        sx={{ 
          p: 3, 
          borderRadius: 2, 
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
          mb: 4
        }}
      >
        <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
          Redis 값 조회
        </Typography>
        
        <Box sx={{ display: 'flex', flexDirection: { xs: 'column', md: 'row' }, gap: 2, mb: 3 }}>
          <TextField
            name="prefix"
            label="접두사"
            variant="outlined"
            value={searchParams.prefix}
            onChange={handleSearchParamChange}
            placeholder="예: user"
            sx={{ width: { xs: '100%', md: 200 } }}
          />
          
          <TextField
            name="pattern"
            label="검색 패턴"
            variant="outlined"
            value={searchParams.pattern}
            onChange={handleSearchParamChange}
            placeholder="예: *"
            fullWidth
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
          />
          
          <TextField
            name="limit"
            label="최대 결과 수"
            variant="outlined"
            type="number"
            value={searchParams.limit}
            onChange={handleSearchParamChange}
            sx={{ width: { xs: '100%', md: 150 } }}
          />
          
          <Button 
            variant="contained" 
            onClick={handleSearch}
            startIcon={<SearchIcon />}
            sx={{ 
              height: 56,
              px: 4,
              background: `linear-gradient(90deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.dark} 100%)`,
              boxShadow: '0 4px 10px rgba(0, 0, 0, 0.1)',
              '&:hover': {
                boxShadow: '0 6px 15px rgba(0, 0, 0, 0.2)',
              }
            }}
          >
            조회
          </Button>
          
          <IconButton 
            color="primary" 
            onClick={refetch}
            sx={{ height: 56, width: 56 }}
          >
            <RefreshIcon />
          </IconButton>
        </Box>
        
        <Divider sx={{ my: 3 }} />
        
        <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
          <Tabs 
            value={viewMode} 
            onChange={handleViewModeChange}
            sx={{
              '& .MuiTab-root': {
                minWidth: 100,
                fontWeight: 600,
              },
            }}
          >
            <Tab 
              value="formatted" 
              label="포맷팅" 
              icon={<DataObjectIcon />} 
              iconPosition="start"
            />
            <Tab 
              value="raw" 
              label="원시 데이터" 
              icon={<CodeIcon />} 
              iconPosition="start"
            />
          </Tabs>
        </Box>
      </Paper>
      
      {isLoading ? (
        <Box 
          sx={{ 
            display: 'flex', 
            justifyContent: 'center', 
            alignItems: 'center', 
            height: 200 
          }}
        >
          <CircularProgress size={40} thickness={4} />
          <Typography variant="body2" sx={{ ml: 2, color: 'text.secondary' }}>
            데이터를 불러오는 중...
          </Typography>
        </Box>
      ) : isError ? (
        <Alert severity="error" sx={{ mb: 3 }}>
          값 조회 중 오류가 발생했습니다: {error?.message || '알 수 없는 오류'}
        </Alert>
      ) : valuesData?.keys?.length === 0 ? (
        <Alert severity="info" sx={{ mb: 3 }}>
          검색 조건에 맞는 데이터가 없습니다.
        </Alert>
      ) : (
        <Box>
          {valuesData?.keys.map((key, index) => {
            const value = valuesData.values[index];
            const type = valuesData.types[index];
            const { icon, color } = getTypeIconAndColor(type);
            
            // 키 접두사 분리
            const keyParts = key.split(':');
            const keyPrefix = keyParts.length > 1 ? keyParts[0] : '';
            const keyDisplay = keyPrefix ? key.substring(keyPrefix.length + 1) : key;
            
            return (
              <Accordion 
                key={key} 
                sx={{ 
                  mb: 2, 
                  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.05)',
                  borderRadius: '8px !important',
                  '&:before': {
                    display: 'none',
                  },
                  overflow: 'hidden'
                }}
              >
                <AccordionSummary
                  expandIcon={<ExpandMoreIcon />}
                  aria-controls={`panel-${key}-content`}
                  id={`panel-${key}-header`}
                  sx={{ 
                    bgcolor: 'background.default',
                    borderBottom: '1px solid',
                    borderColor: 'divider'
                  }}
                >
                  <Box sx={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                    <Box 
                      sx={{ 
                        mr: 2, 
                        color, 
                        display: 'flex', 
                        alignItems: 'center', 
                        justifyContent: 'center' 
                      }}
                    >
                      {icon}
                    </Box>
                    
                    <Box sx={{ flexGrow: 1 }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        {keyPrefix && (
                          <Chip 
                            label={keyPrefix} 
                            size="small" 
                            color="primary" 
                            variant="outlined"
                            sx={{ mr: 1, fontSize: '0.7rem' }}
                          />
                        )}
                        <Typography variant="body1" sx={{ fontWeight: 500 }}>
                          {keyDisplay}
                        </Typography>
                      </Box>
                      
                      <Typography variant="caption" color="text.secondary">
                        {type === 'string' && typeof value === 'string' && value.startsWith('{') ? 'json' : type}
                        {valuesData.ttls[index] !== -1 && ` • TTL: ${valuesData.ttls[index]}초`}
                      </Typography>
                    </Box>
                    
                    <Tooltip title="값 복사">
                      <IconButton 
                        size="small" 
                        onClick={(e) => {
                          e.stopPropagation();
                          handleCopyValue(value);
                        }}
                        sx={{ color: theme.palette.info.main }}
                      >
                        <CopyIcon fontSize="small" />
                      </IconButton>
                    </Tooltip>
                  </Box>
                </AccordionSummary>
                <AccordionDetails sx={{ p: 0 }}>
                  <Box sx={{ p: 2 }}>
                    {renderValue(key, value, type)}
                  </Box>
                </AccordionDetails>
              </Accordion>
            );
          })}
        </Box>
      )}
    </Box>
  );
};

export default RedisValuesViewer;



============================================================
File: /home/CVEHub/frontend/src/features/cache/components/RedisKeysList.jsx
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Paper, 
  Typography, 
  TextField, 
  Button, 
  IconButton,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  TablePagination,
  InputAdornment,
  Chip,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  CircularProgress,
  Divider,
  useTheme,
  Alert,
  Snackbar,
  FormControl,
  InputLabel,
  Select,
  MenuItem
} from '@mui/material';
import { 
  Search as SearchIcon, 
  Delete as DeleteIcon, 
  Refresh as RefreshIcon,
  ContentCopy as CopyIcon,
  Visibility as ViewIcon,
  FilterList as FilterIcon
} from '@mui/icons-material';
import { useCacheKeysQuery, useClearCacheMutation } from '../hooks/useCacheQuery';

/**
 * Redis 키 목록 컴포넌트
 */
const RedisKeysList = () => {
  const theme = useTheme();
  const [searchParams, setSearchParams] = useState({
    prefix: '',
    pattern: '*',
    limit: 100
  });
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [openDialog, setOpenDialog] = useState(false);
  const [selectedKey, setSelectedKey] = useState(null);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' });
  const [prefixOptions, setPrefixOptions] = useState([]);
  
  // 캐시 키 목록 조회
  const { 
    data: keysData, 
    isLoading, 
    isError, 
    error, 
    refetch 
  } = useCacheKeysQuery(searchParams);
  
  // 캐시 삭제 뮤테이션
  const clearCacheMutation = useClearCacheMutation();
  
  // 키 목록 데이터 추출 및 가공
  const keys = keysData?.keys || [];
  const processedKeys = keys.map(keyObj => {
    // 키 객체에서 필요한 정보 추출
    const keyValue = typeof keyObj === 'object' && keyObj.key ? keyObj.key : String(keyObj);
    return {
      key: keyValue,
      type: typeof keyObj === 'object' && keyObj.type ? keyObj.type : 'unknown',
      ttl: typeof keyObj === 'object' && keyObj.ttl !== undefined ? keyObj.ttl : -1,
      size: typeof keyObj === 'object' && keyObj.size !== undefined ? keyObj.size : 0
    };
  });
  
  // 접두사 옵션 추출
  useEffect(() => {
    if (processedKeys.length > 0) {
      const prefixes = new Set();
      processedKeys.forEach(keyObj => {
        const keyParts = keyObj.key.split(':');
        if (keyParts.length > 1) {
          prefixes.add(keyParts[0]);
        }
      });
      setPrefixOptions(Array.from(prefixes));
    }
  }, [processedKeys]);
  
  // 페이지 변경 핸들러
  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };
  
  // 페이지당 행 수 변경 핸들러
  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };
  
  // 검색 핸들러
  const handleSearch = () => {
    refetch();
  };
  
  // 검색 파라미터 변경 핸들러
  const handleSearchParamChange = (e) => {
    const { name, value } = e.target;
    setSearchParams(prev => ({ ...prev, [name]: value }));
  };
  
  // 키 삭제 다이얼로그 열기
  const handleOpenDeleteDialog = (key) => {
    setSelectedKey(key);
    setOpenDialog(true);
  };
  
  // 키 삭제 다이얼로그 닫기
  const handleCloseDialog = () => {
    setOpenDialog(false);
  };
  
  // 키 삭제 실행
  const handleDeleteKey = async () => {
    try {
      await clearCacheMutation.mutateAsync({ pattern: selectedKey });
      setSnackbar({
        open: true,
        message: `키 '${selectedKey}'가 성공적으로 삭제되었습니다.`,
        severity: 'success'
      });
      handleCloseDialog();
    } catch (err) {
      setSnackbar({
        open: true,
        message: `키 삭제 실패: ${err.message}`,
        severity: 'error'
      });
    }
  };
  
  // 키 복사 핸들러
  const handleCopyKey = (key) => {
    navigator.clipboard.writeText(key);
    setSnackbar({
      open: true,
      message: '키가 클립보드에 복사되었습니다.',
      severity: 'success'
    });
  };
  
  // 스낵바 닫기 핸들러
  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({ ...prev, open: false }));
  };
  
  // 접두사 선택 핸들러
  const handlePrefixSelect = (prefix) => {
    setSearchParams(prev => ({ ...prev, prefix }));
  };

  return (
    <Box>
      <Paper 
        elevation={0} 
        sx={{ 
          p: 3, 
          borderRadius: 2, 
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
          mb: 4
        }}
      >
        <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
          Redis 키 검색
        </Typography>
        
        <Box sx={{ display: 'flex', flexDirection: { xs: 'column', md: 'row' }, gap: 2, mb: 3 }}>
          <FormControl variant="outlined" sx={{ minWidth: 200 }}>
            <InputLabel id="prefix-select-label">접두사</InputLabel>
            <Select
              labelId="prefix-select-label"
              id="prefix-select"
              name="prefix"
              value={searchParams.prefix}
              onChange={handleSearchParamChange}
              label="접두사"
            >
              <MenuItem value="">
                <em>없음</em>
              </MenuItem>
              {prefixOptions.map((prefix) => (
                <MenuItem key={prefix} value={prefix}>
                  {prefix}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
          
          <TextField
            name="pattern"
            label="검색 패턴"
            variant="outlined"
            value={searchParams.pattern}
            onChange={handleSearchParamChange}
            placeholder="예: user:*"
            fullWidth
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
          />
          
          <TextField
            name="limit"
            label="최대 결과 수"
            variant="outlined"
            type="number"
            value={searchParams.limit}
            onChange={handleSearchParamChange}
            sx={{ width: { xs: '100%', md: 150 } }}
          />
          
          <Button 
            variant="contained" 
            onClick={handleSearch}
            startIcon={<SearchIcon />}
            sx={{ 
              height: 56,
              px: 4,
              background: `linear-gradient(90deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.dark} 100%)`,
              boxShadow: '0 4px 10px rgba(0, 0, 0, 0.1)',
              '&:hover': {
                boxShadow: '0 6px 15px rgba(0, 0, 0, 0.2)',
              }
            }}
          >
            검색
          </Button>
          
          <IconButton 
            color="primary" 
            onClick={refetch}
            sx={{ height: 56, width: 56 }}
          >
            <RefreshIcon />
          </IconButton>
        </Box>
        
        {prefixOptions.length > 0 && (
          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 3 }}>
            <Chip 
              icon={<FilterIcon />} 
              label="접두사 필터:" 
              variant="outlined" 
              sx={{ bgcolor: 'background.default' }}
            />
            {prefixOptions.map((prefix) => (
              <Chip 
                key={prefix}
                label={prefix}
                onClick={() => handlePrefixSelect(prefix)}
                color={searchParams.prefix === prefix ? 'primary' : 'default'}
                variant={searchParams.prefix === prefix ? 'filled' : 'outlined'}
                sx={{ 
                  '&:hover': { 
                    bgcolor: searchParams.prefix === prefix ? '' : `${theme.palette.primary.main}20` 
                  } 
                }}
              />
            ))}
          </Box>
        )}
        
        {isError && (
          <Alert severity="error" sx={{ mb: 3 }}>
            키 목록 조회 중 오류가 발생했습니다: {error?.message || '알 수 없는 오류'}
          </Alert>
        )}
      </Paper>
      
      <Paper 
        elevation={0} 
        sx={{ 
          borderRadius: 2, 
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
          overflow: 'hidden'
        }}
      >
        <TableContainer sx={{ maxHeight: 600 }}>
          <Table stickyHeader>
            <TableHead>
              <TableRow>
                <TableCell 
                  sx={{ 
                    bgcolor: theme.palette.background.default,
                    fontWeight: 600
                  }}
                >
                  키
                </TableCell>
                <TableCell 
                  align="right"
                  sx={{ 
                    bgcolor: theme.palette.background.default,
                    fontWeight: 600
                  }}
                >
                  타입
                </TableCell>
                <TableCell 
                  align="right"
                  sx={{ 
                    bgcolor: theme.palette.background.default,
                    fontWeight: 600,
                    width: 180
                  }}
                >
                  TTL (초)
                </TableCell>
                <TableCell 
                  align="right"
                  sx={{ 
                    bgcolor: theme.palette.background.default,
                    fontWeight: 600,
                    width: 150
                  }}
                >
                  작업
                </TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {isLoading ? (
                <TableRow>
                  <TableCell colSpan={4} align="center" sx={{ py: 5 }}>
                    <CircularProgress size={40} thickness={4} />
                    <Typography variant="body2" sx={{ mt: 2, color: 'text.secondary' }}>
                      키 목록을 불러오는 중...
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : processedKeys.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={4} align="center" sx={{ py: 5 }}>
                    <Typography variant="body1" sx={{ color: 'text.secondary' }}>
                      검색 결과가 없습니다.
                    </Typography>
                    <Typography variant="body2" sx={{ mt: 1, color: 'text.secondary' }}>
                      다른 검색어나 패턴으로 시도해보세요.
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : (
                processedKeys
                  .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)
                  .map((key, index) => {
                    return (
                      <TableRow
                        key={key.key}
                        hover
                        sx={{ 
                          '&:nth-of-type(odd)': { 
                            bgcolor: 'rgba(0, 0, 0, 0.02)' 
                          } 
                        }}
                      >
                        <TableCell component="th" scope="row">
                          <Box sx={{ display: 'flex', alignItems: 'center' }}>
                            {key.key.includes(':') && (
                              <Chip 
                                label={key.key.split(':')[0]} 
                                size="small" 
                                color="primary" 
                                variant="outlined"
                                sx={{ mr: 1, fontSize: '0.7rem' }}
                              />
                            )}
                            <Tooltip title={key.key} arrow>
                              <Typography 
                                variant="body2" 
                                sx={{ 
                                  maxWidth: 400, 
                                  overflow: 'hidden', 
                                  textOverflow: 'ellipsis', 
                                  whiteSpace: 'nowrap' 
                                }}
                              >
                                {key.key.includes(':') ? key.key.substring(key.key.split(':')[0].length + 1) : key.key}
                              </Typography>
                            </Tooltip>
                          </Box>
                        </TableCell>
                        <TableCell align="right">
                          <Chip 
                            label={key.type} 
                            size="small" 
                            sx={{ 
                              bgcolor: `${theme.palette.info.main}20`,
                              color: theme.palette.info.main,
                              fontWeight: 500,
                              fontSize: '0.7rem'
                            }} 
                          />
                        </TableCell>
                        <TableCell align="right">
                          {key.ttl === -1 ? (
                            <Chip 
                              label="무기한" 
                              size="small" 
                              sx={{ 
                                bgcolor: `${theme.palette.success.main}20`,
                                color: theme.palette.success.main,
                                fontWeight: 500,
                                fontSize: '0.7rem'
                              }} 
                            />
                          ) : key.ttl === -2 ? (
                            <Chip 
                              label="만료됨" 
                              size="small" 
                              sx={{ 
                                bgcolor: `${theme.palette.error.main}20`,
                                color: theme.palette.error.main,
                                fontWeight: 500,
                                fontSize: '0.7rem'
                              }} 
                            />
                          ) : (
                            key.ttl
                          )}
                        </TableCell>
                        <TableCell align="right">
                          <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
                            <Tooltip title="키 복사">
                              <IconButton 
                                size="small" 
                                onClick={() => handleCopyKey(key.key)}
                                sx={{ color: theme.palette.info.main }}
                              >
                                <CopyIcon fontSize="small" />
                              </IconButton>
                            </Tooltip>
                            <Tooltip title="키 삭제">
                              <IconButton 
                                size="small" 
                                onClick={() => handleOpenDeleteDialog(key.key)}
                                sx={{ color: theme.palette.error.main }}
                              >
                                <DeleteIcon fontSize="small" />
                              </IconButton>
                            </Tooltip>
                          </Box>
                        </TableCell>
                      </TableRow>
                    );
                  })
              )}
            </TableBody>
          </Table>
        </TableContainer>
        
        <TablePagination
          rowsPerPageOptions={[10, 25, 50, 100]}
          component="div"
          count={processedKeys.length}
          rowsPerPage={rowsPerPage}
          page={page}
          onPageChange={handleChangePage}
          onRowsPerPageChange={handleChangeRowsPerPage}
          labelRowsPerPage="행 수:"
          labelDisplayedRows={({ from, to, count }) => `${from}-${to} / ${count}`}
        />
      </Paper>
      
      {/* 키 삭제 확인 다이얼로그 */}
      <Dialog
        open={openDialog}
        onClose={handleCloseDialog}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">
          키 삭제 확인
        </DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">
            정말로 <strong>{selectedKey}</strong> 키를 삭제하시겠습니까?
            <br />
            이 작업은 되돌릴 수 없습니다.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog} color="primary">
            취소
          </Button>
          <Button 
            onClick={handleDeleteKey} 
            color="error" 
            variant="contained"
            startIcon={<DeleteIcon />}
            autoFocus
          >
            삭제
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* 알림 스낵바 */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert 
          onClose={handleCloseSnackbar} 
          severity={snackbar.severity} 
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default RedisKeysList;



============================================================
File: /home/CVEHub/frontend/src/features/cache/hooks/useCacheQuery.ts
------------------------------------------------------------
/**
 * 캐시 정보 조회를 위한 React Query 훅
 * 웹소켓 통합 및 낙관적 업데이트 기능이 포함된 버전
 */
import { useQuery, useMutation, useQueryClient, UseQueryOptions, UseMutationOptions, QueryClient } from '@tanstack/react-query';
import { useEffect, useCallback, useRef } from 'react';
import {
  getCacheInfo,
  getCacheStats,
  getCacheKeys,
  getCacheValues,
  clearCache
} from '../services/cacheService';
import { formatDateTime, TIME_ZONES } from 'shared/utils/dateUtils';
import { ApiResponse } from 'shared/api/types/api';
import { useSocket } from 'core/socket/hooks/useSocket';
import _ from 'lodash';
import logger from 'shared/utils/logging';

// 로거 팩토리 함수
const createLogger = (prefix: string) => ({
  info: (message: string, data?: any) => {
    if (data !== undefined) {
      logger.info(prefix, message, data);
    } else {
      logger.info(prefix, message);
    }
  },
  warn: (message: string, data?: any) => {
    if (data !== undefined) {
      logger.warn(prefix, message, data);
    } else {
      logger.warn(prefix, message);
    }
  },
  error: (message: string, error?: any) => {
    if (error !== undefined) {
      logger.error(prefix, message, error);
    } else {
      logger.error(prefix, message);
    }
  },
  debug: (message: string, data?: any) => {
    if (data !== undefined) {
      logger.debug(prefix, message, data);
    } else {
      logger.debug(prefix, message);
    }
  }
});

/**
 * 캐시 정보 인터페이스
 */
export interface CacheInfo {
  version: string;
  mode: string;
  os: string;
  arch: string;
  process_id: number;
  uptime_in_seconds: number;
  uptime_in_days: number;
  connected_clients: number;
  used_memory_human: string;
  used_memory_peak_human: string;
  total_connections_received: number;
  total_commands_processed: number;
  [key: string]: string | number | boolean;
}

/**
 * 캐시 통계 정보 인터페이스
 */
export interface CacheStats {
  total_keys: number;
  expires_keys: number;
  avg_ttl: number;
  memory_usage: string;
  hit_rate: number;
  miss_rate: number;
  [key: string]: string | number | boolean;
}

/**
 * 캐시 키 조회 파라미터 인터페이스
 */
export interface CacheQueryParams {
  prefix?: string;
  pattern?: string;
  limit?: number;
}

/**
 * 캐시 키 정보 인터페이스
 */
export interface CacheKey {
  key: string;
  type: string;
  ttl: number;
  size?: number;
}

/**
 * 캐시 값 정보 인터페이스
 */
export interface CacheValue {
  key: string;
  value: any;
  type: string;
  ttl: number;
  size?: number;
}

/**
 * React Query 캐시 항목 인터페이스
 */
export interface ReactQueryCacheItem {
  queryKey: string;
  state: any;
  queryHash: string;
  isStale: boolean;
  isActive: boolean;
  dataUpdatedAt: number;
  lastUpdated: string;
}

/**
 * 낙관적 업데이트를 위한 컨텍스트 인터페이스
 */
interface CacheMutationContext {
  previousKeys?: ApiResponse<CacheKey[]>;
  previousStats?: ApiResponse<CacheStats>;
  previousInfo?: ApiResponse<CacheInfo>;
}

/**
 * Redis 캐시 서버 정보 조회 훅
 * @returns 캐시 서버 정보 쿼리 결과
 */
export const useCacheInfoQuery = (
  options?: UseQueryOptions<ApiResponse<CacheInfo>, Error>
) => {
  const queryLog = createLogger('useCacheInfoQuery');
  
  return useQuery<ApiResponse<CacheInfo>, Error>({
    queryKey: ['cacheInfo'],
    queryFn: async () => {
      queryLog.info('캐시 서버 정보 조회 요청');
      try {
        const result = await getCacheInfo();
        queryLog.debug('캐시 서버 정보 조회 완료', result);
        return result;
      } catch (error) {
        queryLog.error('캐시 서버 정보 조회 오류', error);
        throw error;
      }
    },
    staleTime: 1000 * 60, // 1분
    ...options,
  });
};

/**
 * Redis 캐시 통계 정보 조회 훅
 * @returns 캐시 통계 정보 쿼리 결과
 */
export const useCacheStatsQuery = (
  options?: UseQueryOptions<ApiResponse<CacheStats>, Error>
) => {
  const queryLog = createLogger('useCacheStatsQuery');
  
  return useQuery<ApiResponse<CacheStats>, Error>({
    queryKey: ['cacheStats'],
    queryFn: async () => {
      queryLog.info('캐시 통계 정보 조회 요청');
      try {
        const result = await getCacheStats();
        queryLog.debug('캐시 통계 정보 조회 완료', result);
        return result;
      } catch (error) {
        queryLog.error('캐시 통계 정보 조회 오류', error);
        throw error;
      }
    },
    staleTime: 1000 * 30, // 30초
    ...options,
  });
};

/**
 * Redis 캐시 키 목록 조회 훅
 * @param params 조회 파라미터
 * @param options 쿼리 옵션
 * @returns 캐시 키 목록 쿼리 결과
 */
export const useCacheKeysQuery = (
  params: CacheQueryParams = {}, 
  options?: UseQueryOptions<ApiResponse<CacheKey[]>, Error>
) => {
  const queryLog = createLogger('useCacheKeysQuery');
  
  return useQuery<ApiResponse<CacheKey[]>, Error>({
    queryKey: ['cacheKeys', params],
    queryFn: async () => {
      queryLog.info('캐시 키 목록 조회 요청', params);
      try {
        const result = await getCacheKeys(params);
        queryLog.debug('캐시 키 목록 조회 완료', {
          params,
          keyCount: result.data?.length || 0
        });
        return result;
      } catch (error) {
        queryLog.error('캐시 키 목록 조회 오류', error);
        throw error;
      }
    },
    staleTime: 1000 * 30, // 30초
    ...options,
  });
};

/**
 * Redis 캐시 값 조회 훅
 * @param params 조회 파라미터
 * @param options 쿼리 옵션
 * @returns 캐시 값 목록 쿼리 결과
 */
export const useCacheValuesQuery = (
  params: CacheQueryParams = {}, 
  options?: UseQueryOptions<ApiResponse<CacheValue[]>, Error>
) => {
  const queryLog = createLogger('useCacheValuesQuery');
  
  return useQuery<ApiResponse<CacheValue[]>, Error>({
    queryKey: ['cacheValues', params],
    queryFn: async () => {
      queryLog.info('캐시 값 목록 조회 요청', params);
      try {
        const result = await getCacheValues(params);
        queryLog.debug('캐시 값 목록 조회 완료', {
          params,
          valueCount: result.data?.length || 0
        });
        return result;
      } catch (error) {
        queryLog.error('캐시 값 목록 조회 오류', error);
        throw error;
      }
    },
    staleTime: 1000 * 30, // 30초
    ...options,
  });
};

/**
 * Redis 캐시 삭제 뮤테이션 훅 (낙관적 업데이트 적용)
 * @returns 캐시 삭제 뮤테이션 결과
 */
export const useClearCacheMutation = (
  options?: UseMutationOptions<ApiResponse<any>, Error, CacheQueryParams, CacheMutationContext>
) => {
  const queryClient = useQueryClient();
  const mutationLog = createLogger('useClearCacheMutation');
  
  return useMutation<ApiResponse<any>, Error, CacheQueryParams, CacheMutationContext>({
    mutationFn: async (params) => {
      mutationLog.info('캐시 삭제 요청', params);
      try {
        const result = await clearCache(params);
        mutationLog.info('캐시 삭제 성공', params);
        return result;
      } catch (error) {
        mutationLog.error('캐시 삭제 오류', error);
        throw error;
      }
    },
    
    // 낙관적 업데이트를 위한 onMutate
    onMutate: async (params) => {
      mutationLog.debug('낙관적 업데이트 시작', params);
      
      // 진행 중인 관련 쿼리 취소
      await queryClient.cancelQueries({ queryKey: ['cacheKeys', params] });
      await queryClient.cancelQueries({ queryKey: ['cacheStats'] });
      await queryClient.cancelQueries({ queryKey: ['cacheInfo'] });
      
      // 이전 상태 스냅샷 저장
      const previousKeys = queryClient.getQueryData<ApiResponse<CacheKey[]>>(['cacheKeys', params]);
      const previousStats = queryClient.getQueryData<ApiResponse<CacheStats>>(['cacheStats']);
      const previousInfo = queryClient.getQueryData<ApiResponse<CacheInfo>>(['cacheInfo']);
      
      // 낙관적으로 캐시 키 목록 업데이트
      if (previousKeys) {
        queryClient.setQueryData<ApiResponse<CacheKey[]>>(['cacheKeys', params], {
          ...previousKeys,
          data: [], // 삭제했으므로 빈 배열로 설정
          message: '캐시가 삭제되었습니다.',
          success: true
        });
      }
      
      // 낙관적으로 캐시 통계 업데이트
      if (previousStats && previousStats.data) {
        queryClient.setQueryData<ApiResponse<CacheStats>>(['cacheStats'], {
          ...previousStats,
          data: {
            ...previousStats.data,
            total_keys: 0,
            expires_keys: 0,
            memory_usage: '0 bytes'
          }
        });
      }
      
      mutationLog.debug('낙관적 업데이트 완료');
      
      return { previousKeys, previousStats, previousInfo };
    },
    
    // 오류 발생 시 롤백
    onError: (err, params, context) => {
      mutationLog.error('캐시 삭제 실패, 롤백 수행', err);
      
      if (context?.previousKeys) {
        queryClient.setQueryData(['cacheKeys', params], context.previousKeys);
      }
      
      if (context?.previousStats) {
        queryClient.setQueryData(['cacheStats'], context.previousStats);
      }
      
      if (context?.previousInfo) {
        queryClient.setQueryData(['cacheInfo'], context.previousInfo);
      }
    },
    
    // 성공 시 쿼리 무효화
    onSuccess: () => {
      mutationLog.info('캐시 삭제 후 쿼리 무효화');
      
      // 모든 관련 쿼리 무효화
      queryClient.invalidateQueries({ 
        queryKey: ['cacheInfo'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheStats'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheKeys'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheValues'],
        refetchType: 'active'
      });
    },
    ...options,
  });
};

/**
 * React Query 캐시 정보 조회 훅
 * @returns React Query 캐시 정보
 */
export const useReactQueryCache = () => {
  const queryClient = useQueryClient();
  
  const getQueryCache = useCallback((): ReactQueryCacheItem[] => {
    const queryCache = queryClient.getQueryCache();
    const queries = queryCache.getAll();
    
    return queries.map(query => ({
      queryKey: JSON.stringify(query.queryKey),
      state: query.state,
      queryHash: query.queryHash,
      isStale: query.isStale(),
      isActive: query.isActive(),
      dataUpdatedAt: query.state.dataUpdatedAt,
      lastUpdated: query.state.dataUpdatedAt ? formatDateTime(new Date(query.state.dataUpdatedAt), undefined, TIME_ZONES.KST) : 'N/A',
    }));
  }, [queryClient]);
  
  return {
    getQueryCache,
    queryClient,
  };
};

/**
 * 디바운스된 캐시 쿼리 갱신 훅
 * @returns 캐시 쿼리 갱신 함수
 */
export const useRefreshCacheQueries = () => {
  const queryClient = useQueryClient();
  const logRefresh = createLogger('useRefreshCacheQueries');
  
  // 디바운스된 캐시 새로고침 함수
  const refreshCache = useCallback(
    _.debounce(() => {
      logRefresh.info('디바운스된 캐시 새로고침 실행');
      
      queryClient.invalidateQueries({ 
        queryKey: ['cacheInfo'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheStats'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheKeys'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheValues'],
        refetchType: 'active'
      });
    }, 300),
    [queryClient]
  );
  
  // 컴포넌트 언마운트 시 디바운스 함수 취소
  useEffect(() => {
    return () => {
      refreshCache.cancel();
    };
  }, [refreshCache]);
  
  return { refreshCache };
};

/**
 * 실시간 캐시 업데이트 구독 훅
 * 웹소켓을 통해 캐시 변경 이벤트를 구독하고 관련 쿼리를 자동으로 갱신합니다.
 * @returns 연결 상태 객체
 */
export const useCacheUpdates = () => {
  const queryClient = useQueryClient();
  const logCache = createLogger('useCacheUpdates');
  
  // 디바운스된 캐시 새로고침 훅 사용
  const { refreshCache } = useRefreshCacheQueries();
  
  // 구독 상태 추적용 Ref
  const isSubscribedRef = useRef(false);
  
  // useSocket 훅 사용
  const { connected, on, emit, cleanup } = useSocket(
    undefined, undefined, [], { 
      componentId: 'cache-updates',
      useRxJS: true
    }
  );
  
  // 캐시 변경 이벤트 처리
  useEffect(() => {
    if (connected && !isSubscribedRef.current) {
      logCache.info('캐시 업데이트 구독 시작');
      
      // 서버에 캐시 모니터링 요청
      emit('MONITOR_CACHE', { enabled: true });
      
      // 캐시 키 변경 이벤트
      const unsubCacheKeysChanged = on('CACHE_KEYS_CHANGED', (data) => {
        logCache.info('캐시 키 변경 감지', data);
        queryClient.invalidateQueries({ 
          queryKey: ['cacheKeys'],
          refetchType: 'active'
        });
        queryClient.invalidateQueries({ 
          queryKey: ['cacheStats'],
          refetchType: 'active'
        });
      });
      
      // 캐시 값 변경 이벤트
      const unsubCacheValuesChanged = on('CACHE_VALUES_CHANGED', (data) => {
        logCache.info('캐시 값 변경 감지', data);
        queryClient.invalidateQueries({ 
          queryKey: ['cacheValues'],
          refetchType: 'active'
        });
      });
      
      // 캐시 정보 변경 이벤트
      const unsubCacheInfoChanged = on('CACHE_INFO_CHANGED', (data) => {
        logCache.info('캐시 정보 변경 감지', data);
        queryClient.invalidateQueries({ 
          queryKey: ['cacheInfo'],
          refetchType: 'active'
        });
      });
      
      // 캐시 플러시 이벤트 (모든 캐시가 삭제된 경우)
      const unsubCacheFlushed = on('CACHE_FLUSHED', () => {
        logCache.info('캐시 플러시 감지');
        refreshCache();
      });
      
      isSubscribedRef.current = true;
      
      return () => {
        logCache.info('캐시 업데이트 구독 해제');
        
        // 서버에 모니터링 중지 요청
        if (connected) {
          emit('MONITOR_CACHE', { enabled: false });
        }
        
        // 이벤트 구독 해제
        unsubCacheKeysChanged();
        unsubCacheValuesChanged();
        unsubCacheInfoChanged();
        unsubCacheFlushed();
        
        // 디바운스된 함수 취소
        refreshCache.cancel();
        
        // 소켓 정리
        cleanup();
        
        isSubscribedRef.current = false;
      };
    }
    
    return () => {
      // 연결되지 않은 경우에도 정리
      refreshCache.cancel();
    };
  }, [connected, on, emit, cleanup, queryClient, refreshCache]);
  
  return { isConnected: connected };
};

// 모든 캐시 관련 훅을 단일 객체로 내보내기
export default {
  useCacheInfoQuery,
  useCacheStatsQuery,
  useCacheKeysQuery,
  useCacheValuesQuery,
  useClearCacheMutation,
  useReactQueryCache,
  useRefreshCacheQueries,
  useCacheUpdates
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/index.ts
------------------------------------------------------------
// index.ts - 명시적 내보내기로 충돌 해결
// 공통 타입들
export type { User } from './CommentTypes';

// 댓글 관련 타입들
export type { 
  CommentData,
  CommentProps,
  CommentsTabProps
} from './CommentTypes';

// 멘션 관련 타입들
export type {
  MentionUser,
  MentionState,
  MentionInputProps
} from './MentionTypes';

// UI 관련 타입들
export type {
  InlineEditTextProps,
  StyledComponentProps,
  SeverityChipProps,
  TabPanelProps
} from './UITypes';

// 탭 관련 타입들
export type {
  TabConfig,
  PoCSourceInfo,
  RuleTypeInfo,
  BaseItem,
  PoCItem,
  SnortRuleItem,
  ReferenceItem,
  DataItem,
  ExtendedTabConfig
} from './TabTypes';

// CVE 관련 핵심 타입들 (중복되지 않는 타입들만)
export type {
  CVEBase,
  CVEListResponse,
  CVEDetail,
  CVEDetailData,
  Reference,
  PoC,
  SnortRule,
  ModificationHistory,
  Comment,
  CommentExtended,
  CommentState,
  Subscriber,
  RefreshTriggers,
  TabCounts,
  CVEDetailHeaderProps,
  CVEDetailInfoPanelProps,
  CVEDetailTabsProps,
  CVEDetailProps,
  SubscriberCountProps,
  CVEFilterOptions,
  CVEUpdateRequest,
  OperationResponse,
  ApiResponse,
  FormData,
  PoCFile,
  SnortRuleFile,
  ReferenceFile,
  CVEData,
  SelectOption,
  GenericDataTabBaseProps,
  SnortRuleTabProps,
  PoCTabProps,
  ReferenceTabProps,
  GenericDataTabProps,
  WebSocketUpdateData,
  HistoryChange,
  HistoryItem,
  HistoryTabProps
} from './cve';

// 생성된 타입 export 추가
export * from './generated/cve';

// 함수 내보내기
export { countActiveComments } from './cve';


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/UITypes.ts
------------------------------------------------------------
import React from 'react';
import { Theme } from '@mui/material';

/**
 * 인라인 텍스트 편집 컴포넌트 Props 인터페이스
 */
export interface InlineEditTextProps {
  /** 표시/편집 값 */
  value: string;
  
  /** 값 저장 콜백 */
  onSave: (value: string) => void;
  
  /** 플레이스홀더 */
  placeholder?: string;
  
  /** 여러 줄 입력 가능 여부 */
  multiline?: boolean;
  
  /** 비활성화 여부 */
  disabled?: boolean;
  
  /** 최대 높이 */
  maxHeight?: string | number;
  
  /** 글꼴 크기 */
  fontSize?: string | number;
  
  /** 외부에서 편집 모드 제어 */
  externalEdit?: boolean;
  
  /** 편집 시작 콜백 */
  onEditingStart?: () => void;
  
  /** 편집 종료 콜백 */
  onEditingEnd?: () => void;
}

/**
 * styled 컴포넌트에 사용되는 Props 타입들
 */
export interface StyledComponentProps {
  theme: Theme;
}

/**
 * 심각도 칩 컴포넌트 Props
 */
export interface SeverityChipProps {
  /** CVSS 점수 (0-10) */
  score?: number;
  
  /** 직접 지정하는 심각도 레벨 */
  severity?: 'critical' | 'high' | 'medium' | 'low' | 'none';
  
  /** 칩 크기 */
  size?: 'small' | 'medium';
  
  /** 점수 표시 여부 */
  showScore?: boolean;
  
  /** 추가 스타일 */
  sx?: React.CSSProperties;
}

/**
 * 탭 패널 컴포넌트 Props
 */
export interface TabPanelProps {
  /** 현재 활성화된 탭 인덱스 */
  currentTab: number;
  
  /** 이 패널의 인덱스 */
  index: number;
  
  /** 패널 내용 */
  children?: React.ReactNode;
  
  /** 추가 Props */
  [key: string]: any;
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/generated/comment.ts
------------------------------------------------------------
/**
 * 자동 생성된 Comment 인터페이스 파일 - 직접 수정하지 마세요
 * 생성 시간: 2025-04-11 18:30:00
 */

// 베이스 모델 정의
export interface BaseGeneratedModel {
  [key: string]: unknown;
}

/**
 * Comment 인터페이스
 * @description 댓글 정보
 */
export interface GeneratedComment extends BaseGeneratedModel {
  /** 댓글 ID */
  id: string;
  /** 댓글 내용 */
  content: string;
  /** 작성자 이름 */
  createdBy: string;
  /** 부모 댓글 ID */
  parentId?: string;
  /** 댓글 깊이 */
  depth: number;
  /** 삭제 여부 */
  isDeleted: boolean;
  /** 생성 시간 */
  createdAt: string | Date;
  /** 마지막 수정 시간 */
  lastModifiedAt?: string | Date;
  /** 마지막 수정자 */
  lastModifiedBy?: string;
  /** 멘션된 사용자 목록 */
  mentions: string[];
}



============================================================
File: /home/CVEHub/frontend/src/features/cve/types/generated/cve.ts
------------------------------------------------------------
/**
 * 자동 생성된 TypeScript 인터페이스 파일 - 직접 수정하지 마세요
 * 생성 시간: 2025-04-11 18:22:52
 */

// 댓글 타입 import
import { GeneratedComment } from './comment';

// 베이스 모델 정의
export interface BaseGeneratedModel {
  [key: string]: unknown;
}

/**
 * Reference 인터페이스
 * @description 참조 정보
 */
export interface GeneratedReference extends BaseGeneratedModel {
  /** 참조 URL */
  url: string;
  /** 참조 타입 */
  type?: string;
  /** 참조 설명 */
  description?: string;
  /** 생성 시간 */
  createdAt: string | Date;
  /** 추가한 사용자 */
  createdBy: string;
  /** 마지막 수정 시간 */
  lastModifiedAt: string | Date;
  /** 마지막 수정자 */
  lastModifiedBy: string;
}

/**
 * PoC 인터페이스
 * @description Proof of Concept 코드
 */
export interface GeneratedPoC extends BaseGeneratedModel {
  /** PoC 소스 */
  source: string;
  /** PoC URL */
  url: string;
  /** PoC 설명 */
  description?: string;
  /** 생성 시간 */
  createdAt: string | Date;
  /** 추가한 사용자 */
  createdBy: string;
  /** 마지막 수정 시간 */
  lastModifiedAt: string | Date;
  /** 마지막 수정자 */
  lastModifiedBy: string;
}

/**
 * SnortRule 인터페이스
 * @description Snort 침입 탐지 규칙
 */
export interface GeneratedSnortRule extends BaseGeneratedModel {
  /** Snort Rule 내용 */
  rule: string;
  /** Rule 타입 */
  type: string;
  /** Rule 설명 */
  description?: string;
  /** 생성 시간 */
  createdAt: string | Date;
  /** 추가한 사용자 */
  createdBy: string;
  /** 마지막 수정 시간 */
  lastModifiedAt: string | Date;
  /** 마지막 수정자 */
  lastModifiedBy: string;
}

/**
 * ChangeItem 인터페이스
 * @description 변경 항목
 */
export interface GeneratedChangeItem extends BaseGeneratedModel {
  /** 변경된 필드명 */
  field: string;
  /** 필드의 한글명 */
  fieldName: string;
  /** 변경 유형 */
  action: "add" | "edit" | "delete";
  /** 변경 내역 표시 방식 */
  detailType?: "simple" | "detailed";
  /** 변경 전 값 */
  before?: any;
  /** 변경 후 값 */
  after?: any;
  /** 컬렉션 타입 필드의 변경 항목들 */
  items?: Array<Record<string, any>>;
  /** 변경 요약 */
  summary: string;
}

/**
 * ModificationHistory 인터페이스 (수동 정의)
 * @description 변경 이력
 * @note 백엔드에서 리팩토링 예정이므로 임시 구현
 */
export interface GeneratedModificationHistory extends BaseGeneratedModel {
  /** 수정 ID */
  id?: string;
  /** 수정한 사용자 */
  username: string;
  /** 수정 시간 */
  timestamp: string | Date;
  /** 변경 내역 목록 */
  changes: GeneratedChangeItem[];
}

/**
 * 생성된 CVE 상세 정보 인터페이스
 */
export interface GeneratedCVEDetail extends BaseGeneratedModel {
  /** CVE ID */
  cveId: string;
  /** CVE 제목 */
  title?: string;
  /** CVE 설명 */
  description?: string;
  /** CVE 상태 */
  status: string;
  /** 담당자 */
  assignedTo?: string;
  /** 심각도 */
  severity?: string;
  /** 추가한 사용자 */
  createdBy: string;
  /** 마지막 수정자 */
  lastModifiedBy: string;
  /** 편집 잠금 여부 */
  isLocked?: boolean;
  /** 잠금 설정한 사용자 */
  lockedBy?: string;
  /** 잠금 설정 시간 */
  lockTimestamp?: string | Date;
  /** 잠금 만료 시간 */
  lockExpiresAt?: string | Date;
  /** 내부 참고사항 */
  notes?: string;
  /** Nuclei 템플릿 해시 */
  nucleiHash?: string;
  
  /** 댓글 목록 */
  comments?: GeneratedComment[];
  
  /** PoC 목록 */
  poc?: GeneratedPoC[];
  
  /** Snort 규칙 목록 */
  snort_rule?: GeneratedSnortRule[];
  
  /** 참조 정보 목록 */
  reference?: GeneratedReference[];
  
  /** 변경 이력 목록 (백엔드 리팩토링 예정) */
  modificationHistory?: GeneratedModificationHistory[];
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/CommentTypes.ts
------------------------------------------------------------
import React from 'react';
import { MentionUser } from './MentionTypes';

/**
 * 확장된 댓글 데이터 타입
 */
export interface CommentData {
  /** 댓글 고유 ID */
  id: string;
  
  /** 댓글 내용 */
  content: string;
  
  /** 작성자 (username) */
  author?: string;
  
  /** 작성자 이름 */
  authorName?: string;
  
  /** 프로필 이미지 URL */
  profileImage?: string;
  
  /** 작성 시간 */
  createdAt: string | Date;
  
  /** 마지막 수정 시간 */
  lastModifiedAt?: string | Date;
  
  /** 부모 댓글 ID (대댓글인 경우) */
  parentId?: string;
  
  /** 삭제 여부 */
  isDeleted?: boolean;
  
  /** 낙관적 업데이트용 플래그 */
  isOptimistic?: boolean;
  
  /** 자식 댓글 목록 */
  children?: CommentData[];
  
  /** 댓글 깊이 (중첩 레벨) */
  depth?: number;
  
  /** 작성자 ID (username) */
  createdBy?: string;
  
  /** 기타 속성 */
  [key: string]: unknown;
}

/**
 * Comment 컴포넌트 Props 인터페이스
 */
export interface CommentProps {
  /** 댓글 데이터 */
  comment: CommentData;
  
  /** 댓글 깊이 (대댓글이면 1,2...) */
  depth?: number;
  
  /** 현재 로그인한 사용자명 */
  currentUsername?: string;
  
  /** 관리자 여부 */
  isAdmin?: boolean;
  
  /** 현재 이 댓글이 "수정 중"인지 여부 */
  isEditing?: boolean;
  
  /** 현재 이 댓글이 "답글 모드"인지 여부 */
  replyMode?: boolean;
  
  /** CVE ID */
  cveId?: string;
  
  /** 멘션 가능한 사용자 목록 */
  usersForMention?: MentionUser[];
  
  /** 제출 중 여부 (로딩 상태) */
  isSubmitting?: boolean;
  
  /** 부모 메시지 전송 함수 */
  parentSendMessage?: (type: string, data: Record<string, unknown>) => Promise<boolean | null> | boolean | null;
  
  /** 수정 시작 콜백 */
  onStartEdit: (commentId: string) => void;
  
  /** 수정 종료 콜백 */
  onFinishEdit: () => void;
  
  /** 수정 콜백 */
  onEdit: (commentId: string, content: string) => Promise<any>;
  
  /** 답글 모드 시작 콜백 */
  onReply: (comment: CommentData) => void;
  
  /** 답글 모드 취소 콜백 */
  onReplyCancel: () => void;
  
  /** 답글 제출 콜백 */
  onReplySubmit: (parentCommentId: string, content: string) => Promise<any>;
  
  /** 삭제 콜백 */
  onDelete: (commentId: string, permanent: boolean) => Promise<any>;
  
  /** 자식 (중첩 댓글) 렌더링 컨텐츠 */
  children?: React.ReactNode;
}

/**
 * 사용자 기본 정보 인터페이스
 */
export interface User {
  id?: string;
  username: string;
  displayName?: string;
  profileImage?: string;
  isAdmin?: boolean;
}

/**
 * CommentsTab 컴포넌트 Props 인터페이스
 */
export interface CommentsTabProps {
  /** CVE 상세 데이터 */
  cve: {
    cveId: string;
    comments?: CommentData[];
    [key: string]: any;
  };
  
  /** 댓글 수 변경 콜백 */
  onCommentCountChange?: (count: number) => void;
  
  /** 현재 사용자 정보 */
  currentUser?: User | null;
  
  /** 새로고침 트리거 */
  refreshTrigger?: number;
  
  /** 부모 메시지 전송 함수 */
  parentSendMessage?: (type: string, data: Record<string, unknown>) => Promise<boolean | null> | boolean | null;
  
  /** 강조할 댓글 ID */
  highlightCommentId?: string | null;
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/TabTypes.ts
------------------------------------------------------------
import React from 'react';
import { SvgIconComponent } from '@mui/icons-material';
import { User } from './CommentTypes';

/**
 * 기본 탭 설정 인터페이스
 */
export interface TabConfig {
  /** 탭 아이콘 */
  icon: SvgIconComponent | React.ElementType;
  
  /** 탭 제목 */
  title: string;
  
  /** 항목 이름 */
  itemName: string;
  
  /** 데이터 필드 이름 */
  dataField: string;
  
  /** 추가 버튼 텍스트 */
  addButtonText: string;
  
  /** 편집 버튼 텍스트 */
  editButtonText: string;
  
  /** 삭제 버튼 텍스트 */
  deleteButtonText: string;
}

/**
 * PoC 소스 정보 인터페이스
 */
export interface PoCSourceInfo {
  /** 표시 라벨 */
  label: string;
  
  /** 색상 스키마 */
  color: 'default' | 'primary' | 'secondary' | 'error' | 'info' | 'success' | 'warning';
}

/**
 * 규칙 타입 정보 인터페이스
 */
export interface RuleTypeInfo {
  /** 표시 라벨 */
  label: string;
  
  /** 색상 스키마 */
  color: 'default' | 'primary' | 'secondary' | 'error' | 'info' | 'success' | 'warning';
}

/**
 * 기본 아이템 인터페이스
 */
export interface BaseItem {
  /** 아이템 ID */
  id?: string | number;
  
  /** 설명 */
  description?: string;
  
  /** 생성 일시 */
  created_at?: string | Date;
  
  /** 생성자 (username) */
  created_by?: string;
  
  /** 마지막 수정 일시 */
  last_modified_at?: string | Date;
  
  /** 마지막 수정자 (username) */
  last_modified_by?: string;
  
  /** 현재 사용자 정보 */
  currentUser?: User;
}

/**
 * PoC 아이템 인터페이스
 */
export interface PoCItem extends BaseItem {
  /** 소스 타입 */
  source: string;
  
  /** URL */
  url: string;
}

/**
 * Snort 규칙 아이템 인터페이스
 */
export interface SnortRuleItem extends BaseItem {
  /** 규칙 타입 */
  type: string;
  
  /** 규칙 내용 */
  rule: string;
}

/**
 * 참조 아이템 인터페이스
 */
export interface ReferenceItem extends BaseItem {
  /** 참조 타입 */
  type: string;
  
  /** URL */
  url: string;
}

/**
 * 모든 데이터 아이템 타입
 */
export type DataItem = PoCItem | SnortRuleItem | ReferenceItem;

/**
 * 확장된 탭 설정 인터페이스
 */
export interface ExtendedTabConfig<T extends DataItem> extends TabConfig {
  /** 웹소켓 필드 이름 */
  wsFieldName: string;
  
  /** 기본 아이템 템플릿 */
  defaultItem: T;
  
  /** 빈 상태 제목 */
  emptyTitle: string;
  
  /** 빈 상태 설명 */
  emptyDescription: string;
  
  /** 아이템 유효성 검사 함수 */
  validateItem: (item: T) => boolean | string;
  
  /** 중복 확인 함수 */
  checkDuplicate?: (item: T, items: T[], excludeIndex?: number) => boolean;
  
  /** 아이템 라벨 렌더링 함수 */
  renderItemLabel?: (item: T) => React.ReactNode;
  
  /** 아이템 콘텐츠 렌더링 함수 */
  renderItemContent?: (item: T) => React.ReactNode;
  
  /** 다이얼로그 콘텐츠 렌더링 함수 */
  renderDialogContent?: (
    item: T,
    updateItemState: <K extends keyof T>(item: T, field: K, value: T[K]) => void,
    isEdit: boolean
  ) => React.ReactNode;
  
  /** 저장 전 아이템 처리 함수 */
  prepareItemForSave?: (item: T, isUpdate: boolean, kstTime?: Date) => Partial<T> | Record<string, any>;
  
  /** 상세 정보 필드 */
  detailsField?: string;
  
  /** 카운트 필드 */
  countField?: string;
  
  /** 빈 아이템 생성 함수 */
  getEmptyItem?: () => T;
  
  /** 아이템 제목 가져오기 함수 */
  getItemTitle?: (item: T) => string;
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/bridge.ts
------------------------------------------------------------
// src/features/cve/types/bridge.ts
import {
    GeneratedCVEDetail,
    GeneratedReference,
    GeneratedPoC,
    GeneratedSnortRule,
    GeneratedModificationHistory,
    GeneratedChangeItem
  } from './generated/cve';
  
import { GeneratedComment } from './generated/comment';

// 타입 매핑 - 기존 필드명(snake_case)에서 자동 생성 타입(camelCase)으로의 브릿지
// CVE 생성/업데이트 요청 시 humps 라이브러리에 의해 자동으로 snake_case로 변환됨

/**
 * 기본 확장 인터페이스 정의
 * 기존 코드와의 호환성을 위해 필드 매핑
 */
export interface CVEDetail extends Omit<GeneratedCVEDetail, 'reference' | 'poc' | 'snortRule' | 'modificationHistory' | 'comments'> {
  id?: string;
  reference: Reference[];
  poc: PoC[];
  snortRule: SnortRule[];
  modificationHistory: ModificationHistory[];
  comments?: Comment[];
  createdAt?: string | Date;
  lastModifiedAt?: string | Date;
  [key: string]: unknown;
}

export interface Reference extends GeneratedReference {
  id?: string;
  [key: string]: unknown;
}

export interface PoC extends Omit<GeneratedPoC, 'source'> {
  id?: string;
  code: string; // 'source' 대신 'code' 필드 사용
  language?: string;
  [key: string]: unknown;
}

export interface SnortRule extends GeneratedSnortRule {
  id?: string;
  [key: string]: unknown;
}

export interface Comment extends Omit<GeneratedComment, 'id'> {
  id?: string;
  children?: Comment[];
  [key: string]: unknown;
}

export interface ChangeItem extends GeneratedChangeItem {
  [key: string]: unknown;
}

export interface ModificationHistory extends GeneratedModificationHistory {
  id?: string;
  [key: string]: unknown;
}

// 주의: API 요청 시 프론트엔드의 카멜케이스 필드명은
// axios interceptor에 의해 자동으로 스네이크케이스로 변환됨
// config.js에 설정된 CASE_CONVERSION_CONFIG에 따라 일부 필드는 변환에서 제외될 수 있음


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/MentionTypes.ts
------------------------------------------------------------
import React from 'react';

/**
 * 멘션 가능한 사용자 타입
 */
export interface MentionUser {
  /** 사용자 ID (일반적으로 username) */
  id: string;
  
  /** 표시 이름 */
  display: string;
  
  /** 사용자명 (id와 동일할 수 있음) */
  username?: string;
  
  /** 프로필 이미지 URL */
  profileImage?: string;
}

/**
 * 멘션 상태 타입 정의
 */
export interface MentionState {
  /** 활성화 여부 */
  active: boolean;
  
  /** 검색 쿼리 */
  query: string;
  
  /** 시작 위치 */
  startPos: number;
}

/**
 * MentionInput 컴포넌트 Props 인터페이스
 */
export interface MentionInputProps {
  /** 입력 값 */
  value: string;
  
  /** 입력 값 변경 핸들러 */
  onChange: (value: string | React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  
  /** 제출 핸들러 (Enter 키 등 사용 시) */
  onSubmit?: (value: string) => void;
  
  /** 플레이스홀더 텍스트 */
  placeholder?: string;
  
  /** 로딩 상태 여부 */
  loading?: boolean;
  
  /** 전체 너비 차지 여부 */
  fullWidth?: boolean;
  
  /** 여러 줄 입력 가능 여부 */
  multiline?: boolean;
  
  /** 멀티라인일 경우 기본 행 수 */
  rows?: number;
  
  /** 입력 컴포넌트 variant */
  variant?: 'outlined' | 'filled' | 'standard';
  
  /** 입력 컴포넌트 크기 */
  size?: 'small' | 'medium';
  
  /** 멘션 가능한 사용자 목록 */
  users?: MentionUser[];
  
  /** 입력 요소 ref */
  inputRef?: React.RefObject<HTMLDivElement>;
  
  /** 컴포넌트 키 (리렌더링 제어용) */
  key?: number | string;
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/cve.ts
------------------------------------------------------------
/**
 * CVE 관련 타입 정의 파일
 */

// 생성된 타입 임포트
import {
  GeneratedCVEDetail,
  GeneratedPoC,
  GeneratedReference,
  GeneratedSnortRule,
  GeneratedModificationHistory,
  GeneratedChangeItem,
  // 필요한 다른 생성된 타입들...
} from './generated/cve';

// GeneratedComment 타입 import
import { GeneratedComment } from './generated/comment';

// 다른 타입 파일에서 중복된 타입 임포트
import { CommentProps as ImportedCommentProps } from './CommentTypes';
import { CommentsTabProps as ImportedCommentsTabProps } from './CommentTypes';
import { MentionUser as ImportedMentionUser } from './MentionTypes';
import { TabConfig as ImportedTabConfig } from './TabTypes';
import { SeverityChipProps as ImportedSeverityChipProps } from './UITypes';
import { TabPanelProps as ImportedTabPanelProps } from './UITypes';

// 중복 타입을 재내보내기 (타입 호환성 유지)
export type CommentProps = ImportedCommentProps;
export type CommentsTabProps = ImportedCommentsTabProps;
export type MentionUser = ImportedMentionUser;
export type TabConfig = ImportedTabConfig;
export type SeverityChipProps = ImportedSeverityChipProps;
export type TabPanelProps = ImportedTabPanelProps;

/**
 * CVE 기본 정보 인터페이스
*/
export interface CVEBase {
  id?: string;
  cveId: string;
  title?: string;
  status: string;
  createdAt: string | Date;
  lastModifiedAt?: string | Date;
  severity?: string;
}

/**
 * CVE 목록 응답 인터페이스
 */
export interface CVEListResponse {
  items: CVEBase[];
  total: number;
  page: number;
  limit: number;
}

/**
 * CVE 상세 정보 인터페이스
 */
export interface CVEDetail extends CVEBase {
  description?: string;
  reference: Reference[];
  poc: PoC[];
  snortRule: SnortRule[];
  modificationHistory: ModificationHistory[];
  createdBy?: string;
  lastModifiedBy?: string;
  comments?: Comment[];
  // CVEDetailData 타입과의 호환성을 위한 인덱스 시그니처 추가
  [key: string]: unknown;
}

/**
 * CVE 상세 데이터 인터페이스 - API 응답 또는 캐시된 데이터를 위한 확장 인터페이스
 * 백엔드와 프론트엔드 간의 필드명 차이를 허용하기 위한 유연한 인터페이스
 */
export interface CVEDetailData {
  cveId: string;
  createdAt?: string | Date;
  created_at?: string | Date;
  lastModifiedAt?: string | Date;
  last_modified_at?: string | Date;
  fromCache?: boolean;
  _cachedAt?: number | string;
  cachedAt?: number | string;
  poc?: unknown[];
  PoC?: unknown[];
  pocList?: unknown[];
  snortRule?: unknown[];
  snort_rule?: unknown[];
  reference?: unknown[];
  ref?: unknown[];
  comments?: Comment[];
  [key: string]: unknown;
}

/**
 * 참고자료 인터페이스
 * 중앙화된 타입 정의를 확장
 */
export interface Reference extends GeneratedReference {
  id?: string;
  // CVEData 타입과의 호환성을 위한 인덱스 시그니처 추가
  [key: string]: unknown;
}

/**
 * PoC (Proof of Concept) 인터페이스
 * 중앙화된 타입 정의를 확장
 */
export interface PoC extends Omit<GeneratedPoC, 'source'> {
  id?: string;
  code: string;
  language?: string;
  // CVEData 타입과의 호환성을 위한 인덱스 시그니처 추가
  [key: string]: unknown;
}

/**
 * Snort Rule 인터페이스
 * 중앙화된 타입 정의를 확장
 */
export interface SnortRule extends GeneratedSnortRule {
  id?: string;
  // CVEData 타입과의 호환성을 위한 인덱스 시그니처 추가
  [key: string]: unknown;
}

/**
 * 수정 기록 항목 인터페이스
 * 중앙화된 타입 정의를 확장
 */
export interface ChangeItem extends GeneratedChangeItem {
  // 호환성을 위한 인덱스 시그니처
  [key: string]: unknown;
}

/**
 * 수정 기록 인터페이스
 * 중앙화된 타입 정의를 확장
 */
export interface ModificationHistory extends GeneratedModificationHistory {
  id?: string;
  // 호환성을 위한 인덱스 시그니처
  [key: string]: unknown;
}

/**
 * 댓글 인터페이스
 * 중앙화된 타입 정의를 확장
 */
export interface Comment extends Omit<GeneratedComment, 'id'> {
  id?: string;
  // 호환성을 위한 인덱스 시그니처
  [key: string]: unknown;
}

/**
 * 확장된 댓글 인터페이스 (Comment 컴포넌트용)
 */
export interface CommentExtended extends Comment {
  parentId?: string;
  depth?: number;
  lastModifiedAt?: string | Date;
}

/**
 * 댓글 상태 관리 인터페이스
 */
export interface CommentState {
  editingId: string | null;
  replyingToId: string | null;
  comments: Comment[];
  loading: boolean;
  error: string | null;
}

/**
 * 구독자 인터페이스
 */
export interface Subscriber {
  id?: string;
  userId?: string;
  displayName?: string;
  username?: string;
  profile_image?: string;
  profileImage?: string;
}

/**
 * 새로고침 트리거 인터페이스
 */
export interface RefreshTriggers {
  general: number;
  poc: number;
  snortRule: number;
  reference: number;
  comments: number;
  history: number;
}

/**
 * 탭 카운트 인터페이스
 */
export interface TabCounts {
  poc: number;
  snortRule: number;
  reference: number;
  comments: number;
}

/**
 * CVE 상세 헤더 Props 인터페이스
 */
export interface CVEDetailHeaderProps {
  cveId: string;
  subscribers: Subscriber[];
  createdAt: string | Date;
  lastModifiedAt: string | Date;
  isCached: boolean;
  isLoading: boolean;
  onRefresh: () => void;
  onClose: () => void;
}

/**
 * CVE 상세 정보 패널 Props 인터페이스
 */
export interface CVEDetailInfoPanelProps {
  cveData: CVEDetailData;
  onUpdateField: (field: string, value: unknown) => Promise<void>;
  canEdit: boolean;
}

/**
 * CVE 상세 탭 Props 인터페이스
 */
export interface CVEDetailTabsProps {
  cveData: CVEDetailData;
  currentUser: unknown;
  refreshTriggers: RefreshTriggers;
  tabCounts: TabCounts;
  onCountChange: (tabKey: keyof TabCounts, count: number) => void;
  parentSendMessage: (type: string, data: Record<string, unknown>) => Promise<boolean | null>;
  highlightCommentId?: string | null;
}

/**
 * CVE 상세 컴포넌트 Props 인터페이스
 */
export interface CVEDetailProps {
  cveId?: string;
  open?: boolean;
  onClose: () => void;
  highlightCommentId?: string | null;
}

/**
 * 구독자 수 표시 컴포넌트 Props 인터페이스
 */
export interface SubscriberCountProps {
  subscribers: Subscriber[];
  cveId?: string;
}

/**
 * CVE 필터링 옵션 인터페이스
 */
export interface CVEFilterOptions {
  page?: number;
  rowsPerPage?: number;
  search?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  filters?: Record<string, any>;
}

/**
 * CVE 업데이트 요청 인터페이스
 */
export interface CVEUpdateRequest {
  title?: string;
  description?: string;
  status?: string;
  severity?: string;
  reference?: Reference[];
  poc?: PoC[];
  snortRule?: SnortRule[];
}

/**
 * 작업 결과 응답 인터페이스
 */
export interface OperationResponse {
  success: boolean;
  message: string;
  data?: any;
}

/**
 * API 응답 인터페이스 (제네릭)
 */
export interface ApiResponse<T> {
  data?: T;
  success?: boolean;
  message?: string;
  status?: number;
  [key: string]: unknown;
}

/**
 * CreateCVE 폼 데이터 인터페이스
 */
export interface FormData {
  cveId: string;
  title: string;
  description: string;
  status: string;
  severity: string;
  tags: string[];
  exploitStatus: string;
}

/**
 * PoC (Proof of Concept) 파일 인터페이스
 */
export interface PoCFile {
  id?: string;
  source: string;
  url: string;
  created_by?: string;
  last_modified_by?: string;
}

/**
 * Snort 규칙 파일 인터페이스
 */
export interface SnortRuleFile {
  id?: string;
  rule: string;
  type: string;
  created_by?: string;
  last_modified_by?: string;
}

/**
 * 참조 URL 인터페이스
 */
export interface ReferenceFile {
  id?: string;
  url: string;
  createdAt?: string;
  createdBy?: string;
  lastModifiedAt?: string | null;
  lastModifiedBy?: string;
}

/**
 * CVE 데이터 인터페이스 (CreateCVE 컴포넌트용)
 */
export interface CVEData extends FormData {
  poc: Omit<PoCFile, 'id'>[];
  snortRule: Omit<SnortRuleFile, 'id'>[];
  reference: Omit<ReferenceFile, 'id'>[];
}

/**
 * 선택 옵션 인터페이스
 */
export interface SelectOption {
  value: string;
  label: string;
}

/**
 * GenericDataTab의 기본 프롭스 인터페이스
 */
export interface GenericDataTabBaseProps {
  cveData: CVEDetail;
  refreshTrigger?: number;
  currentUser?: { username: string; [key: string]: any };
  canEdit?: boolean;
  onTabCountChange?: (key: string, count: number) => void;
  parentSendMessage?: (type: string, data: Record<string, any>) => Promise<boolean | null>;
}

/**
 * SnortRuleTab 컴포넌트의 프롭스 인터페이스
 */
export interface SnortRuleTabProps extends GenericDataTabBaseProps {}

/**
 * PoCTab 컴포넌트의 프롭스 인터페이스
 */
export interface PoCTabProps extends GenericDataTabBaseProps {}

/**
 * ReferenceTab 컴포넌트의 프롭스 인터페이스
 */
export interface ReferenceTabProps extends GenericDataTabBaseProps {}

/**
 * GenericDataTab 프롭스 인터페이스
 */
export interface GenericDataTabProps extends GenericDataTabBaseProps {
  tabConfig: ImportedTabConfig; // 변경된 부분
}

/**
 * 웹소켓 업데이트 데이터 인터페이스
 */
export interface WebSocketUpdateData {
  id?: string;
  cveId?: string;
  field?: string;
  field_key?: string;
  value?: unknown;
  data?: Record<string, unknown>;
  timestamp?: string | number;
  senderId?: string;
  event?: string;
  updateId?: number | string;
  updatedData?: Record<string, any>;
  [key: string]: unknown;
}

/**
 * 운영 중인 댓글 수 계산 함수
 * @param comments 댓글 배열 (중첩 댓글 포함)
 * @returns 삭제되지 않은 댓글의 총 개수
 */
export const countActiveComments = (comments?: Comment[]): number => {
  if (!comments || !Array.isArray(comments)) return 0;
  
  let count = 0;
  comments.forEach(comment => {
    // 삭제되지 않은 댓글만 쪽수
    if (!(comment.isDeleted || comment.is_deleted)) {
      count++;
    }
    // 중첩 댓글 처리
    if (comment.children && Array.isArray(comment.children)) {
      count += countActiveComments(comment.children);
    }
  });
  
  return count;
};

/**
 * HistoryTab 컴포넌트에서 사용하는 수정 이력 인터페이스
 */
export interface HistoryChange {
  /**
   * 변경된 필드명
   */
  field: string;
  
  /**
   * 표시용 필드명
   */
  fieldName?: string;
  
  /**
   * 변경 액션 (add, edit, delete)
   */
  action: 'add' | 'edit' | 'delete';
  
  /**
   * 변경 내용 요약
   */
  summary: string;
  
  /**
   * 상세 표시 타입
   */
  detailType?: 'simple' | 'detailed';
  
  /**
   * 변경 전 값
   */
  before?: string;
  
  /**
   * 변경 후 값
   */
  after?: string;
  
  /**
   * 변경된 아이템 목록 (배열 타입 필드의 경우)
   */
  items?: Array<{
    type?: string;
    rule?: string;
    url?: string;
    [key: string]: unknown;
  }>;
}

/**
 * HistoryTab 컴포넌트에서 사용하는 수정 이력 항목 인터페이스
 */
export interface HistoryItem {
  /**
   * 수정한 사용자명
   */
  username: string;
  
  /**
   * 수정 일시
   */
  modifiedAt?: string | Date;
  
  /**
   * 수정 일시 (백엔드 필드명 호환용)
   */
  lastModifiedAt?: string | Date;
  
  /**
   * 변경 내역 목록
   */
  changes?: HistoryChange[];
}

/**
 * HistoryTab 컴포넌트 Props 인터페이스
 */
export interface HistoryTabProps {
  /**
   * 수정 이력 목록
   */
  modificationHistory?: HistoryItem[];
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/CVEDetail.tsx
------------------------------------------------------------
import React, {
  useState,
  useEffect,
  useRef,
  useCallback,
  useMemo,
} from 'react';
import { useSocket } from 'core/socket/hooks/useSocket';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { useQueryClient } from '@tanstack/react-query';
import { useSnackbar } from 'notistack';
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogActions,
  DialogContentText,
  Card,
  CardContent,
  Box,
  Fade,
  CircularProgress,
  Button,
  Typography,
  Chip,
} from '@mui/material';
import logger from 'shared/utils/logging';
import { useUpdateCVEField } from 'features/cve/hooks/useCVEMutation';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { timeAgo } from 'shared/utils/dateUtils';
import { useCVEDetail, useCVERefresh, useCVESubscription } from './hooks';
import {
  ApiResponse,
  Comment,
  CVEDetail as CVEDetailType,
  CVEDetailData,
  CVEDetailHeaderProps,
  CVEDetailInfoPanelProps,
  CVEDetailProps,
  CVEDetailTabsProps,
  RefreshTriggers,
  Subscriber,
  TabCounts,
  WebSocketUpdateData,
  countActiveComments
} from './types/cve';

import CVEDetailHeader from './CVEDetailHeader';
import CVEDetailInfoPanel from './CVEDetailInfoPanel';
import CVEDetailTabs from './CVEDetailTabs';

// --- 메인 컴포넌트 ---
const CVEDetail: React.FC<CVEDetailProps> = ({ cveId: propsCveId, open = false, onClose, highlightCommentId = null }) => {
  const { enqueueSnackbar, closeSnackbar } = useSnackbar();
  const { socket, connected } = useSocket();
  const { user: currentUser } = useAuth();
  const queryClient = useQueryClient();

  // 프론트엔드와 백엔드 필드명 매핑 (웹소켓 업데이트 처리용)
  const fieldMapping = useRef<Record<string, string>>({
    status: 'status',
    title: 'title',
    description: 'description',
    severity: 'severity',
    cveId: 'cve_id',
    poc: 'poc',
    snortRule: 'snort_rule',
    reference: 'reference',
    comments: 'comments',
    createdAt: 'created_at',
    lastModifiedAt: 'last_modified_at',
    lastModifiedBy: 'last_modified_by',
    modificationHistory: 'modification_history',
    tags: 'tags',
  }).current;

  // 개발 환경에서만 로그 레벨을 DEBUG로 설정 (디버깅 목적)
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      // @ts-ignore - logger.setLogLevel 타입 에러 무시
      logger.setLogLevel(0); // DEBUG 레벨 설정
      logger.debug('CVEDetail: 로그 레벨을 DEBUG로 설정했습니다.');
    }
  }, []);

  // --- 상태 관리 ---
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [isCached, setIsCached] = useState<boolean>(false);
  const [errorDialogOpen, setErrorDialogOpen] = useState<boolean>(false);
  const [refreshTriggers, setRefreshTriggers] = useState<RefreshTriggers>({
    general: 0,
    poc: 0,
    snortRule: 0,
    reference: 0,
    comments: 0,
    history: 0,
  });
  const [tabCounts, setTabCounts] = useState<TabCounts>({
    poc: 0,
    snortRule: 0,
    reference: 0,
    comments: 0,
  });

  // --- Refs ---
  const socketRef = useRef(socket);
  const connectedRef = useRef(connected);
  const snackbarShown = useRef<boolean>(false);
  const refreshTriggersRef = useRef<RefreshTriggers>(refreshTriggers);
  const lastProcessedUpdateIdRef = useRef<Record<string, number | string>>({});
  const currentUserRef = useRef<typeof currentUser | null>(null);
  const isFirstLoadRef = useRef<boolean>(true);
  const isSubscribedRef = useRef<boolean>(false);
  // 구독 관련 추가 Refs
  const hasAttemptedSubscriptionRef = useRef<boolean>(false);
  const isModalOpenRef = useRef<boolean>(false);

  // Socket.IO 서비스 참조
  const socketServiceRef = useRef(socket?.socketService).current;

  // 구독 관련 상태와 기능
  const { isSubscribed, isLoading: isSubscriptionLoading, subscribe, unsubscribe, getSubscribers } = useCVESubscription(propsCveId);
  
  // 기존 구독 상태 참조 유지 (최신 상태 접근용)
  isSubscribedRef.current = isSubscribed;
  
  // 구독 상태가 변경될 때마다 참조 업데이트
  useEffect(() => {
    isSubscribedRef.current = isSubscribed;
  }, [isSubscribed]);

  // --- Hooks ---
  // 현재 사용자 참조 유지
  useEffect(() => {
    currentUserRef.current = currentUser;
  }, [currentUser]);

  // 소켓 참조 유지
  useEffect(() => {
    socketRef.current = socket;
    connectedRef.current = connected;
    
    if (process.env.NODE_ENV === 'development') {
      logger.info('CVEDetail', '소켓 참조 업데이트됨 (메인 컴포넌트)', {
        socketId: socket?.id,
        connected,
        hasSocket: !!socket,
      });
    }
  }, [socket, connected]);

  // 모달 상태 참조 유지
  useEffect(() => {
    isModalOpenRef.current = open;
  }, [open]);

  // 구독자 정보 (중앙 관리 시스템에서 가져옴)
  const subscribers = useMemo(() => {
    return getSubscribers();
  }, [getSubscribers, propsCveId, isSubscribed]);

  // 구독 상태 변경 핸들러
  const handleSubscription = useCallback(() => {
    if (isSubscribed) {
      unsubscribe();
    } else {
      subscribe();
    }
  }, [isSubscribed, subscribe, unsubscribe]);

  // React Query: CVE 상세 정보 조회
  const {
    data: cveData,
    isLoading: isQueryLoading,
    isFetching,
    dataUpdatedAt,
    error: queryError,
    refetch: refetchCveDetail,
  } = useCVEDetail(propsCveId || '', {
    enabled: !!propsCveId && open,
    refetchOnReconnect: false,
    // @ts-ignore - 타입 정의와 실제 라이브러리 구현 간의 불일치 무시
    onSuccess: (data: CVEDetailData) => {
      logger.info('CVEDetail', '데이터 로딩 성공', { dataReceived: !!data });
      if (snackbarShown.current) {
        closeSnackbar();
      }
      updateTabCounts(data);
      setIsCached(false);
      setLoading(false);
      setError(null);
      setErrorDialogOpen(false);
    },
    onError: (err: Error) => {
      logger.error('CVEDetail', '데이터 로딩 실패', { error: err.message });
      if (snackbarShown.current) {
        closeSnackbar();
      }
      enqueueSnackbar(`데이터 로딩 실패: ${err.message || '알 수 없는 오류'}`, {
        variant: 'error',
      });
      setError(err.message || '데이터 로딩 실패');
      setLoading(false);
      setErrorDialogOpen(true);
    },
  });

  // 캐시 상태 확인
  const isDataFromCache = useMemo(() => {
    if (cveData && dataUpdatedAt) {
      const cacheThreshold = 30 * 1000;
      return Date.now() - dataUpdatedAt > cacheThreshold;
    }
    return false;
  }, [cveData, dataUpdatedAt]);

  // 캐시 상태 업데이트
  useEffect(() => {
    setIsCached(isDataFromCache);
  }, [isDataFromCache]);

  // 탭 카운트 업데이트 함수
  const updateTabCounts = useCallback((data: CVEDetailData) => {
    if (!data) {
      logger.warn('updateTabCounts: 데이터가 없어 카운트를 업데이트할 수 없습니다.');
      setTabCounts({ poc: 0, snortRule: 0, reference: 0, comments: 0 });
      return;
    }
    
    const newCounts: TabCounts = {
      poc:
        data.poc?.length ??
        data.PoC?.length ??
        data.pocList?.length ??
        0,
      snortRule: data.snortRule?.length ?? data.snort_rule?.length ?? 0,
      reference: data.reference?.length ?? data.ref?.length ?? 0,
      comments: countActiveComments(data.comments),
    };
    setTabCounts(newCounts);
  }, []);

  // CVE 새로고침 훅
  const { mutate: refreshCVE, isLoading: isRefreshing } = useCVERefresh(
    propsCveId || ''
  );
  
  // CVE 필드 업데이트 훅
  const { mutate: updateCVEField } = useUpdateCVEField();

  // 필드 업데이트 핸들러
  const handleFieldUpdate = useCallback((field: string, value: unknown) => {
    if (!propsCveId || !field) {
      logger.warn('handleFieldUpdate: cveId 또는 field가 없습니다.');
      return;
    }
    
    if (!cveData || cveData[field] === value) {
      logger.info('handleFieldUpdate: 변경 사항 없음', { field, value });
      return;
    }
    
    logger.info('handleFieldUpdate 시작', { field, value });
    const fieldMappingLocal: Record<string, string> = {
      title: 'title',
      description: 'description',
      status: 'status',
      severity: 'severity',
    };
    
    const backendField = fieldMappingLocal[field] || field;
    const cachedData = queryClient.getQueryData<CVEDetailData>(
      QUERY_KEYS.CVE.detail(propsCveId)
    );
    
    if (cachedData) {
      // 낙관적 업데이트
      const optimisticData = { ...cachedData, [field]: value };
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(propsCveId), optimisticData);
      logger.info('handleFieldUpdate: 캐시 낙관적 업데이트 완료', { field, value });
    }
    
    setLoading(true);
    updateCVEField(
      { cveId: propsCveId, fieldName: backendField, fieldValue: value },
      {
        // @ts-ignore - ApiResponse와 CVEDetailData 타입 불일치 무시
        onSuccess: (updatedData: any) => {
          logger.info('CVEDetail', `필드 업데이트 성공: ${field}`, {
            response: updatedData,
          });
          enqueueSnackbar(`${field} 업데이트 성공`, {
            variant: 'success',
            autoHideDuration: 1500,
          });
          
          // 주요 필드 변경 시 목록 쿼리 무효화
          if (['title', 'status', 'severity'].includes(field)) {
            logger.info('CVEDetail: 목록 쿼리 무효화 중...');
            queryClient.invalidateQueries({
              predicate: (query) =>
                Array.isArray(query.queryKey) &&
                query.queryKey[0] === QUERY_KEYS.CVE.list()[0],
            });
          }
        },
        onError: (err: Error) => {
          logger.error('CVEDetail', `필드 업데이트 실패: ${field}`, {
            error: err.message,
          });
          enqueueSnackbar(
            `업데이트 실패 (${field}): ${err.message || '알 수 없는 오류'}`,
            { variant: 'error' }
          );
          
          // 오류 시 캐시 롤백
          if (cachedData) {
            queryClient.setQueryData(
              QUERY_KEYS.CVE.detail(propsCveId),
              cachedData
            );
            logger.info('handleFieldUpdate: 캐시 롤백 완료', { field });
          }
        },
        onSettled: () => {
          setLoading(false);
          logger.info('handleFieldUpdate: 완료 (성공/실패 무관)', { field });
        },
      }
    );
  }, [propsCveId, cveData, updateCVEField, queryClient, enqueueSnackbar]);

  // 제목 업데이트 핸들러
  const handleTitleUpdate = useCallback((newTitle: string) => {
    if (!cveData || !propsCveId || newTitle === cveData.title) return;
    handleFieldUpdate('title', newTitle);
  }, [cveData, propsCveId, handleFieldUpdate]);

  // 설명 업데이트 핸들러
  const handleDescriptionUpdate = useCallback((newDescription: string) => {
    if (!cveData || !propsCveId || newDescription === cveData.description) return;
    handleFieldUpdate('description', newDescription);
  }, [cveData, propsCveId, handleFieldUpdate]);

  // 웹소켓 업데이트 처리 핸들러
  const handleWebSocketUpdate = useCallback((data: WebSocketUpdateData) => {
    logger.info('CVEDetail', '웹소켓 업데이트 수신', data);
    if (!data) return;
    
    const fieldKey = data.field_key || data.field || 'general';
    const updateId = data.updateId || Date.now();
    
    // 중복 업데이트 필터링
    if (lastProcessedUpdateIdRef.current[fieldKey] === updateId) {
      logger.info('CVEDetail', `중복 웹소켓 업데이트 무시: ${fieldKey}, ID: ${updateId}`);
      return;
    }
    
    // 업데이트 ID 기록
    lastProcessedUpdateIdRef.current[fieldKey] = updateId;
    
    // 리프레시 트리거 업데이트
    const newTriggers = {
      ...refreshTriggersRef.current,
      [fieldKey]: (refreshTriggersRef.current[fieldKey as keyof RefreshTriggers] || 0) + 1
    };
    
    refreshTriggersRef.current = newTriggers;
    setRefreshTriggers(newTriggers);
    
    logger.info('CVEDetail: Refresh trigger 업데이트', {
      fieldKey,
      newTrigger: newTriggers[fieldKey as keyof RefreshTriggers],
    });
    
    // 댓글 업데이트는 CommentsTab에서 별도 처리
    if (fieldKey === 'comments') {
      logger.info('CVEDetail: 댓글 업데이트는 CommentsTab에서 처리');
      return;
    }
    
    // 로딩 중이 아닐 때만 캐시 업데이트
    if (!loading) {
      try {
        const cachedData = queryClient.getQueryData<CVEDetailData>(
          QUERY_KEYS.CVE.detail(propsCveId)
        );
        
        if (cachedData && data.updatedData) {
          logger.info('CVEDetail', `${fieldKey} 필드 웹소켓 업데이트 - 캐시 직접 업데이트`);
          let updatedCacheData = { ...cachedData };
          
          // 전체 데이터 업데이트
          if (fieldKey === 'all') {
            updatedCacheData = { ...updatedCacheData, ...(data.updatedData as Record<string, any>) };
          } 
          // 특정 필드 업데이트
          else if (data.updatedData.hasOwnProperty(fieldKey)) {
            (updatedCacheData as any)[fieldKey] = data.updatedData[fieldKey];
            
            // 프론트엔드 필드명 매핑 처리
            const frontendField = Object.keys(fieldMapping).find(
              (key) => fieldMapping[key] === fieldKey
            );
            if (frontendField) {
              (updatedCacheData as any)[frontendField] = data.updatedData[fieldKey];
            }
          } 
          // 특수 필드 처리
          else {
            if (fieldKey === 'poc' && data.updatedData.poc)
              updatedCacheData.poc = data.updatedData.poc;
            else if (fieldKey === 'snort_rule' && data.updatedData.snort_rule)
              updatedCacheData.snortRule = data.updatedData.snort_rule;
            else if (fieldKey === 'reference' && data.updatedData.reference)
              updatedCacheData.reference = data.updatedData.reference;
            else {
              logger.warn('CVEDetail: 처리되지 않은 웹소켓 필드 업데이트', {
                fieldKey,
                updatedData: data.updatedData,
              });
              updatedCacheData = { ...updatedCacheData, ...(data.updatedData as Record<string, any>) };
            }
          }
          
          // 캐시 업데이트
          queryClient.setQueryData(
            QUERY_KEYS.CVE.detail(propsCveId),
            updatedCacheData
          );
          updateTabCounts(updatedCacheData);
        } 
        // 캐시가 없는 경우 쿼리 무효화
        else if (!cachedData) {
          logger.info('CVEDetail', `웹소켓 업데이트 - 캐시 없음, 쿼리 무효화: ${fieldKey}`);
          queryClient.invalidateQueries({
            queryKey: QUERY_KEYS.CVE.detail(propsCveId),
          });
        }
      } catch (error: unknown) {
        const err = error instanceof Error ? error : new Error('Unknown error');
        logger.error('CVEDetail', '웹소켓 업데이트 처리 중 캐시 업데이트 오류', {
          error: err.message,
        });
        queryClient.invalidateQueries({
          queryKey: QUERY_KEYS.CVE.detail(propsCveId),
        });
      }
    } else {
      logger.info('CVEDetail: 로딩 중이므로 웹소켓 업데이트 건너뜀', { fieldKey });
    }
    
    // 스낵바 표시
    if (!snackbarShown.current) {
      snackbarShown.current = true;
      let fieldName = fieldKey;
      enqueueSnackbar(`${fieldName} 정보가 업데이트되었습니다.`, {
        variant: 'info',
        autoHideDuration: 2500,
        anchorOrigin: { vertical: 'bottom', horizontal: 'right' },
        onClose: () => {
          snackbarShown.current = false;
        },
      });
    }
  }, [enqueueSnackbar, propsCveId, queryClient, loading, updateTabCounts]);

  // CVE 업데이트 이벤트 핸들러
  const handleCVEUpdated = useCallback((data: WebSocketUpdateData) => {
    if (!data || !(data.cveId === propsCveId || data.id === propsCveId)) return;
    
    logger.info('CVEDetail', '`cve_updated` 이벤트 수신', {
      dataId: data.id || data.cveId,
      propsCveId,
      type: data.field_key || data.field || 'general',
    });
    
    handleWebSocketUpdate(data);
  }, [propsCveId, handleWebSocketUpdate]);

  // 새로고침 핸들러
  const handleRefresh = useCallback(() => {
    if (!propsCveId || loading) {
      logger.warn('handleRefresh: 이미 로딩 중이거나 ID가 없습니다.');
      return;
    }
    
    logger.info('handleRefresh: 데이터 새로고침 시작', { cveId: propsCveId });
    
    if (snackbarShown.current) closeSnackbar();
    enqueueSnackbar('데이터를 새로고침 중입니다...', { variant: 'info' });
    snackbarShown.current = true;
    
    setLoading(true);
    setIsCached(false);
    
    queryClient.invalidateQueries({
      queryKey: QUERY_KEYS.CVE.detail(propsCveId),
    });
    
    refetchCveDetail()
      .then(() => {
        logger.info('handleRefresh: 데이터 새로고침 성공', { cveId: propsCveId });
        closeSnackbar();
        enqueueSnackbar('최신 데이터를 성공적으로 불러왔습니다', {
          variant: 'success',
          autoHideDuration: 2000,
        });
        snackbarShown.current = false;
      })
      .catch((error: Error) => {
        logger.error('handleRefresh: 데이터 새로고침 실패', {
          cveId: propsCveId,
          error: error.message,
        });
        closeSnackbar();
        enqueueSnackbar(`새로고침 실패: ${error.message || '알 수 없는 오류'}`, {
          variant: 'error',
        });
        snackbarShown.current = false;
        setError(error.message || '새로고침 실패');
        setErrorDialogOpen(true);
      })
      .finally(() => {
        setLoading(false);
      });
  }, [propsCveId, loading, refetchCveDetail, queryClient, enqueueSnackbar, closeSnackbar]);

  // 메시지 전송 핸들러
  const sendMessage = useCallback(async (type: string, data: Record<string, unknown>): Promise<boolean | null> => {
    if (!socketRef.current || !connectedRef.current) {
      logger.warn('sendMessage: 소켓 연결 없음', { type });
      enqueueSnackbar('서버 연결이 없어 메시지를 보낼 수 없습니다.', {
        variant: 'warning',
      });
      return null;
    }
    
    if (!type) {
      logger.error('sendMessage: 이벤트 타입 누락', { data });
      enqueueSnackbar('메시지 전송 오류: 타입 누락', { variant: 'error' });
      return null;
    }
    
    logger.info('sendMessage: 메시지 전송 시도', {
      type,
      cveId: propsCveId,
      data,
    });
    
    try {
      socketRef.current.emit(type, {
        cve_id: propsCveId,
        ...data,
      });
      
      logger.info('sendMessage: 메시지 전송 성공', { type });
      
      // 잠시 후 쿼리 무효화
      if (!loading && !isQueryLoading) {
        setTimeout(() => {
          queryClient.invalidateQueries({
            queryKey: QUERY_KEYS.CVE.detail(propsCveId),
          });
        }, 1000);
      }
      
      return true;
    } catch (socketError: unknown) {
      const err = socketError instanceof Error ? socketError : new Error('Unknown error');
      logger.error('sendMessage: 소켓 emit 오류', { type, error: err.message });
      enqueueSnackbar('메시지 전송 중 오류 발생', { variant: 'error' });
      return null;
    }
  }, [propsCveId, enqueueSnackbar, queryClient, loading, isQueryLoading]);

  // 오류 다이얼로그 닫기 핸들러
  const handleErrorDialogClose = useCallback(() => {
    setErrorDialogOpen(false);
    setError(null);
  }, []);

  // 탭 카운트 변경 핸들러
  const handleTabCountChange = useCallback((tabKey: keyof TabCounts, count: number) => {
    setTabCounts(prev => {
      if (prev[tabKey] === count) return prev;
      return { ...prev, [tabKey]: count };
    });
  }, []);

  // 편집 권한 확인
  const canEdit = useCallback((): boolean => {
    // 실제 권한 확인 로직 구현 가능
    return true;
  }, []);

  // 오류 다이얼로그 렌더링
  const renderErrorDialog = useCallback((): React.ReactElement => (
    <Dialog
      open={errorDialogOpen}
      onClose={handleErrorDialogClose}
      aria-labelledby="error-dialog-title"
      aria-describedby="error-dialog-description"
    >
      <DialogTitle id="error-dialog-title">오류 발생</DialogTitle>
      <DialogContent>
        <DialogContentText id="error-dialog-description">
          {error || '데이터 처리 중 오류가 발생했습니다.'}
        </DialogContentText>
        <Typography variant="body2" color="text.secondary" mt={2}>
          문제가 지속되면 관리자에게 문의하세요.
        </Typography>
      </DialogContent>
      <DialogActions>
        {queryError && (
          <Button
            onClick={() => {
              handleErrorDialogClose();
              handleRefresh();
            }}
            color="primary"
          >
            다시 시도
          </Button>
        )}
        <Button onClick={handleErrorDialogClose} color="secondary">
          닫기
        </Button>
      </DialogActions>
    </Dialog>
  ), [errorDialogOpen, handleErrorDialogClose, error, queryError, handleRefresh]);

  // 대화상자 닫기 핸들러
  const handleClose = useCallback(() => {
    snackbarShown.current = false;
    
    // 컴포넌트 닫힐 때 구독 정보 즉시 저장
    try {
      if (socketServiceRef && typeof socketServiceRef.updateSubscription === 'function') {
        // 현재 구독 상태를 중앙 저장소에 반영
        socketServiceRef.updateSubscription(propsCveId, isSubscribedRef.current);
        logger.info('CVEDetail', '컴포넌트 닫힘 - 구독 정보 저장 완료', { 
          cveId: propsCveId, 
          isSubscribed: isSubscribedRef.current 
        });
      } else {
        // 소켓 서비스를 찾을 수 없는 경우 로컬에 직접 저장
        const key = 'cvehub_subscribed_cves';
        const savedCVEs = localStorage.getItem(key);
        let cveList: string[] = [];
        
        if (savedCVEs) {
          try {
            cveList = JSON.parse(savedCVEs);
          } catch (e) {
            logger.error('CVEDetail', '저장된 구독 정보 파싱 실패', e);
            cveList = [];
          }
        }
        
        // 구독 여부에 따라 리스트 업데이트
        if (isSubscribedRef.current) {
          // 이미 리스트에 없는 경우에만 추가
          if (!cveList.includes(propsCveId)) {
            cveList.push(propsCveId);
          }
        } else {
          // 리스트에서 제거
          cveList = cveList.filter(id => id !== propsCveId);
        }
        
        // 업데이트된 리스트 저장
        localStorage.setItem(key, JSON.stringify(cveList));
        logger.info('CVEDetail', '로컬 구독 정보 직접 업데이트', { 
          cveId: propsCveId, 
          isSubscribed: isSubscribedRef.current 
        });
      }
    } catch (error) {
      logger.error('CVEDetail', '구독 정보 저장 중 오류 발생', error);
    }
    
    // 원래 onClose 콜백 호출
    if (typeof onClose === 'function') {
      onClose();
    }
  }, [propsCveId, onClose, socketServiceRef, isSubscribedRef]);

  // --- useEffects ---
  // CVE 업데이트 이벤트 구독
  useEffect(() => {
    if (!propsCveId || !open || !socketRef.current) return;
    
    const eventName = `cve_updated_${propsCveId}`;
    
    // 이벤트 리스너 등록
    socketRef.current.on(eventName, handleCVEUpdated);
    
    logger.debug('CVEDetail: 소켓 이벤트 리스너 등록', { event: eventName });
    
    return () => {
      if (socketRef.current) {
        socketRef.current.off(eventName, handleCVEUpdated);
        logger.debug('CVEDetail: 소켓 이벤트 리스너 제거', { event: eventName });
      }
    };
  }, [propsCveId, open, handleCVEUpdated]);

  // CVEDetail.tsx에서 구독 관리 로직 수정
  useEffect(() => {
    // 모달이 열려 있고, CVE ID가 있을 때만 실행
    if (!propsCveId || !open) {
      return;
    }
    
    // 이미 구독 상태면 중복 요청 방지
    if (isSubscribedRef.current) {
      logger.debug('CVEDetail: 이미 구독 중, 중복 요청 방지', { cveId: propsCveId });
      return;
    }
    
    // 아직 구독 시도를 하지 않았고 연결된 상태에서만 구독
    if (!hasAttemptedSubscriptionRef.current && connected && socketRef.current) {
      logger.info('CVEDetail: 구독 시작', { cveId: propsCveId });
      hasAttemptedSubscriptionRef.current = true;
      
      // 확실한 타이밍을 위해 약간 지연 (선택적)
      setTimeout(() => {
        subscribe();
      }, 100);
    }
    
    // 모달 또는 컴포넌트가 닫힐 때만 구독 해제 (중요)
    return () => {
      // 모달이 닫히거나 컴포넌트가 언마운트될 때만 구독 해제
      if (isSubscribedRef.current) {
        logger.info('CVEDetail: 모달 닫힘 또는 언마운트, 구독 해제', { cveId: propsCveId });
        unsubscribe();
      }
    };
  }, [propsCveId, open, connected, subscribe, unsubscribe]);

  // 연결 상태 변경 처리 (분리된 useEffect)
  useEffect(() => {
    // 연결 상태가 변경되고 모달이 열려있는 상태에서만 처리
    if (!propsCveId || !open) return;
    
    if (connected) {
      // 연결됐지만 아직 구독되지 않은 경우에만 구독 시도
      if (hasAttemptedSubscriptionRef.current && !isSubscribedRef.current) {
        logger.info('CVEDetail: 연결 복구, 구독 재시도', { cveId: propsCveId });
        subscribe();
      }
    }
  }, [connected, propsCveId, open, subscribe]);

  // 렌더링 로직
  if (!open) return null;
  
  if (isQueryLoading && !cveData) {
    return (
      <Dialog open={open} fullWidth maxWidth="md" onClose={handleClose}>
        <DialogContent
          sx={{
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            p: 5,
            height: '200px',
          }}
        >
          <CircularProgress />
        </DialogContent>
      </Dialog>
    );
  }
  
  if (queryError && !cveData) {
    return (
      <Dialog open={open} onClose={handleClose} fullWidth maxWidth="sm">
        <DialogTitle>오류</DialogTitle>
        <DialogContent>
          <Typography color="error" gutterBottom>
            데이터를 불러오는 데 실패했습니다.
          </Typography>
          <Typography variant="body2" sx={{ mt: 1 }}>
            {queryError.message || '알 수 없는 오류'}
          </Typography>
        </DialogContent>
        <DialogActions>
          {queryError && (
            <Button
              onClick={() => {
                handleErrorDialogClose();
                handleRefresh();
              }}
              color="primary"
            >
              다시 시도
            </Button>
          )}
          <Button onClick={handleClose}>닫기</Button>
        </DialogActions>
      </Dialog>
    );
  }
  
  if (!cveData) {
    logger.warn('CVEDetail: cveData가 없습니다 (로딩/에러 아님). 렌더링 중단.');
    return (
      <Dialog open={open} onClose={handleClose} fullWidth maxWidth="sm">
        <DialogTitle>정보 없음</DialogTitle>
        <DialogContent>
          <Typography>해당 CVE 정보를 찾을 수 없습니다.</Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>닫기</Button>
        </DialogActions>
      </Dialog>
    );
  }

  return (
    <Dialog
      open={open}
      onClose={handleClose}
      maxWidth="lg"
      fullWidth
      TransitionComponent={Fade}
      PaperProps={{
        sx: {
          borderRadius: 3,
          height: '90vh',
          maxHeight: '90vh',
          overflow: 'hidden',
          zIndex: 1500,
        },
      }}
      aria-labelledby="cve-detail-dialog-title"
    >
      <DialogTitle sx={{ p: 2, flexShrink: 0 }} id="cve-detail-dialog-title">
        <CVEDetailHeader
          cveId={cveData.cveId}
          subscribers={subscribers}
          createdAt={(cveData.createdAt || cveData.created_at) as string | Date}
          lastModifiedAt={(cveData.lastModifiedAt || cveData.last_modified_at) as string | Date}
          isCached={isCached}
          isLoading={loading}
          onRefresh={handleRefresh}
          onClose={handleClose}
        />
      </DialogTitle>
      <DialogContent
        sx={{
          p: 0,
          flexGrow: 1,
          overflow: 'hidden',
          display: 'flex',
        }}
      >
        <Card
          elevation={0}
          sx={{
            height: '100%',
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
          }}
        >
          <CardContent
            sx={{
              p: 0,
              flexGrow: 1,
              display: 'flex',
              flexDirection: 'column',
              overflow: 'hidden',
            }}
          >
            <Box
              sx={{
                p: 2,
                flexShrink: 0,
                borderBottom: 1,
                borderColor: 'divider',
              }}
            >
              <CVEDetailInfoPanel
                cveData={cveData}
                onUpdateField={handleFieldUpdate}
                canEdit={canEdit()}
              />
            </Box>
            <CVEDetailTabs
              cveData={cveData}
              currentUser={currentUser}
              refreshTriggers={refreshTriggers}
              tabCounts={tabCounts}
              onCountChange={handleTabCountChange}
              parentSendMessage={sendMessage}
              highlightCommentId={highlightCommentId}
            />
            {(isCached || cveData.fromCache) && (
              <Box
                sx={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 1,
                  p: 1,
                  borderTop: 1,
                  borderColor: 'divider',
                  flexShrink: 0,
                  bgcolor: 'action.hover',
                }}
              >
                <Chip
                  size="small"
                  label="캐시된 데이터"
                  color="info"
                  variant="outlined"
                  sx={{ fontWeight: 500 }}
                />
                {(cveData._cachedAt || cveData.cachedAt) && (
                  <Typography variant="caption" color="text.secondary">
                    서버와 {timeAgo((cveData._cachedAt || cveData.cachedAt) as string | number)} 전에 동기화됨
                  </Typography>
                )}
              </Box>
            )}
          </CardContent>
        </Card>
      </DialogContent>
      {renderErrorDialog()}
    </Dialog>
  );
};

export default CVEDetail;


============================================================
File: /home/CVEHub/frontend/src/features/cve/CVEList.jsx
------------------------------------------------------------
// frontend/src/features/cve/CVEList.jsx

import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  Chip,
  Tooltip,
  IconButton,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  TextField,
  CircularProgress,
  Skeleton,
  Grid,
  Card,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  InputAdornment,
  useTheme,
  alpha
} from '@mui/material';
import { TIME_ZONES, DATE_FORMATS, formatDateTime } from 'shared/utils/dateUtils';
import SearchIcon from '@mui/icons-material/Search';
import DeleteIcon from '@mui/icons-material/Delete';
import RefreshIcon from '@mui/icons-material/Refresh';
import AddIcon from '@mui/icons-material/Add';
import SearchOffIcon from '@mui/icons-material/SearchOff';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { useQueryClient } from '@tanstack/react-query'; 
import { useSocket } from 'core/socket/hooks/useSocket';
import { QUERY_KEYS } from 'shared/api/queryKeys';

// 기존 import 대신 새로운 통합 서비스 사용
import {
  useDeleteCVE,
  useCreateCVE
} from 'features/cve/hooks/useCVEMutation';

import CVEDetail from './CVEDetail';
import CrawlerUpdateButton from './components/CrawlerUpdateButton';
import CreateCVE from './CreateCVE';
import { useSnackbar } from 'notistack';
import { useCVEDetail, useCVEList, useCVEListUpdates, useCVEStats } from './hooks';

// 기본 폰트 스타일
const fontStyles = {
  fontFamily: "'Noto Sans KR', sans-serif",
  letterSpacing: '0.5px'
};

// 공통 스타일 상수 - 카드 기본 스타일
const cardBaseStyle = {
  p: 2,
  borderRadius: '8px',
  boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
  textAlign: 'center',
  transition: 'all 0.3s ease',
};

// 공통 스타일 상수 - 호버 효과
const cardHoverStyle = {
  transform: 'translateY(-5px)',
  boxShadow: '0 8px 24px rgba(0,0,0,0.15)',
};

// 공통 스타일 상수 - 필터 컴포넌트 기본 스타일
const filterBaseStyle = {
  borderRadius: '30px',
  backgroundColor: 'white',
  transition: 'all 0.2s ease',
};

// 공통 스타일 상수 - 테이블 셀 기본 스타일
const tableCellBaseStyle = {
  p: '12px 20px',
  ...fontStyles
};

// 심각도별 스타일 (HTML 디자인과 유사하게 수정)
const getSeverityStyles = (severity) => {
  // 대소문자 구분 없이 비교하기 위해 소문자로 변환하고 매핑
  const severityLower = severity ? severity.toLowerCase() : '';
  
  const styles = {
    'critical': { bg: 'rgba(255, 7, 58, 0.15)', color: '#ff073a' },
    'high':     { bg: 'rgba(255, 84, 0, 0.15)', color: '#ff5400' },
    'medium':   { bg: 'rgba(255, 190, 11, 0.15)', color: '#e5a800' },
    'low':      { bg: 'rgba(56, 176, 0, 0.15)', color: '#38b000' },
    'none':     { bg: 'rgba(108, 117, 125, 0.15)', color: '#6c757d' }
  };
  
  return styles[severityLower] || styles['none'];
};

// 상태별 스타일 (HTML 디자인에 맞춤)
const getStatusStyles = (status) => {
  const styles = {
    '신규등록':  { bg: 'rgba(58, 134, 255, 0.15)', color: '#3a86ff' },
    '분석중':   { bg: 'rgba(131, 56, 236, 0.15)', color: '#8338ec' },
    '릴리즈 완료': { bg: 'rgba(56, 176, 0, 0.15)', color: '#38b000' },
    '분석불가': { bg: 'rgba(244, 67, 54, 0.15)', color: '#f44336' }
  };
  return styles[status] || { bg: 'rgba(108, 117, 125, 0.15)', color: '#6c757d' };
};

// 심각도별 색상 설정 함수
const getSeverityColor = (severity, theme) => {
  // 대소문자 구분 없이 비교하기 위해 소문자로 변환
  const severityLower = severity ? severity.toLowerCase() : '';
  
  switch (severityLower) {
    case 'critical':
      return theme.palette.error.main;
    case 'high':
      return theme.palette.secondary.main;
    case 'medium':
      return theme.palette.warning.main;
    case 'low':
      return theme.palette.info.main;
    default:
      return theme.palette.text.secondary;
  }
};

// 상태별 색상 설정 함수
const getStatusColor = (status, theme) => {
  switch (status) {
    case '신규등록':
      return theme.palette.info.main;
    case '분석중':
      return theme.palette.warning.main;
    case '릴리즈 완료':
      return theme.palette.success.main;
    case '분석불가':
      return theme.palette.error.main;
    default:
      return theme.palette.text.secondary;
  }
};

const CVECardSkeleton = () => (
  <Card elevation={0} variant="outlined" sx={{ height: '100%' }}>
    <Skeleton animation="wave" height={30} />
  </Card>
);

const CVEDetailWrapper = ({ cveId, open, onClose }) => {
  const { data: cve, isLoading, isError, error, refetch } = useCVEDetail(cveId, {
    enabled: !!cveId && open,
    refetchOnWindowFocus: false
  });

  useEffect(() => {
    if (error) console.error('CVE 세부 정보 조회 중 오류:', error);
  }, [error]);

  if (!cveId || !open) return null;

  if (isLoading) {
    return (
      <Dialog open={open} onClose={onClose} maxWidth="md" fullWidth>
        <DialogTitle>CVE 세부 정보 로드 중...</DialogTitle>
        <DialogContent>
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
            <CircularProgress />
          </Box>
        </DialogContent>
      </Dialog>
    );
  }

  if (isError) {
    return (
      <Dialog open={open} onClose={onClose}>
        <DialogTitle>오류 발생</DialogTitle>
        <DialogContent>
          <Typography color="error">데이터 로딩 중 오류가 발생했습니다.</Typography>
          <Button onClick={refetch}>다시 시도</Button>
        </DialogContent>
        <DialogActions>
          <Button onClick={onClose}>닫기</Button>
        </DialogActions>
      </Dialog>
    );
  }

  return <CVEDetail cveId={cveId} open={open} onClose={onClose} />;
};

const StatisticsSection = React.memo(({ statsData, totalCount, theme }) => {
  return (
    <Grid container spacing={2} sx={{ mb: 3 }}>
      <Grid item xs={12} sm={6} md={3}>
        <Card
          elevation={0}
          sx={{
            ...cardBaseStyle,
            '&:hover': cardHoverStyle,
            background: `linear-gradient(135deg, ${alpha(theme.palette.primary.main, 0.05)} 0%, ${alpha(theme.palette.primary.main, 0.1)} 100%)`
          }}
        >
          <Typography variant="caption" sx={{ textTransform: 'uppercase', color: theme.palette.text.secondary }}>
            전체 CVE
          </Typography>
          <Typography variant="h4" sx={{ fontWeight: 'bold', color: theme.palette.primary.main, my: 1 }}>
            {totalCount}
          </Typography>
          <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>등록된 취약점</Typography>
        </Card>
      </Grid>
      <Grid item xs={12} sm={6} md={3}>
        <Card
          elevation={0}
          sx={{
            ...cardBaseStyle,
            '&:hover': cardHoverStyle,
            background: `linear-gradient(135deg, ${alpha(theme.palette.secondary.main, 0.05)} 0%, ${alpha(theme.palette.secondary.main, 0.1)} 100%)`
          }}
        >
          <Typography variant="caption" sx={{ textTransform: 'uppercase', color: theme.palette.text.secondary }}>
            위험도 높음
          </Typography>
          <Typography variant="h4" sx={{ fontWeight: 'bold', color: theme.palette.secondary.main, my: 1 }}>
            {statsData.highSeverityCount || 0}
          </Typography>
          <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>심각한 취약점</Typography>
        </Card>
      </Grid>
      <Grid item xs={12} sm={6} md={3}>
        <Card
          elevation={0}
          sx={{
            ...cardBaseStyle,
            '&:hover': cardHoverStyle,
            background: `linear-gradient(135deg, ${alpha(theme.palette.info.main, 0.05)} 0%, ${alpha(theme.palette.info.main, 0.1)} 100%)`
          }}
        >
          <Typography variant="caption" sx={{ textTransform: 'uppercase', color: theme.palette.text.secondary }}>
            최근 7일
          </Typography>
          <Typography variant="h4" sx={{ fontWeight: 'bold', color: theme.palette.info.main, my: 1 }}>
            {statsData.newLastWeekCount || 0}
          </Typography>
          <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>신규 등록</Typography>
        </Card>
      </Grid>
      <Grid item xs={12} sm={6} md={3}>
        <Card
          elevation={0}
          sx={{
            ...cardBaseStyle,
            '&:hover': cardHoverStyle,
            background: `linear-gradient(135deg, ${alpha(theme.palette.success.main, 0.05)} 0%, ${alpha(theme.palette.success.main, 0.1)} 100%)`
          }}
        >
          <Typography variant="caption" sx={{ textTransform: 'uppercase', color: theme.palette.text.secondary }}>
            완료됨
          </Typography>
          <Typography variant="h4" sx={{ fontWeight: 'bold', color: theme.palette.success.main, my: 1 }}>
            {statsData.completedCount}
          </Typography>
          <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>분석 완료</Typography>
        </Card>
      </Grid>
    </Grid>
  );
});

const FilterBar = React.memo(({ 
  searchInput, 
  statusFilter, 
  severityFilter, 
  sortOption, 
  handleSearchChange, 
  handleStatusFilterChange, 
  handleSeverityFilterChange, 
  handleSortOptionChange, 
  handleRefresh,
  theme
}) => {
  return (
    <Box
      sx={{
        backgroundColor: theme.palette.background.paper,
        p: 2.5,
        borderRadius: '8px',
        boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
        mb: 3,
        display: 'flex',
        flexWrap: 'wrap',
        gap: 2,
        alignItems: 'center',
        transition: 'all 0.3s ease',
        '&:hover': {
          boxShadow: '0 6px 20px rgba(0,0,0,0.15)'
        }
      }}
    >
      <Box sx={{ flex: 1, position: 'relative', minWidth: 300 }}>
        <SearchIcon
          sx={{
            position: 'absolute',
            left: 15,
            top: '50%',
            transform: 'translateY(-50%)',
            color: theme.palette.text.secondary
          }}
        />
        <TextField
          placeholder="CVE ID, 키워드 또는 제목으로 검색"
          size="small"
          value={searchInput}
          onChange={handleSearchChange}
          fullWidth
          sx={{
            '& .MuiOutlinedInput-root': {
              borderRadius: '30px',
              pl: '45px',
              backgroundColor: 'white',
              transition: 'all 0.2s ease',
              '& fieldset': { borderColor: '#e0e0e0' },
              '&:hover fieldset': { borderColor: theme.palette.primary.main },
              '&.Mui-focused': {
                boxShadow: `0 0 0 2px ${alpha(theme.palette.primary.main, 0.2)}`
              }
            }
          }}
        />
      </Box>
      <FormControl size="small" sx={{ minWidth: 150 }}>
        <InputLabel sx={fontStyles}>상태별 필터</InputLabel>
        <Select
          value={statusFilter}
          label="상태별 필터"
          onChange={handleStatusFilterChange}
          sx={{
            ...filterBaseStyle,
            '&:hover': {
              boxShadow: `0 0 0 2px ${alpha(theme.palette.primary.main, 0.2)}`
            }
          }}
        >
          <MenuItem value="">전체</MenuItem>
          <MenuItem value="신규등록">신규등록</MenuItem>
          <MenuItem value="분석중">분석중</MenuItem>
          <MenuItem value="릴리즈 완료">릴리즈 완료</MenuItem>
          <MenuItem value="분석불가">분석불가</MenuItem>
        </Select>
      </FormControl>
      <FormControl size="small" sx={{ minWidth: 150 }}>
        <InputLabel sx={fontStyles}>심각도별 필터</InputLabel>
        <Select
          value={severityFilter}
          label="심각도별 필터"
          onChange={handleSeverityFilterChange}
          sx={{
            ...filterBaseStyle,
            '&:hover': {
              boxShadow: `0 0 0 2px ${alpha(theme.palette.primary.main, 0.2)}`
            }
          }}
        >
          <MenuItem value="">전체</MenuItem>
          <MenuItem value="CRITICAL">심각</MenuItem>
          <MenuItem value="HIGH">높음</MenuItem>
          <MenuItem value="MEDIUM">중간</MenuItem>
          <MenuItem value="LOW">낮음</MenuItem>
        </Select>
      </FormControl>
      <FormControl size="small" sx={{ minWidth: 150 }}>
        <InputLabel sx={fontStyles}>정렬 기준</InputLabel>
        <Select
          value={sortOption}
          label="정렬 기준"
          onChange={handleSortOptionChange}
          sx={{
            ...filterBaseStyle,
            '&:hover': {
              boxShadow: `0 0 0 2px ${alpha(theme.palette.primary.main, 0.2)}`
            }
          }}
        >
          <MenuItem value="newest">최신순</MenuItem>
          <MenuItem value="severity">심각도순</MenuItem>
          <MenuItem value="status">상태순</MenuItem>
        </Select>
      </FormControl>
      <Tooltip title="새로고침">
        <IconButton 
          onClick={handleRefresh}
          sx={{
            transition: 'all 0.2s ease',
            '&:hover': {
              backgroundColor: alpha(theme.palette.primary.main, 0.1),
              transform: 'rotate(180deg)'
            }
          }}
        >
          <RefreshIcon />
        </IconButton>
      </Tooltip>
    </Box>
  );
});

const TableSkeletonRow = React.memo(() => (
  <TableRow>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
  </TableRow>
));

const NoDataRow = ({ colSpan, searchQuery, onResetSearch, theme }) => (
  <TableRow>
    <TableCell
      colSpan={colSpan}
      sx={{ ...tableCellBaseStyle, textAlign: 'center', py: 4 }}
    >
      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', py: 2 }}>
        <SearchOffIcon sx={{ fontSize: 48, color: theme.palette.text.secondary, mb: 1 }} />
        <Typography variant="body1" sx={{ color: theme.palette.text.secondary }}>
          검색 결과가 없습니다
        </Typography>
        {searchQuery && (
          <>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
              검색어: "{searchQuery}"
            </Typography>
            <Button
              onClick={onResetSearch}
              variant="outlined"
              size="small"
              sx={{ mt: 2 }}
            >
              검색 초기화
            </Button>
          </>
        )}
      </Box>
    </TableCell>
  </TableRow>
);

const CVETable = React.memo(({ 
  cves, 
  isLoading, 
  page, 
  totalCount, 
  rowsPerPage, 
  onPageChange, 
  onRowsPerPageChange, 
  onCVEClick,
  theme,
  sortOption,
  searchQuery,
  onResetSearch,
  onDeleteClick
}) => {
  return (
    <Paper
      elevation={0}
      sx={{
        width: '100%',
        borderRadius: '8px',
        overflow: 'hidden',
        boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
        mb: 4,
        transition: 'box-shadow 0.3s ease',
        '&:hover': {
          boxShadow: '0 6px 20px rgba(0,0,0,0.15)'
        }
      }}
    >
      <TableContainer sx={{ maxHeight: '60vh' }}>
        <Table stickyHeader sx={{ minWidth: 900 }}>
          <TableHead>
            <TableRow>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>CVE ID</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>제목</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>심각도</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>상태</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>등록일</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>최종 수정일</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>액션</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {isLoading ? (
              // 로딩 중일 때 스켈레톤 UI 표시
              Array.from(new Array(5)).map((_, index) => (
                <TableSkeletonRow key={`skeleton-${index}`} />
              ))
            ) : cves && cves.length > 0 ? (
              cves.map((cve, index) => {
                console.log(`CVE 항목 렌더링 시작 [${index}]:`, {
                  cveId: cve.cveId,
                  title: cve.title,
                  status: cve.status,
                  severity: cve.severity
                });
                
                try {
                  return (
                    <TableRow
                      key={cve.cveId || `cve-${index}`}
                      onClick={() => onCVEClick(cve)}
                      sx={{
                        cursor: 'pointer',
                        transition: 'background-color 0.2s',
                        '&:hover': {
                          backgroundColor: alpha(theme.palette.primary.main, 0.04)
                        }
                      }}
                    >
                      <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'medium', color: theme.palette.primary.main }}>
                        {cve.cveId || '-'}
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        <Tooltip title={cve.title || ''} placement="top">
                          <Typography
                            variant="body2"
                            sx={{
                              maxWidth: 400,
                              overflow: 'hidden',
                              textOverflow: 'ellipsis',
                              whiteSpace: 'nowrap'
                            }}
                          >
                            {cve.title || '-'}
                          </Typography>
                        </Tooltip>
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        <Chip
                          label={cve.severity ? cve.severity.toUpperCase() : '미정'}
                          size="small"
                          sx={{
                            backgroundColor: alpha(getSeverityColor(cve.severity, theme), 0.1),
                            color: getSeverityColor(cve.severity, theme),
                            fontWeight: 'medium',
                            borderRadius: '4px'
                          }}
                        />
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        <Chip
                          label={cve.status || '미정'}
                          size="small"
                          sx={{
                            backgroundColor: alpha(getStatusColor(cve.status, theme), 0.1),
                            color: getStatusColor(cve.status, theme),
                            fontWeight: 'medium',
                            borderRadius: '4px'
                          }}
                        />
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        {formatDateTime(cve.createdAt || cve.created_at, DATE_FORMATS.DISPLAY.DEFAULT)}
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        {formatDateTime(cve.lastModifiedAt || cve.last_modified_at, DATE_FORMATS.DISPLAY.DEFAULT)}
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        <Box sx={{ display: 'flex', gap: 1 }}>
                          <Tooltip title="삭제">
                            <IconButton
                              size="small"
                              color="error"
                              onClick={(e) => onDeleteClick(e, cve)}
                              sx={{
                                '&:hover': {
                                  backgroundColor: alpha(theme.palette.error.main, 0.1),
                                }
                              }}
                            >
                              <DeleteIcon fontSize="small" />
                            </IconButton>
                          </Tooltip>
                        </Box>
                      </TableCell>
                    </TableRow>
                  );
                } catch (error) {
                  console.error(`CVE 항목 렌더링 중 오류 [${index}]:`, error);
                  return (
                    <TableRow key={`error-${index}`}>
                      <TableCell colSpan={7} sx={{ ...tableCellBaseStyle, textAlign: 'center', py: 4 }}>
                        <Typography variant="body2" color="error">오류가 발생했습니다.</Typography>
                      </TableCell>
                    </TableRow>
                  );
                }
              })
            ) : (
              <NoDataRow 
                colSpan={7} 
                searchQuery={searchQuery} 
                onResetSearch={onResetSearch}
                theme={theme}
              />
            )}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[1, 5, 10, 25]}
        component="div"
        count={totalCount} 
        rowsPerPage={rowsPerPage}
        page={page - 1}
        onPageChange={onPageChange}
        onRowsPerPageChange={onRowsPerPageChange}
        labelRowsPerPage="페이지당 행 수"
        labelDisplayedRows={({ from, to, count }) => {
          // 검색 결과가 없는 경우
          if (count === 0) return '검색 결과 없음';
          // 일반적인 경우
          return `${from}-${to} / 총 ${count !== -1 ? count : '?'}개${searchQuery ? ' (검색 결과)' : ''}`;
        }}
        sx={{
          borderTop: `1px solid ${theme.palette.divider}`,
          '& .MuiToolbar-root': {
            ...fontStyles,
            height: 56
          }
        }}
      />
    </Paper>
  );
});

// 테이블 로딩 상태를 위한 스켈레톤 UI
const CVETableSkeleton = () => {
  const theme = useTheme();
  
  return (
    <Paper
      elevation={0}
      sx={{
        width: '100%',
        borderRadius: '8px',
        overflow: 'hidden',
        boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
        mb: 4
      }}
    >
      <TableContainer>
        <Table sx={{ minWidth: 900 }}>
          <TableHead>
            <TableRow>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>CVE ID</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>제목</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>심각도</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>상태</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>등록일</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>최종 수정일</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>액션</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {Array.from(new Array(5)).map((_, index) => (
              <TableRow key={`skeleton-${index}`}>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Paper>
  );
};

// 에러 표시 컴포넌트
const ErrorDisplay = ({ error, onRetry }) => {
  const theme = useTheme();
  
  return (
    <Paper
      elevation={0}
      sx={{
        p: 3,
        borderRadius: '8px',
        textAlign: 'center',
        boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
        mb: 4
      }}
    >
      <Typography variant="h6" color="error" sx={{ mb: 2 }}>
        데이터를 불러오는 중 오류가 발생했습니다
      </Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        {error?.message || '알 수 없는 오류가 발생했습니다. 다시 시도해주세요.'}
      </Typography>
      <Button
        variant="contained"
        color="primary"
        onClick={onRetry}
        startIcon={<RefreshIcon />}
        sx={{
          borderRadius: '20px',
          boxShadow: 'none',
          '&:hover': { boxShadow: 'none' }
        }}
      >
        다시 시도
      </Button>
    </Paper>
  );
};

// 빈 상태 표시 컴포넌트
const EmptyStateDisplay = ({ searchQuery, onResetSearch, isFiltered }) => {
  const theme = useTheme();
  
  return (
    <Paper
      elevation={0}
      sx={{
        p: 4,
        borderRadius: '8px',
        textAlign: 'center',
        boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
        mb: 4,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      <SearchOffIcon sx={{ fontSize: 64, color: theme.palette.text.secondary, mb: 2 }} />
      
      <Typography variant="h6" sx={{ mb: 1 }}>
        {searchQuery ? '검색 결과가 없습니다' : '등록된 CVE가 없습니다'}
      </Typography>
      
      {isFiltered ? (
        <>
          <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
            {searchQuery ? `"${searchQuery}"에 대한 검색 결과가 없습니다.` : '현재 필터 조건에 맞는 CVE가 없습니다.'}
          </Typography>
          <Button
            variant="outlined"
            color="primary"
            onClick={onResetSearch}
            sx={{
              borderRadius: '20px',
              mt: 1
            }}
          >
            필터 초기화
          </Button>
        </>
      ) : (
        <Typography variant="body2" color="text.secondary">
          새로운 CVE를 등록해 보세요.
        </Typography>
      )}
    </Paper>
  );
};

const CVEList = () => {
  const theme = useTheme();
  const navigate = useNavigate();
  const { currentUser: user } = useAuth();
  const { enqueueSnackbar } = useSnackbar();
  const { emit } = useSocket();
  const queryClient = useQueryClient(); 

  // 실시간 업데이트 구독
  useCVEListUpdates(queryClient);

  // 전체 CVE 개수 조회 (주석 처리 - 테이블의 totalCount로 대체)
  // const { data: totalCVECount = 0, isLoading: isTotalCountLoading } = useTotalCVECount();

  // 통계 데이터를 가져오는 쿼리
  const { data: backendStats, isLoading: isLoadingStats } = useCVEStats();
  
  // 필터 상태 (상태, 심각도, 정렬 옵션)
  const [page, setPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(1); // 테스트를 위해 1로 변경
  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState('');
  const [severityFilter, setSeverityFilter] = useState('');
  const [sortOption, setSortOption] = useState('newest');
  
  // 다이얼로그 및 검색 관련 상태
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [cveToDelete, setCveToDelete] = useState(null);
  const [searchInput, setSearchInput] = useState('');
  const [selectedCVE, setSelectedCVE] = useState(null);
  const [detailOpen, setDetailOpen] = useState(false);
  
  // 검색 디바운스 ref
  const searchTimeoutRef = useRef(null);

  // 상단 액션 버튼 렌더링 (새 CVE 생성, 크롤러 업데이트)
  const renderActionButtons = () => (
    <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3, flexWrap: 'wrap', gap: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
        <Button
          variant="contained"
          color="primary"
          startIcon={<AddIcon />}
          onClick={() => setCreateDialogOpen(true)}
          sx={{
            ...fontStyles,
            borderRadius: '20px',
            fontWeight: 500,
            boxShadow: '0 4px 12px rgba(58, 134, 255, 0.2)',
            background: 'linear-gradient(135deg, #3a86ff, #8338ec)',
            '&:hover': {
              background: 'linear-gradient(135deg, #2a76ef, #7328dc)',
              boxShadow: '0 6px 16px rgba(58, 134, 255, 0.3)'
            }
          }}
        >
          새 CVE 생성
        </Button>
        <CrawlerUpdateButton />
      </Box>
    </Box>
  );

  // React Query: CVE 목록 가져오기 (필터와 정렬 옵션 반영)
  const { 
    data: queryData, 
    isLoading, 
    isError, 
    error: queryError, 
    refetch: refetchCVEList 
  } = useCVEList({ 
    page, 
    rowsPerPage, 
    search: searchQuery,
    status: statusFilter,
    severity: severityFilter,
    sortBy: sortOption === 'newest' ? 'createdAt' : sortOption === 'severity' ? 'severity' : 'status',
    sortOrder: sortOption === 'newest' ? 'desc' : (sortOption === 'severity' ? 'desc' : 'asc')
  });
  
  // 쿼리 실행 후 로깅 추가
  useEffect(() => {
    console.log('쿼리 매개변수:', {
      page,
      rowsPerPage,
      필터: { 상태: statusFilter, 심각도: severityFilter, 검색어: searchQuery },
      정렬: sortOption
    });
    console.log('쿼리 결과:', queryData?.items?.length, '아이템 중', queryData?.total || queryData?.totalItems, '총 아이템');
    
    // 백엔드 검색 API에 전달되는 실제 파라미터 구조 출력 (백엔드 /cves/list 엔드포인트에 맞춤)
    console.log('백엔드로 전송되는 검색 파라미터:', { 
      search: searchQuery,
      page: page,
      limit: rowsPerPage,
      status: statusFilter,
      severity: severityFilter,
      sort_by: sortOption === 'newest' ? 'createdAt' : sortOption === 'severity' ? 'severity' : 'status',
      sort_order: sortOption === 'newest' ? 'desc' : (sortOption === 'severity' ? 'desc' : 'asc')
    });
    
    // 첫 번째 아이템 디버깅 로깅
    if (queryData?.items && queryData.items.length > 0) {
      console.log('첫 번째 CVE 아이템 데이터:', queryData.items[0]);
      console.log('필드 확인:', {
        id: queryData.items[0].id,
        cveId: queryData.items[0].cveId,
        title: queryData.items[0].title,
        status: queryData.items[0].status,
        severity: queryData.items[0].severity,
        createdAt: queryData.items[0].createdAt,
        lastModifiedAt: queryData.items[0].lastModifiedAt
      });
    }
  }, [queryData, page, rowsPerPage, statusFilter, severityFilter, searchQuery, sortOption]);
  
  const cves = useMemo(() => queryData?.items || [], [queryData]);
  const totalCount = useMemo(() => queryData?.total || queryData?.totalItems || 0, [queryData]);
  
  // 통계 데이터 (백엔드 API 결과와 로컬 데이터 결합)
  const statsData = useMemo(() => {
    // 백엔드 통계 데이터가 있으면 사용하되, totalCount는 항상 테이블 데이터와 동일하게 사용
    if (backendStats) {
      return {
        ...backendStats,
        totalCount  // 테이블 데이터와 동일한 totalCount 사용 (중요)
      };
    }
    
    // 백엔드 데이터가 없으면 현재 페이지 데이터로 계산 (임시 방법)
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    return {
      totalCount,  // 테이블 데이터와 동일한 totalCount 사용 (중요)
      newLastWeekCount: cves.filter(cve => new Date(cve.createdAt) >= oneWeekAgo).length,
      highSeverityCount: cves.filter(cve => 
        cve.severity?.toLowerCase() === 'critical' || 
        cve.severity?.toLowerCase() === 'high'
      ).length,
      inProgressCount: cves.filter(cve => cve.status === '분석중').length,
      completedCount: cves.filter(cve => cve.status === '릴리즈 완료').length
    };
  }, [cves, totalCount, backendStats]);

  // 개선된 검색 핸들러 - 디바운스 및 유효성 검사 강화
  const handleSearchChange = useCallback((e) => {
    // 현재 입력값 설정
    const inputValue = e.target.value;
    setSearchInput(inputValue);
    
    // 이전 타이머 클리어
    clearTimeout(searchTimeoutRef.current);
    
    // 검색어가 너무 짧으면 검색하지 않음 (공백만 있는 경우 제외)
    const trimmedValue = inputValue.trim();
    
    // 검색 입력값 디버깅
    console.log('검색 입력 값:', inputValue, '정제된 값:', trimmedValue, '길이:', trimmedValue.length);
    
    // 디바운스 처리 - 입력 후 300ms 후에 검색 실행
    searchTimeoutRef.current = setTimeout(() => {
      // 검색어가 비어있거나 공백만 있는 경우
      if (trimmedValue === '' && searchQuery !== '') {
        console.log('검색어 초기화');
        setSearchQuery('');
        setPage(1);
        
        // 검색 초기화 시 캐시 무효화
        queryClient.invalidateQueries({
          queryKey: [QUERY_KEYS.CVE.list],
          refetchType: 'active'
        });
      } 
      // 검색어가 1글자 이상인 경우
      else if (trimmedValue.length >= 1 && trimmedValue !== searchQuery) {
        console.log('검색 쿼리 설정:', trimmedValue);
        // 쿼리 캐시 무효화 후 새 검색 실행
        queryClient.invalidateQueries({
          queryKey: [QUERY_KEYS.CVE.list],
          refetchType: 'active'
        });
        setSearchQuery(trimmedValue);
        setPage(1); // 페이지 초기화
      }
    }, 300);
  }, [searchQuery, queryClient]);

  // 검색 리셋 핸들러 개선
  const handleResetSearch = useCallback(() => {
    console.log('검색 초기화');
    setSearchInput('');
    setSearchQuery('');
    
    // 검색 초기화 시 캐시 무효화
    queryClient.invalidateQueries({
      queryKey: [QUERY_KEYS.CVE.list],
      refetchType: 'active'
    });
    
    setPage(1);
  }, [queryClient]);

  // 필터 핸들러들
  const handleStatusFilterChange = useCallback((e) => {
    setStatusFilter(e.target.value);
    setPage(1);
  }, []);

  const handleSeverityFilterChange = useCallback((e) => {
    setSeverityFilter(e.target.value);
    setPage(1);
  }, []);

  const handleSortOptionChange = useCallback((e) => {
    setSortOption(e.target.value);
    setPage(1);
  }, []);

  // 페이지 변경 핸들러에 디바운싱 적용 (빠른 연속 클릭 방지)
  const pageChangeTimeoutRef = useRef(null);
  
  const handlePageChange = useCallback((event, newPage) => {
    // 이전 타임아웃이 있으면 취소
    if (pageChangeTimeoutRef.current) {
      clearTimeout(pageChangeTimeoutRef.current);
    }
    
    // 새로운 타임아웃 설정 (150ms 디바운스)
    pageChangeTimeoutRef.current = setTimeout(() => {
      setPage(newPage + 1);
      pageChangeTimeoutRef.current = null;
    }, 150);
  }, []);

  const handleRowsPerPageChange = useCallback((event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(1);
  }, []);

  const handleRefresh = useCallback(() => {
    refetchCVEList();
    enqueueSnackbar('데이터 새로고침 중...', { variant: 'info', autoHideDuration: 1000 });
  }, [refetchCVEList, enqueueSnackbar]);

  const handleCVEClick = useCallback((cve) => {
    setSelectedCVE(cve);
    setDetailOpen(true);
  }, []);

  const handleDetailClose = useCallback(() => {
    setDetailOpen(false);
    setSelectedCVE(null);
  }, []);

  const handleCreateCVE = useCallback(() => {
    setCreateDialogOpen(true);
  }, []);

  const handleCreateDialogClose = useCallback(() => {
    setCreateDialogOpen(false);
  }, []);

  // 새로운 훅 사용
  const deleteMutation = useDeleteCVE();
  const createMutation = useCreateCVE();

  const handleCreateSubmit = useCallback(async (cveData) => {
    try {
      await createMutation.mutateAsync(cveData);
      // 성공 메시지는 useCVEService 내부에서 처리됨
      handleCreateDialogClose();
    } catch (error) {
      // 에러 메시지는 useCVEService 내부에서 처리됨
      console.error('CVE 생성 중 오류:', error);
    }
  }, [createMutation, handleCreateDialogClose]);

  const handleCreateFormSubmit = (event) => {
    event.preventDefault();
    const formData = new FormData(event.target);
    const data = {
      cveId: formData.get('cveId'),
      title: formData.get('title'),
      description: formData.get('description'),
      status: formData.get('status') || '신규등록'
    };
    handleCreateSubmit(data);
  };

  const handleDeleteClick = useCallback((e, cve) => {
    e.stopPropagation();
    setCveToDelete(cve);
    setDeleteDialogOpen(true);
  }, []);

  const handleDeleteCancel = useCallback(() => {
    setDeleteDialogOpen(false);
    setCveToDelete(null);
  }, []);

  const handleDeleteConfirm = useCallback(async () => {
    if (!cveToDelete) return;
    try {
      const cveId = cveToDelete.cveId;
      await deleteMutation.mutateAsync(cveId);
      setDeleteDialogOpen(false);
      setCveToDelete(null);
      // 성공 메시지는 useCVEService 내부에서 처리됨
    } catch (error) {
      // 에러 메시지는 useCVEService 내부에서 처리됨
      console.error('CVE 삭제 중 오류:', error);
    }
  }, [cveToDelete, deleteMutation]);

  const handleCVECreated = useCallback((newCVEData) => {
    handleCreateDialogClose();
    refetchCVEList();
  }, [handleCreateDialogClose, refetchCVEList]);

  return (
    <Box sx={{ width: '100%', px: { sm: 2, md: 3 } }}>
      {/* 상단 액션 버튼 추가 */}
      {renderActionButtons()}
      
      <StatisticsSection 
        statsData={statsData} 
        totalCount={totalCount} 
        theme={theme} 
      />

      {/* 필터 섹션 */}
      <FilterBar 
        searchInput={searchInput}
        statusFilter={statusFilter}
        severityFilter={severityFilter}
        sortOption={sortOption}
        handleSearchChange={handleSearchChange}
        handleStatusFilterChange={handleStatusFilterChange}
        handleSeverityFilterChange={handleSeverityFilterChange}
        handleSortOptionChange={handleSortOptionChange}
        handleRefresh={handleRefresh}
        theme={theme}
      />

      {isLoading ? (
        <CVETableSkeleton />
      ) : isError ? (
        <ErrorDisplay error={queryError} onRetry={handleRefresh} />
      ) : (
        <>
          {cves.length === 0 ? (
            <EmptyStateDisplay 
              searchQuery={searchQuery} 
              onResetSearch={handleResetSearch}
              isFiltered={!!statusFilter || !!severityFilter || !!searchQuery}
            />
          ) : (
            <CVETable 
              cves={cves} 
              isLoading={isLoading} 
              page={page} 
              totalCount={totalCount}
              rowsPerPage={rowsPerPage}
              onPageChange={handlePageChange}
              onRowsPerPageChange={handleRowsPerPageChange}
              onCVEClick={handleCVEClick}
              theme={theme}
              sortOption={sortOption}
              searchQuery={searchQuery}
              onResetSearch={handleResetSearch}
              onDeleteClick={handleDeleteClick}
            />
          )}
        </>
      )}

      {/* 다이얼로그 컴포넌트들 */}
      <CreateCVE open={createDialogOpen} onSuccess={handleCVECreated} onClose={handleCreateDialogClose} />

      {/* 상세보기 모달 */}
      {selectedCVE && (
        <CVEDetailWrapper
          cveId={selectedCVE.cveId}
          open={detailOpen}
          onClose={handleDetailClose}
        />
      )}

      <Dialog open={deleteDialogOpen} onClose={handleDeleteCancel}>
        <DialogTitle sx={{ p: 2 }}>CVE 삭제 확인</DialogTitle>
        <DialogContent sx={{ px: 3, pt: 1, pb: 2 }}>
          <Typography sx={fontStyles}>
            '{cveToDelete?.cveId || ""}' 항목을 삭제하시겠습니까?
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
            이 작업은 되돌릴 수 없습니다.
          </Typography>
        </DialogContent>
        <DialogActions sx={{ px: 3, pb: 2 }}>
          <Button onClick={handleDeleteCancel} color="inherit">취소</Button>
          <Button
            onClick={handleDeleteConfirm}
            color="error"
            variant="contained"
            disabled={deleteMutation.isPending}
            startIcon={deleteMutation.isPending ? <CircularProgress size={20} color="inherit" /> : null}
            sx={{
              boxShadow: 'none',
              '&:hover': { boxShadow: 'none', backgroundColor: 'error.dark' }
            }}
          >
            삭제
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default CVEList;


============================================================
File: /home/CVEHub/frontend/src/features/cve/CVEDetailInfoPanel.tsx
------------------------------------------------------------
import React, { useState, useCallback, memo } from 'react';
import {
  Grid,
  Typography,
  Box,
  Paper,
  IconButton,
  SxProps,
  Theme,
} from '@mui/material';
import CircleIcon from '@mui/icons-material/Circle';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import InlineEditText from './components/InlineEditText';

// 타입 정의
interface StatusOption {
  label: string;
  description: string;
}

interface SeverityOption {
  value: string;
  label: string;
  color: string;
}

interface CVEData {
  title?: string;
  description?: string;
  status?: string;
  severity?: string;
  [key: string]: any; // 기타 필드를 위한 인덱스 시그니처
}

interface CVEDetailInfoPanelProps {
  cveData: CVEData;
  onUpdateField: (field: string, value: string) => void;
  canEdit: boolean;
}

// 상수 및 유틸리티 함수 (원래 CVEDetail에 있던 것들)
// 별도 파일(constants/cveConstants.ts, utils/cveUtils.ts)로 분리하는 것을 강력히 권장합니다.
const STATUS_OPTIONS: Record<string, StatusOption> = {
  '신규등록': { label: '신규등록', description: '새로 등록된 CVE' },
  '분석중': { label: '분석중', description: '보안 전문가가 분석 진행중' },
  '릴리즈 완료': { label: '릴리즈 완료', description: '분석이 완료되어 릴리즈됨' },
  '분석불가': { label: '분석불가', description: '분석이 불가능한 상태' }
};

const getStatusColor = (status: string): string => {
  switch (status) {
    case '분석중':      return '#2196f3';
    case '신규등록':    return '#ff9800';
    case '릴리즈 완료': return '#4caf50';
    case '분석불가':    return '#f44336';
    default:           return '#757575';
  }
};

const statusCardStyle: SxProps<Theme> = {
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  padding: '8px 12px',
  minHeight: '60px',
  border: '1px solid',
  borderRadius: 1,
  cursor: 'pointer',
  transition: 'all 0.2s',
  '&:hover': {
    backgroundColor: 'rgba(0, 0, 0, 0.04)',
    boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
  }
};

const SEVERITY_OPTIONS: SeverityOption[] = [
  { value: 'Critical', label: 'Critical', color: '#d32f2f' },
  { value: 'High', label: 'High', color: '#f44336' },
  { value: 'Medium', label: 'Medium', color: '#ff9800' },
  { value: 'Low', label: 'Low', color: '#4caf50' }
];

// Severity 색상 가져오기 (대소문자 구분 없이 비교 추가)
const getSeverityColor = (severity: string | undefined): string => {
  // severity가 null이나 undefined일 경우 빈 문자열로 처리
  const lowerCaseSeverity = (severity || '').toLowerCase();
  const option = SEVERITY_OPTIONS.find(opt => opt.value.toLowerCase() === lowerCaseSeverity);
  return option ? option.color : '#757575'; // 기본 색상
};
// --- 상수 및 유틸리티 끝 ---

const CVEDetailInfoPanel: React.FC<CVEDetailInfoPanelProps> = memo(({ cveData, onUpdateField, canEdit }) => {
  const [detailExpanded, setDetailExpanded] = useState<boolean>(false);

  // 이벤트 핸들러에 참조 안정성 보장
  const handleTitleSave = useCallback((newTitle: string): void => {
    // 값이 실제로 변경되었는지 확인 후 업데이트 요청
    if (canEdit && newTitle !== cveData?.title) {
      onUpdateField('title', newTitle);
    }
  }, [canEdit, cveData?.title, onUpdateField]);

  const handleDescriptionSave = useCallback((newDescription: string): void => {
    // 값이 실제로 변경되었는지 확인 후 업데이트 요청
    if (canEdit && newDescription !== cveData?.description) {
      onUpdateField('description', newDescription);
    }
  }, [canEdit, cveData?.description, onUpdateField]);

  const handleStatusClick = useCallback((newStatus: string): void => {
    // 편집 권한이 있고 실제 값이 변경된 경우에만 업데이트
    if (canEdit && newStatus !== cveData?.status) {
      onUpdateField('status', newStatus);
    }
  }, [canEdit, cveData?.status, onUpdateField]);

  const handleSeverityClick = useCallback((newSeverity: string): void => {
    // 편집 권한이 있고 실제 값이 변경된 경우에만 업데이트
    if (canEdit && newSeverity !== cveData?.severity) {
      onUpdateField('severity', newSeverity);
    }
  }, [canEdit, cveData?.severity, onUpdateField]);

  // 설명 필드 확장/축소 토글 핸들러
  const toggleDetailExpanded = useCallback(() => {
    setDetailExpanded(prev => !prev);
  }, []);

  // 설명 필드 편집 종료 시 축소 핸들러
  const handleDescriptionEditEnd = useCallback(() => {
    // 편집이 끝난 후 약간의 딜레이 후에 축소 (UX 개선)
    setTimeout(() => setDetailExpanded(false), 100);
  }, []);

  return (
    <Grid container spacing={2}>
      {/* 좌측: Title, Description */}
      <Grid item xs={12} md={7}>
        {/* Title */}
        <Box mb={2}>
          <Typography variant="subtitle2" color="text.secondary" gutterBottom>
            Title
          </Typography>
          <Paper variant="outlined" sx={{ p: 1, borderRadius: 1, mb: 2 }}>
            <InlineEditText
              value={cveData?.title || ''}
              onSave={handleTitleSave}
              placeholder="제목을 입력하세요"
              disabled={!canEdit}
              fontSize="0.9rem"
            />
          </Paper>
        </Box>

        {/* Description */}
        <Box>
          <Typography variant="subtitle2" color="text.secondary" gutterBottom>
            Description
          </Typography>
          <Box sx={{ position: 'relative' }}>
            <Paper
              className="description-container"
              variant="outlined"
              sx={{
                p: 1,
                borderRadius: 1,
                border: '1px solid',
                borderColor: 'divider',
                overflow: 'hidden',
                transition: 'max-height 0.3s ease-in-out',
                height: 'auto',
                maxHeight: detailExpanded ? '500px' : '100px',
                display: 'flex',
                flexDirection: 'column'
              }}
            >
              <InlineEditText
                value={cveData?.description || ''}
                multiline
                maxHeight={detailExpanded ? '500px' : '100px'}
                onSave={handleDescriptionSave}
                placeholder="설명을 입력하세요..."
                disabled={!canEdit}
                fontSize="0.85rem"
                onEditingStart={() => setDetailExpanded(true)}
                onEditingEnd={handleDescriptionEditEnd}
              />
            </Paper>
            {/* 확장/축소 버튼 */}
            <Box sx={{ position: 'absolute', bottom: 4, right: 4 }}>
              <IconButton size="small" onClick={toggleDetailExpanded}>
                {detailExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
              </IconButton>
            </Box>
          </Box>
        </Box>
      </Grid>

      {/* 우측: Status, Severity */}
      <Grid item xs={12} md={5}>
        {/* Status */}
        <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1 }}>
          Status
        </Typography>
        <Box
          sx={{
            display: 'grid',
            gridTemplateColumns: 'repeat(2, 1fr)',
            gap: 1.5,
            height: '150px' // 고정 높이 유지
          }}
        >
          {Object.entries(STATUS_OPTIONS).map(([value, { label, description }]) => {
            const isSelected = value === cveData?.status;
            const currentStatusColor = getStatusColor(value);
            return (
              <Paper
                key={value}
                elevation={0}
                sx={{
                  ...statusCardStyle, // 기본 스타일 적용
                  bgcolor: isSelected ? 'action.selected' : 'background.paper',
                  borderColor: isSelected ? currentStatusColor : 'divider',
                  cursor: canEdit ? 'pointer' : 'default', // 편집 가능할 때만 커서 변경
                  // 호버 스타일은 canEdit일 때만 적용
                  ...(canEdit && {
                    '&:hover': {
                      backgroundColor: 'rgba(0, 0, 0, 0.04)',
                      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
                    }
                  }),
                }}
                onClick={() => handleStatusClick(value)}
              >
                <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 1, width: '100%' }}>
                  <CircleIcon sx={{ fontSize: 8, color: currentStatusColor, flexShrink: 0, mt: 0.7 }} />
                  <Box sx={{ display: 'flex', flexDirection: 'column', width: '100%', minWidth: 0 }}>
                    <Typography variant="body2" sx={{ fontWeight: isSelected ? 600 : 400, color: isSelected ? currentStatusColor : 'text.primary', lineHeight: 1.2 }}>
                      {label}
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      {description}
                    </Typography>
                  </Box>
                </Box>
              </Paper>
            );
          })}
        </Box>

        {/* Severity */}
        <Box sx={{ mt: 2 }}>
          <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1 }}>
            Severity
          </Typography>
          <Box sx={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: 1 }}>
            {SEVERITY_OPTIONS.map((option) => {
              const backendSeverity = (cveData?.severity || '').toLowerCase();
              const optionValue = option.value.toLowerCase();
              const isSelected = optionValue === backendSeverity;
              const currentSeverityColor = getSeverityColor(option.value); // 옵션 값 기준으로 색상 가져오기

              return (
                <Paper
                  key={option.value}
                  elevation={0}
                  sx={{
                    display: 'flex',
                    flexDirection: 'column',
                    justifyContent: 'center',
                    alignItems: 'center', // 중앙 정렬
                    minHeight: '40px',
                    border: '1px solid',
                    borderRadius: 1,
                    p: 1, // 패딩
                    textAlign: 'center',
                    cursor: canEdit ? 'pointer' : 'default',
                    transition: 'all 0.2s',
                    bgcolor: isSelected ? 'action.selected' : 'background.paper',
                    borderColor: isSelected ? currentSeverityColor : 'divider',
                    // 호버 스타일
                    ...(canEdit && {
                      '&:hover': {
                        backgroundColor: 'rgba(0, 0, 0, 0.04)',
                        borderColor: currentSeverityColor, // 호버 시 해당 색상으로 테두리 변경
                        boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
                      }
                    }),
                  }}
                  onClick={() => handleSeverityClick(option.value)}
                >
                  <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', gap: 0.5 }}> {/* 아이콘과 텍스트 간격 조정 */}
                    <CircleIcon sx={{ fontSize: 8, color: currentSeverityColor, flexShrink: 0 }} />
                    <Typography
                      variant="body2"
                      sx={{
                        fontWeight: isSelected ? 600 : 400,
                        color: isSelected ? currentSeverityColor : 'text.primary'
                      }}
                    >
                      {option.label}
                    </Typography>
                  </Box>
                </Paper>
              );
            })}
          </Box>
        </Box>
      </Grid>
    </Grid>
  );
});

// displayName 설정 (React DevTools에서 디버깅 시 유용)
CVEDetailInfoPanel.displayName = 'CVEDetailInfoPanel';

export default CVEDetailInfoPanel;


============================================================
File: /home/CVEHub/frontend/src/features/cve/CreateCVE.tsx
------------------------------------------------------------
import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Button,
  TextField,
  Typography,
  Paper,
  Grid,
  Divider,
  Chip,
  IconButton,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Autocomplete,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Alert,
  Link,
  useTheme,
  alpha,
  SelectChangeEvent,
  TextFieldProps,
  Theme,
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
} from '@mui/icons-material';
// 기존 hook 및 유틸리티 import는 그대로 유지
import { useCreateCVE } from 'features/cve/hooks/useCVEMutation';
import { useSnackbar } from 'notistack';
import { useNavigate } from 'react-router-dom';
import { useQueryClient } from '@tanstack/react-query';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { getUser } from 'shared/utils/storage/tokenStorage';
import { getUtcTimestamp } from 'shared/utils/dateUtils';
import { ApiResponse } from 'shared/api/types/api';
import { 
  CVEDetail,
  CVEData, 
  FormData, 
  PoCFile as PoC, 
  SnortRuleFile as SnortRule, 
  ReferenceFile as Reference, 
  SelectOption 
} from 'features/cve/types/cve';

// 타입 정의
interface CreateCVEProps {
  open?: boolean;
  onClose: () => void;
  onSuccess?: (data: CVEData) => void;
}

// 상수 정의
const POC_SOURCES: Record<string, string> = { Etc: "Etc", Metasploit: "Metasploit", "Nuclei-Templates": "Nuclei-Templates" };
const SNORT_RULE_TYPES: Record<string, string> = { "사용자 정의": "USER_DEFINED", "IPS": "IPS", "ONE": "ONE", "UTM": "UTM", "Emerging-Threats": "EMERGING_THREATS", "Snort Official": "SNORT_OFFICIAL" };
const SNORT_RULE_TYPE_OPTIONS: Array<{ label: string; value: string }> = Object.entries(SNORT_RULE_TYPES).map(([label, value]) => ({ label, value }));
const STATUS_OPTIONS: SelectOption[] = [{ value: '신규등록', label: '신규등록' }, { value: '분석중', label: '분석중' }, { value: '릴리즈 완료', label: '릴리즈 완료' }, { value: '분석불가', label: '분석불가' }];
const SEVERITY_OPTIONS: SelectOption[] = [{ value: 'Critical', label: 'Critical' }, { value: 'High', label: 'High' }, { value: 'Medium', label: 'Medium' }, { value: 'Low', label: 'Low' }, { value: 'None', label: 'None' }];

// 스타일 상수 및 함수
const antdBorderColor = '#d9d9d9';
const antdPrimaryColor = '#1677ff';
const antdBorderRadius = '6px';
const antdInputHeight = '32px';
const antdListBgColor = '#fafafa';

// 입력 필드 공통 스타일 (AntD 유사)
const inputStyles = (theme: Theme) => ({
  borderRadius: antdBorderRadius,
  '& .MuiOutlinedInput-root': {
    borderRadius: antdBorderRadius,
    '& fieldset': {
      borderColor: antdBorderColor,
    },
    '&:hover fieldset': {
      borderColor: theme.palette.primary.main,
    },
    '&.Mui-focused fieldset': {
      borderColor: theme.palette.primary.main,
      borderWidth: '1px',
    },
  },
  '& .MuiInputLabel-outlined': {}
});

// 태그(Chip) 스타일 (AntD Tag 유사)
const tagStyles = (theme: Theme, type: string, value: string) => {
  let colors: { bgcolor: string; color: string } = { bgcolor: alpha(theme.palette.grey[500], 0.1), color: theme.palette.text.secondary }; // Default (None/Unknown)

  if (type === 'severity') {
    const severityLower = value ? String(value).toLowerCase() : '';
    switch (severityLower) {
      case 'critical': colors = { bgcolor: alpha(theme.palette.error.main, 0.1), color: theme.palette.error.dark }; break;
      case 'high': colors = { bgcolor: alpha(theme.palette.warning.main, 0.15), color: theme.palette.warning.dark }; break;
      case 'medium': colors = { bgcolor: alpha(theme.palette.info.main, 0.1), color: theme.palette.info.dark }; break;
      case 'low': colors = { bgcolor: alpha(theme.palette.success.light, 0.2), color: theme.palette.success.dark }; break;
    }
  } else if (type === 'status') {
    switch (value) {
      case '신규등록': colors = { bgcolor: alpha(theme.palette.primary.light, 0.15), color: theme.palette.primary.dark }; break;
      case '분석중': colors = { bgcolor: alpha(theme.palette.secondary.light, 0.15), color: theme.palette.secondary.dark }; break;
      case '릴리즈 완료': colors = { bgcolor: alpha(theme.palette.success.light, 0.2), color: theme.palette.success.dark }; break;
      case '분석불가': colors = { bgcolor: alpha(theme.palette.error.light, 0.1), color: theme.palette.error.dark }; break;
    }
  }

  return {
    ...colors,
    height: '22px',
    fontSize: '0.75rem',
    borderRadius: '4px',
    border: `1px solid ${colors.bgcolor}`,
    mr: 0.5,
    mb: 0.5,
  };
};

// 컴포넌트 시작
const CreateCVE: React.FC<CreateCVEProps> = ({ open = false, onClose, onSuccess }) => {
  // 머테리얼 UI 테마를 가져오고 타입을 명시적으로 지정
  const theme: Theme = useTheme();
  const { enqueueSnackbar } = useSnackbar();

  // 상태 정의
  const [formData, setFormData] = useState<FormData>({
    cveId: '',
    title: '',
    description: '',
    status: '신규등록',
    severity: 'Low',
    tags: [],
    exploitStatus: 'Unknown',
  });

  const [poc, setPoc] = useState<PoC[]>([]);
  const [snortRule, setSnortRule] = useState<SnortRule[]>([]);
  const [reference, setReference] = useState<Reference[]>([]);

  const [newPoc, setNewPoc] = useState<Omit<PoC, 'id' | 'created_by' | 'last_modified_by'>>({ source: POC_SOURCES.Etc, url: '' });
  const [newSnortRule, setNewSnortRule] = useState<Omit<SnortRule, 'id' | 'created_by' | 'last_modified_by'>>({ rule: '', type: 'USER_DEFINED' });
  const [newReference, setNewReference] = useState<string>('');
  const [error, setError] = useState<string>('');

  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const currentUser = getUser();
  const username = currentUser?.username || 'anonymous';

  const { mutate, isPending, error: mutationError } = useCreateCVE({
    onSuccess: (response: ApiResponse<CVEDetail>) => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.CVE.lists(), refetchType: 'active' });
      enqueueSnackbar('CVE가 성공적으로 생성되었습니다', { variant: 'success' });
      if (onSuccess && response.data) {
        // response.data를 CVEData 형태로 변환하여 전달
        const cveData: CVEData = {
          cveId: response.data.cveId,
          title: response.data.title || '',
          description: response.data.description || '',
          status: response.data.status,
          severity: response.data.severity || '',
          tags: (response.data.tags as string[]) || [],
          exploitStatus: (response.data.exploitStatus as string) || '',
          // 배열 형태로 변환할 때는 리턴타입에 맞게 변환하는 것이 중요합니다
          poc: Array.isArray(response.data.poc) 
            ? (response.data.poc as any[]).map(poc => ({
                source: poc.source || '',
                url: poc.url || ''
              })) 
            : [],
          snortRule: Array.isArray(response.data.snortRule) 
            ? (response.data.snortRule as any[]).map(rule => ({
                rule: rule.rule || '',
                type: rule.type || ''
              })) 
            : [],
          reference: Array.isArray(response.data.reference) 
            ? (response.data.reference as any[]).map(ref => ({
                url: ref.url || ''
              })) 
            : [],
        };
        onSuccess(cveData);
      }
      handleClose();
    },
    onError: (error: Error) => handleError(error)
  });

  const handleError = (error: Error): void => {
    const errorMsg = `CVE 생성 실패: ${error.message || '알 수 없는 오류'}`;
    enqueueSnackbar(errorMsg, { variant: 'error' });
    setError(errorMsg);
  };

  // 폼 필드 변경 핸들러
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement> | SelectChangeEvent<string>): void => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  // Autocomplete (Tags) 핸들러
  const handleTagsChange = (event: React.SyntheticEvent, newValue: string[]): void => {
    setFormData(prev => ({ ...prev, tags: newValue }));
  };

  // 다이얼로그 닫기 및 폼 초기화
  const handleClose = (): void => {
    setFormData({
      cveId: '',
      title: '',
      description: '',
      status: '신규등록',
      severity: 'Low',
      tags: [],
      exploitStatus: 'Unknown'
    });
    setPoc([]);
    setSnortRule([]);
    setReference([]);
    setNewPoc({ source: POC_SOURCES.Etc, url: '' });
    setNewSnortRule({ rule: '', type: 'USER_DEFINED' });
    setNewReference('');
    setError('');
    onClose();
  };

  // 목록 추가/삭제 핸들러
  const handleAddPoc = (): void => {
    if (!newPoc.url.trim()) return;
    setPoc(prev => [...prev, {
      ...newPoc,
      id: `poc-${Date.now()}`,
      created_by: username,
      last_modified_by: username
    }]);
    setNewPoc({ source: POC_SOURCES.Etc, url: '' });
  };

  const handleRemovePoc = (id: string): void => {
    setPoc(prev => prev.filter(item => item.id !== id));
  };

  const handleAddSnortRule = (): void => {
    if (!newSnortRule.rule.trim()) return;
    setSnortRule(prev => [...prev, {
      ...newSnortRule,
      id: `snort-${Date.now()}`,
      created_by: username,
      last_modified_by: username
    }]);
    setNewSnortRule({ rule: '', type: 'USER_DEFINED' });
  };

  const handleRemoveSnortRule = (id: string): void => {
    setSnortRule(prev => prev.filter(item => item.id !== id));
  };

  const handleAddReference = (): void => {
    if (!newReference.trim()) return;
    const utcTime = getUtcTimestamp();
    setReference(prev => [...prev, {
      url: newReference.trim(),
      id: `ref-${Date.now()}`,
      created_at: utcTime,
      created_by: username,
      last_modified_at: null,
      last_modified_by: username
    }]);
    setNewReference('');
  };

  const handleRemoveReference = (id: string): void => {
    setReference(prev => prev.filter(item => item.id !== id));
  };

  const handleSubmit = async (e: React.FormEvent): Promise<void> => {
    e.preventDefault();

    if (!formData.cveId.trim()) {
      setError('CVE ID는 필수 항목입니다.');
      enqueueSnackbar('필수 입력 값을 확인해주세요.', { variant: 'warning' });
      return;
    }
    setError('');

    const cveData: CVEData = {
      ...formData,
      poc: poc.map(({ id, ...rest }) => rest),
      snortRule: snortRule.map(({ id, ...rest }) => rest),
      reference: reference.map(({ id, ...rest }) => rest),
    };

    mutate(cveData);
  };

  return (
    <Dialog
      open={open}
      onClose={handleClose}
      maxWidth="md"
      fullWidth
      PaperProps={{ sx: { minHeight: '80vh', borderRadius: antdBorderRadius } }}
    >
      <DialogTitle sx={{ pb: 1, borderBottom: `1px solid ${antdBorderColor}` }}>
        <Typography variant="h6" component="div" sx={{ fontWeight: 500 }}>
          새 CVE 등록
        </Typography>
      </DialogTitle>
      <DialogContent sx={{ pt: '20px !important', backgroundColor: '#f5f5f5' }}>
        {error && (
          <Alert severity="error" onClose={() => setError('')} sx={{ mb: 2, borderRadius: antdBorderRadius }}>
            {error}
          </Alert>
        )}

        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
          {/* 기본 정보 섹션 */}
          <Paper elevation={0} sx={{ p: 2.5, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
            <Typography variant="subtitle1" sx={{ mb: 2.5, fontWeight: 500 }}>기본 정보</Typography>
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6} md={4} lg={3}>
                <TextField
                  required
                  fullWidth
                  label="CVE ID"
                  name="cveId"
                  value={formData.cveId}
                  onChange={handleInputChange}
                  helperText="Format: CVE-YYYY-NNNNN"
                  size="small"
                  sx={inputStyles(theme)}
                  error={!formData.cveId.trim() && !!error}
                />
              </Grid>
              <Grid item xs={12} sm={6} md={8} lg={5}>
                <TextField
                  fullWidth
                  label="제목"
                  name="title"
                  value={formData.title}
                  onChange={handleInputChange}
                  size="small"
                  sx={inputStyles(theme)}
                />
              </Grid>
              <Grid item xs={12} sm={6} md={4} lg={2}>
                <FormControl fullWidth size="small" sx={inputStyles(theme)}>
                  <InputLabel>상태</InputLabel>
                  <Select
                    name="status"
                    value={formData.status}
                    onChange={handleInputChange}
                    label="상태"
                  >
                    {STATUS_OPTIONS.map(option => (
                      <MenuItem key={option.value} value={option.value}>{option.label}</MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>
              <Grid item xs={12} sm={6} md={4} lg={2}>
                <FormControl fullWidth size="small" sx={inputStyles(theme)}>
                  <InputLabel>심각도</InputLabel>
                  <Select
                    name="severity"
                    value={formData.severity}
                    onChange={handleInputChange}
                    label="심각도"
                  >
                    {SEVERITY_OPTIONS.map(option => (
                      <MenuItem key={option.value} value={option.value}>{option.label}</MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
            <TextField
              label="설명"
              name="description"
              value={formData.description}
              onChange={handleInputChange}
              multiline
              rows={4}
              fullWidth
              size="small"
              sx={{ ...inputStyles(theme), mt: 2 }}
            />
            <Autocomplete
              multiple
              freeSolo
              options={[]}
              value={formData.tags}
              onChange={handleTagsChange}
              renderTags={(value: string[], getTagProps) =>
                value.map((option, index) => (
                  <Chip
                    label={option}
                    size="small"
                    sx={tagStyles(theme, 'tag', option)}
                    {...getTagProps({ index })}
                  />
                ))
              }
              renderInput={(params) => (
                <TextField
                  {...params}
                  label="태그"
                  placeholder="태그 입력 후 Enter"
                  size="small"
                  sx={{ ...inputStyles(theme), mt: 2 }}
                />
              )}
              sx={{ mt: 2 }}
            />
          </Paper>

          {/* PoC 섹션 */}
          <Paper elevation={0} sx={{ p: 2.5, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
            <Typography variant="subtitle1" sx={{ mb: 2, fontWeight: 500 }}>Proof of Concepts (PoC)</Typography>
            <Box sx={{ display: 'flex', gap: 1, mb: 2, alignItems: 'center' }}>
              <FormControl size="small" sx={{ ...inputStyles(theme), width: '25%', minWidth: 150 }}>
                <InputLabel>Source</InputLabel>
                <Select
                  value={newPoc.source}
                  onChange={(e) => setNewPoc(prev => ({ ...prev, source: e.target.value }))}
                  label="Source"
                >
                  {Object.entries(POC_SOURCES).map(([key, value]) => (
                    <MenuItem key={key} value={value}>{value}</MenuItem>
                  ))}
                </Select>
              </FormControl>
              <TextField
                size="small"
                placeholder="PoC URL"
                value={newPoc.url}
                onChange={(e) => setNewPoc(prev => ({ ...prev, url: e.target.value }))}
                sx={{ ...inputStyles(theme), flexGrow: 1 }}
                onKeyDown={(e) => e.key === 'Enter' && handleAddPoc()}
              />
              <Button
                variant="outlined"
                onClick={handleAddPoc}
                startIcon={<AddIcon />}
                sx={{
                  borderRadius: antdBorderRadius,
                  borderColor: antdBorderColor,
                  color: theme.palette.text.secondary,
                  borderStyle: 'dashed',
                  height: antdInputHeight,
                  '&:hover': {
                    borderColor: theme.palette.primary.main,
                    color: theme.palette.primary.main,
                    backgroundColor: alpha(theme.palette.primary.main, 0.05),
                    borderStyle: 'dashed',
                  }
                }}
              >
                추가
              </Button>
            </Box>
            <Box sx={{ maxHeight: '200px', overflowY: 'auto', p: 1, bgcolor: antdListBgColor, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
              {poc.length === 0 ? (
                <Typography variant="body2" color="textSecondary" align="center" sx={{ p: 2 }}>추가된 PoC가 없습니다.</Typography>
              ) : (
                poc.map((poc) => (
                  <Paper key={poc.id} elevation={0} sx={{ p: 1, mb: 1, display: 'flex', gap: 1, alignItems: 'center', borderRadius: '4px', border: `1px solid ${alpha(antdBorderColor, 0.6)}`, '&:last-child': { mb: 0 } }}>
                    <Typography variant="body2" sx={{ width: '25%', fontWeight: 500, flexShrink: 0 }}>{poc.source}</Typography>
                    <Link href={poc.url} target="_blank" rel="noopener noreferrer" variant="body2" sx={{ flexGrow: 1, wordBreak: 'break-all', color: theme.palette.primary.main }}>
                      {poc.url}
                    </Link>
                    <IconButton onClick={() => handleRemovePoc(poc.id as string)} size="small" sx={{ color: theme.palette.error.main, '&:hover': { bgcolor: alpha(theme.palette.error.main, 0.1) } }}>
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                  </Paper>
                ))
              )}
            </Box>
          </Paper>

          {/* Snort Rules 섹션 */}
          <Paper elevation={0} sx={{ p: 2.5, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
            <Typography variant="subtitle1" sx={{ mb: 2, fontWeight: 500 }}>Snort Rules</Typography>
            <Box sx={{ display: 'flex', gap: 1, mb: 2, alignItems: 'center' }}>
              <FormControl size="small" sx={{ ...inputStyles(theme), width: '30%', minWidth: 180 }}>
                <InputLabel>Rule Type</InputLabel>
                <Select
                  value={newSnortRule.type}
                  onChange={(e) => setNewSnortRule(prev => ({ ...prev, type: e.target.value }))}
                  label="Rule Type"
                >
                  {SNORT_RULE_TYPE_OPTIONS.map(({ label, value }) => (
                    <MenuItem key={value} value={value}>{label}</MenuItem>
                  ))}
                </Select>
              </FormControl>
              <TextField
                size="small"
                placeholder="Snort Rule"
                value={newSnortRule.rule}
                onChange={(e) => setNewSnortRule(prev => ({ ...prev, rule: e.target.value }))}
                sx={{ ...inputStyles(theme), flexGrow: 1 }}
                onKeyDown={(e) => e.key === 'Enter' && handleAddSnortRule()}
              />
              <Button
                variant="outlined"
                onClick={handleAddSnortRule}
                startIcon={<AddIcon />}
                sx={{
                  borderRadius: antdBorderRadius,
                  borderColor: antdBorderColor,
                  color: theme.palette.text.secondary,
                  borderStyle: 'dashed',
                  height: antdInputHeight,
                  '&:hover': {
                    borderColor: theme.palette.primary.main,
                    color: theme.palette.primary.main,
                    backgroundColor: alpha(theme.palette.primary.main, 0.05),
                    borderStyle: 'dashed',
                  }
                }}
              >
                추가
              </Button>
            </Box>
            <Box sx={{ maxHeight: '200px', overflowY: 'auto', p: 1, bgcolor: antdListBgColor, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
              {snortRule.length === 0 ? (
                <Typography variant="body2" color="textSecondary" align="center" sx={{ p: 2 }}>추가된 Snort Rule이 없습니다.</Typography>
              ) : (
                snortRule.map((rule) => (
                  <Paper key={rule.id} elevation={0} sx={{ p: 1, mb: 1, display: 'flex', gap: 1, alignItems: 'center', borderRadius: '4px', border: `1px solid ${alpha(antdBorderColor, 0.6)}`, '&:last-child': { mb: 0 } }}>
                    <Typography variant="body2" sx={{ width: '30%', fontWeight: 500, flexShrink: 0 }}>
                      {SNORT_RULE_TYPE_OPTIONS.find(opt => opt.value === rule.type)?.label || rule.type}
                    </Typography>
                    <Typography variant="body2" sx={{ flexGrow: 1, whiteSpace: 'pre-wrap', wordBreak: 'break-all', fontFamily: 'monospace', fontSize: '0.8rem' }}>
                      {rule.rule}
                    </Typography>
                    <IconButton onClick={() => handleRemoveSnortRule(rule.id as string)} size="small" sx={{ color: theme.palette.error.main, '&:hover': { bgcolor: alpha(theme.palette.error.main, 0.1) } }}>
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                  </Paper>
                ))
              )}
            </Box>
          </Paper>

          {/* Reference 섹션 */}
          <Paper elevation={0} sx={{ p: 2.5, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
            <Typography variant="subtitle1" sx={{ mb: 2, fontWeight: 500 }}>Reference</Typography>
            <Box sx={{ display: 'flex', gap: 1, mb: 2, alignItems: 'center' }}>
              <TextField
                size="small"
                placeholder="참조 URL"
                value={newReference}
                onChange={(e) => setNewReference(e.target.value)}
                fullWidth
                sx={inputStyles(theme)}
                onKeyDown={(e) => e.key === 'Enter' && handleAddReference()}
              />
              <Button
                variant="outlined"
                onClick={handleAddReference}
                startIcon={<AddIcon />}
                sx={{
                  borderRadius: antdBorderRadius,
                  borderColor: antdBorderColor,
                  color: theme.palette.text.secondary,
                  borderStyle: 'dashed',
                  height: antdInputHeight,
                  '&:hover': {
                    borderColor: theme.palette.primary.main,
                    color: theme.palette.primary.main,
                    backgroundColor: alpha(theme.palette.primary.main, 0.05),
                    borderStyle: 'dashed',
                  }
                }}
              >
                추가
              </Button>
            </Box>
            <Box sx={{ maxHeight: '200px', overflowY: 'auto', p: 1, bgcolor: antdListBgColor, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
              {reference.length === 0 ? (
                <Typography variant="body2" color="textSecondary" align="center" sx={{ p: 2 }}>추가된 참조 URL이 없습니다.</Typography>
              ) : (
                reference.map((ref) => (
                  <Paper key={ref.id} elevation={0} sx={{ p: 1, mb: 1, display: 'flex', gap: 1, alignItems: 'center', borderRadius: '4px', border: `1px solid ${alpha(antdBorderColor, 0.6)}`, '&:last-child': { mb: 0 } }}>
                    <Link href={ref.url} target="_blank" rel="noopener noreferrer" variant="body2" sx={{ flexGrow: 1, wordBreak: 'break-all', color: theme.palette.primary.main }}>
                      {ref.url}
                    </Link>
                    <IconButton onClick={() => handleRemoveReference(ref.id as string)} size="small" sx={{ color: theme.palette.error.main, '&:hover': { bgcolor: alpha(theme.palette.error.main, 0.1) } }}>
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                  </Paper>
                ))
              )}
            </Box>
          </Paper>
        </Box>
      </DialogContent>
      <DialogActions sx={{ p: 2, borderTop: `1px solid ${antdBorderColor}`, backgroundColor: '#fff' }}>
        <Button
          onClick={handleClose}
          variant="outlined"
          sx={{ borderRadius: antdBorderRadius, borderColor: antdBorderColor, color: theme.palette.text.primary }}
        >
          취소
        </Button>
        <Button
          variant="contained"
          color="primary"
          onClick={handleSubmit}
          disabled={isPending || !formData.cveId.trim()}
          startIcon={isPending ? <CircularProgress size={20} color="inherit" /> : null}
          sx={{
            borderRadius: antdBorderRadius,
            boxShadow: 'none',
          }}
        >
          CVE 생성
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default CreateCVE;


============================================================
File: /home/CVEHub/frontend/src/features/cve/tests/BridgeTest.tsx
------------------------------------------------------------
// src/features/cve/tests/BridgeTest.tsx
import React from 'react';
import { CVEDetail, Reference, PoC, Comment } from '../types/bridge';

/**
 * 브릿지 타입 테스트 컴포넌트
 */
const BridgeTest: React.FC = () => {
  // 테스트 객체 생성
  const testCVE: CVEDetail = {
    cveId: 'CVE-2023-1234',
    title: '테스트 CVE',
    status: '신규등록',
    createdBy: 'admin',
    lastModifiedBy: 'admin',
    createdAt: new Date(),
    reference: [],
    poc: [],
    snortRule: [],
    modificationHistory: []
  };
  
  console.log('테스트 CVE:', testCVE);
  
  return (
    <div>
      <h2>브릿지 타입 테스트</h2>
      <pre>{JSON.stringify(testCVE, null, 2)}</pre>
    </div>
  );
};

export default BridgeTest;


============================================================
File: /home/CVEHub/frontend/src/features/cve/services/cveService.js
------------------------------------------------------------
// cveService.js
import api from 'shared/api/config/axios';
import { CASE_CONVERSION_CONFIG } from 'config';
import logger from 'shared/utils/logging';
import { camelToSnake, snakeToCamel } from 'shared/utils/caseConverter';

// 변환에서 제외할 필드 목록
const EXCLUDED_FIELDS = CASE_CONVERSION_CONFIG.EXCLUDED_FIELDS;

// 날짜 필드 목록 (로깅용)
const DATE_FIELDS = [
  'created_at', 'createdAt', 
  'last_modified_at', 'lastModifiedAt',
  'updated_at', 'updatedAt',
  'published_date', 'publishedDate',
  'expiration_date', 'expirationDate',
  'timestamp', 'date'
];

// 진행 중인 요청을 추적하기 위한 맵
const pendingRequests = new Map();

/**
 * CVE 데이터를 관리하는 서비스 클래스
 * 백엔드 API와 통신하여 CVE 데이터의 CRUD 작업을 처리
 * @class CVEService
 */
class CVEService {
  /**
   * CVE 목록 조회
   * @param {Object} filters - 페이지네이션, 검색, 필터링 옵션
   * @returns {Promise<Object>} 응답 데이터 (results, pagination 포함)
   */
  async getCVEs(filters = {}) {
    try {
      logger.info('cveService', '목록 조회 요청', {
        page: filters.page,
        limit: filters.rowsPerPage,
        search: filters.search
      });
      
      // 백엔드 API와 호환되는 파라미터로 변환
      const params = {};
      
      // 페이지네이션 처리
      if (filters.page !== undefined) {
        params.page = Number(filters.page); // 페이지 번호 그대로 전달
      }
      
      if (filters.rowsPerPage !== undefined) {
        params.limit = filters.rowsPerPage;
      }
      
      // 검색어 처리
      if (filters.search) {
        // 검색어는 'search' 파라미터로 전달 (백엔드 API에 맞춤)
        params.search = filters.search;
      }
      
      // 정렬 처리
      if (filters.sortBy) {
        params.sort_by = filters.sortBy; // 스네이크 케이스 사용 (백엔드 API에 맞춤)
        params.sort_order = filters.sortOrder || 'desc';
      }
      
      // 필터 처리 (severity, status 등)
      if (filters.filters) {
        Object.entries(filters.filters).forEach(([key, value]) => {
          if (value !== undefined && value !== null && value !== '') {
            // 스네이크 케이스로 변환 없이 그대로 전달
            params[key] = value;
          }
        });
      }
      
      // API 엔드포인트 선택 (/cves/list 사용)
      const endpoint = '/cves/list';
      
      // 캐시 우회를 위한 헤더 추가 (검색어가 있는 경우)
      const headers = filters.search ? {
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache',
        'x-refresh': 'true'
      } : {};
      
      const response = await api.get(endpoint, {
        params,
        headers
      });
      
      // 응답 형식 표준화
      const result = {
        items: response.data?.results || response.data?.items || [],
        total: response.data?.pagination?.total || response.data?.total || 0,
        page: filters.page || 1, 
        limit: filters.rowsPerPage || 10
      };
      
      logger.info('cveService', '목록 조회 성공', { 
        count: result.items.length || 0,
        total: result.total || 0,
        search: filters.search || ''
      });
      
      return result;
    } catch (error) {
      logger.error('cveService', '목록 조회 실패', { error: error.message });
      throw this._handleError(error, '목록 조회 실패');
    }
  }

  /**
   * CVE 상세 정보 조회
   * @param {string} cveId - 조회할 CVE ID
   * @param {Object} options - 요청 옵션
   * @returns {Promise<Object>} - CVE 상세 정보
   */
  async getCVEById(cveId, options = {}) {
    if (!cveId) {
      throw new Error('CVE ID가 필요합니다');
    }
    
    try {
      // 동일한 CVE ID에 대한 진행 중인 요청이 있는지 확인
      const requestKey = `cve_${cveId}_${options.bypassCache ? 'bypass' : 'normal'}`;
      
      // 이미 진행 중인 요청이 있으면 해당 Promise 반환
      if (pendingRequests.has(requestKey)) {
        logger.info('cveService', '진행 중인 요청 재사용', { 
          cveId,
          bypassCache: !!options.bypassCache
        });
        return pendingRequests.get(requestKey);
      }
      
      // 캐시 우회 옵션 추가
      const headers = options.bypassCache ? {
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache',
        'x-refresh': 'true'
      } : {};
      
      logger.info('cveService', 'CVE 상세 정보 요청', { 
        cveId,
        bypassCache: !!options.bypassCache
      });
      
      // 새로운 요청 생성 및 추적
      const requestPromise = api.get(`/cves/${cveId}`, { headers })
        .then(response => {
          // 요청 완료 후 맵에서 제거
          pendingRequests.delete(requestKey);
          
          logger.info('cveService', 'CVE 상세 정보 응답', {
            cveId,
            status: response.status
          });
          
          return response.data;
        })
        .catch(error => {
          // 오류 발생 시에도 맵에서 제거
          pendingRequests.delete(requestKey);
          throw error;
        });
      
      // 진행 중인 요청 맵에 추가
      pendingRequests.set(requestKey, requestPromise);
      
      return requestPromise;
    } catch (error) {
      logger.error('cveService', 'CVE 상세 정보 조회 실패', { 
        cveId, 
        error: error.message,
        status: error.response?.status
      });
      
      throw this._handleError(error, '상세 정보 조회 실패');
    }
  }

  /**
   * 캐시 우회 CVE 상세 정보 조회 (강제 새로고침)
   * @param {string} cveId - CVE ID
   * @returns {Promise<Object>} 응답 데이터
   */
  async getCVEByIdNoCache(cveId) {
    if (!cveId) {
      logger.warn('cveService', 'getCVEByIdNoCache 호출 시 cveId가 없습니다');
      throw new Error('CVE ID는 필수 항목입니다');
    }

    try {
      logger.info('cveService', 'CVE 강제 새로고침 요청', { cveId });
      const response = await api.get(`/cves/${cveId}`, {
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache',
          'x-refresh': 'true'
        }
      });
      logger.info('cveService', 'CVE 강제 새로고침 성공', { cveId });
      return response.data;
    } catch (error) {
      logger.error('cveService', 'CVE 강제 새로고침 실패', { cveId, error: error.message });
      throw this._handleError(error, `CVE #${cveId} 새로고침 실패`);
    }
  }

  /**
   * 새로운 CVE를 생성합니다.
   * @param {Object} cveData - 생성할 CVE 데이터
   * @param {Object} options - 요청 옵션
   * @param {Object} options.meta - 메타 정보
   * @returns {Promise<Object>} 생성된 CVE 객체
   */
  async createCVE(cveData, options = {}) {
    try {
      const url = '/cves';
      
      // 요청 옵션 준비
      const requestOptions = {
        skipAuthRefresh: false, // 기본값: 인증 갱신 허용
        ...(options || {})
      };
      
      // API 호출
      const response = await api.post(url, cveData, requestOptions);
      
      // 응답 로깅
      logger.info('cveService', '생성 성공', { 
        id: response.data?.id,
        status: response.status
      });
      
      return response.data;
    } catch (error) {
      // 에러 처리 강화
      logger.error('cveService', '생성 실패', { 
        error: error?.message,
        status: error?.response?.status
      });
      
      // 에러 객체 구조 확인
      const statusCode = error?.response?.status || 500;
      
      // 409 에러 (중복 CVE) 처리
      if (statusCode === 409) {
        // 백엔드에서 전달된 상세 에러 메시지 사용
        const detailMessage = error?.response?.data?.detail || '이미 존재하는 CVE입니다.';
        
        const enhancedError = new Error(detailMessage);
        enhancedError.code = 409;
        enhancedError.status = 409;
        enhancedError.originalError = error;
        enhancedError.isHandled = true; // 이미 처리된 에러임을 표시
        
        // response 객체 구성
        enhancedError.response = {
          status: 409,
          data: {
            detail: detailMessage,
            errorCode: error?.response?.data?.errorCode || 'DUPLICATE_CVE'
          }
        };
        
        throw enhancedError;
      }
      
      // 기타 에러 처리
      const errorMessage = error?.response?.data?.detail || 
                          error?.response?.data?.message || 
                          (error?.message && !error?.message.includes('status code')) ? error.message : 
                          'CVE 생성 중 오류가 발생했습니다.';
      
      const enhancedError = new Error(errorMessage);
      enhancedError.code = statusCode;
      enhancedError.status = statusCode;
      enhancedError.originalError = error;
      enhancedError.isHandled = true; // 이미 처리된 에러임을 표시
      
      // response 객체 구성
      enhancedError.response = {
        status: statusCode,
        data: {
          detail: errorMessage,
          errorCode: error?.response?.data?.errorCode || 'UNKNOWN_ERROR'
        }
      };
      
      throw enhancedError;
    }
  }

  /**
   * CVE 업데이트 (전체)
   * @param {string} cveId - CVE ID
   * @param {Object} updateData - 업데이트할 데이터
   * @param {Object} options - 요청 옵션
   * @returns {Promise<Object>} 업데이트된 CVE 데이터
   */
  async updateCVE(cveId, updateData, options = {}) {
    if (!cveId) {
      logger.warn('cveService', 'updateCVE 호출 시 cveId가 없습니다');
      throw new Error('CVE ID는 필수 항목입니다');
    }

    if (!updateData) {
      logger.warn('cveService', 'updateCVE 호출 시 updateData가 없습니다');
      throw new Error('업데이트 데이터는 필수 항목입니다');
    }

    try {
      logger.info('cveService', 'CVE 업데이트 요청', { cveId });
      
      // 요청 옵션 설정
      const requestOptions = {
        ...(options || {}),
        skipAuthRefresh: options?.skipAuthRefresh ?? false
      };
      
      // 백엔드에서 PATCH 메서드 사용하므로 일관성 유지
      const response = await api.patch(`/cves/${cveId}`, updateData, requestOptions);
      
      logger.info('cveService', 'CVE 업데이트 성공', { 
        cveId,
        status: response.status
      });
      
      return response.data;
    } catch (error) {
      logger.error('cveService', 'CVE 업데이트 실패', { 
        cveId, 
        error: error.message,
        status: error.response?.status
      });
      
      // 에러 객체 강화 (config 정보 보존)
      const enhancedError = {
        ...error,
        code: error?.response?.status || 500,
        message: error?.response?.data?.detail || error?.response?.data?.message || error?.message || `CVE #${cveId} 업데이트 실패`,
        config: {
          ...(error?.config || {}),
          skipAuthRefresh: options?.skipAuthRefresh ?? false
        }
      };
      
      throw enhancedError;
    }
  }

  /**
   * CVE의 특정 필드를 업데이트합니다.
   * @param {string} cveId - CVE ID
   * @param {string} fieldName - 필드 이름
   * @param {any} fieldValue - 필드 값
   * @param {Object} options - 요청 옵션
   * @returns {Promise<Object>} 업데이트된 CVE 데이터
   */
  async updateCVEField(cveId, fieldName, fieldValue, options = {}) {
    if (!cveId) {
      logger.warn('cveService', 'updateCVEField 호출 시 cveId가 없습니다');
      throw new Error('CVE ID는 필수 항목입니다');
    }

    if (!fieldName) {
      logger.warn('cveService', 'updateCVEField 호출 시 fieldName이 없습니다');
      throw new Error('필드 이름은 필수 항목입니다');
    }

    try {
      logger.info('cveService', 'CVE 필드 업데이트 요청', { 
        cveId, 
        field: fieldName
      });
      
      // 업데이트할 데이터 구성
      const updateData = {
        [fieldName]: fieldValue
      };
      
      // 요청 옵션 설정 (options가 undefined여도 안전하게 처리)
      const requestOptions = {
        ...(options || {}),
        skipAuthRefresh: options?.skipAuthRefresh ?? false
      };
      
      // PATCH 요청 보내기
      const response = await api.patch(`/cves/${cveId}`, updateData, requestOptions);
      
      logger.info('cveService', 'CVE 필드 업데이트 성공', { 
        cveId,
        field: fieldName,
        status: response.status
      });
      
      return response.data;
    } catch (error) {
      logger.error('cveService', 'CVE 필드 업데이트 실패', { 
        cveId, 
        field: fieldName,
        error: error.message,
        status: error.response?.status
      });
      
      // 에러 객체 강화 (config 정보 보존, options가 undefined여도 안전하게 처리)
      const safeOptions = options || {};
      const enhancedError = {
        ...error,
        code: error?.response?.status || 500,
        message: error?.response?.data?.detail || error?.response?.data?.message || error?.message || `CVE #${cveId} 필드 업데이트 실패`,
        config: {
          ...(error?.config || {}),
          skipAuthRefresh: safeOptions.skipAuthRefresh ?? false
        }
      };
      
      throw enhancedError;
    }
  }

  /**
   * CVE 상태 업데이트
   * @param {string} cveId - CVE ID
   * @param {string} status - 업데이트할 상태 값
   * @returns {Promise<Object>} 업데이트된 CVE 데이터
   */
  async updateCVEStatus(cveId, status) {
    if (!cveId) {
      logger.warn('cveService', 'updateCVEStatus 호출 시 cveId가 없습니다');
      throw new Error('CVE ID는 필수 항목입니다');
    }

    if (!status) {
      logger.warn('cveService', 'updateCVEStatus 호출 시 status가 없습니다');
      throw new Error('상태 값은 필수 항목입니다');
    }

    try {
      logger.info('cveService', 'CVE 상태 업데이트 요청', { cveId });
      
      // MongoDB ObjectId 관련 로직 제거 - cve_id만 사용
      const url = `/cves/${cveId}`;
      
      // 상태 필드만 업데이트하는 데이터 구조 생성
      const updateData = {
        status: status
      };
      
      // axios 대신 fetch API 사용 (인터셉터 문제 우회)
      const token = localStorage.getItem('accessToken');
      if (!token) {
        throw new Error('인증 토큰이 없습니다');
      }
      
      // 데이터를 스네이크 케이스로 변환
      const snakeCaseData = camelToSnake(updateData, { excludeFields: EXCLUDED_FIELDS });
      
      const response = await fetch(url, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(snakeCaseData)
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.detail || `서버 오류: ${response.status}`);
      }
      
      const responseData = await response.json();
      
      // 응답 데이터를 카멜 케이스로 변환 (최신 구현에 맞게 수정)
      const camelCaseData = snakeToCamel(responseData, { 
        excludeFields: EXCLUDED_FIELDS,
        processDate: true,
        requestUrl: url
      });
      
      logger.info('cveService', 'CVE 상태 업데이트 성공', { 
        cveId, 
        status,
        responseStatus: response.status
      });
      
      return camelCaseData;
    } catch (error) {
      // 오류 로깅
      logger.error('cveService', 'CVE 상태 업데이트 실패', { 
        cveId, 
        status, 
        error: error.message
      });
      
      // 오류 메시지 개선 - skipAuthRefresh 관련 코드 제거
      const errorMessage = error.message || `CVE #${cveId} 상태 업데이트 실패`;
      
      // 단순한 Error 객체 반환 (axios 인터셉터 의존성 제거)
      const simpleError = new Error(errorMessage);
      simpleError.code = error.code || 500;
      simpleError.status = error.status || 500;
      
      throw simpleError;
    }
  }

  /**
   * CVE 삭제
   * @param {string} cveId - CVE ID
   * @param {Object} options - 요청 옵션
   * @returns {Promise<boolean>} 성공 여부
   */
  async deleteCVE(cveId, options = {}) {
    if (!cveId) {
      logger.warn('cveService', 'deleteCVE 호출 시 cveId가 없습니다');
      throw new Error('CVE ID는 필수 항목입니다');
    }

    try {
      logger.info('cveService', 'CVE 삭제 요청', { cveId });
      
      // 요청 옵션 설정
      const requestOptions = {
        ...(options || {}),
        skipAuthRefresh: options?.skipAuthRefresh ?? false
      };
      
      // DELETE 요청 보내기
      const response = await api.delete(`/cves/${cveId}`, { ...requestOptions });
      
      logger.info('cveService', 'CVE 삭제 성공', { 
        cveId,
        status: response.status
      });
      
      // 참고: 이 서비스 레이어에서는 캐시 무효화를 직접 처리하지 않음
      // React Query의 useMutation 훅에서 onSuccess 콜백을 통해 캐시 무효화 처리
      // queryClient.invalidateQueries([QUERY_KEYS.CVE_LIST]) 형태로 처리해야 함
      
      return true; // 삭제 성공 시 true 반환
    } catch (error) {
      logger.error('cveService', 'CVE 삭제 실패', { 
        cveId, 
        error: error.message,
        status: error.response?.status
      });
      
      // 에러 객체 강화 (config 정보 보존)
      const enhancedError = {
        ...error,
        code: error?.response?.status || 500,
        message: error?.response?.data?.detail || error?.response?.data?.message || error?.message || `CVE #${cveId} 삭제 실패`,
        config: {
          ...(error?.config || {}),
          skipAuthRefresh: options?.skipAuthRefresh ?? false
        }
      };
      
      throw enhancedError;
    }
  }

  /**
   * CVE 전체 개수 조회 (필터링 없이 DB에 존재하는 모든 CVE 개수)
   * @returns {Promise<number>} 전체 CVE 개수
   */
  async getTotalCVECount() {
    try {
      const response = await api.get('/cves/total-count');
      return response.data.count;
    } catch (error) {
      logger.error('cveService', '전체 CVE 개수 조회 실패', { error: error.message });
      throw this._handleError(error, '전체 CVE 개수 조회 실패');
    }
  }

  /**
   * 에러 핸들링 공통 메서드
   * @private
   * @param {Error} error - 발생한 에러
   * @param {string} defaultMessage - 기본 에러 메시지
   * @returns {Error} 처리된 에러
   */
  _handleError(error, defaultMessage = '요청 실패') {
    // axios 오류 형태 확인
    if (error.response) {
      // 서버 응답이 있지만 2xx 외의 상태 코드
      const statusCode = error.response.status;
      
      // 서버 메시지 추출 (detail 필드 우선, 없으면 message, error 순으로 확인)
      const serverMessage = 
        error.response.data?.detail || 
        error.response.data?.message || 
        error.response.data?.error || 
        '알 수 없는 서버 오류';
      
      // 특정 상태 코드에 따른 처리
      switch (statusCode) {
        case 400:
          return new Error(`잘못된 요청: ${serverMessage}`);
        case 401:
          return new Error('인증이 필요합니다');
        case 403:
          return new Error('권한이 없습니다');
        case 404:
          return new Error('자원을 찾을 수 없습니다');
        case 409:
          return new Error(`충돌 발생: ${serverMessage}`);
        case 422:
          return new Error(`유효성 검사 실패: ${serverMessage}`);
        case 500:
          return new Error(`서버 오류: ${serverMessage}`);
        default:
          return new Error(`${defaultMessage}: ${serverMessage} (${statusCode})`);
      }
    } else if (error.request) {
      // 요청은 보냈지만 응답이 없음 (네트워크 오류)
      return new Error('서버에서 응답이 없습니다. 네트워크 연결을 확인하세요.');
    } else {
      // 요청 설정 중 오류
      return new Error(`${defaultMessage}: ${error.message || '알 수 없는 오류'}`);
    }
  }
}

// cveService 싱글톤 객체 생성 및 내보내기
export default new CVEService();



============================================================
File: /home/CVEHub/frontend/src/features/cve/components/MentionInput.tsx
------------------------------------------------------------
import React, { useState, useRef, useCallback, useEffect, useLayoutEffect, ChangeEvent, KeyboardEvent, MouseEvent } from 'react';
import {
  TextField,
  Popper,
  Paper,
  List,
  ListItem,
  ListItemText,
  CircularProgress,
  Box,
  TextFieldProps
} from '@mui/material';
import api from 'shared/api/config/axios';
import logger from 'shared/utils/logging';
import { useQueryClient } from '@tanstack/react-query';
import { debounce } from 'lodash';

// 사용자 타입 정의
interface User {
  username: string;
  displayName?: string;
  [key: string]: any;
}

// 멘션 사용자 타입 정의
export interface MentionUser {
  id: string;
  display: string;
}

// 컴포넌트 Props 타입 정의
interface MentionInputProps {
  value: string;
  onChange?: (value: string) => void;
  onSubmit?: (value: string) => void;
  placeholder?: string;
  loading?: boolean;
  fullWidth?: boolean;
  multiline?: boolean;
  rows?: number;
  variant?: TextFieldProps['variant'];
  size?: TextFieldProps['size'];
  users?: MentionUser[];
  inputRef?: React.RefObject<HTMLDivElement>;
}

// 멘션 상태 타입 정의
interface MentionState {
  active: boolean;
  query: string;
  startPos: number;
}

// ResizeObserver 오류 방지 함수
const preventResizeObserverError = (): void => {
  // ResizeObserver 루프 오류 방지를 위한 전역 핸들러
  window.addEventListener('error', (e: ErrorEvent) => {
    if (e.message === 'ResizeObserver loop limit exceeded' ||
        e.message.includes('ResizeObserver') ||
        e.message.includes('loop completed with undelivered notifications')) {
      e.stopImmediatePropagation();
      return true;
    }
    return false;
  });
};

const MentionInput: React.FC<MentionInputProps> = ({
  value,
  onChange,
  onSubmit,
  placeholder,
  loading = false,
  fullWidth = true,
  multiline = true,
  rows = 3,
  variant = "outlined",
  size = "small",
  users = [],
  inputRef: externalInputRef
}) => {
  const [inputValue, setInputValue] = useState<string>(value || '');
  const [mentionState, setMentionState] = useState<MentionState>({ active: false, query: '', startPos: 0 });
  const [suggestions, setSuggestions] = useState<User[]>([]);
  const [anchorEl, setAnchorEl] = useState<HTMLDivElement | null>(null);
  const [selectedIndex, setSelectedIndex] = useState<number>(0);
  const [searchLoading, setSearchLoading] = useState<boolean>(false);
  const internalInputRef = useRef<HTMLDivElement | null>(null);
  const inputRef = externalInputRef || internalInputRef;
  const queryClient = useQueryClient();
  const lastSearchRef = useRef<string>('');

  // 디바운스된 검색 함수 생성
  const debouncedSearch = useRef(
    debounce(async (query: string) => {
      if (!query || query.length < 2 || query === lastSearchRef.current) {
        return;
      }
      
      lastSearchRef.current = query;
      setSearchLoading(true);
      
      try {
        // 외부에서 전달받은 users가 있는 경우 사용
        if (users && users.length > 0) {
          const filteredUsers = users
            .filter(user => user.id.toLowerCase().includes(query.toLowerCase()) || 
                           user.display.toLowerCase().includes(query.toLowerCase()))
            .map(user => ({
              username: user.id,
              displayName: user.display
            }));
          
          setSuggestions(filteredUsers);
          setSearchLoading(false);
          return;
        }
        
        // 외부 users가 없는 경우 API 호출
        // 캐시에서 검색 결과 확인
        const cacheKey = ['auth', 'search', query];
        const cachedResults = queryClient.getQueryData<User[]>(cacheKey);
        
        if (cachedResults) {
          setSuggestions(cachedResults);
          setSearchLoading(false);
          return;
        }
        
        const response = await api.get('/auth/search', {
          params: { query }
        });
        
        // 개발 환경에서만 로그 출력
        if (process.env.NODE_ENV === 'development') {
          logger.debug('[MentionInput] Search query:', query);
          logger.debug('[MentionInput] Search results:', response.data);
        }
        
        // 응답 데이터 안전하게 처리
        const responseData = response.data || [];
        
        if (Array.isArray(responseData)) {
          setSuggestions(responseData);
          // 결과를 캐시에 저장
          queryClient.setQueryData(cacheKey, responseData);
        } else {
          logger.error('[MentionInput] Invalid response format:', response.data);
          setSuggestions([]);
        }
      } catch (error) {
        logger.error('[MentionInput] Search error:', error);
        setSuggestions([]);
      } finally {
        setSearchLoading(false);
      }
    }, 300) // 300ms 디바운스
  ).current;

  // 멘션 쿼리가 변경될 때 검색 실행
  useEffect(() => {
    if (mentionState.active && mentionState.query) {
      const cleanQuery = mentionState.query.trim();
      if (cleanQuery.length >= 2) {
        debouncedSearch(cleanQuery);
      } else if (cleanQuery.length === 0) {
        setSuggestions([]);
      }
    }
    
    return () => {
      debouncedSearch.cancel(); // 컴포넌트 언마운트 시 디바운스 취소
    };
  }, [mentionState.query, debouncedSearch]);

  // 컴포넌트 마운트 시 ResizeObserver 오류 방지 함수 실행
  useEffect(() => {
    preventResizeObserverError();
  }, []);

  // 입력 요소의 너비를 측정하여 Popper 너비 설정
  useLayoutEffect(() => {
    if (inputRef.current && mentionState.active) {
      try {
        const width = inputRef.current.offsetWidth;
        setAnchorEl(inputRef.current);
      } catch (e) {
        setAnchorEl(null);
      }
    }
  }, [mentionState.active]);

  // 입력 처리
  const handleInputChange = useCallback((e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const newText = e.target.value;
    const cursorPos = e.target.selectionStart || 0;
    
    setInputValue(newText);
    setMentionState((prev) => ({ ...prev, startPos: cursorPos }));

    // @ 문자 이후의 텍스트 추출
    const textBeforeCursor = newText.slice(0, cursorPos);
    const lastAtSymbol = textBeforeCursor.lastIndexOf('@');
    
    if (lastAtSymbol !== -1 && lastAtSymbol < cursorPos) {
      const searchText = textBeforeCursor.slice(lastAtSymbol + 1);
      // 한글, 영문, 숫자만 허용하는 정규식
      const validSearchPattern = /^[가-힣a-zA-Z0-9\s]*$/;
      
      if (validSearchPattern.test(searchText)) {
        setMentionState((prev) => ({ ...prev, active: true, query: searchText }));
      } else {
        setMentionState((prev) => ({ ...prev, active: false, query: '' }));
        setAnchorEl(null);
        setSuggestions([]);
      }
    } else {
      setMentionState((prev) => ({ ...prev, active: false, query: '' }));
      setAnchorEl(null);
      setSuggestions([]);
    }
    
    if (onChange) {
      onChange(newText);
    }
  }, [onChange]);

  // 멘션 클릭 처리
  const handleMentionClick = useCallback((username: string) => {
    const textBeforeMention = inputValue.slice(0, mentionState.startPos);
    const lastAtSymbol = textBeforeMention.lastIndexOf('@');
    const textAfterMention = inputValue.slice(mentionState.startPos);
    
    const newText = 
      textBeforeMention.slice(0, lastAtSymbol) + 
      `@${username} ` + 
      textAfterMention;
    
    setInputValue(newText);
    setMentionState((prev) => ({ ...prev, active: false, query: '' }));
    setAnchorEl(null);
    setSuggestions([]);
    
    if (onChange) {
      onChange(newText);
    }
  }, [inputValue, mentionState.startPos, onChange]);

  // 포커스가 외부로 이동했을 때 팝업 닫기
  const handleClickAway = useCallback(() => {
    setMentionState((prev) => ({ ...prev, active: false, query: '' }));
    setAnchorEl(null);
    setSuggestions([]);
  }, []);

  // Enter 키 처리 함수 추가
  const handleKeyDown = useCallback((e: KeyboardEvent<HTMLDivElement>) => {
    // multiline이 true일 때는 Shift + Enter로 줄바꿈
    // multiline이 false일 때는 Enter로 제출
    if (e.key === 'Enter' && !e.shiftKey && !multiline) {
      e.preventDefault();
      if (onSubmit && inputValue.trim()) {
        onSubmit(inputValue);
      }
    }
    
    // ESC 키로 멘션 팝업 닫기
    if (e.key === 'Escape' && mentionState.active) {
      e.preventDefault();
      setMentionState((prev) => ({ ...prev, active: false, query: '' }));
      setAnchorEl(null);
      setSuggestions([]);
    }
  }, [onSubmit, inputValue, multiline, mentionState.active]);

  // 컴포넌트 언마운트 시 타이머 정리
  useEffect(() => {
    return () => {
      debouncedSearch.cancel(); // 컴포넌트 언마운트 시 디바운스 취소
    };
  }, [debouncedSearch]);

  return (
    <Box onClick={handleClickAway}>
      <div style={{ position: 'relative' }}>
        <TextField
          fullWidth={fullWidth}
          multiline={multiline}
          rows={rows}
          value={inputValue}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          variant={variant}
          size={size}
          inputRef={inputRef}
          disabled={loading}
        />
        {mentionState.active && Boolean(anchorEl) && suggestions.length > 0 && (
          <Popper
            open={true}
            anchorEl={anchorEl}
            placement="bottom-start"
            style={{ width: 'auto', zIndex: 1300 }}
          >
            <Paper 
              elevation={3}
              sx={{
                maxHeight: '200px',
                overflow: 'auto',
                mt: 1
              }}
            >
              <List>
                {searchLoading ? (
                  <ListItem>
                    <CircularProgress size={20} />
                  </ListItem>
                ) : suggestions.length > 0 ? (
                  suggestions.map((user) => (
                    <ListItem
                      key={user.username}
                      button
                      onClick={() => handleMentionClick(user.username)}
                      sx={{
                        '&:hover': {
                          backgroundColor: 'action.hover'
                        }
                      }}
                    >
                      <ListItemText 
                        primary={user.username}
                        secondary={user.displayName || user.username}
                        primaryTypographyProps={{
                          variant: 'body2',
                          fontWeight: 'medium'
                        }}
                        secondaryTypographyProps={{
                          variant: 'caption'
                        }}
                      />
                    </ListItem>
                  ))
                ) : (
                  <ListItem>
                    <ListItemText 
                      primary="검색 결과가 없습니다."
                      sx={{ textAlign: 'center', color: 'text.secondary' }}
                    />
                  </ListItem>
                )}
              </List>
            </Paper>
          </Popper>
        )}
      </div>
    </Box>
  );
};

export default MentionInput;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/CommentsTab.tsx
------------------------------------------------------------
import React, { useState, useEffect, useCallback, useMemo, useRef, memo, Fragment } from 'react';
import {
  Box,
  Typography,
  Button,
  CircularProgress,
} from '@mui/material';
import Comment from './Comment';
import MentionInput from './MentionInput';
import api from 'shared/api/config/axios';
import { useSnackbar } from 'notistack';
import { useQueryClient, useQuery } from '@tanstack/react-query';
import {
  ListHeader,
  EmptyState
} from './CommonStyles';
import { Comment as CommentIcon } from '@mui/icons-material';
import { SOCKET_EVENTS } from 'core/socket/services/constants';
import logger from 'shared/utils/logging';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { useSocket } from 'core/socket/hooks/useSocket';

// 커스텀 훅과 타입 임포트
import { useCommentMutations } from 'features/cve/hooks/useCommentMutation';
import { CommentData, CommentProps } from 'features/cve/types/CommentTypes';
import { MentionUser } from '../types';

// 사용자 타입 정의
interface User {
  id: string;
  username: string;
  displayName?: string;
  profileImage?: string;
  isAdmin?: boolean;
}

// CVE 상세 데이터 타입
interface CVEDetailData {
  cveId: string;
  comments?: CommentData[];
  [key: string]: any;
}

// 컴포넌트 Props 타입
interface CommentsTabProps {
  cve: CVEDetailData;
  onCommentCountChange?: (count: number) => void;
  currentUser?: User | null;
  refreshTrigger?: number;
  parentSendMessage?: (type: string, data: Record<string, unknown>) => Promise<boolean | null> | boolean | null;
  highlightCommentId?: string | null;
}

/**
 * 댓글 탭 컴포넌트
 */
const CommentsTab: React.FC<CommentsTabProps> = memo((props) => {
  const {
    cve,
    onCommentCountChange,
    currentUser,
    refreshTrigger = 0,
    parentSendMessage,
  } = props;

  const { enqueueSnackbar } = useSnackbar();
  const queryClient = useQueryClient();

  // --- 상태 관리 ---
  const [newComment, setNewComment] = useState<string>('');
  const [replyingTo, setReplyingTo] = useState<CommentData | null>(null);
  const [editingCommentId, setEditingCommentId] = useState<string | null>(null);
  const [mentionInputKey, setMentionInputKey] = useState<number>(0);

  const commentInputRef = useRef<HTMLDivElement>(null);

  // --- useSocket 훅 사용 ---
  const { emit, on, connected } = useSocket();

  // --- 핸들러 함수 ---
  const handleStartEdit = useCallback((commentId: string): void => {
    setEditingCommentId(commentId);
    setReplyingTo(null);
  }, []);

  const handleFinishEdit = useCallback((): void => {
    setEditingCommentId(null);
  }, []);

  const handleStartReply = useCallback((comment: CommentData): void => {
    setReplyingTo(comment);
    setEditingCommentId(null);
  }, []);

  const handleCancelReply = useCallback((): void => {
    setReplyingTo(null);
  }, []);
  
  // --- 댓글 관련 웹소켓 이벤트 처리 ---
  
  // 새 댓글 알림 처리 콜백
  const handleCommentNotification = useCallback((message: { type: string; data?: { author?: string } }): void => {
    if (
      message.type === SOCKET_EVENTS.COMMENT_ADDED &&
      message.data?.author &&
      currentUser?.username &&
      message.data.author !== currentUser.username
    ) {
      logger.info('CommentsTab', '새로운 댓글 알림 수신', { author: message.data.author });
      enqueueSnackbar('새로운 댓글이 작성되었습니다.', {
        variant: 'info',
        autoHideDuration: 3000,
        anchorOrigin: { vertical: 'bottom', horizontal: 'right' }
      });
    }
  }, [currentUser?.username, enqueueSnackbar]);

  // 댓글 캐시 업데이트 함수 (웹소켓 수신 시)
  const updateCommentsCache = useCallback((
    cachedData: CVEDetailData | undefined, 
    eventData: { type: string; data?: { comments?: CommentData[] }; updateId?: string | number }
  ): CVEDetailData | undefined => {
    if (!cachedData || !eventData?.data?.comments) {
      return cachedData; // 업데이트할 데이터 없으면 원본 반환
    }
    logger.info('CommentsTab', '웹소켓: 댓글 캐시 업데이트', { eventType: eventData.type, updateId: eventData.updateId || Date.now() });
    // 새 데이터 객체 생성 및 댓글 업데이트
    return { ...cachedData, comments: eventData.data.comments };
  }, []);

  // 댓글 관련 웹소켓 이벤트 리스너 등록 및 해제
  useEffect(() => {
    if (!connected || !cve.cveId) return; // 연결 및 cveId 확인

    const queryKey = QUERY_KEYS.CVE.detail(cve.cveId);

    const handleSocketEvent = (eventName: string, eventData: any): void => {
      logger.info(`CommentsTab: Socket ${eventName} 수신`, eventData);
      
      // 알림 처리
      if (eventName === SOCKET_EVENTS.COMMENT_ADDED) {
        handleCommentNotification(eventData);
      }
      
      // 캐시 업데이트 - 개선된 로직
      if (eventData?.data?.comments) {
        // 현재 캐시된 데이터 확인
        const currentData = queryClient.getQueryData<CVEDetailData>(queryKey);
        
        // 특별히 COMMENT_DELETED 이벤트인 경우, 이미 낙관적 업데이트가 적용된 상태라면
        // 깜빡임 방지를 위해 캐시 업데이트 스킵 (중복 업데이트 방지)
        if (eventName === SOCKET_EVENTS.COMMENT_DELETED && currentData?.comments) {
          const deletedCommentId = eventData.deletedCommentId;
          
          // 이미 낙관적으로 업데이트된 상태인지 확인
          const isAlreadyOptimisticallyUpdated = currentData.comments.some(
            c => (c.id === deletedCommentId && c.isOptimistic) ||
                 !currentData.comments.some(c => c.id === deletedCommentId)
          );
          
          if (isAlreadyOptimisticallyUpdated) {
            logger.info('CommentsTab: 이미 낙관적 업데이트가 적용됨, 소켓 업데이트 스킵', { 
              eventName, deletedCommentId 
            });
            // 낙관적 업데이트 마커 제거만 수행
            queryClient.setQueryData<CVEDetailData>(queryKey, (oldData) => {
              if (!oldData?.comments) return oldData;
              
              const sanitizedComments = oldData.comments.map(comment => {
                if (comment.isOptimistic) {
                  const { isOptimistic, ...rest } = comment as any;
                  return rest;
                }
                return comment;
              });
              
              return { ...oldData, comments: sanitizedComments };
            });
            return;
          }
        }
        
        // 일반적인 캐시 업데이트 진행
        queryClient.setQueryData<CVEDetailData>(queryKey, (oldData) =>
          updateCommentsCache(oldData, eventData)
        );
        
        // 댓글 수 업데이트
        const newActiveCount = (eventData.data.comments || []).filter((c: CommentData) => !c.isDeleted).length;
        onCommentCountChange?.(newActiveCount);
      } else if (eventName !== SOCKET_EVENTS.COMMENT_DELETED) {
        // COMMENT_DELETED가 아닌 이벤트에서만 캐시 무효화 고려
        // comments 데이터가 없으면 캐시 무효화 고려
        logger.warn(`Socket ${eventName}: comments 데이터 없음, 캐시 무효화`, { eventData });
        queryClient.invalidateQueries({ queryKey });
      }
    };

    const unsubAdded = on(SOCKET_EVENTS.COMMENT_ADDED, (data) => handleSocketEvent(SOCKET_EVENTS.COMMENT_ADDED, data));
    const unsubUpdated = on(SOCKET_EVENTS.COMMENT_UPDATED, (data) => handleSocketEvent(SOCKET_EVENTS.COMMENT_UPDATED, data));
    const unsubDeleted = on(SOCKET_EVENTS.COMMENT_DELETED, (data) => handleSocketEvent(SOCKET_EVENTS.COMMENT_DELETED, data));

    return () => {
      unsubAdded();
      unsubUpdated();
      unsubDeleted();
    };
  }, [connected, cve.cveId, queryClient, handleCommentNotification, updateCommentsCache, on, onCommentCountChange]);

  // --- 사용자 목록 조회 (멘션용) ---
  const { data: users = [], isLoading: isUsersLoading } = useQuery<User[], Error>({
    queryKey: ['users', 'search'],
    queryFn: async (): Promise<User[]> => {
      try {
        const response = await api.get<{ data: User[] }>('/auth/search');
        return response.data?.data || [];
      } catch (error) {
        logger.error('사용자 목록 조회 실패:', error);
        throw new Error('사용자 목록을 불러오는데 실패했습니다.');
      }
    },
    gcTime: 10 * 60 * 1000,
    staleTime: 5 * 60 * 1000,
    initialData: [],
  });

  // --- 데이터 가공 (Memoization) ---
  const organizeComments = useCallback((commentsArray: CommentData[] = []): CommentData[] => {
    // 입력 배열이 없을 경우 빈 배열 반환
    if (!commentsArray || commentsArray.length === 0) return [];

    const commentMap = new Map<string, CommentData>();
    const rootComments: CommentData[] = [];

    commentsArray.forEach(comment => {
      // isDeleted 댓글도 포함하여 Map 생성
      commentMap.set(comment.id, { ...comment, children: [], depth: 0 });
    });

    commentsArray.forEach(comment => {
      const current = commentMap.get(comment.id);
      if (current && comment.parentId && commentMap.has(comment.parentId)) {
        const parent = commentMap.get(comment.parentId);
        if (parent) {
          current.depth = (parent.depth ?? 0) + 1;
          parent.children = parent.children || []; // children 초기화
          parent.children.push(current);
        } else {
          current.depth = 0;
          rootComments.push(current);
        }
      } else if (current) {
        current.depth = 0;
        rootComments.push(current);
      }
    });

    const sortByDate = (arr: CommentData[]): void => {
      // Date 객체로 변환 후 비교 (타입 안정성)
      arr.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
      arr.forEach(item => {
        if (item.children && item.children.length > 0) {
          sortByDate(item.children);
        }
      });
    };

    sortByDate(rootComments);
    return rootComments;
  }, []);

  // 활성 댓글 수 계산
  const activeCommentCount = useMemo((): number => {
    return (cve.comments || []).filter(comment => !comment.isDeleted).length;
  }, [cve.comments]);

  // 계층 구조로 정리된 댓글 목록
  const organizedComments = useMemo((): CommentData[] => {
    // 댓글 목록 로깅 (디버깅 용도)
    logger.info('CommentsTab: 댓글 데이터 상태', { 
      cveId: cve.cveId,
      commentsAvailable: Array.isArray(cve.comments),
      commentsCount: Array.isArray(cve.comments) ? cve.comments.length : 0,
      firstComment: Array.isArray(cve.comments) && cve.comments.length > 0 ? cve.comments[0] : null
    });
    
    return organizeComments(cve.comments); // undefined 방지
  }, [cve.comments, organizeComments]);

  // 댓글 수 변경 시 콜백 호출
  useEffect(() => {
    onCommentCountChange?.(activeCommentCount);
  }, [activeCommentCount, onCommentCountChange]);

  // --- 댓글 관련 mutations 사용 ---
  const {
    createComment,
    editCommentMutation,
    replyCommentMutation,
    deleteCommentMutation,
    isLoading: isMutationLoading
  } = useCommentMutations(
    cve.cveId,
    currentUser,
    onCommentCountChange,
    parentSendMessage
  );

  // --- 입력 핸들러 ---
  const handleCommentChange = useCallback((value: string): void => {
    setNewComment(value);
  }, []);

  // 댓글 제출 핸들러
  const handleSubmit = useCallback((): void => {
    if (!newComment.trim()) {
      enqueueSnackbar('댓글 내용을 입력해주세요.', { variant: 'warning' });
      return;
    }
    createComment(newComment);
    // 성공 시 입력 필드 초기화
    setNewComment('');
    setMentionInputKey(prev => prev + 1);
  }, [newComment, createComment, enqueueSnackbar]);

  // 댓글 수정 핸들러
  const editComment = useCallback((commentId: string, content: string): Promise<any> => {
    return new Promise((resolve) => {
      if (!content.trim()) {
        enqueueSnackbar('댓글 내용을 입력해주세요.', { variant: 'warning' });
        resolve(null);
        return;
      }
      editCommentMutation.mutate({ commentId, content });
      resolve(null);
    });
  }, [editCommentMutation, enqueueSnackbar]);

  // 답글 작성 핸들러
  const replyComment = useCallback((parentId: string, content: string): Promise<any> => {
    return new Promise((resolve) => {
      if (!content.trim()) {
        enqueueSnackbar('답글 내용을 입력해주세요.', { variant: 'warning' });
        resolve(null);
        return;
      }
      replyCommentMutation.mutate({ parentId, content });
      setReplyingTo(null); // 답글 모드 종료
      resolve(null);
    });
  }, [replyCommentMutation, enqueueSnackbar, setReplyingTo]);

  // 댓글 삭제 핸들러
  const deleteComment = useCallback((commentId: string, permanent: boolean): Promise<any> => {
    return new Promise((resolve) => {
      deleteCommentMutation.mutate({ commentId, permanent });
      resolve(null);
    });
  }, [deleteCommentMutation]);

  // --- refreshTrigger 변경 시 캐시 무효화 ---
  useEffect(() => {
    if (refreshTrigger > 0 && cve.cveId) {
      logger.info('CommentsTab: refreshTrigger 변경, 캐시 무효화', { refreshTrigger });
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.CVE.detail(cve.cveId) });
    }
  }, [refreshTrigger, cve.cveId, queryClient]);

  // --- 댓글 렌더링 ---
  const CommentItem = useCallback(({ comment }: { comment: CommentData }) => {
    const isEditingThis = editingCommentId === comment.id;
    const isReplyingToThis = replyingTo?.id === comment.id;

    // MentionInput에 필요한 users 타입 변환
    const usersForMention: MentionUser[] = users.map(u => ({
      id: u.username,
      display: u.displayName || u.username,
    }));

    const commentProps: CommentProps = {
      comment,
      isEditing: isEditingThis,
      replyMode: isReplyingToThis,
      onStartEdit: handleStartEdit,
      onFinishEdit: handleFinishEdit,
      onEdit: editComment,
      onReply: handleStartReply,
      onReplyCancel: handleCancelReply,
      onReplySubmit: replyComment,
      onDelete: deleteComment,
      currentUsername: currentUser?.username,
      isAdmin: currentUser?.isAdmin ?? false,
      depth: comment.depth ?? 0,
      cveId: cve.cveId,
      usersForMention: usersForMention,
      parentSendMessage,
      isSubmitting: isMutationLoading,
    };
    return <Comment {...commentProps} />;
  }, [
    editingCommentId, 
    replyingTo, 
    handleStartEdit, 
    handleFinishEdit, 
    editComment, 
    handleStartReply, 
    handleCancelReply, 
    replyComment, 
    deleteComment, 
    currentUser, 
    cve.cveId, 
    users, 
    parentSendMessage, 
    isMutationLoading
  ]);

  const MemoizedCommentItem = useMemo(() => memo(CommentItem), [CommentItem]);

  // 재귀 댓글 렌더링
  const renderComment = useCallback((comment: CommentData) => {
    return (
      <Fragment key={comment.id}>
        <MemoizedCommentItem comment={comment} />
        {comment.children?.map(child => renderComment(child))}
      </Fragment>
    );
  }, [MemoizedCommentItem]);

  // MentionInput props 준비
  const mentionInputUsers: MentionUser[] = useMemo(() => users.map(u => ({
    id: u.username,
    display: u.displayName || u.username,
  })), [users]);

  // MentionInput 핸들러
  const handleMentionInputChange = useCallback((value: string | React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>): void => {
    if (typeof value === 'string') {
      setNewComment(value);
    } else {
      setNewComment(value.target.value);
    }
  }, []);

  return (
    <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <ListHeader>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <CommentIcon color="action" />
          <Typography variant="h6" color="text.primary">
            댓글 ({activeCommentCount})
          </Typography>
          {(isUsersLoading || isMutationLoading) && <CircularProgress size={20} sx={{ ml: 1 }} />}
        </Box>
      </ListHeader>

      {(!editingCommentId && !replyingTo) && (
        <Box sx={{ mb: 2, px: 2, flexShrink: 0 }}>
          <Box sx={{ display: 'flex', gap: 1, alignItems: 'flex-start' }}>
            <Box sx={{ flex: 1 }}>
              <MentionInput
                key={mentionInputKey}
                value={newComment}
                onChange={handleMentionInputChange}
                onSubmit={handleSubmit}
                placeholder="댓글을 입력하세요... (@로 사용자 멘션)"
                loading={isMutationLoading}
                users={mentionInputUsers}
                inputRef={commentInputRef}
              />
            </Box>
            <Button
              variant="contained"
              color="primary"
              onClick={handleSubmit}
              disabled={isMutationLoading || !newComment.trim()}
              sx={{ mt: '8px', height: 'fit-content' }}
            >
              {isMutationLoading ? '작성중...' : '작성'}
            </Button>
          </Box>
        </Box>
      )}

      <Box sx={{ flex: 1, overflowY: 'auto', px: 2, pb: 2 }}>
        {organizedComments.length > 0 ? (
          organizedComments.map(comment => renderComment(comment))
        ) : (
          // 데이터 로딩 중이 아닐 때만 빈 상태 표시
          !isUsersLoading && !isMutationLoading && (
            <EmptyState>
              <Typography variant="body1" color="text.secondary">
                아직 댓글이 없습니다. 첫 댓글을 작성해보세요!
              </Typography>
            </EmptyState>
          )
        )}
      </Box>
    </Box>
  );
});

CommentsTab.displayName = 'CommentsTab';
export default CommentsTab;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/SnortRulesTab.tsx
------------------------------------------------------------
import React, { memo } from 'react';
import GenericDataTab from './GenericDataTab';
import { snortRuleTabConfig } from './tabConfigs';
import { CVEDetail, SnortRule, GenericDataTabBaseProps, GenericDataTabProps, SnortRuleTabProps } from '../types/cve';

// SnortRuleTab 컴포넌트의 props 인터페이스 - types/cve.ts에 정의된 GenericDataTabBaseProps 사용

// 이전 버전과의 호환성을 위한 래퍼 컴포넌트
const SnortRuleTab: React.FC<SnortRuleTabProps> = memo((props) => {
  // GenericDataTab이 JavaScript로 작성되어 있어 타입스크립트 인터페이스와 호환되지 않음
  // any 타입으로 단언하여 타입 오류 해결
  return React.createElement(GenericDataTab as any, {
    ...props,
    tabConfig: snortRuleTabConfig
  });
});

// displayName 설정 (React DevTools에서 디버깅 시 유용)
SnortRuleTab.displayName = 'SnortRuleTab';

export default SnortRuleTab;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/SeverityChip.tsx
------------------------------------------------------------
import React from 'react';
import { Chip, Tooltip, Theme, useTheme } from '@mui/material';
import { alpha } from '@mui/system';
import { SeverityChipProps } from '../types/cve';

// 심각도 타입 정의
type SeverityLevel = 'critical' | 'high' | 'medium' | 'low' | 'unknown';

// 심각도 설정 인터페이스
interface SeverityConfig {
  color: string;
  backgroundColor: string;
  label: string;
  tooltip: string;
}

/**
 * CVE 심각도를 표시하는 칩 컴포넌트
 * @param {string} severity - 심각도 (critical, high, medium, low)
 * @returns {JSX.Element} 심각도 표시 Chip 컴포넌트
 */
const SeverityChip: React.FC<SeverityChipProps> = ({
  severity = 'unknown',
}) => {
  // 심각도 레벨에 따른 설정
  const severityConfig: Record<SeverityLevel, SeverityConfig> = {
    critical: {
      color: '#7b1fa2', // 보라색
      backgroundColor: '#f3e5f5',
      label: '심각',
      tooltip: '심각한 수준의 취약점입니다. 즉시 조치가 필요합니다.'
    },
    high: {
      color: '#c62828', // 빨간색
      backgroundColor: '#ffebee',
      label: '높음',
      tooltip: '높은 수준의 취약점입니다. 빠른 조치가 필요합니다.'
    },
    medium: {
      color: '#ef6c00', // 주황색
      backgroundColor: '#fff3e0',
      label: '중간',
      tooltip: '중간 수준의 취약점입니다. 계획적인 조치가 필요합니다.'
    },
    low: {
      color: '#2e7d32', // 초록색
      backgroundColor: '#e8f5e9',
      label: '낮음',
      tooltip: '낮은 수준의 취약점입니다. 일반적인 관리 체계 내에서 처리 가능합니다.'
    },
    unknown: {
      color: '#546e7a', // 회색
      backgroundColor: '#eceff1',
      label: '알 수 없음',
      tooltip: '심각도가 정의되지 않았거나 알 수 없는 수준입니다.'
    }
  };

  // 심각도 값이 없거나 유효하지 않은 경우 'unknown' 사용
  const normalizedSeverity = (severity && severity.toLowerCase() in severityConfig) 
    ? severity.toLowerCase() as SeverityLevel 
    : 'unknown';
  
  const config = severityConfig[normalizedSeverity];

  return (
    <Tooltip title={config.tooltip} arrow placement="top">
      <Chip
        label={config.label}
        size="small"
        sx={{
          color: config.color,
          backgroundColor: config.backgroundColor,
          fontWeight: 'bold',
          borderRadius: '4px',
          minWidth: '60px',
          '& .MuiChip-label': {
            padding: '0 8px',
          }
        }}
      />
    </Tooltip>
  );
};

// React 18에서는 defaultProps 대신 함수 매개변수 기본값 사용

export default SeverityChip;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/InlineEditText.tsx
------------------------------------------------------------
// InlineEditText.tsx
import React, { useState, useEffect, useRef, ChangeEvent, KeyboardEvent } from 'react';
import { TextField, Typography, Box, TextFieldProps } from '@mui/material';
import { Edit as EditIcon } from '@mui/icons-material';

interface InlineEditTextProps {
  value: string;
  onSave: (value: string) => void;
  placeholder?: string;
  multiline?: boolean;
  disabled?: boolean;
  maxHeight?: string | number;
  fontSize?: string | number;
  externalEdit?: boolean; // 외부에서 편집 모드를 제어하는 prop
  onEditingStart?: () => void;
  onEditingEnd?: () => void;
}

const InlineEditText: React.FC<InlineEditTextProps> = ({
  value,
  onSave,
  placeholder = '입력하세요...',
  multiline = false,
  disabled = false,
  maxHeight,
  fontSize = 'inherit',
  externalEdit = false,
  onEditingStart = () => {},
  onEditingEnd = () => {}
}) => {
  const [isEditing, setIsEditing] = useState(externalEdit);
  const [editedValue, setEditedValue] = useState(value || '');
  const textFieldRef = useRef<HTMLDivElement | null>(null);

  // 외부 prop이 변경되면 내부 상태를 업데이트
  useEffect(() => {
    setIsEditing(externalEdit);
  }, [externalEdit]);

  useEffect(() => {
    setEditedValue(value || '');
  }, [value]);

  // 텍스트 필드의 높이를 조정하는 함수
  const adjustTextFieldHeight = (): void => {
    if (multiline && textFieldRef.current) {
      const inputElement = textFieldRef.current.querySelector('textarea');
      if (inputElement) {
        // 자동 높이 조정 로직
        inputElement.style.height = 'auto';
        inputElement.style.height = `${inputElement.scrollHeight}px`;
      }
    }
  };

  // 편집 모드 변경 시 높이 조정
  useEffect(() => {
    if (isEditing) {
      adjustTextFieldHeight();
    }
  }, [isEditing, editedValue]);

  const handleClick = (e: React.MouseEvent): void => {
    if (!disabled && !isEditing) {
      setIsEditing(true);
      onEditingStart();
    }
  };

  const handleBlur = (): void => {
    if (editedValue !== value) {
      onSave(editedValue);
    }
    setIsEditing(false);
    onEditingEnd();
  };

  const handleKeyPress = (e: KeyboardEvent<HTMLDivElement>): void => {
    if (e.key === 'Enter' && !multiline) {
      if (editedValue !== value) {
        onSave(editedValue);
      }
      setIsEditing(false);
      onEditingEnd();
    }
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>): void => {
    setEditedValue(e.target.value);
    // 값이 변경될 때마다 높이 조정 (멀티라인인 경우)
    if (multiline) {
      setTimeout(adjustTextFieldHeight, 0);
    }
  };

  return (
    <Box
      onClick={handleClick}
      onMouseDown={(e) => e.stopPropagation()}
      sx={{
        position: 'relative',
        cursor: disabled ? 'default' : 'pointer',
        width: '100%',
        height: '100%',
      }}
    >
      {isEditing ? (
        <TextField
          inputRef={textFieldRef}
          fullWidth
          multiline={multiline}
          value={editedValue}
          onChange={handleChange}
          onBlur={handleBlur}
          onKeyPress={handleKeyPress}
          autoFocus
          variant="standard"
          InputProps={{
            sx: {
              fontSize: fontSize,
              '&:before, &:after': { display: 'none' },
            },
          }}
          sx={{
            '& .MuiInputBase-root': {
              padding: '4px 8px',
              bgcolor: 'background.paper',
              borderRadius: 1,
              width: '100%',
              overflow: multiline ? 'hidden' : 'auto',
            },
          }}
        />
      ) : (
        <Box
          sx={{
            display: 'flex',
            alignItems: 'flex-start',
            gap: 1,
            p: '4px 8px',
            height: '100%',
            overflow: 'hidden', // 스크롤 표시 안함
          }}
        >
          <Typography
            sx={{
              flex: 1,
              fontSize: fontSize,
              whiteSpace: multiline ? 'pre-wrap' : 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
            }}
          >
            {value || placeholder}
          </Typography>
          {!disabled && (
            <EditIcon
              className="edit-icon"
              sx={{
                fontSize: 16,
                opacity: 0,
                transition: 'opacity 0.2s',
                color: 'text.secondary',
                mt: 0.5,
                flexShrink: 0,
              }}
            />
          )}
        </Box>
      )}
    </Box>
  );
};

export default InlineEditText;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/PoCTab.tsx
------------------------------------------------------------
import React, { memo } from 'react';
import GenericDataTab from './GenericDataTab';
import { pocTabConfig } from './tabConfigs';
import { CVEDetail, SnortRule, GenericDataTabBaseProps, GenericDataTabProps, SnortRuleTabProps } from '../types/cve';

// SnortRuleTab 컴포넌트의 props 인터페이스 - types/cve.ts에 정의된 GenericDataTabBaseProps 사용

// 이전 버전과의 호환성을 위한 래퍼 컴포넌트
const pocTab: React.FC<SnortRuleTabProps> = memo((props) => {
  // GenericDataTab이 JavaScript로 작성되어 있어 타입스크립트 인터페이스와 호환되지 않음
  // any 타입으로 단언하여 타입 오류 해결
  return React.createElement(GenericDataTab as any, {
    ...props,
    tabConfig: pocTabConfig
  });
});

// displayName 설정 (React DevTools에서 디버깅 시 유용)
pocTab.displayName = 'SnortRuleTab';

export default pocTab;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/Comment.tsx
------------------------------------------------------------
import React, { useState, useMemo, ChangeEvent } from 'react';
import {
  Box,
  Typography,
  IconButton,
  Button,
  Stack,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions
} from '@mui/material';
import {
  Delete as DeleteIcon,
  Edit as EditIcon,
  Reply as ReplyIcon,
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon
} from '@mui/icons-material';
import { formatDistanceToNow, parseISO } from 'date-fns';
import { ko } from 'date-fns/locale';
import { StyledListItem } from './CommonStyles';
import MentionInput from './MentionInput';
import { highlightMentions } from 'shared/utils/mentionUtils';
import { CommentProps } from '../types/cve';

/**
 * 댓글 컴포넌트
 */
const Comment: React.FC<CommentProps> = React.memo(({
  comment,
  depth = 0,
  currentUsername,
  isAdmin,
  isEditing,
  onEdit,
  onDelete,
  onReplySubmit,
  onReply,        // 부모에서 관리하는 답글 모드 시작 핸들러
  onReplyCancel,  // 부모에서 관리하는 답글 모드 종료 핸들러
  replyMode,      // 부모에서 전달받은 현재 답글 모드 여부
  children,
  onStartEdit,
  onFinishEdit,
}) => {
  // 수정 모드에서의 로컬 입력 상태
  const [editContent, setEditContent] = useState<string>(comment.content);
  // 답글 입력 상태
  const [replyContent, setReplyContent] = useState<string>('');
  // 삭제 확인 다이얼로그 상태
  const [deleteDialogOpen, setDeleteDialogOpen] = useState<boolean>(false);
  // 삭제된 댓글 원본 보기 토글
  const [showOriginal, setShowOriginal] = useState<boolean>(false);

  const isDeleted = comment.isDeleted;
  const isAuthor = currentUsername === comment.createdBy;
  const canModify = isAdmin || isAuthor;

  // 날짜 포맷 함수를 useMemo로 최적화
  const formattedDate = useMemo(() => {
    if (!comment.createdAt) return '';
    try {
      const date = typeof comment.createdAt === 'string' 
        ? parseISO(comment.createdAt) 
        : comment.createdAt;
      return formatDistanceToNow(date, { addSuffix: true, locale: ko });
    } catch {
      return typeof comment.createdAt === 'string' 
        ? comment.createdAt 
        : comment.createdAt.toString();
    }
  }, [comment.createdAt]);

  // 수정 모드 토글
  const handleEditToggle = (): void => {
    if (isEditing) {
      console.log('=== Comment Edit Debug ===');
      console.log('Saving edited comment:', {
        commentId: comment.id,
        content: editContent,
        currentUser: currentUsername
      });

      onEdit?.(comment.id || '', editContent)
        .then(response => {
          console.log('Edit success:', response);
          onFinishEdit?.();
        })
        .catch(error => {
          console.error('Edit error:', {
            status: error.response?.status,
            data: error.response?.data,
            message: error.message
          });
        });
    } else {
      setEditContent(comment.content);
      onStartEdit?.(comment.id || '');
    }
  };

  const handleCancelEdit = (): void => {
    onFinishEdit?.();
  };

  // 삭제 다이얼로그
  const handleDeleteClick = (): void => {
    console.log('=== Comment Delete Debug ===');
    console.log('Opening delete dialog:', {
      commentId: comment.id,
      currentUser: currentUsername,
      isAdmin
    });
    setDeleteDialogOpen(true);
  };

  const handleDeleteConfirm = (permanent: boolean = false): void => {
    console.log('Confirming delete:', {
      commentId: comment.id,
      permanent,
      currentUser: currentUsername
    });

    onDelete?.(comment.id || '', permanent)
      .then(response => {
        console.log('Delete success:', response);
        setDeleteDialogOpen(false);
      })
      .catch(error => {
        console.error('Delete error:', {
          status: error.response?.status,
          data: error.response?.data,
          message: error.message
        });
      });
  };

  // 답글 아이콘 클릭
  const handleReplyIconClick = (): void => {
    if (replyMode) {
      // 이미 답글 모드 -> 취소
      onReplyCancel?.();
      setReplyContent('');
    } else {
      // 답글 모드 시작
      onReply?.(comment);
    }
  };

  // 답글 제출
  const handleReplySubmitLocal = (): void => {
    if (!replyContent.trim()) return;
    
    console.log('=== Comment Reply Debug ===');
    console.log('Submitting reply:', {
      parentId: comment.id,
      content: replyContent,
      currentUser: currentUsername
    });

    onReplySubmit?.(comment.id || '', replyContent)
      .then(response => {
        console.log('Reply submission success:', response);
        onReplyCancel?.();
        setReplyContent('');
      })
      .catch(error => {
        console.error('Reply submission error:', {
          status: error.response?.status,
          data: error.response?.data,
          message: error.message
        });
      });
  };

  // 댓글 내용 렌더링
  const renderContent = (): React.ReactNode => {
    // 수정 모드
    if (isEditing) {
      return (
        <Box sx={{ mt: 1 }}>
          <MentionInput
            value={editContent}
            onChange={(value: string) => setEditContent(value)}
            placeholder="댓글을 수정하세요..."
          />
          <Stack direction="row" spacing={1} sx={{ mt: 1, justifyContent: 'flex-end' }}>
            <Button size="small" onClick={handleCancelEdit}>
              취소
            </Button>
            <Button 
              size="small" 
              variant="contained"
              onClick={handleEditToggle}
              disabled={!editContent.trim()}
            >
              수정 완료
            </Button>
          </Stack>
        </Box>
      );
    }

    // 삭제된 댓글 처리
    if (isDeleted && !showOriginal) {
      return (
        <Typography variant="body2" color="text.secondary" sx={{ fontStyle: 'italic' }}>
          삭제된 댓글입니다.
        </Typography>
      );
    }

    // 일반 댓글
    return (
      <Typography
        variant="body2"
        component="div"
        dangerouslySetInnerHTML={{
          __html: highlightMentions(comment.content),
        }}
        sx={{
          wordBreak: 'break-word',
          '& .mention': {
            color: 'primary.main',
            fontWeight: 'medium',
            '&:hover': {
              textDecoration: 'underline',
              cursor: 'pointer',
            },
          },
        }}
      />
    );
  };

  return (
    <StyledListItem
      elevation={1}
      sx={{
        ml: depth * 3,  // 들여쓰기 간격
        border: '1px solid',
        borderColor: 'divider',
        borderLeft: depth > 0 ? `2px solid rgba(25, 118, 210, 0.12)` : '1px solid rgba(0, 0, 0, 0.12)',  // primary 컬러의 연한 버전
        position: 'relative',
        '&::before': depth > 0 ? {
          content: '""',
          position: 'absolute',
          left: -16,
          top: 0,
          bottom: 0,
          width: 16,
          borderLeft: '1px solid',
          borderColor: 'divider',
          opacity: 0.5
        } : {}
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 1 }}>
        <Box sx={{ flex: 1 }}>
          {/* 작성자 + 시간 */}
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
            <Typography variant="subtitle2">{comment.createdBy}</Typography>
            <Typography variant="caption" color="text.secondary">
              {formattedDate}
            </Typography>
          </Box>

          {/* 댓글 본문 */}
          {renderContent()}
        </Box>

        {/* 우측 아이콘들 */}
        <Box>
          {!isDeleted && (
            <Stack direction="row" spacing={1}>
              {canModify && (
                <>
                  {/* 수정 아이콘 */}
                  <IconButton size="small" onClick={handleEditToggle}>
                    <EditIcon fontSize="small" />
                  </IconButton>
                  {/* 삭제 아이콘 */}
                  <IconButton size="small" onClick={handleDeleteClick} color="error">
                    <DeleteIcon fontSize="small" />
                  </IconButton>
                </>
              )}
              {/* 답글 아이콘 */}
              <IconButton size="small" onClick={handleReplyIconClick}>
                <ReplyIcon fontSize="small" />
              </IconButton>
            </Stack>
          )}
          {isDeleted && isAdmin && (
            <Stack direction="row" spacing={1}>
              <Tooltip title="영구 삭제">
                <IconButton size="small" onClick={handleDeleteClick} color="error">
                  <DeleteIcon fontSize="small" />
                </IconButton>
              </Tooltip>
              <Tooltip title={showOriginal ? '삭제된 댓글 숨기기' : '삭제된 댓글 보기'}>
                <IconButton size="small" onClick={() => setShowOriginal(!showOriginal)}>
                  {showOriginal ? <VisibilityOffIcon fontSize="small" /> : <VisibilityIcon fontSize="small" />}
                </IconButton>
              </Tooltip>
            </Stack>
          )}
        </Box>
      </Box>

      {/* 답글 작성 영역 */}
      {replyMode && !isDeleted && (
        <Box sx={{ mt: 2 }}>
          <MentionInput
            value={replyContent}
            onChange={(value: string) => setReplyContent(value)}
            placeholder="답글을 입력하세요..."
          />
          <Stack direction="row" spacing={1} sx={{ mt: 1, justifyContent: 'flex-end' }}>
            <Button
              size="small"
              onClick={() => {
                onReplyCancel?.();
                setReplyContent('');
              }}
            >
              취소
            </Button>
            <Button
              size="small"
              variant="contained"
              onClick={handleReplySubmitLocal}
              disabled={!replyContent.trim()}
            >
              답글 달기
            </Button>
          </Stack>
        </Box>
      )}

      {/* 삭제 다이얼로그 */}
      <Dialog open={deleteDialogOpen} onClose={() => setDeleteDialogOpen(false)}>
        <DialogTitle>댓글 삭제</DialogTitle>
        <DialogContent>
          {isAdmin ? (
            <>
              <Typography>관리자 권한으로 삭제 방식을 선택할 수 있습니다.</Typography>
              <Typography color="error" sx={{ mt: 1 }}>
                * 영구 삭제된 댓글은 복구할 수 없습니다.
              </Typography>
            </>
          ) : (
            <Typography>이 댓글을 삭제하시겠습니까?</Typography>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteDialogOpen(false)}>취소</Button>
          {isAdmin ? (
            <>
              <Button onClick={() => handleDeleteConfirm(false)} color="warning">
                일반 삭제
              </Button>
              <Button onClick={() => handleDeleteConfirm(true)} color="error">
                영구 삭제
              </Button>
            </>
          ) : (
            <Button onClick={() => handleDeleteConfirm(false)} color="error">
              삭제
            </Button>
          )}
        </DialogActions>
      </Dialog>

      {/* 자식(대댓글) */}
      {children}
    </StyledListItem>
  );
}, (prevProps, nextProps) => {
  // 최적화된 비교 로직
  return prevProps.comment.id === nextProps.comment.id &&
         prevProps.comment.content === nextProps.comment.content &&
         prevProps.comment.lastModifiedAt === nextProps.comment.lastModifiedAt &&
         prevProps.comment.isDeleted === nextProps.comment.isDeleted &&
         prevProps.isEditing === nextProps.isEditing &&
         prevProps.replyMode === nextProps.replyMode;
});

// displayName 설정 (디버깅 용이성 향상)
Comment.displayName = 'Comment';

export default Comment;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/tabConfigs.tsx
------------------------------------------------------------
// tabConfigs.ts
import React, { ReactElement, ReactNode } from 'react';
import {
  Science as ScienceIcon,
  Shield as ShieldIcon,
  Link as LinkIcon,
  Code as CodeIcon,
} from '@mui/icons-material';
import {
  Chip,
  Typography,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  TextField,
  SelectChangeEvent,
  ChipProps
} from '@mui/material';
// 타입을 임포트
import {
  PoCSourceInfo,
  RuleTypeInfo,
  BaseItem,
  PoCItem,
  SnortRuleItem,
  ReferenceItem,
  DataItem,
  ExtendedTabConfig
} from '../types/TabTypes';
// ChipLabel이 CommonStyles에 정의되어 있다고 가정
import { ChipLabel } from './CommonStyles'; // 경로 확인 필요

// --- PoC 탭 설정 ---
export const POC_SOURCES: Record<string, PoCSourceInfo> = {
  Etc: { label: 'Etc', color: 'default' },
  Metasploit: { label: 'Metasploit', color: 'secondary' },
  'Nuclei-Templates': { label: 'Nuclei Templates', color: 'primary' },
  GitHub: { label: 'GitHub', color: 'info' },
  ExploitDB: { label: 'Exploit-DB', color: 'warning' },
};

export const DEFAULT_POC: PoCItem = {
  source: 'Etc',
  url: '',
  description: '',
};

export const pocTabConfig: ExtendedTabConfig<PoCItem> = {
  icon: CodeIcon,
  title: 'Proof of Concept',
  itemName: 'PoC',
  dataField: 'poc',
  wsFieldName: 'poc',
  defaultItem: DEFAULT_POC,
  emptyTitle: '등록된 PoC 정보 없음',
  emptyDescription: '아직 이 취약점에 대한 PoC 코드가 등록되지 않았습니다.',
  addButtonText: 'PoC 추가',
  editButtonText: 'PoC 수정',
  deleteButtonText: 'PoC 삭제',
  validateItem: (item) => (item.url && item.url.trim() !== '') || 'URL은 필수 항목입니다.',
  checkDuplicate: (item, items, excludeIndex = -1) => {
    const currentUrl = item.url.trim().toLowerCase();
    return (items || []).some((poc, index) =>
      index !== excludeIndex && poc.url.trim().toLowerCase() === currentUrl
    );
  },
  
  renderItemLabel: (item: PoCItem): ReactElement => (
    <>
      <Chip
        label={
          <ChipLabel>
            <CodeIcon sx={{ fontSize: 16, mr: 0.5 }} />
            {POC_SOURCES[item.source]?.label || item.source}
          </ChipLabel>
        }
        size="small"
        color={POC_SOURCES[item.source]?.color || 'default'}
        variant="outlined"
        sx={{ minWidth: 80, mr: 1 }}
      />
      <Typography
        component="a"
        href={item.url.startsWith('http') ? item.url : `https://${item.url}`}
        target="_blank"
        rel="noopener noreferrer"
        sx={{
          color: 'info.main',
          textDecoration: 'none',
          fontWeight: 400,
          wordBreak: 'break-all',
          '&:hover': { textDecoration: 'underline', color: 'info.dark' },
        }}
      >
        {item.url}
      </Typography>
    </>
  ),
  renderDialogContent: (item: PoCItem, updateItemState: <K extends keyof PoCItem>(item: PoCItem, field: K, value: PoCItem[K]) => void, isEdit: boolean): ReactElement => (
    <>
      <FormControl fullWidth margin="normal">
        <InputLabel id="poc-source-label">Source</InputLabel>
        <Select
          labelId="poc-source-label"
          value={item.source}
          onChange={(e: SelectChangeEvent) => updateItemState(item, 'source', e.target.value as string)}
          label="Source"
        >
          {Object.entries(POC_SOURCES).map(([value, { label }]) => (
            <MenuItem key={value} value={value}>{label}</MenuItem>
          ))}
        </Select>
      </FormControl>
      <TextField
        required
        fullWidth
        margin="normal"
        label="URL"
        value={item.url}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => updateItemState(item, 'url', e.target.value)}
        error={!item.url || item.url.trim() === ''}
        helperText={!item.url || item.url.trim() === '' ? "URL은 필수 입력 항목입니다." : ""}
        placeholder="https://example.com/poc"
      />
      <TextField
        fullWidth
        margin="normal"
        label="Description (Optional)"
        value={item.description || ''}
        onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => updateItemState(item, 'description', e.target.value)}
        multiline
        rows={3}
      />
    </>
  )
}; // 세미콜론 추가

// --- Snort Rules 탭 설정 ---
export const RULE_TYPES: Record<string, RuleTypeInfo> = {
  USER_DEFINED: { label: '사용자 정의', color: 'default' },
  IPS: { label: 'IPS', color: 'primary' },
  ONE: { label: 'ONE', color: 'secondary' },
  UTM: { label: 'UTM', color: 'success' },
  'Emerging-Threats': { label: 'Emerging Threats', color: 'warning' },
  SNORT_OFFICIAL: { label: 'Snort Official', color: 'info' }
};

export const DEFAULT_RULE: SnortRuleItem = {
  type: 'Emerging-Threats',
  rule: '',
  description: '',
};

export const snortRuleTabConfig: ExtendedTabConfig<SnortRuleItem> = {
  icon: ShieldIcon,
  title: 'Snort Rules',
  itemName: '규칙',
  dataField: 'snortRule',
  wsFieldName: 'snort_rule',
  defaultItem: DEFAULT_RULE,
  emptyTitle: '등록된 Snort 규칙 없음',
  emptyDescription: '아직 이 취약점에 대한 Snort 규칙이 정의되지 않았습니다.',
  addButtonText: '규칙 추가',
  editButtonText: '규칙 수정',
  deleteButtonText: '규칙 삭제',
  validateItem: (item) => (item.rule && item.rule.trim() !== '') || '규칙 내용은 필수 항목입니다.',
  prepareItemForSave: (item, isUpdate, kstTime) => {
    const now = kstTime?.toISOString() || new Date().toISOString();
    const username = item.currentUser?.username || 'anonymous';
    if (isUpdate) {
      return {
        id: item.id, // 수정 시 ID 포함
        type: item.type,
        rule: item.rule,
        description: item.description,
        last_modified_at: now,
        last_modified_by: username,
      };
    } else {
      return {
        type: item.type,
        rule: item.rule,
        description: item.description,
        created_at: now,
        created_by: username,
      };
    }
  },
  renderItemLabel: (item: SnortRuleItem): ReactElement => (
    <Chip
      label={
        <ChipLabel>
          <ShieldIcon sx={{ fontSize: 16, mr: 0.5 }} />
          {RULE_TYPES[item.type]?.label || item.type}
        </ChipLabel>
      }
      size="small"
      color={RULE_TYPES[item.type]?.color || 'default'}
      variant="outlined"
      sx={{ minWidth: 80 }}
    />
  ),
  renderItemContent: (item) => (
    <Typography
      variant="body2"
      component="pre"
      sx={{
        fontSize: '0.813rem',
        fontFamily: 'monospace',
        maxHeight: '6em',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'pre-wrap',
        wordBreak: 'break-all',
        m: 0, p: 0, lineHeight: 1.4,
      }}
    >
      {item.rule}
    </Typography>
  ),
  renderDialogContent: (item: SnortRuleItem, updateItemState: <K extends keyof SnortRuleItem>(item: SnortRuleItem, field: K, value: SnortRuleItem[K]) => void, isEdit: boolean): ReactElement => (
    <>
      <FormControl fullWidth margin="normal">
        <InputLabel id="rule-type-label">Type</InputLabel>
        <Select
          labelId="rule-type-label"
          value={item.type}
          onChange={(e: SelectChangeEvent) => updateItemState(item, 'type', e.target.value as string)}
          label="Type"
        >
          {Object.entries(RULE_TYPES).map(([value, { label }]) => (
            <MenuItem key={value} value={value}>{label}</MenuItem>
          ))}
        </Select>
      </FormControl>
      <TextField
        required
        fullWidth
        margin="normal"
        label="Rule"
        value={item.rule}
        onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => updateItemState(item, 'rule', e.target.value)}
        error={!item.rule || item.rule.trim() === ''}
        helperText={!item.rule || item.rule.trim() === '' ? "규칙 내용은 필수 입력 항목입니다." : ""}
        multiline
        rows={5}
        placeholder={`alert tcp any any -> any any (msg:"Example Rule"; sid:1000001;)`}
        InputProps={{ sx: { fontFamily: 'monospace' } }}
      />  
      <TextField
        fullWidth
        margin="normal"
        label="Description (Optional)"
        value={item.description || ''}
        onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => updateItemState(item, 'description', e.target.value)}
        multiline
        rows={2}
      />
    </>
  )
}; // 세미콜론 추가

// --- Reference 탭 설정 ---
export const REFERENCE_TYPES: Record<string, string> = {
  NVD: 'NVD',
  ADVISORY: 'Advisory',
  EXPLOIT: 'Exploit',
  PATCH: 'Patch',
  REPORT: 'Report',
  TOOL: 'Tool',
  OTHER: 'Other',
}; // 세미콜론 추가

export const DEFAULT_REFERENCE: ReferenceItem = {
  type: 'OTHER',
  url: '',
  description: '',
}; // 세미콜론 추가

export const referenceTabConfig: ExtendedTabConfig<ReferenceItem> = {
  icon: LinkIcon,
  title: 'Reference',
  itemName: '참조 링크',
  dataField: 'reference',
  wsFieldName: 'reference',
  defaultItem: DEFAULT_REFERENCE,
  emptyTitle: '등록된 참조 링크 없음',
  emptyDescription: '아직 이 취약점과 관련된 참조 링크가 등록되지 않았습니다.',
  addButtonText: '링크 추가',
  editButtonText: '링크 수정',
  deleteButtonText: '링크 삭제',
  validateItem: (item) => (item.url && item.url.trim() !== '') || 'URL은 필수 항목입니다.',
  checkDuplicate: (item, items, excludeIndex = -1) => {
    const currentUrl = item.url.trim().toLowerCase();
    return (items || []).some((ref, index) =>
      index !== excludeIndex && ref.url.trim().toLowerCase() === currentUrl
    );
  },
  renderItemLabel: (item: ReferenceItem): ReactElement => (
    <>
      <Chip
        label={REFERENCE_TYPES[item.type] || item.type}
        size="small"
        color="info"
        variant="outlined"
        sx={{ mr: 1 }}
      />
      <Typography
        component="a"
        href={item.url.startsWith('http') ? item.url : `https://${item.url}`}
        target="_blank"
        rel="noopener noreferrer"
        sx={{
          color: 'info.main',
          textDecoration: 'none',
          fontWeight: 400,
          wordBreak: 'break-all',
          '&:hover': { textDecoration: 'underline', color: 'info.dark' },
        }}
      >
        {item.url}
      </Typography>
    </>
  ),
  renderDialogContent: (item: ReferenceItem, updateItemState: <K extends keyof ReferenceItem>(item: ReferenceItem, field: K, value: ReferenceItem[K]) => void, isEdit: boolean): ReactElement => (
    <>
      <FormControl fullWidth margin="normal">
        <InputLabel id="reference-type-label">Type</InputLabel>
        <Select
          labelId="reference-type-label"
          value={item.type}
          onChange={(e: SelectChangeEvent) => updateItemState(item, 'type', e.target.value as string)}
          label="Type"
        >
          {Object.entries(REFERENCE_TYPES).map(([value, label]) => (
            <MenuItem key={value} value={value}>{label}</MenuItem>
          ))}
        </Select>
      </FormControl>
      <TextField
        required
        fullWidth
        margin="normal"
        label="URL"
        value={item.url}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => updateItemState(item, 'url', e.target.value)}
        error={!item.url || item.url.trim() === ''}
        helperText={!item.url || item.url.trim() === '' ? "URL은 필수 입력 항목입니다." : ""}
        placeholder="https://example.com/reference"
      />
      <TextField
        fullWidth
        margin="normal"
        label="Description (Optional)"
        value={item.description || ''}
        onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => updateItemState(item, 'description', e.target.value)}
        multiline
        rows={3}
      />
    </>
  )
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/HistoryTab.tsx
------------------------------------------------------------
import React from 'react';
import {
  Box,
  Typography,
  Paper,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Chip,
  Tooltip
} from '@mui/material';
import {
  Timeline,
  TimelineItem,
  TimelineSeparator,
  TimelineConnector,
  TimelineContent,
  TimelineDot,
  TimelineOppositeContent
} from '@mui/lab';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Person as PersonIcon,
  Code as CodeIcon,
  Security as SecurityIcon,
  Link as LinkIcon,
  Title as TitleIcon,
  Description as DescriptionIcon,
  Assignment as AssignmentIcon,
  Note as NoteIcon
} from '@mui/icons-material';
import { formatDateTime, TIME_ZONES } from 'shared/utils/dateUtils';
import { HistoryTabProps, HistoryItem, HistoryChange } from '../types/cve';

// 필드별 아이콘 매핑
const FIELD_ICONS: Record<string, React.ReactElement> = {
  title: <TitleIcon />,
  description: <DescriptionIcon />,
  status: <AssignmentIcon />,
  assigned_to: <PersonIcon />,
  notes: <NoteIcon />,
  snort_rule: <SecurityIcon />,
  poc: <CodeIcon />,
  reference: <LinkIcon />
};

// 액션별 색상 매핑
const ACTION_COLORS: Record<string, 'success' | 'primary' | 'error'> = {
  add: 'success',
  edit: 'primary',
  delete: 'error'
};

// 액션별 한글 텍스트
const ACTION_TEXT: Record<string, string> = {
  add: '추가',
  edit: '수정',
  delete: '삭제'
};

/**
 * 수정 이력 탭 컴포넌트
 * @param props HistoryTabProps
 * @returns React 컴포넌트
 */
const HistoryTab: React.FC<HistoryTabProps> = ({ modificationHistory = [] }) => {

  if (!Array.isArray(modificationHistory) || modificationHistory.length === 0) {
    return (
      <Box sx={{ p: 3, textAlign: 'center' }}>
        <Typography color="text.secondary">
          수정 이력이 없습니다.
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3 }}>
      <Timeline>
        {modificationHistory.map((history: HistoryItem, historyIndex: number) => (
          <TimelineItem key={historyIndex}>
            <TimelineOppositeContent color="text.secondary">
              {formatDateTime(history.modifiedAt || history.lastModifiedAt, undefined, TIME_ZONES.KST)}
            </TimelineOppositeContent>
            <TimelineSeparator>
              <TimelineDot color="primary">
                <PersonIcon />
              </TimelineDot>
              {historyIndex < modificationHistory.length - 1 && <TimelineConnector />}
            </TimelineSeparator>
            <TimelineContent>
              <Paper 
                elevation={0} 
                sx={{ 
                  p: 2, 
                  bgcolor: 'background.default',
                  border: '1px solid',
                  borderColor: 'divider',
                  borderRadius: 2
                }}
              >
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                  <Typography variant="subtitle2" component="span">
                    {history.username}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    님이 변경사항을 {history.changes?.length || 0}건 적용했습니다
                  </Typography>
                </Box>
                <List dense>
                  {history.changes?.map((change: HistoryChange, changeIndex: number) => (
                    <ListItem 
                      key={changeIndex}
                      sx={{
                        borderRadius: 1,
                        '&:hover': {
                          bgcolor: 'action.hover'
                        }
                      }}
                    >
                      <ListItemIcon>
                        <Tooltip title={change.fieldName || change.field}>
                          {FIELD_ICONS[change.field] ? FIELD_ICONS[change.field] : <EditIcon />}
                        </Tooltip>
                      </ListItemIcon>
                      <ListItemText
                        primary={
                          <Box component="span" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            {change.summary}
                            <Chip
                              label={ACTION_TEXT[change.action] || change.action}
                              size="small"
                              color={ACTION_COLORS[change.action] || 'primary'}
                              sx={{ height: 20 }}
                            />
                          </Box>
                        }
                        secondary={
                          change.detailType === 'detailed' && (
                            <Box component="span" sx={{ display: 'block', mt: 1 }}>
                              {change.before && change.after && (
                                <Box component="span" sx={{ display: 'block' }}>
                                  <Typography component="span" variant="body2" color="text.secondary" display="block">
                                    변경 전: {change.before}
                                  </Typography>
                                  <Typography component="span" variant="body2" color="text.secondary" display="block">
                                    변경 후: {change.after}
                                  </Typography>
                                </Box>
                              )}
                              {change.items && change.items.length > 0 && (
                                <Box component="span" sx={{ display: 'block', mt: 1 }}>
                                  {change.items.map((item, idx) => (
                                    <Paper
                                      key={idx}
                                      variant="outlined"
                                      sx={{ 
                                        p: 1, 
                                        mt: 1,
                                        bgcolor: 'background.paper',
                                        borderRadius: 1
                                      }}
                                    >
                                      <Typography component="span" variant="body2" color="text.secondary">
                                        {item.type && `[${item.type}] `}
                                        {item.rule || item.url || JSON.stringify(item)}
                                      </Typography>
                                    </Paper>
                                  ))}
                                </Box>
                              )}
                            </Box>
                          )
                        }
                      />
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </TimelineContent>
          </TimelineItem>
        ))}
      </Timeline>
    </Box>
  );
};

export default HistoryTab;



============================================================
File: /home/CVEHub/frontend/src/features/cve/components/GenericDataTab.tsx
------------------------------------------------------------
import React, { useState, useEffect, useCallback, useMemo, memo, ReactNode } from 'react';
import {
  Typography,
  Box,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Tooltip,
  Fade,
  Button,
  CircularProgress, // 로딩 상태 표시
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  Launch as LaunchIcon,
  SvgIconComponent, // 아이콘 타입
} from '@mui/icons-material';
import {
  StyledListItem,
  ActionButton,
  ActionIconButton,
  ListHeader,
  EmptyState,
} from './CommonStyles'; // 스타일 컴포넌트 경로 (확인 필요)
import { useQueryClient, InvalidateQueryFilters } from '@tanstack/react-query'; // React Query 타입
import api from 'shared/api/config/axios'; // Axios 인스턴스 경로 (확인 필요)
import { useSnackbar, OptionsObject, SnackbarMessage } from 'notistack'; // 스낵바 타입
import { SOCKET_EVENTS } from 'core/socket/services/constants'; // 소켓 상수 경로 (확인 필요)
import { useSocket } from 'core/socket/hooks/useSocket'; // useSocket 훅 경로 (확인 필요)
import { formatDateTime } from 'shared/utils/dateUtils'; // 날짜 유틸 경로 (확인 필요)
import { AxiosError } from 'axios'; // Axios 타입
import { QUERY_KEYS } from 'shared/api/queryKeys'; // 쿼리 키 경로 (확인 필요)
import logger from 'shared/utils/logging'; // 로거 경로 (확인 필요)

// --- 인터페이스 및 타입 정의 ---

// User 타입 (다른 파일에서 import 하거나 여기서 정의)
interface User {
  id?: string | number; // id 추가
  username: string;
  // 필요한 다른 사용자 속성...
}

// CVE 데이터 타입 (최소 필요 필드)
interface CVEDetailData {
  cveId: string;
  // dataField에 해당하는 필드를 포함해야 함 (인덱스 시그니처 사용 또는 구체적 필드 명시)
  [key: string]: any; // 실제 타입에 맞게 수정 권장
}

// 기본 아이템 인터페이스 (모든 데이터 아이템의 기본 구조)
interface BaseItem {
  id?: string | number; // id는 백엔드에서 오는 실제 식별자일 수 있음
  description?: string;
  created_by?: string; // 기존 소스코드와 필드명 통일
  created_at?: string | Date; // 기존 소스코드와 필드명 통일
  last_modified_by?: string; // 수정자 정보 (필요시)
  last_modified_at?: string | Date; // 수정 시간 (필요시)
  url?: string; // URL 속성
  [key: string]: any; // 유연성을 위한 인덱스 시그니처 (구체적인 타입 사용 권장)
}

// 각 탭에서 사용될 구체적인 아이템 타입 (BaseItem 확장, 예시)
interface PoCItem extends BaseItem {
  source: string;
  url: string; // 필수
}

interface SnortRuleItem extends BaseItem {
  type: string;
  rule: string; // 필수
}

interface ReferenceItem extends BaseItem {
  type: string;
  url: string; // 필수
}

// 모든 아이템 타입을 포함하는 유니온 타입 (구체적인 타입 추가 필요)
type DataItem = BaseItem & (PoCItem | SnortRuleItem | ReferenceItem | Record<string, any>); // Record<string, any>는 임시

// 탭 설정 타입 (제네릭 T 사용)
interface TabConfig<T extends DataItem> {
  icon?: SvgIconComponent | React.ElementType; // 아이콘 (Optional)
  title: string;
  itemName: string;
  dataField: keyof CVEDetailData | string; // CVE 데이터 객체의 키 또는 문자열
  wsFieldName: string; // 웹소켓 필드명
  defaultItem: T; // 기본 아이템 객체
  emptyTitle: string;
  emptyDescription: string;
  // addButtonText 삭제 -> Add ${itemName} 사용
  // editButtonText 삭제 -> Edit ${itemName} 사용
  // deleteButtonText 삭제 -> Delete 사용
  validateItem?: (item: T) => boolean | string; // 유효성 검사 (결과: boolean 또는 에러 메시지 string)
  checkDuplicate?: (item: T, items: T[], excludeIndex?: number) => boolean; // 중복 검사
  renderItemLabel: (item: T) => ReactNode; // 필수
  renderItemContent?: (item: T) => ReactNode; // Optional
  renderDialogContent: ( // 필수
    item: T,
    updateItemState: <K extends keyof T>(item: T, field: K, value: T[K]) => void, // 제네릭 방식으로 변경
    isEdit: boolean
  ) => ReactNode;
  prepareItemForSave?: (item: Partial<T>, isUpdate: boolean, currentUser?: User | null) => Partial<T> | Record<string, any>; // 사용자 정보 전달
}

// 부모로부터 받는 메시지 전송 함수 타입
type SendMessageFn = (type: string, data: Record<string, unknown>) => void;

// useSocket 훅 반환 타입 (실제 반환 타입에 맞춰야 함)
interface SocketHookReturn {
  socket?: any; // 실제 소켓 객체 타입으로 교체 필요 (e.g., Socket from 'socket.io-client')
  emit: SendMessageFn;
  on: (eventName: string, callback: (data: any) => void) => void;
  off: (eventName: string, callback: (data: any) => void) => void;
  connected: boolean;
}

// 컴포넌트 Props 타입
interface GenericDataTabProps<T extends DataItem> {
  cve: CVEDetailData;
  currentUser?: User | null;
  refreshTrigger: number; // 새로고침 트리거 (필수)
  tabConfig: TabConfig<T>; // 해당 탭의 설정 객체 (필수)
  parentSendMessage?: SendMessageFn; // Optional (useSocket으로 대체 가능성 있음)
  onCountChange?: (count: number) => void; // Optional
}

// API 응답 타입 (예시)
interface CveUpdateResponse {
    data: CVEDetailData; // 응답 데이터 구조 확인 필요
}

// --- 컴포넌트 구현 ---

// 제네릭 타입 T를 사용하여 컴포넌트 정의
const GenericDataTab = memo(<T extends DataItem>(props: GenericDataTabProps<T>) => {
  const {
    cve,
    currentUser,
    refreshTrigger,
    tabConfig,
    // parentSendMessage, // useSocket의 emit으로 대체되었으므로 주석 처리 또는 제거
    onCountChange = () => {}, // 기본값 함수
  } = props;

  const { enqueueSnackbar } = useSnackbar();
  const queryClient = useQueryClient();

  // --- 상태 관리 ---
  const [loading, setLoading] = useState(false); // 로딩 상태
  const [open, setOpen] = useState(false); // 다이얼로그 열림 상태
  const [newItem, setNewItem] = useState<T>({ ...tabConfig.defaultItem }); // 새 아이템
  const [selectedItem, setSelectedItem] = useState<T & { originalIndex?: number } | null>(null); // 선택된 아이템 (원본 인덱스 포함 가능)
  // const [selectedIndex, setSelectedIndex] = useState<number>(-1); // selectedItem.originalIndex 로 대체 가능
  const [error, setError] = useState<string | null>(null); // 다이얼로그 내 에러 메시지

  // --- Socket 설정 ---
  const { socket, emit, on, off, connected } = useSocket(); // useSocket 훅 사용

  // 데이터 배열 참조 (prop으로 받은 cve 사용)
  // dataField가 string일 수 있으므로 타입 단언 사용 (백엔드 응답 구조에 따라 조정)
  const items: T[] = useMemo(() =>
    (cve && typeof tabConfig.dataField === 'string' && cve[tabConfig.dataField] as T[]) || [],
    [cve, tabConfig.dataField]
  );

  // --- 핸들러 및 콜백 ---

  // 다이얼로그 내 아이템 상태 업데이트 함수 (제네릭 사용)
  const updateItemState = useCallback(<K extends keyof T>(item: T, field: K, value: T[K]) => {
      if (selectedItem) {
          // 선택된 아이템 업데이트 (수정 모드)
          setSelectedItem(prev => prev ? { ...prev, [field]: value } : null);
      } else {
          // 새 아이템 업데이트 (추가 모드)
          setNewItem(prev => ({ ...prev, [field]: value }));
      }
      setError(null); // 입력 변경 시 에러 초기화
  }, [selectedItem]); // 의존성 배열에 selectedItem 추가

  // refreshTrigger 변경 시 캐시 무효화
  useEffect(() => {
    if (refreshTrigger > 0 && cve?.cveId) {
      logger.info(`GenericDataTab (${tabConfig.title}): refreshTrigger 감지, 캐시 무효화`);
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.CVE.detail(cve.cveId) } as InvalidateQueryFilters);
    }
  }, [refreshTrigger, queryClient, cve?.cveId, tabConfig.title]);

  // 아이템 수 변경 시 콜백 호출
  useEffect(() => {
    onCountChange(items.length);
  }, [items.length, onCountChange]);

  // 웹소켓 이벤트 리스너 (데이터 업데이트 수신)
  useEffect(() => {
    if (!connected || !cve?.cveId || !tabConfig.wsFieldName) return;

    const handleDataUpdated = (data: { cveId?: string; field?: string; cve?: CVEDetailData }) => {
      if (data?.cveId === cve.cveId && data?.field === tabConfig.wsFieldName && data?.cve) {
        logger.debug('GenericDataTab', `${tabConfig.itemName} 데이터 업데이트 이벤트 수신`, { cveId: data.cveId, field: data.field });
        // React Query 캐시 직접 업데이트
        queryClient.setQueryData<CVEDetailData>(QUERY_KEYS.CVE.detail(cve.cveId), data.cve);
        // 아이템 수 업데이트 (캐시 업데이트 후 자동으로 반영될 수도 있음, 필요시 호출)
        const updatedItems = (data.cve[tabConfig.dataField as keyof CVEDetailData] as T[]) || [];
        onCountChange(updatedItems.length);
      }
    };

    const eventName = SOCKET_EVENTS.DATA_UPDATED; // 실제 사용하는 이벤트 이름으로 확인/변경 필요
    on(eventName, handleDataUpdated);

    return () => { // 클린업
      off(eventName, handleDataUpdated);
    };
  }, [connected, cve?.cveId, tabConfig.wsFieldName, tabConfig.itemName, tabConfig.dataField, on, off, queryClient, onCountChange]); // tabConfig.dataField 추가

  // 유효성 검사 함수
  const isItemValid = useCallback((item: T): boolean => {
    // 빈 값 체크 등 기본 유효성 추가 가능
    if (!item) return false;
    const validationResult = tabConfig.validateItem ? tabConfig.validateItem(item) : true;
    return typeof validationResult === 'boolean' ? validationResult : false; // boolean 결과만 유효
  }, [tabConfig.validateItem]);

  // 중복 검사 함수
  const isDuplicateItem = useCallback((item: T, excludeIndex: number = -1): boolean => {
    return tabConfig.checkDuplicate ? tabConfig.checkDuplicate(item, items, excludeIndex) : false;
  }, [tabConfig.checkDuplicate, items]); // items 의존성 추가

  // 다이얼로그 버튼 활성화 조건
  const isButtonEnabled = useMemo(() => {
    const itemToCheck = selectedItem ?? newItem;
    if (!isItemValid(itemToCheck)) {
      return false; // 유효하지 않으면 비활성화
    }
    // 수정 시에는 handleUpdateItem에서, 추가 시에는 handleAddItem에서 중복 검사
    return !loading; // 로딩 중 아닐 때 활성화
  }, [selectedItem, newItem, isItemValid, loading]); // isDuplicateItem 제거, loading 추가

  // 추가 버튼 클릭
  const handleAddClick = useCallback(() => {
    setSelectedItem(null);
    setNewItem({ ...tabConfig.defaultItem }); // 항상 defaultItem으로 초기화
    setError(null);
    setOpen(true);
  }, [tabConfig.defaultItem]);

  // 수정 버튼 클릭
  const handleEditClick = useCallback((item: T, index: number) => {
    setSelectedItem({ ...item, originalIndex: index }); // 원본 인덱스 저장
    setError(null);
    setOpen(true);
  }, []);

  // 다이얼로그 닫기
  const handleClose = useCallback(() => {
    // activeElement가 HTMLElement인지 확인 후 blur 호출
    if (document.activeElement instanceof HTMLElement) {
        document.activeElement.blur();
    }
    setTimeout(() => {
      setOpen(false);
      // 상태 초기화는 다이얼로그가 완전히 닫힌 후 실행될 수 있도록 보장
      setSelectedItem(null);
      setNewItem({ ...tabConfig.defaultItem });
      setError(null); // 에러 상태 초기화
    }, 150); // Fade Transition 시간을 고려하여 약간의 지연 추가 (Material UI 기본값)
  }, [tabConfig.defaultItem]);

  // 데이터 업데이트 성공 처리 (공통 로직)
  const handleUpdateSuccess = useCallback((responseData: CVEDetailData, successMessage: string) => {
      // React Query 캐시 업데이트
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cve.cveId), responseData);

      // 소켓 이벤트 전송 (emit 사용)
      if (connected) {
          emit(SOCKET_EVENTS.DATA_UPDATED, { // 실제 이벤트 이름 사용
              cveId: cve.cveId,
              field: tabConfig.wsFieldName,
              cve: responseData, // 전체 CVE 데이터 전송
          });
      } else {
          logger.warn('[GenericDataTab] Socket not connected, skipping emit.');
      }

      // UI 업데이트 및 알림
      if (document.activeElement instanceof HTMLElement) {
          document.activeElement.blur();
      }
      setTimeout(() => {
          handleClose(); // 다이얼로그 닫기 및 상태 초기화
          enqueueSnackbar(successMessage as SnackbarMessage, { variant: 'success' });
      }, 0); // 즉시 실행하되, call stack 분리

      // 아이템 수 업데이트 (캐시 업데이트로 반영될 수 있으므로 선택적)
      // const updatedItems = (responseData[tabConfig.dataField as keyof CVEDetailData] as T[]) || [];
      // onCountChange(updatedItems.length);

  }, [queryClient, cve.cveId, connected, emit, tabConfig.wsFieldName, handleClose, enqueueSnackbar /*, onCountChange, tabConfig.dataField*/]);

  // API 에러 처리 (공통 로직)
  const handleApiError = useCallback((error: unknown, action: string) => {
    const errorMessage = (error instanceof AxiosError ? error.response?.data?.detail || error.message : (error as Error).message)
                     || `${tabConfig.itemName} ${action} 중 오류가 발생했습니다.`;
    logger.error(`Failed to ${action} ${tabConfig.itemName}:`, error);
    setError(errorMessage); // 다이얼로그 내 에러 표시
    // 스낵바 에러는 간결하게 표시하거나, 다이얼로그 내 에러와 중복되므로 제거 가능
    // enqueueSnackbar(errorMessage as SnackbarMessage, { variant: 'error' });
  }, [tabConfig.itemName]); // setError 추가

  // 아이템 추가 핸들러
  const handleAddItem = useCallback(async () => {
    setError(null); // 이전 에러 초기화

    // 유효성 검사 (버튼 활성화 로직과 별개로 한 번 더 체크)
    if (!isItemValid(newItem)) {
      const validationMessage = typeof tabConfig.validateItem === 'function'
          ? tabConfig.validateItem(newItem) || '입력값을 확인해주세요.' // validateItem이 string 반환 시 사용
          : '입력값을 확인해주세요.';
      setError(validationMessage as string);
      // enqueueSnackbar(validationMessage as SnackbarMessage, { variant: 'warning' }); // 다이얼로그 에러로 대체
      return;
    }
    // 중복 검사
    if (isDuplicateItem(newItem)) {
      setError('이미 존재하는 항목입니다.');
      // enqueueSnackbar('이미 존재하는 항목입니다.', { variant: 'error' }); // 다이얼로그 에러로 대체
      return;
    }

    setLoading(true);

    // 생성자 정보 추가 (기존 로직 유지)
    const newItemWithMeta: Partial<T> = {
      ...newItem,
      created_by: currentUser?.username || 'anonymous',
      // created_at 등 타임스탬프는 prepareItemForSave 또는 백엔드에서 처리
    };

    // 저장용 데이터 준비 (prepareItemForSave 사용)
    const finalItemPayload = tabConfig.prepareItemForSave
      ? tabConfig.prepareItemForSave(newItemWithMeta, false, currentUser)
      : newItemWithMeta;

    // 기존 아이템 배열에 새 아이템 추가 (업데이트할 전체 배열)
    const updatedItems = [...items, finalItemPayload as T]; // 타입 단언 주의

    try {
      const response = await api.patch<CveUpdateResponse>(`/cves/${cve.cveId}`, {
        [tabConfig.dataField as string]: updatedItems,
      }, { skipAuthRefresh: false }); // skipAuthRefresh 명시

      handleUpdateSuccess(response.data.data, `${tabConfig.itemName}이(가) 추가되었습니다.`);

    } catch (error) {
      handleApiError(error, '추가');
      // 낙관적 업데이트 롤백은 React Query가 관리하므로 명시적 롤백 불필요
    } finally {
      setLoading(false);
    }
  }, [
      newItem, items, tabConfig, currentUser, isItemValid, isDuplicateItem, cve.cveId,
      handleUpdateSuccess, handleApiError, // 공통 함수 사용
      // queryClient, emit, enqueueSnackbar, onCountChange, // handleUpdateSuccess/handleApiError로 이동
  ]);

  // 아이템 삭제 핸들러
  const handleDeleteItem = useCallback(async (indexToDelete: number) => {
    // 삭제 확인 다이얼로그 추가 고려
    // if (!window.confirm(`${tabConfig.itemName} 항목을 삭제하시겠습니까?`)) {
    //   return;
    // }

    setLoading(true); // 개별 아이템 로딩 상태는 아직 없으므로 전체 로딩 사용

    const updatedItems = items.filter((_, i) => i !== indexToDelete);

    try {
      const response = await api.patch<CveUpdateResponse>(`/cves/${cve.cveId}`, {
        [tabConfig.dataField as string]: updatedItems,
        // action: 'delete' // 백엔드가 요구하는 경우 추가
      }, { skipAuthRefresh: false });

      // 삭제 성공 시 스낵바 알림 (handleUpdateSuccess는 다이얼로그 닫기가 포함됨)
      enqueueSnackbar(`${tabConfig.itemName}이(가) 삭제되었습니다.`, { variant: 'success' });
      // 캐시 업데이트는 필요 (handleUpdateSuccess와 유사하게)
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cve.cveId), response.data.data);
      // 소켓 이벤트 전송
      if (connected) {
          emit(SOCKET_EVENTS.DATA_UPDATED, {
              cveId: cve.cveId,
              field: tabConfig.wsFieldName,
              cve: response.data.data,
          });
      }
       // 아이템 수 업데이트 (필요시)
       onCountChange(updatedItems.length);


    } catch (error) {
       // 삭제 실패 시 스낵바 알림
      const errorMessage = (error instanceof AxiosError ? error.response?.data?.detail || error.message : (error as Error).message)
                       || `${tabConfig.itemName} 삭제 중 오류가 발생했습니다.`;
      logger.error(`Failed to delete ${tabConfig.itemName}:`, error);
      enqueueSnackbar(errorMessage as SnackbarMessage, { variant: 'error' });
      // 명시적인 롤백 불필요 (React Query 캐시 사용)
    } finally {
      setLoading(false);
    }
  }, [
      items, tabConfig, cve.cveId, queryClient, emit, enqueueSnackbar, connected, onCountChange, // 필요한 의존성 추가
      // handleApiError 삭제 (직접 에러 처리)
  ]);

  // 아이템 수정 핸들러
  const handleUpdateItem = useCallback(async () => {
    if (!selectedItem) return; // 수정할 아이템 없으면 중단

    setError(null); // 이전 에러 초기화

    const itemToUpdate = { ...selectedItem }; // 복사본 사용
    const originalIndex = itemToUpdate.originalIndex; // 원본 인덱스 가져오기
    if (typeof originalIndex !== 'number' || originalIndex < 0) {
        logger.error("Invalid originalIndex for update", selectedItem);
        setError("항목 수정 중 오류가 발생했습니다. (Invalid Index)");
        return;
    }
    delete (itemToUpdate as any).originalIndex; // 내부용 인덱스 제거

    // 유효성 검사
    if (!isItemValid(itemToUpdate as T)) {
      const validationMessage = typeof tabConfig.validateItem === 'function'
          ? tabConfig.validateItem(itemToUpdate as T) || '입력값을 확인해주세요.'
          : '입력값을 확인해주세요.';
      setError(validationMessage as string);
      // enqueueSnackbar(validationMessage as SnackbarMessage, { variant: 'warning' });
      return;
    }
    // 중복 검사 (자기 자신 제외)
    if (isDuplicateItem(itemToUpdate as T, originalIndex)) {
      setError('이미 존재하는 항목입니다.');
      // enqueueSnackbar('이미 존재하는 항목입니다.', { variant: 'error' });
      return;
    }

    setLoading(true);

    // 수정자 정보 추가 (필요시)
    const updatedItemWithMeta: Partial<T> = {
      ...itemToUpdate,
      last_modified_by: currentUser?.username || 'anonymous',
      // last_modified_at은 prepareItemForSave 또는 백엔드에서 처리
    };

    // 저장용 데이터 준비
    const finalItemPayload = tabConfig.prepareItemForSave
      ? tabConfig.prepareItemForSave(updatedItemWithMeta, true, currentUser)
      : updatedItemWithMeta;

    // 업데이트된 아이템 배열 생성
    const updatedItems = items.map((item, i) =>
      i === originalIndex ? (finalItemPayload as T) : item // 타입 단언 주의
    );

    try {
      const response = await api.patch<CveUpdateResponse>(`/cves/${cve.cveId}`, {
        [tabConfig.dataField as string]: updatedItems,
      }, { skipAuthRefresh: false });

      handleUpdateSuccess(response.data.data, `${tabConfig.itemName}이(가) 수정되었습니다.`);

    } catch (error) {
      handleApiError(error, '수정');
      // 롤백은 React Query가 처리
    } finally {
      setLoading(false);
    }
  }, [
      selectedItem, items, tabConfig, currentUser, isItemValid, isDuplicateItem, cve.cveId,
      handleUpdateSuccess, handleApiError, // 공통 함수 사용
      // queryClient, emit, enqueueSnackbar, onCountChange, // handleUpdateSuccess/handleApiError로 이동
  ]);

  // 저장 버튼 클릭 핸들러 (다이얼로그)
  const handleSave = useCallback(() => {
    if (document.activeElement instanceof HTMLElement) {
        document.activeElement.blur();
    }
    // 비동기 처리하여 blur() 완료 후 실행 보장
    setTimeout(() => {
      if (selectedItem) {
        handleUpdateItem();
      } else {
        handleAddItem();
      }
    }, 0);
  }, [selectedItem, handleUpdateItem, handleAddItem]);

  // --- 렌더링 ---
  return (
    <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      {/* 헤더 */}
      <ListHeader> {/* CommonStyles의 ListHeader 사용 (padding, border 등 포함 가정) */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          {/* tabConfig.icon이 있으면 렌더링, color="primary" 적용 */}
          {tabConfig.icon && React.createElement(tabConfig.icon, { color: "primary" })}
          <Typography variant="h6" color="text.primary">
            {tabConfig.title} ({items.length}) {/* 아이템 수 표시 */}
          </Typography>
          {/* 로딩 상태 표시 */}
          {/* 헤더 전체 로딩보다 버튼 로딩이 더 적합할 수 있음 */}
          {/* {loading && <CircularProgress size={20} sx={{ ml: 1 }} />} */}
        </Box>
        {/* 추가 버튼 - ActionButton 사용 */}
        <ActionButton
          variant="contained"
          startIcon={<AddIcon />}
          onClick={handleAddClick}
          disabled={loading} // 전체 로딩 상태에 따라 비활성화
        >
          {`Add ${tabConfig.itemName}`} {/* 기존 텍스트 형식 사용 */}
        </ActionButton>
      </ListHeader>

      {/* 컨텐츠 영역 */}
      {items.length === 0 ? (
        // 아이템 없을 때 빈 상태 화면 - EmptyState 사용
        <EmptyState>
          {/* 아이콘 스타일 원본 적용 */}
          {tabConfig.icon && React.createElement(tabConfig.icon, {
            sx: { fontSize: 48, color: 'primary.main', opacity: 0.7 }
          })}
          <Typography variant="h6" gutterBottom /* sx={{ mt: 1 }} 제거 */>
            {tabConfig.emptyTitle}
          </Typography>
          <Typography variant="body2" color="text.secondary" /* sx={{ mb: 2 }} 제거 */>
            {tabConfig.emptyDescription}
          </Typography>
          <Button
            variant="outlined"
            startIcon={<AddIcon />}
            onClick={handleAddClick}
            disabled={loading}
            sx={{ mt: 2 }} // 원본 스타일 적용
          >
            {`Add First ${tabConfig.itemName}`} {/* 기존 텍스트 형식 사용 */}
          </Button>
        </EmptyState>
      ) : (
        // 아이템 목록
        <Box sx={{
          flex: 1,
          overflowY: 'auto',
          px: 2, // 좌우 패딩
          py: 1, // 상하 패딩
          '& > *:not(:last-child)': { mb: 2 } // 아이템 간 간격 원본 적용 (mb: 2)
        }}>
          {items.map((item, index) => (
            <StyledListItem key={item.id ?? `item-${index}`} elevation={0}>
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                {/* 상단: 라벨 및 액션 버튼 */}
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                  {/* 좌측: 라벨 */}
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, flexWrap: 'wrap', mr: 1 }}>
                    {tabConfig.renderItemLabel(item)}
                  </Box>
                  {/* 우측: 액션 버튼 */}
                  <Box sx={{ display: 'flex', gap: 1, flexShrink: 0 }}>
                    {/* URL 열기 버튼 (item.url이 있을 때만) */}
                    {('url' in item && item.url) && (
                      <Tooltip title="Open URL">
                        {/* <a> 태그로 ActionIconButton을 감쌉니다. */}
                        <a
                          href={(item.url as string).startsWith('http') ? (item.url as string) : `https://${item.url as string}`}
                          target="_blank"
                          rel="noopener noreferrer"
                          style={{ textDecoration: 'none', color: 'inherit' }} // 링크 밑줄 제거 및 아이콘 색상 상속
                          aria-label={`Open URL for ${tabConfig.renderItemLabel(item)}`} // 접근성 향상
                        >
                          <ActionIconButton
                            size="small"
                            disabled={loading}
                            // component, href, target, rel 속성 제거
                          >
                            <LaunchIcon fontSize="small" />
                          </ActionIconButton>
                        </a>
                      </Tooltip>
                    )}
                    {/* 수정 버튼 */}
                    <Tooltip title="Edit">
                      <ActionIconButton size="small" onClick={() => handleEditClick(item, index)} disabled={loading}>
                        <EditIcon fontSize="small" />
                      </ActionIconButton>
                    </Tooltip>
                    {/* 삭제 버튼 */}
                    <Tooltip title="Delete">
                      <ActionIconButton size="small" color="error" onClick={() => handleDeleteItem(index)} disabled={loading}>
                        <DeleteIcon fontSize="small" />
                      </ActionIconButton>
                    </Tooltip>
                  </Box>
                </Box>

                {/* 설명 (있을 경우) */}
                {item.description && (
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{
                      pl: 2,
                      borderLeft: '2px solid',
                      borderColor: 'divider',
                      wordBreak: 'break-word'
                    }}
                  >
                    {item.description}
                  </Typography>
                )}

                {/* 추가 컨텐츠 (설정된 경우) */}
                {tabConfig.renderItemContent && (
                    <Box sx={{ mt: 0.5 }}>{tabConfig.renderItemContent(item)}</Box>
                )}

                {/* 하단: 메타 정보 */}
                { (item.created_by || item.created_at) && (
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mt: 0.5 }}>
                      {item.created_by && (
                          <Typography variant="caption" color="text.secondary">
                              Added by {item.created_by}
                          </Typography>
                      )}
                      {item.created_by && item.created_at && (
                          <Typography variant="caption" color="text.secondary" sx={{ lineHeight: '1' }}>•</Typography>
                      )}
                      {item.created_at && (
                          <Tooltip title={`Created at: ${new Date(item.created_at).toLocaleString()}`}>
                              <Typography variant="caption" color="text.secondary">
                                  {formatDateTime(item.created_at)}
                              </Typography>
                          </Tooltip>
                      )}
                    </Box>
                )}
              </Box>
            </StyledListItem>
          ))}
        </Box>
      )}

      {/* 추가/수정 다이얼로그 */}
      <Dialog
        open={open}
        onClose={handleClose} // onClose 핸들러 사용
        maxWidth="sm"
        fullWidth
        TransitionComponent={Fade} // Fade 트랜지션 사용
        PaperProps={{ sx: { borderRadius: 3 } }} // 원본 borderRadius 적용
        keepMounted={false} // 필요시 false로 설정하여 성능 최적화
        disableRestoreFocus={false} // 원본 설정 유지
        disableEnforceFocus={false} // 원본 설정 유지
        disableAutoFocus={false} // 원본 설정 유지
        disablePortal={false} // 원본 설정 유지
        aria-labelledby="generic-dialog-title"
      >
        <DialogTitle id="generic-dialog-title">
          {/* 기존 텍스트 형식 사용 */}
          {selectedItem ? `Edit ${tabConfig.itemName}` : `Add ${tabConfig.itemName}`}
        </DialogTitle>
        <DialogContent dividers /* 컨텐츠 구분선 추가 (유지) */>
          {/* 다이얼로그 컨텐츠 렌더링 (아이템과 업데이트 함수 전달) */}
          {tabConfig.renderDialogContent(
            selectedItem ?? newItem, // 수정 중이면 selectedItem, 아니면 newItem
            updateItemState, // 업데이트 함수 전달
            selectedItem !== null // 수정 모드 여부 전달
          )}
          {/* 에러 메시지 표시 (다이얼로그 하단) */}
          {error && <Typography color="error" variant="caption" sx={{ mt: 1, display: 'block' }}>{error}</Typography>}
        </DialogContent>
        <DialogActions sx={{ px: 3, py: 2 }} /* 패딩 유지 */>
          <Button onClick={handleClose} color="inherit" /* 색상 유지 */>Cancel</Button>
          <Button
            variant="contained"
            onClick={handleSave}
            disabled={!isButtonEnabled || loading} // 로딩 중일 때도 비활성화
            startIcon={loading ? <CircularProgress size={16} color="inherit" /> : undefined} // 로딩 아이콘 유지
            autoFocus={true} // 원본 autoFocus 적용
          >
            {/* 기존 텍스트 형식 사용 */}
            {selectedItem ? 'Save' : 'Add'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}); // memo 끝

GenericDataTab.displayName = 'GenericDataTab'; // DevTools 이름 설정
export default GenericDataTab;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/CrawlerUpdateButton.tsx
------------------------------------------------------------
// CrawlerUpdateButton.tsx - 리팩토링 버전
import React, { useState, useEffect, useCallback, useRef, MouseEvent } from 'react';
import { useSnackbar } from 'notistack';
import {
  Button, Menu, MenuItem, Dialog, DialogTitle, DialogContent, Typography, Box, 
  LinearProgress, IconButton, Tooltip, Divider, Paper, CircularProgress, 
  Stepper, Step, StepLabel, Card, Grid, Avatar
} from '@mui/material';
import {
  CloudDownload as CloudDownloadIcon,
  Close as CloseIcon,
  Error as ErrorIcon,
  Settings as SettingsIcon,
  DataObject as DataObjectIcon,
  Storage as StorageIcon,
  CheckCircle as CheckCircleIcon,
  Update as UpdateIcon,
  KeyboardArrowDown as ArrowDownIcon,
  InfoOutlined as InfoIcon
} from '@mui/icons-material';
import { useQueryClient } from '@tanstack/react-query';
import api from 'shared/api/config/axios';
import { useSocket } from 'core/socket/hooks/useSocket';
import { formatDistance } from 'date-fns';
import { ko } from 'date-fns/locale';
import logger, { LOG_LEVEL } from 'shared/utils/logging';
import { SOCKET_EVENTS, SOCKET_STATE } from 'core/socket/services/constants';
import { get } from 'lodash';
import { StageInfo, UpdatedCVEs, Crawler, CrawlerStatusResponse, ProgressState, CrawlerUpdateData } from 'features/crawler/types';

// 개발 환경에서 디버그 로깅
if (process.env.NODE_ENV === 'development') {
  logger.setLogLevel(LOG_LEVEL.DEBUG);
  logger.setEnabled(true);
}

// 크롤러 진행 단계 정의
const CRAWLER_STAGES: StageInfo[] = [
  {
    key: 'preparing',
    label: '준비 중',
    description: '크롤러 초기화 및 저장소 연결 준비',
    icon: <SettingsIcon fontSize="small" />,
    color: '#3f51b5',
    backendValues: ['준비 중', '준비', '초기화', '연결', '진행 중']
  },
  {
    key: 'fetching',
    label: '데이터 수집',
    description: '소스에서 데이터 수집 중',
    icon: <CloudDownloadIcon fontSize="small" />,
    color: '#2196f3',
    backendValues: ['데이터 수집', '수집', '진행 중']
  },
  {
    key: 'processing',
    label: '데이터 처리',
    description: '수집된 데이터 처리 및 분석',
    icon: <DataObjectIcon fontSize="small" />,
    color: '#00bcd4',
    backendValues: ['데이터 처리', '처리', '진행 중']
  },
  {
    key: 'saving',
    label: '저장 중',
    description: '처리된 데이터 데이터베이스에 저장',
    icon: <StorageIcon fontSize="small" />,
    color: '#009688',
    backendValues: ['저장 중', '저장', '데이터베이스 업데이트', '업데이트', '진행 중']
  },
  {
    key: 'completed',
    label: '완료',
    description: '크롤링 작업 완료',
    icon: <CheckCircleIcon fontSize="small" />,
    color: '#4caf50',
    backendValues: ['완료', 'done', 'complete', 'finished', 'completed']
  },
  {
    key: 'error',
    label: '오류',
    description: '크롤링 작업 중 오류 발생',
    icon: <ErrorIcon fontSize="small" />,
    color: '#f44336',
    backendValues: ['오류', 'error', '실패', 'failed']
  }
];

// 크롤러 목록
const CRAWLERS: Crawler[] = [
  { id: 'nuclei', name: 'Nuclei Templates', type: 'nuclei' },
  { id: 'metasploit', name: 'Metasploit', type: 'metasploit' },
  { id: 'emerging_threats', name: 'EmergingThreats Rules', type: 'emerging_threats' }
];

/**
 * 단계 인덱스 추출 함수
 */
const getStageIndex = (stageName: string | undefined): number => {
  if (!stageName) return 0;

  const lowerStageName = String(stageName).toLowerCase().trim();
  
  // 1. 키 매칭
  const stageIndex = CRAWLER_STAGES.findIndex((stage) => stage.key === lowerStageName);
  if (stageIndex >= 0) return stageIndex;

  // 2. 백엔드 값 매칭
  for (let i = 0; i < CRAWLER_STAGES.length; i++) {
    const stage = CRAWLER_STAGES[i];
    if (
      stage.backendValues &&
      stage.backendValues.some(
        (value) =>
          value.toLowerCase() === lowerStageName ||
          lowerStageName.includes(value.toLowerCase()) ||
          value.toLowerCase().includes(lowerStageName)
      )
    ) {
      return i;
    }
  }

  return 0; // 준비 중 반환
};

/**
 * CrawlerUpdateButton 컴포넌트
 */
const CrawlerUpdateButton: React.FC = () => {
  const { enqueueSnackbar } = useSnackbar();
  const queryClient = useQueryClient();
  const socket = useSocket();
  const { connected } = socket;

  // 메뉴와 다이얼로그 상태
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [progressOpen, setProgressOpen] = useState<boolean>(false);
  const [selectedCrawler, setSelectedCrawler] = useState<Crawler | null>(null);

  // 진행 상태
  const [progress, setProgress] = useState<ProgressState>({
    stage: '',
    percent: 0,
    message: ''
  });
  const [isRunning, setIsRunning] = useState<boolean>(false);
  const [loading, setLoading] = useState<boolean>(false);
  const [activeStep, setActiveStep] = useState<number>(0);
  const [hasError, setHasError] = useState<boolean>(false);
  const [lastUpdate, setLastUpdate] = useState<Record<string, unknown>>({});
  const [updatedCVEs, setUpdatedCVEs] = useState<UpdatedCVEs | null>(null);

  // 웹소켓과 폴링 관련 상태
  const [isSocketConnected, setIsSocketConnected] = useState<boolean>(false);
  const [lastWebSocketUpdate, setLastWebSocketUpdate] = useState<Date | null>(null);
  const [pollTimer, setPollTimer] = useState<NodeJS.Timeout | null>(null);

  // 참조
  const buttonRef = useRef<HTMLButtonElement | null>(null);
  const dialogRef = useRef<HTMLDivElement | null>(null);

  // ---- 크롤러 상태 관리 ------------------------------------------------

  // 크롤러 상태 로드
  const loadCrawlerStatus = useCallback(async (): Promise<void> => {
    try {
      setLoading(true);
      const response = await api.get<CrawlerStatusResponse>('/crawler/status');
      const statusData = response.data;

      setIsRunning(statusData.isRunning);

      // 단계 정보
      if (statusData.currentStatus) {
        const currentStatus = statusData.currentStatus;
        if (typeof currentStatus.stage === 'string') {
          const stageIndex = getStageIndex(currentStatus.stage);
          setActiveStep(stageIndex);
        }
        setProgress((prev) => ({
          stage: currentStatus.stage_label || currentStatus.stage || '',
          percent: typeof currentStatus.percent === 'number' ? currentStatus.percent : 0,
          message: currentStatus.message || ''
        }));
      }

      // 크롤러별 마지막 업데이트 시간
      const newLastUpdate: Record<string, unknown> = {};
      if (statusData.results) {
        Object.keys(statusData.results).forEach((crawlerType) => {
          const crawler = CRAWLERS.find((c) => c.type === crawlerType);
          if (crawler) {
            newLastUpdate[crawler.id] = statusData.lastUpdate;
          }
        });
      }
      // 나머지 크롤러는 기본값
      CRAWLERS.forEach((crawler) => {
        if (!newLastUpdate[crawler.id]) {
          newLastUpdate[crawler.id] = null;
        }
      });
      // 전체 시스템 마지막 업데이트
      newLastUpdate['default'] = statusData.lastUpdate;
      setLastUpdate(newLastUpdate);
    } catch (error) {
      logger.error('크롤러', '상태 로드 실패:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  // ---- 폴링 관리 --------------------------------------------------------

  // 폴링 중지
  const stopPolling = useCallback(() => {
    if (pollTimer) {
      logger.info('폴링 중지');
      clearInterval(pollTimer);
      setPollTimer(null);
    }
  }, [pollTimer]);

  // 폴링 시작
  const startPolling = useCallback(() => {
    if (pollTimer) clearInterval(pollTimer);
    
    logger.info('폴링 시작');
    const timer = setInterval(async () => {
      try {
        if (!isRunning) {
          stopPolling();
          return;
        }
        await loadCrawlerStatus();
      } catch (error) {
        logger.error('폴링', '크롤러 상태 조회 실패:', error);
      }
    }, 3000);
    
    setPollTimer(timer);
  }, [pollTimer, isRunning, loadCrawlerStatus, stopPolling]);

  // ---- 웹소켓 이벤트 처리 ------------------------------------------------

  // 연결 상태 변경 처리 함수
  const handleConnectionStateChange = useCallback((data: any) => {
    if (data.state === SOCKET_STATE.CONNECTED) {
      setIsSocketConnected(true);
    } else if (data.state === SOCKET_STATE.DISCONNECTED) {
      setIsSocketConnected(false);
    }
  }, []);

  // 크롤러 업데이트 이벤트 처리
  const handleCrawlerUpdateEvent = useCallback(
    (rawData: any) => {
      // 데이터 추출
      const extractedData: CrawlerUpdateData = {
        stage: get(rawData, 'data.data.stage') || get(rawData, 'data.stage') || get(rawData, 'stage'),
        stage_label: get(rawData, 'data.data.stage_label') || get(rawData, 'data.stage_label') || get(rawData, 'stage_label'),
        percent: get(rawData, 'data.data.percent') || get(rawData, 'data.percent') || get(rawData, 'percent'),
        message: get(rawData, 'data.data.message') || get(rawData, 'data.message') || get(rawData, 'message'),
        isRunning: get(rawData, 'data.data.isRunning') || get(rawData, 'data.isRunning') || get(rawData, 'isRunning'),
        hasError: get(rawData, 'data.data.hasError') || get(rawData, 'data.hasError') || get(rawData, 'hasError'),
        updatedCves: get(rawData, 'data.data.updatedCves') || get(rawData, 'data.updatedCves') || get(rawData, 'updatedCves')
      };

      try {
        // 단계 정보 업데이트
        if (typeof extractedData.stage === 'string') {
          const index = getStageIndex(extractedData.stage);
          setActiveStep(index);
        }

        // 진행 상태 업데이트
        setProgress((prev) => ({
          ...prev,
          stage: extractedData.stage_label || 
                 (extractedData.stage && CRAWLER_STAGES[getStageIndex(extractedData.stage)]?.label) || 
                 extractedData.stage || 
                 '',
          percent: typeof extractedData.percent === 'number' ? extractedData.percent : prev.percent,
          message: extractedData.message || prev.message
        }));

        // 완료 / 오류 상태 판단
        const stageValue = String(extractedData.stage || '').toLowerCase();
        const isCompleted = CRAWLER_STAGES.find((st) => st.key === 'completed')?.backendValues.some((val) =>
          stageValue.includes(val.toLowerCase())
        );
        const isError = CRAWLER_STAGES.find((st) => st.key === 'error')?.backendValues.some((val) =>
          stageValue.includes(val.toLowerCase())
        );

        if (isError) {
          setHasError(true);
          setIsRunning(false);
        } else if (isCompleted) {
          setHasError(false);
          setIsRunning(false);
          setProgress((prev) => ({ ...prev, message: '작업이 완료되었습니다.' }));
          enqueueSnackbar('크롤러 작업이 완료되었습니다. CVE 목록을 갱신합니다.', {
            variant: 'success',
            autoHideDuration: 4000
          });
          queryClient.invalidateQueries({ queryKey: ['cves'] });
        } else {
          setHasError(false);
          setIsRunning(true);
        }

        // 마지막 업데이트 시간
        setLastUpdate((prev) => ({ ...prev, default: new Date().toISOString() }));
        setLastWebSocketUpdate(new Date());
      } catch (err) {
        logger.error('handleCrawlerUpdateEvent', '데이터 처리 중 오류', err);
      }
    },
    [enqueueSnackbar, queryClient]
  );

  // 소켓 이벤트 구독 설정
  useEffect(() => {
    // 이벤트 구독 설정
    const stateUnsubscribe = socket.on(
      SOCKET_EVENTS.CONNECTION_STATE_CHANGE, 
      handleConnectionStateChange
    );
    
    // 크롤러 업데이트 이벤트 구독
    const updateUnsubscribe = socket.on(
      SOCKET_EVENTS.CRAWLER_UPDATE_PROGRESS, 
      handleCrawlerUpdateEvent
    );
    
    // 초기 상태 설정
    setIsSocketConnected(connected);
    
    // 컴포넌트 언마운트 시 구독 해제
    return () => {
      stateUnsubscribe();
      updateUnsubscribe();
    };
  }, [connected, handleConnectionStateChange, handleCrawlerUpdateEvent]);

  // 연결 상태 및 폴링 관리
  useEffect(() => {
    if (isRunning) {
      // 웹소켓 연결 상태 확인
      if (!connected) {
        if (!pollTimer) {
          logger.info('CrawlerUpdateButton', '웹소켓 연결 없음 - 폴링 시작');
          startPolling();
        }
      } else {
        // 웹소켓이 연결되어 있고 최소 한 번 이상의 이벤트를 수신한 경우 폴링 중지
        if (pollTimer && lastWebSocketUpdate) {
          logger.info('CrawlerUpdateButton', '웹소켓 연결 감지 - 폴링 중지');
          stopPolling();
        }
      }
    } else {
      // 실행 중이 아니면 폴링 중지
      if (pollTimer) {
        logger.info('CrawlerUpdateButton', '크롤러 실행 중지 - 폴링 중지');
        stopPolling();
      }
    }
  }, [isRunning, connected, pollTimer, lastWebSocketUpdate, startPolling, stopPolling]);

  // 컴포넌트 언마운트 시 폴링 중지
  useEffect(() => {
    return () => {
      if (pollTimer) {
        logger.info('CrawlerUpdateButton', '컴포넌트 언마운트 - 폴링 중지');
        clearInterval(pollTimer);
      }
    };
  }, [pollTimer]);

  // 초기 상태 로드
  useEffect(() => {
    const timer = setTimeout(() => {
      loadCrawlerStatus();
    }, 500);
    return () => clearTimeout(timer);
  }, [loadCrawlerStatus]);

  // ---- UI 이벤트 ------------------------------------------------

  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleSelect = (crawler: Crawler) => {
    setSelectedCrawler(crawler);
    setAnchorEl(null);
    runCrawler(crawler);
  };

  const runCrawler = async (crawler: Crawler) => {
    try {
      setSelectedCrawler(crawler);
      setProgressOpen(true);
      setProgress({ stage: '준비 중', percent: 0, message: '크롤러 초기화 중...' });
      setActiveStep(0);
      setHasError(false);
      setUpdatedCVEs(null);

      await api.post(`/crawler/run/${crawler.type}`, { id: crawler.id });
      startPolling();
    } catch (error: any) {
      logger.error('크롤러', '실행 오류:', error);
      setHasError(true);
      const errorMessage = error.response?.data?.detail || '크롤러 실행 중 오류가 발생했습니다.';
      setProgress({
        stage: '오류',
        percent: 0,
        message: errorMessage
      });
      enqueueSnackbar(errorMessage, {
        variant: 'error',
        autoHideDuration: 5000
      });
    }
  };

  // 마지막 업데이트 포맷팅
  const formatLastUpdate = (lastUpdateObj: unknown): string => {
    if (!lastUpdateObj) return '없음';
    try {
      if (typeof lastUpdateObj === 'string') {
        const date = new Date(lastUpdateObj);
        return formatDistance(date, new Date(), { addSuffix: true, locale: ko });
      }
      if (typeof lastUpdateObj === 'object' && lastUpdateObj !== null) {
        const obj = lastUpdateObj as Record<string, any>;
        const dateString = obj.datetime || obj.date || obj.timestamp;
        if (dateString) {
          const date = new Date(dateString);
          return formatDistance(date, new Date(), { addSuffix: true, locale: ko });
        }
      }
      return '없음';
    } catch (e) {
      console.error('날짜 포맷팅 오류:', e);
      return '알 수 없음';
    }
  };

  const handleCloseDialog = useCallback(() => {
    if (isRunning) return;
    if (buttonRef.current) {
      buttonRef.current.focus();
    }
    setTimeout(() => {
      setProgressOpen(false);
    }, 10);
  }, [isRunning]);

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && progressOpen && !isRunning) {
        handleCloseDialog();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [progressOpen, isRunning, handleCloseDialog]);

  // ---- 렌더링 컴포넌트 ------------------------------------------------

  // 크롤러 단계 표시 컴포넌트
  const CrawlerStepper = () => (
    <Card elevation={0} sx={{ p: 3, bgcolor: 'background.paper', borderRadius: 2, mb: 3 }}>
      <Stepper activeStep={activeStep} orientation="horizontal">
        {CRAWLER_STAGES.map((stage, index) => (
          <Step key={stage.key}>
            <StepLabel
              error={hasError && index === activeStep}
              optional={
                index === activeStep ? (
                  <Typography
                    variant="caption"
                    color={
                      index === activeStep
                        ? hasError
                          ? 'error.main'
                          : 'primary.main'
                        : 'text.secondary'
                    }
                  >
                    {index === activeStep ? progress.message || stage.description : stage.description}
                  </Typography>
                ) : null
              }
              StepIconProps={{
                icon:
                  hasError && index === activeStep ? (
                    <ErrorIcon color="error" />
                  ) : (
                    <Avatar
                      sx={{
                        bgcolor:
                          index < activeStep
                            ? stage.color
                            : index === activeStep
                            ? hasError
                              ? 'error.main'
                              : stage.color
                            : 'grey.300',
                        width: 24,
                        height: 24,
                        boxShadow:
                          index === activeStep && !hasError
                            ? '0 0 0 2px #fff, 0 0 0 4px ' + stage.color
                            : 'none',
                        animation:
                          index === activeStep && !hasError && isRunning
                            ? 'pulse 1.5s infinite'
                            : 'none',
                        '@keyframes pulse': {
                          '0%': { boxShadow: '0 0 0 0 rgba(33, 150, 243, 0.4)' },
                          '70%': { boxShadow: '0 0 0 6px rgba(33, 150, 243, 0)' },
                          '100%': { boxShadow: '0 0 0 0 rgba(33, 150, 243, 0)' }
                        }
                      }}
                    >
                      {stage.icon}
                    </Avatar>
                  )
              }}
            >
              <Typography
                variant="body2"
                fontWeight={index === activeStep ? 'bold' : 'normal'}
                color={
                  index === activeStep
                    ? hasError
                      ? 'error.main'
                      : 'primary.main'
                    : 'text.primary'
                }
              >
                {stage.label}
                {index === activeStep && isRunning && !hasError && (
                  <Box
                    component="span"
                    sx={{ ml: 0.5, display: 'inline-flex', alignItems: 'center' }}
                  >
                    <CircularProgress
                      size={12}
                      color="primary"
                      thickness={5}
                      sx={{ color: stage.color }}
                    />
                  </Box>
                )}
              </Typography>
            </StepLabel>
          </Step>
        ))}
      </Stepper>
    </Card>
  );

  // 진행률 표시 컴포넌트
  const ProgressIndicator = () => (
    <Box sx={{ mb: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
        <Typography
          variant="subtitle1"
          fontWeight="500"
          sx={{
            display: 'flex',
            alignItems: 'center',
            color: hasError
              ? 'error.main'
              : CRAWLER_STAGES[activeStep]?.color || 'primary.main'
          }}
        >
          {CRAWLER_STAGES[activeStep]?.icon && (
            <Box component="span" sx={{ mr: 1, display: 'inline-flex' }}>
              {CRAWLER_STAGES[activeStep]?.icon}
            </Box>
          )}
          {progress.stage || CRAWLER_STAGES[activeStep]?.label}
        </Typography>
      </Box>

      <Box sx={{ position: 'relative', mb: 1 }}>
        <LinearProgress
          variant="determinate"
          value={progress.percent || 0}
          sx={{
            height: 10,
            borderRadius: 5,
            bgcolor: 'background.paper',
            '& .MuiLinearProgress-bar': {
              bgcolor: hasError
                ? 'error.main'
                : CRAWLER_STAGES[activeStep]?.color || 'primary.main',
              transition: 'transform 0.3s ease-in-out'
            }
          }}
        />
        {isRunning && !hasError && (
          <LinearProgress
            variant="indeterminate"
            sx={{
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              height: 10,
              borderRadius: 5,
              opacity: 0.3,
              bgcolor: 'transparent',
              '& .MuiLinearProgress-bar': {
                bgcolor: CRAWLER_STAGES[activeStep]?.color || 'primary.main'
              }
            }}
          />
        )}
      </Box>

      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography
          variant="body2"
          sx={{
            color: 'text.secondary',
            maxWidth: '85%',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            whiteSpace: 'nowrap'
          }}
        >
          {progress.message || '초기화 중...'}
        </Typography>
        {isRunning ? (
          <CircularProgress size={16} color="primary" thickness={5} />
        ) : hasError ? (
          <ErrorIcon fontSize="small" color="error" />
        ) : progress.percent >= 100 ? (
          <CheckCircleIcon fontSize="small" color="success" />
        ) : null}
      </Box>

      {lastWebSocketUpdate && (
        <Typography
          variant="caption"
          sx={{ mt: 1, display: 'block', textAlign: 'right', color: 'text.secondary' }}
        >
          마지막 업데이트:{' '}
          {formatDistance(lastWebSocketUpdate, new Date(), { addSuffix: true, locale: ko })}
        </Typography>
      )}
    </Box>
  );

  // 상태 카드 컴포넌트
  const StatusCard = () => (
    <Card
      elevation={0}
      sx={{
        p: 2,
        bgcolor: hasError ? 'error.light' : `${CRAWLER_STAGES[activeStep]?.color}15`,
        borderLeft: hasError
          ? '4px solid #f44336'
          : `4px solid ${CRAWLER_STAGES[activeStep]?.color}`,
        borderRadius: 1
      }}
    >
      <Grid container spacing={2} alignItems="center">
        <Grid item>
          <Avatar
            sx={{
              bgcolor: hasError
                ? 'error.main'
                : CRAWLER_STAGES[activeStep]?.color,
              width: 40,
              height: 40
            }}
          >
            {hasError ? <ErrorIcon /> : CRAWLER_STAGES[activeStep]?.icon}
          </Avatar>
        </Grid>
        <Grid item xs>
          <Typography variant="subtitle1" fontWeight="500">
            {hasError ? '오류 발생' : CRAWLER_STAGES[activeStep]?.label}
          </Typography>
          <Typography variant="body2" color="text.secondary">
            {hasError
              ? progress.message
              : CRAWLER_STAGES[activeStep]?.description}
          </Typography>
        </Grid>
      </Grid>
    </Card>
  );

  // 업데이트된 CVE 목록 컴포넌트
  const UpdatedCVEList = () => {
    if (!updatedCVEs || updatedCVEs.count === 0) {
      return null;
    }

    return (
      <Box sx={{ mt: 3 }}>
        <Divider sx={{ my: 2 }} />
        <Typography
          variant="h6"
          gutterBottom
          sx={{ display: 'flex', alignItems: 'center' }}
        >
          <CheckCircleIcon sx={{ mr: 1, color: 'success.main' }} />
          업데이트된 CVE ({updatedCVEs.count}개)
        </Typography>
        <Box
          sx={{
            maxHeight: '300px',
            overflow: 'auto',
            mt: 1,
            '&::-webkit-scrollbar': {
              width: '8px'
            },
            '&::-webkit-scrollbar-thumb': {
              backgroundColor: 'rgba(0,0,0,0.2)',
              borderRadius: '4px'
            }
          }}
        >
          {updatedCVEs.items.map((cve, index) => (
            <Paper
              key={index}
              elevation={1}
              sx={{
                p: 2,
                mb: 1,
                borderLeft: '4px solid #2196f3',
                borderRadius: 1,
                transition: 'all 0.2s',
                ':hover': {
                  boxShadow: 3,
                  transform: 'translateY(-2px)'
                }
              }}
            >
              <Typography variant="subtitle1" fontWeight="bold" color="primary.main">
                {cve.cveId}
              </Typography>
              <Typography variant="body2">{cve.title}</Typography>
            </Paper>
          ))}
        </Box>
      </Box>
    );
  };

  return (
    <>
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        <Button
          variant="contained"
          color="primary"
          onClick={handleClick}
          startIcon={loading ? <CircularProgress size={20} color="inherit" /> : <UpdateIcon />}
          endIcon={<ArrowDownIcon />}
          disabled={isRunning || loading}
          sx={{
            mr: 1,
            borderRadius: '30px',
            boxShadow: 'none',
            '&:hover': { boxShadow: 'none', backgroundColor: '#1565c0' }
          }}
          ref={buttonRef}
        >
          크롤러 업데이트
        </Button>

        <Menu anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={handleClose}>
          {CRAWLERS.map((crawler) => (
            <MenuItem
              key={crawler.id}
              onClick={() => handleSelect(crawler)}
              sx={{
                display: 'flex',
                justifyContent: 'space-between',
                minWidth: '200px'
              }}
            >
              <span>{crawler.name}</span>
              <Tooltip
                title={`마지막 업데이트: ${formatLastUpdate(lastUpdate[crawler.id])}`}
                placement="right"
              >
                <InfoIcon
                  fontSize="small"
                  color={lastUpdate[crawler.id] ? 'action' : 'disabled'}
                  sx={{ ml: 1 }}
                />
              </Tooltip>
            </MenuItem>
          ))}
        </Menu>
      </Box>

      <Dialog
        open={progressOpen}
        onClose={handleCloseDialog}
        maxWidth="md"
        fullWidth
        PaperProps={{
          sx: { borderRadius: 2 },
          ref: dialogRef
        }}
        aria-labelledby="crawler-progress-dialog-title"
        disableRestoreFocus={true}
        keepMounted
      >
        <DialogTitle id="crawler-progress-dialog-title">
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Typography variant="h6">
              {selectedCrawler?.name || '크롤러'} 업데이트 진행 상황
            </Typography>
            {!isRunning && (
              <IconButton
                onClick={handleCloseDialog}
                size="small"
                aria-label="닫기"
                edge="end"
                tabIndex={0}
                sx={{
                  '&:focus': {
                    outline: '2px solid #3f51b5',
                    outlineOffset: '2px'
                  }
                }}
              >
                <CloseIcon />
              </IconButton>
            )}
          </Box>
        </DialogTitle>

        <DialogContent>
          <Box sx={{ mb: 4 }}>
            <CrawlerStepper />
            <ProgressIndicator />
            <StatusCard />
          </Box>

          <UpdatedCVEList />
        </DialogContent>

        <Box sx={{ display: 'flex', justifyContent: 'flex-end', p: 2 }}>
          <Button
            onClick={handleCloseDialog}
            disabled={isRunning}
            color="primary"
            variant="contained"
            startIcon={<CloseIcon />}
            aria-label="다이얼로그 닫기"
            tabIndex={0}
            sx={{
              '&.Mui-disabled': {
                bgcolor: 'rgba(0, 0, 0, 0.12)',
                color: 'rgba(0, 0, 0, 0.26)'
              },
              '&:focus': {
                outline: '2px solid #3f51b5',
                outlineOffset: '2px'
              }
            }}
          >
            닫기
          </Button>
        </Box>
      </Dialog>
    </>
  );
};

export default CrawlerUpdateButton;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/ReferencesTab.tsx
------------------------------------------------------------
import React, { memo } from 'react';
import GenericDataTab from './GenericDataTab';
import { referenceTabConfig } from './tabConfigs';
import { CVEDetail, SnortRule, GenericDataTabBaseProps, GenericDataTabProps, SnortRuleTabProps } from '../types/cve';

// SnortRuleTab 컴포넌트의 props 인터페이스 - types/cve.ts에 정의된 GenericDataTabBaseProps 사용

// 이전 버전과의 호환성을 위한 래퍼 컴포넌트
const referenceTab: React.FC<SnortRuleTabProps> = memo((props) => {
  // GenericDataTab이 JavaScript로 작성되어 있어 타입스크립트 인터페이스와 호환되지 않음
  // any 타입으로 단언하여 타입 오류 해결
  return React.createElement(GenericDataTab as any, {
    ...props,
    tabConfig: referenceTabConfig
  });
});

// displayName 설정 (React DevTools에서 디버깅 시 유용)
referenceTab.displayName = 'SnortRuleTab';

export default referenceTab;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/CommonStyles.tsx
------------------------------------------------------------
// CommonStyles.tsx
import { styled } from '@mui/material/styles';
import { Paper, Button, IconButton, Box, Theme } from '@mui/material';

export const StyledListItem = styled(Paper)(({ theme }: { theme: Theme }) => ({
  padding: '8px',
  marginBottom: '6px',
  backgroundColor: '#ffffff',
  borderRadius: theme.shape.borderRadius,
  border: `1px solid ${theme.palette.divider}`,
  '& + &': {
    marginTop: '6px'
  },
  '& .MuiTypography-root': {
    fontSize: '0.75rem',
    lineHeight: 1.4
  },
  '& .MuiTypography-caption': {
    fontSize: '0.65rem'
  },
  transition: 'all 0.2s ease-in-out',
  '&:hover': {
    transform: 'translateY(-2px)',
    boxShadow: theme.shadows[2]
  }
}));

export const ActionButton = styled(Button)(({ theme }: { theme: Theme }) => ({
  textTransform: 'none',
  borderRadius: theme.shape.borderRadius,
  padding: '4px 12px',
  fontSize: '0.75rem',
  fontWeight: 500,
  '&.MuiButton-outlined': {
    borderColor: theme.palette.divider,
    '&:hover': {
      backgroundColor: theme.palette.action.hover,
      borderColor: theme.palette.text.primary
    }
  }
}));

export const ActionIconButton = styled(IconButton)(({ theme }: { theme: Theme }) => ({
  color: theme.palette.text.secondary,
  '&:hover': {
    backgroundColor: theme.palette.action.hover,
    color: theme.palette.text.primary
  }
}));

export const ListHeader = styled('div')(({ theme }: { theme: Theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
  alignItems: 'center',
  marginBottom: theme.spacing(2)
}));

export const ChipLabel = styled('span')(({ theme }: { theme: Theme }) => ({
  display: 'flex',
  alignItems: 'center',
  gap: theme.spacing(0.5),
  fontSize: '0.75rem'
}));

export const EmptyState = styled(Paper)(({ theme }: { theme: Theme }) => ({
  padding: theme.spacing(2),
  textAlign: 'center',
  borderRadius: theme.shape.borderRadius * 2,
  backgroundColor: '#ffffff',
  border: `1px dashed ${theme.palette.divider}`,
  color: theme.palette.text.secondary,
  '& .MuiTypography-root': {
    fontSize: '0.75rem'
  },
}));

export const TabContentContainer = styled(Box)(({ theme }: { theme: Theme }) => ({
  display: 'flex',
  flexDirection: 'column',
  height: '100%',
  minHeight: 0,
  overflow: 'hidden'
}));

export const TabContentScroll = styled(Box)(({ theme }: { theme: Theme }) => ({
  flex: 1,
  minHeight: 0,
  overflowY: 'auto',
  padding: theme.spacing(1),
  '&::-webkit-scrollbar': {
    width: '6px',
    backgroundColor: 'transparent'
  },
  '&::-webkit-scrollbar-thumb': {
    backgroundColor: 'rgba(0, 0, 0, 0.1)',
    borderRadius: '3px',
    '&:hover': {
      backgroundColor: 'rgba(0, 0, 0, 0.2)'
    }
  }
}));


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/TabPanel.tsx
------------------------------------------------------------
import React from 'react';
import { Box } from '@mui/material';
import { TabPanelProps } from '../types/cve';

/**
 * 탭 패널 컴포넌트 - 선택된 탭의 내용을 표시합니다.
 *
 * @param children 탭 패널에 표시할 내용
 * @param value 현재 선택된 탭 인덱스
 * @param index 이 패널의 인덱스
 * @param other 기타 props
 */
const TabPanel: React.FC<TabPanelProps> = ({ children, value, index, ...other }) => {
  if (value !== index) return null;  // 선택되지 않은 탭은 렌더링하지 않음

  return (
    <Box
      role="tabpanel"
      id={`tabpanel-${index}`}
      aria-labelledby={`tab-${index}`}
      sx={{
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'auto',
        '&::-webkit-scrollbar': {
          width: '8px',
          backgroundColor: 'transparent'
        },
        '&::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.1)',
          borderRadius: '4px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.2)'
          }
        }
      }}
      {...other}
    >
      <Box sx={{ p: 3 }}>
        {children}
      </Box>
    </Box>
  );
};

export default TabPanel;



============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/useCommentMutation.ts
------------------------------------------------------------
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useSnackbar } from 'notistack';
import { AxiosError } from 'axios';
import api from 'shared/api/config/axios';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { SOCKET_EVENTS } from 'core/socket/services/constants';
import logger from 'shared/utils/logging';
import { CommentData } from '../types/CommentTypes';

// 타입 정의
export interface CVEDetailData {
  cveId: string;
  comments?: CommentData[];
  [key: string]: any;
}

// API 응답 타입
export interface CveApiResponse extends CVEDetailData {
  newComment?: CommentData;
  message?: string;
  status?: string;
}

export type MutationError = Error | AxiosError<{ detail?: string }>;

// 유틸리티 함수
export const extractMentions = (content: string): string[] =>
  content.match(/@(\w+)/g)?.map(mention => mention.substring(1)) || [];

/**
 * 댓글 관련 mutation hooks
 */
export const useCommentMutations = (
  cveId: string,
  currentUser?: { username: string; displayName?: string } | null,
  onCommentCountChange?: (count: number) => void,
  parentSendMessage?: (type: string, data: Record<string, unknown>) => Promise<boolean | null> | boolean | null
) => {
  const { enqueueSnackbar } = useSnackbar();
  const queryClient = useQueryClient();

  // 낙관적 업데이트 유틸리티
  const performOptimisticUpdate = async (
    updateFn: (cachedData: CVEDetailData) => CVEDetailData
  ): Promise<CVEDetailData | null> => {
    const queryKey = QUERY_KEYS.CVE.detail(cveId);
    await queryClient.cancelQueries({ queryKey });
    const previousData = queryClient.getQueryData<CVEDetailData>(queryKey);

    if (previousData) {
      try {
        const optimisticData = updateFn(previousData);
        queryClient.setQueryData<CVEDetailData>(queryKey, optimisticData);
        logger.info('CommentsTab: 낙관적 업데이트 적용', { queryKey });
        const newActiveCount = (optimisticData.comments || []).filter(c => !c.isDeleted).length;
        onCommentCountChange?.(newActiveCount);
        return previousData;
      } catch (error) {
        logger.error('CommentsTab: 낙관적 업데이트 함수 오류', error);
        return previousData;
      }
    }
    return null;
  };

  // 공통 에러 핸들러
  const handleMutationError = (
    error: MutationError, 
    context: CVEDetailData | null | undefined, 
    defaultMessage: string
  ) => {
    logger.error(`${defaultMessage} 실패:`, error);
    if (context) { // 롤백
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), context);
      const rollbackActiveCount = (context.comments || []).filter(c => !c.isDeleted).length;
      onCommentCountChange?.(rollbackActiveCount);
    }
    // Axios 에러 응답에서 detail 메시지 추출 시도
    const detail = (error as AxiosError<{ detail?: string }>)?.response?.data?.detail;
    enqueueSnackbar(detail || defaultMessage, { variant: 'error' });
  };

  // 1. 댓글 생성 mutation
  const createCommentMutation = useMutation<CveApiResponse, MutationError, string, CVEDetailData | null>({
    mutationFn: async (content) => {
      const mentions = extractMentions(content);
      const response = await api.post<CveApiResponse>(`/cves/${cveId}/comments`, { content, mentions });
      return response.data;
    },
    onMutate: async (content) => {
      if (!currentUser) return null;
      return performOptimisticUpdate(cachedData => {
        const tempId = `temp-comment-${Date.now()}`;
        const tempComment: CommentData = { 
          id: tempId, 
          content, 
          author: currentUser.username, 
          authorName: currentUser.displayName || currentUser.username, 
          createdAt: new Date().toISOString(), 
          parentId: undefined, 
          isDeleted: false, 
          isOptimistic: true 
        };
        const comments = cachedData.comments || [];
        return { ...cachedData, comments: [...comments, tempComment] };
      });
    },
    onSuccess: async (responseData, content) => {
      logger.info('댓글 작성 성공', { 
        responseAvailable: !!responseData,
        commentsAvailable: !!responseData.comments,
        commentsCount: responseData.comments ? responseData.comments.length : 0,
        cveId
      });
      
      // 서버 응답에 comments 배열이 포함된 경우 캐시 업데이트
      if (responseData && responseData.comments) {
        logger.info('댓글 작성 후 전체 CVE 데이터 수신', { 
          commentsCount: responseData.comments.length 
        });
        
        // 소켓 이벤트 전송
        await parentSendMessage?.(SOCKET_EVENTS.COMMENT_ADDED, { 
          cveId, 
          data: { 
            comments: responseData.comments,
            author: currentUser?.username
          }, 
        });
        
        // 성공 시 캐시 업데이트
        queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), responseData);
        const newActiveCount = (responseData.comments || []).filter(c => !c.isDeleted).length;
        onCommentCountChange?.(newActiveCount);
        enqueueSnackbar('댓글이 작성되었습니다.', { variant: 'success' });
      } else {
        // 서버로부터 완전한 데이터를 받지 못한 경우 쿼리 무효화
        logger.warn('댓글 작성 성공했으나 응답에 comments 데이터가 유효하지 않음', responseData);
        queryClient.invalidateQueries({ 
          queryKey: QUERY_KEYS.CVE.detail(cveId),
          refetchType: 'active'
        });
        enqueueSnackbar('댓글이 작성되었지만 최신 데이터를 가져오는 중입니다.', { variant: 'info' });
      }
    },
    onError: (error, variables, context) => 
      handleMutationError(error, context, '댓글 작성 중 오류 발생'),
  });

  // 2. 댓글 수정 mutation
  interface EditCommentVariables { 
    commentId: string; 
    content: string; 
  }

  const editCommentMutation = useMutation<CveApiResponse, MutationError, EditCommentVariables, CVEDetailData | null>({
    mutationFn: async ({ commentId, content }) => {
      const response = await api.patch<CveApiResponse>(`/cves/${cveId}/comments/${commentId}`, { content });
      return response.data;
    },
    onMutate: async ({ commentId, content }) => {
      return performOptimisticUpdate(cachedData => {
        const comments = cachedData.comments || [];
        const updatedComments = comments.map(c => 
          c.id === commentId 
            ? { 
                ...c, 
                content, 
                lastModifiedAt: new Date().toISOString(), 
                isOptimistic: true 
              } 
            : c
        );
        return { ...cachedData, comments: updatedComments };
      });
    },
    onSuccess: async (responseData, { commentId, content }) => {
      logger.info('댓글 수정 성공', { commentId });
      const mentions = extractMentions(content);
      if (mentions.length > 0 && currentUser) {
        await parentSendMessage?.(SOCKET_EVENTS.MENTION_ADDED, { 
          type: 'mention', 
          recipients: mentions, 
          content: `${currentUser.displayName || currentUser.username}님이 댓글에서 회원님을 멘션했습니다.`, 
          metadata: { cveId, commentId, comment_content: content } 
        });
      }
      await parentSendMessage?.(SOCKET_EVENTS.COMMENT_UPDATED, { 
        cveId, 
        cve: responseData,
        updatedCommentId: commentId 
      });
      // 성공 시 캐시 업데이트
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), responseData);
      enqueueSnackbar('댓글이 수정되었습니다.', { variant: 'success' });
    },
    onError: (error, variables, context) => 
      handleMutationError(error, context, '댓글 수정 중 오류 발생'),
  });

  // 3. 답글 작성 mutation
  interface ReplyCommentVariables { 
    parentId: string; 
    content: string; 
  }

  const replyCommentMutation = useMutation<CveApiResponse, MutationError, ReplyCommentVariables, CVEDetailData | null>({
    mutationFn: async ({ parentId, content }) => {
      const mentions = extractMentions(content);
      const response = await api.post<CveApiResponse>(`/cves/${cveId}/comments`, { 
        content, 
        parent_id: parentId, 
        mentions 
      });
      return response.data;
    },
    onMutate: async ({ parentId, content }) => {
      if (!currentUser) return null;
      return performOptimisticUpdate(cachedData => {
        const tempId = `temp-reply-${Date.now()}`;
        const tempComment: CommentData = { 
          id: tempId, 
          content, 
          author: currentUser.username, 
          authorName: currentUser.displayName || currentUser.username, 
          createdAt: new Date().toISOString(), 
          parentId, 
          isDeleted: false, 
          isOptimistic: true 
        };
        const comments = cachedData.comments || [];
        return { ...cachedData, comments: [...comments, tempComment] };
      });
    },
    onSuccess: async (responseData, { parentId, content }) => {
      const newCommentId = responseData.newComment?.id;
      logger.info('답글 작성 성공', { parentId, newCommentId });
      const mentions = extractMentions(content);
      if (mentions.length > 0 && currentUser && newCommentId) {
        await parentSendMessage?.(SOCKET_EVENTS.MENTION_ADDED, { 
          type: 'mention', 
          recipients: mentions, 
          content: `${currentUser.displayName || currentUser.username}님이 답글에서 회원님을 멘션했습니다.`, 
          metadata: { cveId, commentId: newCommentId, comment_content: content } 
        });
      }
      await parentSendMessage?.(SOCKET_EVENTS.COMMENT_ADDED, { 
        cveId, 
        cve: responseData,
        newComment: responseData.newComment 
      });
      // 성공 시 캐시 업데이트
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), responseData);
      const newActiveCount = (responseData.comments || []).filter(c => !c.isDeleted).length;
      onCommentCountChange?.(newActiveCount); // 댓글 수 업데이트
      enqueueSnackbar('답글이 작성되었습니다.', { variant: 'success' });
    },
    onError: (error, variables, context) => 
      handleMutationError(error, context, '답글 작성 중 오류 발생'),
  });

  // 4. 댓글 삭제 mutation
  interface DeleteCommentVariables { 
    commentId: string; 
    permanent: boolean; 
  }

  const deleteCommentMutation = useMutation<CveApiResponse, MutationError, DeleteCommentVariables, CVEDetailData | null>({
    mutationFn: async ({ commentId, permanent }) => {
      const response = await api.delete<CveApiResponse>(`/cves/${cveId}/comments/${commentId}`, { 
        params: { permanent } 
      });
      return response.data;
    },
    onMutate: async ({ commentId, permanent }) => {
      // 먼저 진행 중인 쿼리를 취소해서 낙관적 업데이트와 충돌 방지
      await queryClient.cancelQueries({ queryKey: QUERY_KEYS.CVE.detail(cveId) });
      
      // 이전 상태 저장
      const previousData = queryClient.getQueryData<CVEDetailData>(QUERY_KEYS.CVE.detail(cveId));
      
      if (!previousData) return null;
      
      try {
        // 낙관적 업데이트 적용
        const cachedData = { ...previousData };
        const comments = cachedData.comments || [];
        
        // 영구 삭제 시 목록에서 제거, 소프트 삭제 시 isDeleted 플래그만 설정
        const updatedComments = permanent
          ? comments.filter(c => c.id !== commentId)
          : comments.map(c => c.id === commentId ? { ...c, isDeleted: true, isOptimistic: true } : c);
        
        const optimisticData = { ...cachedData, comments: updatedComments };
        
        // 캐시 업데이트
        queryClient.setQueryData<CVEDetailData>(QUERY_KEYS.CVE.detail(cveId), optimisticData);
        
        // 댓글 수 업데이트 (낙관적으로)
        const newActiveCount = updatedComments.filter(c => !c.isDeleted).length;
        onCommentCountChange?.(newActiveCount);
        
        logger.info('CommentsTab: 댓글 삭제 낙관적 업데이트 완료', { commentId, permanent });
        
        return previousData;
      } catch (error) {
        logger.error('CommentsTab: 낙관적 업데이트 오류', error);
        return previousData;
      }
    },
    onSuccess: async (responseData, { commentId, permanent }) => {
      logger.info('댓글 삭제 성공', { commentId, permanent });
      
      // 소켓 이벤트 발생
      await parentSendMessage?.(SOCKET_EVENTS.COMMENT_DELETED, { 
        cveId, 
        cve: responseData,
        deletedCommentId: commentId, 
        isPermanent: permanent 
      });
      
      // 이미 낙관적 업데이트를 통해 UI가 업데이트됐으므로,
      // 서버의 응답과 클라이언트 상태가 일치하는지 검증 후 
      // 필요한 경우에만 업데이트 (깜빡임 방지)
      const currentData = queryClient.getQueryData<CVEDetailData>(QUERY_KEYS.CVE.detail(cveId));
      
      if (currentData) {
        // 서버 응답에 낙관적 업데이트 마커 제거 (참조 비교를 위해)
        const sanitizedComments = responseData.comments?.map(comment => {
          const { isOptimistic, ...rest } = comment as any;
          return rest;
        });
        
        const updatedResponseData = {
          ...responseData,
          comments: sanitizedComments
        };
        
        // refetchActive: true 옵션은 사용하지 않고 수동으로 상태 관리
        // setQueryData로 상태 업데이트 (refetch 없이 상태 업데이트)
        queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), updatedResponseData);
      }
      
      // 댓글 수 업데이트
      const newActiveCount = (responseData.comments || []).filter(c => !c.isDeleted).length;
      onCommentCountChange?.(newActiveCount);
      
      enqueueSnackbar(permanent ? '댓글이 영구적으로 삭제되었습니다.' : '댓글이 삭제되었습니다.', { 
        variant: 'success' 
      });
    },
    onError: (error, variables, context) => {
      // 롤백 처리 개선
      if (context) {
        const previousData = context as CVEDetailData;
        // 원래 상태로 복원
        queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), previousData);
        
        // 댓글 수도 복원
        const rollbackActiveCount = (previousData.comments || []).filter(c => !c.isDeleted).length;
        onCommentCountChange?.(rollbackActiveCount);
      }
      
      // 사용자에게 오류 알림
      const detail = (error as AxiosError<{ detail?: string }>)?.response?.data?.detail;
      enqueueSnackbar(detail || '댓글 삭제 중 오류가 발생했습니다.', { variant: 'error' });
      
      logger.error('댓글 삭제 실패:', error);
    }
  });

  return {
    createCommentMutation,
    editCommentMutation,
    replyCommentMutation,
    deleteCommentMutation,
    // 편의를 위한 핸들러 함수들
    createComment: (content: string) => {
      if (!content.trim()) {
        enqueueSnackbar('댓글 내용을 입력해주세요.', { variant: 'warning' });
        return;
      }
      createCommentMutation.mutate(content);
    },
    editComment: (commentId: string, content: string) => {
      if (!content.trim()) {
        enqueueSnackbar('댓글 내용을 입력해주세요.', { variant: 'warning' });
        return;
      }
      editCommentMutation.mutate({ commentId, content });
    },
    replyComment: (parentId: string, content: string) => {
      if (!content.trim()) {
        enqueueSnackbar('답글 내용을 입력해주세요.', { variant: 'warning' });
        return;
      }
      replyCommentMutation.mutate({ parentId, content });
    },
    deleteComment: (commentId: string, permanent: boolean = false) => {
      deleteCommentMutation.mutate({ commentId, permanent });
    },
    // 로딩 상태 통합
    isLoading: 
      createCommentMutation.isPending || 
      editCommentMutation.isPending || 
      replyCommentMutation.isPending || 
      deleteCommentMutation.isPending
  };
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/socket/useCVESubscription.ts
------------------------------------------------------------
// socket/useCVESubscription.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { useSocket } from 'core/socket/hooks/useSocket';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { useQueryClient } from '@tanstack/react-query';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import logger from 'shared/utils/logging';
import socketService from 'core/socket/services/socketService';
import socketEventBus from 'core/socket/services/socketEventBus';
import { SUBSCRIPTION_EVENTS } from 'core/socket/services/constants';
import { Subscription } from 'rxjs';

// 구독자 타입 정의
export interface Subscriber {
  id: string;
  userId: string;
  username: string;
  displayName: string;
  profileImage?: string;
}

// 구독 상태 타입
interface SubscriptionState {
  isSubscribed: boolean;
  isLoading: boolean;
  error: string | null;
}

// 구독 상태 이벤트 타입
interface SubscriptionStatusEvent {
  cveId: string;
  subscribed: boolean;
}

/**
 * CVE 구독 관련 훅
 * - 구독/구독취소 액션 제공
 * - 구독자 정보 조회 (중앙 관리 시스템 활용)
 */
export function useCVESubscription(cveId: string) {
  const { connected } = useSocket();
  const { user } = useAuth();
  const queryClient = useQueryClient();
  
  // 구독 상태 (로컬 상태로 관리)
  const [state, setState] = useState<SubscriptionState>({
    isSubscribed: false, // 초기값은 false, 이후 useEffect에서 업데이트됨
    isLoading: false,
    error: null
  });
  
  // 기본적인 refs
  const componentIdRef = useRef(`cve-subscription-${cveId}`);
  const attemptedInitialSubscriptionRef = useRef(false);
  const subscriptionsRef = useRef<Subscription[]>([]);
  
  // 구독자 목록 가져오기 (중앙 관리 시스템에서)
  const getSubscribers = useCallback(() => {
    // 쿼리 클라이언트에서 구독자 목록 가져오기
    const subscribersKey = [QUERY_KEYS.CVE_SUBSCRIBERS, cveId];
    let subscribers: Subscriber[] = queryClient.getQueryData(subscribersKey) || [];
    
    return subscribers;
  }, [cveId, queryClient]);
  
  // 구독하기
  const subscribe = useCallback((silent: boolean = false) => {
    if (!connected || !user) {
      if (!silent) {
        setState(prev => ({
          ...prev,
          error: '소켓 연결이 없거나 로그인되지 않았습니다.'
        }));
      }
      return;
    }
    
    setState(prev => ({
      ...prev,
      isLoading: true,
      error: null
    }));
    
    logger.debug('useCVESubscription', `CVE 구독 시도: ${cveId}`, { cveId });
    
    try {
      // 이벤트 버스를 통해 구독 요청 이벤트 발행 대신
      // socketService의 updateSubscription 메서드 사용
      socketService.updateSubscription(cveId, true);
      
      // 성공 시 UI 상태 업데이트 - 실제 상태는 이벤트 응답으로 업데이트됨
      setState(prev => ({
        ...prev,
        isLoading: false
      }));
      
      logger.info('useCVESubscription', `CVE 구독 요청 성공: ${cveId}`, { cveId });
    } catch (error: any) {
      // 실패 시 오류 상태로 업데이트
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error?.message || '구독 요청 실패'
      }));
      
      logger.error('useCVESubscription', `CVE 구독 실패: ${cveId}`, { 
        cveId, 
        error 
      });
    }
  }, [cveId, connected, user]);
  
  // 구독 취소하기
  const unsubscribe = useCallback((silent: boolean = false) => {
    if (!connected) {
      if (!silent) {
        setState(prev => ({
          ...prev,
          error: '소켓 연결이 없습니다.'
        }));
      }
      return;
    }
    
    setState(prev => ({
      ...prev,
      isLoading: true,
      error: null
    }));
    
    logger.debug('useCVESubscription', `CVE 구독 취소 시도: ${cveId}`, { cveId });
    
    try {
      // 이벤트 버스를 통해 구독 취소 요청 이벤트 발행 대신
      // socketService의 updateSubscription 메서드 사용
      socketService.updateSubscription(cveId, false);
      
      // 성공 시 UI 상태 업데이트 - 실제 상태는 이벤트 응답으로 업데이트됨
      setState(prev => ({
        ...prev,
        isLoading: false
      }));
      
      logger.info('useCVESubscription', `CVE 구독 취소 요청 성공: ${cveId}`, { cveId });
    } catch (error: any) {
      // 실패 시 오류 상태로 업데이트
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error?.message || '구독 취소 요청 실패'
      }));
      
      logger.error('useCVESubscription', `CVE 구독 취소 실패: ${cveId}`, {
        cveId,
        error
      });
    }
  }, [cveId, connected]);
  
  // 구독 상태 변경 감시 (이벤트 버스 사용)
  useEffect(() => {
    // 이벤트 버스를 통한 구독 상태 업데이트 구독
    const subscription = socketEventBus.on<SubscriptionStatusEvent>(SUBSCRIPTION_EVENTS.SUBSCRIPTION_STATUS)
      .subscribe(data => {
        if (data && data.cveId === cveId) {
          const isSubscribed = !!data.subscribed;
          
          // 로컬 상태와 다를 경우에만 업데이트
          if (state.isSubscribed !== isSubscribed) {
            setState(prev => ({
              ...prev,
              isSubscribed,
              isLoading: false,
              error: null
            }));
            
            logger.debug('useCVESubscription', `구독 상태 업데이트: ${isSubscribed ? '구독중' : '미구독'}`, {
              cveId,
              isSubscribed
            });
          }
        }
      });
    
    // 구독 추적을 위해 ref에 저장
    subscriptionsRef.current.push(subscription);
    
    return () => {
      // 구독 정리
      subscription.unsubscribe();
    };
  }, [cveId, state.isSubscribed]);
  
  // 컴포넌트 언마운트 시 모든 구독 정리
  useEffect(() => {
    return () => {
      // 모든 RxJS 구독 정리
      subscriptionsRef.current.forEach(subscription => {
        if (subscription && !subscription.closed) {
          subscription.unsubscribe();
        }
      });
      subscriptionsRef.current = [];
      
      logger.debug('useCVESubscription', `구독 훅 정리: ${cveId}`, { cveId });
    };
  }, [cveId]);
  
  return {
    // 구독 관련 상태 및 액션
    isSubscribed: state.isSubscribed,
    isLoading: state.isLoading,
    error: state.error,
    subscribe,
    unsubscribe,
    
    // 구독자 목록 접근자
    getSubscribers,
  };
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/socket/cveHandlers.ts
------------------------------------------------------------
// frontend/src/features/cve/hooks/socket/cveHandlers.ts
import { QueryClient } from '@tanstack/react-query';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import logger from 'shared/utils/logging';
import socketService from 'core/socket/services/socketService';
import { 
  SOCKET_EVENTS, 
  CVE_EVENTS, 
  SUBSCRIPTION_EVENTS 
} from 'core/socket/services/constants';

/**
 * CVE 이벤트 핸들러 모음
 */

/**
 * CVE 웹소켓 업데이트 처리 함수
 * 웹소켓 이벤트로 수신된 CVE 변경사항을 React Query 캐시에 반영
 */
export const handleCVESubscriptionUpdate = (
  queryClient: QueryClient,
  data: { type?: string; payload?: any; }
) => {
  if (!data || !data.type) {
    logger.warn('handleCVESubscriptionUpdate', '유효하지 않은 이벤트 데이터', { data });
    return;
  }

  const { type, payload } = data;
  const logData = { type, payloadId: payload?.id };
  const eventId = Date.now().toString(36) + Math.random().toString(36).substr(2);

  // 서버가 보내는 데이터 형식 로깅 (향상된 디버깅)
  logger.info('handleCVESubscriptionUpdate', `상세 이벤트 데이터 로깅(${eventId})`, {
    type,
    payload: payload ? {
      id: payload.id,
      cveId: payload.cveId,
      cve_id: payload.cve_id,
      keys: payload ? Object.keys(payload) : [],
      hasSubscribers: payload?.subscribers !== undefined,
      subscribersCount: Array.isArray(payload?.subscribers) ? payload.subscribers.length : '없음',
      isSubscribed: payload?.subscribed
    } : '페이로드 없음',
    rawData: {
      type,
      keys: Object.keys(data),
      payloadType: payload ? typeof payload : '없음',
    },
    timestamp: new Date().toISOString()
  });

  switch (type) {
    case CVE_EVENTS.CVE_CREATED:
      logger.info('handleCVESubscriptionUpdate', `CVE 생성 이벤트(${eventId}) 수신`, logData);
      queryClient.invalidateQueries({ 
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
      logger.debug('handleCVESubscriptionUpdate', `CVE 생성 이벤트(${eventId}) 처리 완료`);
      break;

    case CVE_EVENTS.CVE_UPDATED:
      logger.info('handleCVESubscriptionUpdate', `CVE 업데이트 이벤트(${eventId}) 수신`, logData);
      
      // 구독 상태 관련 정보가 있으면 추가 로깅
      if (payload?.subscribed !== undefined || payload?.subscribers !== undefined) {
        logger.info('handleCVESubscriptionUpdate', `구독 관련 정보 포함됨(${eventId})`, {
          cveId: payload.id,
          isSubscribed: payload.subscribed,
          subscribersCount: Array.isArray(payload.subscribers) ? payload.subscribers.length : '알 수 없음',
          subscribersFormat: Array.isArray(payload.subscribers) 
            ? `배열: [${payload.subscribers.slice(0, 2).map(s => JSON.stringify({id: s.id, username: s.username})).join(', ')}${payload.subscribers.length > 2 ? '...' : ''}]`
            : typeof payload.subscribers
        });
        
        // socketService 상태 업데이트 (CveId가 있고 구독 정보가 있는 경우)
        if (payload.id && typeof payload.subscribed === 'boolean') {
          socketService.updateSubscription(payload.id, payload.subscribed);
          logger.debug('handleCVESubscriptionUpdate', `구독 상태 자동 업데이트: ${payload.id}`, {
            isSubscribed: payload.subscribed
          });
        }
      }
      
      // 상세 정보 캐시 업데이트
      queryClient.setQueryData(
        QUERY_KEYS.CVE.detail(payload.id), 
        (oldData: any) => oldData ? { ...oldData, ...payload } : payload
      );
      // 목록 갱신
      queryClient.invalidateQueries({ 
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
      logger.debug('handleCVESubscriptionUpdate', `CVE 업데이트 이벤트(${eventId}) 처리 완료`);
      break;

    case CVE_EVENTS.CVE_DELETED:
      logger.info('handleCVESubscriptionUpdate', `CVE 삭제 이벤트(${eventId}) 수신`, logData);
      
      // 상세 정보 캐시 제거
      queryClient.removeQueries({ 
        queryKey: QUERY_KEYS.CVE.detail(payload.id) 
      });
      // 목록 갱신
      queryClient.invalidateQueries({ 
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
      logger.debug('handleCVESubscriptionUpdate', `CVE 삭제 이벤트(${eventId}) 처리 완료`);
      break;

    default:
      logger.warn('handleCVESubscriptionUpdate', `알 수 없는 이벤트 타입(${eventId})`, { type, payload });
  }
};

/**
 * CVE 생성 이벤트 처리 함수
 */
export const handleCVECreated = (queryClient: QueryClient, newCve: any) => {
  const eventId = Date.now().toString(36) + Math.random().toString(36).substr(2);
  
  // 향상된 로깅 - 실제 데이터 형식 기록
  logger.info('handleCVECreated', `CVE 생성 데이터 형식(${eventId})`, {
    // 원본 필드와 변환된 필드 함께 로깅 (서버와 클라이언트 형식 비교)
    id: newCve?.id,
    cveId: newCve?.cveId, 
    cve_id: newCve?.cve_id,
    
    // 데이터 구조 정보
    dataStructure: {
      keys: Object.keys(newCve || {}),
      types: Object.entries(newCve || {}).reduce((acc, [key, val]) => {
        acc[key] = typeof val;
        return acc;
      }, {} as Record<string, string>)
    },
    
    // 중요 필드 샘플 (구독 관련)
    subscribed: newCve?.subscribed,
    hasSubscribers: newCve?.subscribers !== undefined,
    subscribersType: newCve?.subscribers ? (Array.isArray(newCve.subscribers) ? 'array' : typeof newCve.subscribers) : 'undefined',
    subscribersCount: Array.isArray(newCve?.subscribers) ? newCve.subscribers.length : 0,
    
    timestamp: new Date().toISOString()
  });
  
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.lists(),
    refetchType: 'active'
  });
  
  // 통계 데이터 쿼리도 함께 무효화
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.stats(),
    refetchType: 'active'
  });
  
  // 통계 데이터 강제 리패치 (staleTime 무시)
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.stats(),
    type: 'active',
    exact: true
  });
  
  // 전체 CVE 개수 쿼리도 함께 무효화 및 리패치
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.totalCount(),
    refetchType: 'active'
  });
  
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.totalCount(),
    type: 'active',
    exact: true
  });
  
  logger.debug('handleCVECreated', `CVE 생성 이벤트(${eventId}) 처리 완료`, {
    cveId: newCve?.id || newCve?.cveId || newCve?.cve_id
  });
};

/**
 * CVE 업데이트 이벤트 처리 함수
 */
export const handleCVEUpdated = (queryClient: QueryClient, updatedCve: any) => {
  const eventId = Date.now().toString(36) + Math.random().toString(36).substr(2);
  const updatedCveId = updatedCve?.id || updatedCve?.cveId;
  
  // 향상된 로깅 - 데이터 형식 및 구독 정보 기록
  logger.info('handleCVEUpdated', `CVE 업데이트 데이터 형식(${eventId})`, {
    // ID 정보 (다양한 형식 모두 로깅)
    id: updatedCve?.id,
    cveId: updatedCve?.cveId,
    cve_id: updatedCve?.cve_id,
    
    // 구독 관련 정보
    subscription: {
      isSubscribed: updatedCve?.subscribed,
      subscribersCount: Array.isArray(updatedCve?.subscribers) ? updatedCve.subscribers.length : 0,
      subscribersFormat: updatedCve?.subscribers 
        ? (Array.isArray(updatedCve.subscribers) 
          ? `배열[${updatedCve.subscribers.length}]: ${JSON.stringify(updatedCve.subscribers.slice(0, 1))}`
          : typeof updatedCve.subscribers)
        : '없음',
    },
    
    // 전체 데이터 키와 타입
    dataKeys: Object.keys(updatedCve || {}),
    topLevelTypes: Object.entries(updatedCve || {})
      .filter(([key]) => ['id', 'cveId', 'cve_id', 'subscribed', 'subscribers'].includes(key))
      .reduce((acc, [key, val]) => {
        acc[key] = `${typeof val}${Array.isArray(val) ? `[${(val as any[]).length}]` : ''}`;
        return acc;
      }, {} as Record<string, string>),
      
    timestamp: new Date().toISOString()
  });
  
  // 구독 상태 자동 업데이트 (필요한 경우)
  if (updatedCveId && typeof updatedCve.subscribed === 'boolean') {
    socketService.updateSubscription(updatedCveId, updatedCve.subscribed);
    logger.debug('handleCVEUpdated', `구독 상태 자동 업데이트: ${updatedCveId}`, {
      isSubscribed: updatedCve.subscribed
    });
  }
  
  // 통계 데이터 강제 리패치 (staleTime 무시)
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.stats(),
    type: 'active',
    exact: true
  });
  
  // 전체 CVE 개수 쿼리도 함께 무효화 및 리패치
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.totalCount(),
    refetchType: 'active'
  });
  
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.totalCount(),
    type: 'active',
    exact: true
  });

  // 상세 정보 캐시 업데이트
  if (updatedCveId) {
    queryClient.setQueryData(
      QUERY_KEYS.CVE.detail(updatedCveId), 
      (oldData: any) => oldData ? { ...oldData, ...updatedCve } : updatedCve
    );
  }
  
  // 목록 갱신
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.lists(),
    refetchType: 'active'
  });
  
  logger.debug('handleCVEUpdated', `CVE 업데이트 이벤트(${eventId}) 처리 완료`, {
    cveId: updatedCveId
  });
};

/**
 * CVE 삭제 이벤트 처리 함수
 */
export const handleCVEDeleted = (queryClient: QueryClient, deletedCve: any) => {
  const eventId = Date.now().toString(36) + Math.random().toString(36).substr(2);
  const deletedCveId = deletedCve?.id || deletedCve?.cveId;
  
  // 향상된 로깅 - 데이터 형식 정보 포함
  logger.info('handleCVEDeleted', `CVE 삭제 데이터 형식(${eventId})`, {
    // ID 정보 (다양한 형식)
    id: deletedCve?.id,
    cveId: deletedCve?.cveId,
    cve_id: deletedCve?.cve_id,
    
    // 객체 구조 정보
    dataFormat: {
      keys: Object.keys(deletedCve || {}),
      objectType: typeof deletedCve,
      hasSubscriptionInfo: deletedCve?.subscribed !== undefined || deletedCve?.subscribers !== undefined
    },
    
    timestamp: new Date().toISOString()
  });
  
  // 해당 CVE의 상세 정보 캐시 무효화
  if (deletedCveId) {
    queryClient.removeQueries({
      queryKey: QUERY_KEYS.CVE.detail(deletedCveId)
    });
  }
  
  // 목록 갱신
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.lists(),
    refetchType: 'active'
  });
  
  // 통계 데이터 쿼리도 함께 무효화
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.stats(),
    refetchType: 'active'
  });
  
  // 통계 데이터 강제 리패치 (staleTime 무시)
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.stats(),
    type: 'active',
    exact: true
  });
  
  // 전체 CVE 개수 쿼리도 함께 무효화 및 리패치
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.totalCount(),
    refetchType: 'active'
  });
  
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.totalCount(),
    type: 'active',
    exact: true
  });
  
  logger.debug('handleCVEDeleted', `CVE 삭제 이벤트(${eventId}) 처리 완료`, {
    cveId: deletedCveId
  });
};



============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/socket/useCVESocket.ts
------------------------------------------------------------
// core/socket/hooks/useCVESocket.ts
import { useCallback, useRef } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import _ from 'lodash';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { SOCKET_EVENTS } from 'core/socket/services/constants';
import useSocket from 'core/socket/hooks/useSocket';
import { 
  handleCVECreated, 
  handleCVEUpdated, 
  handleCVEDeleted 
} from './cveHandlers';
import logger from 'shared/utils/logging';

/**
 * CVE 관련 소켓 이벤트 처리를 위한 훅
 * 기본 소켓 기능에 CVE 이벤트 처리 기능을 추가합니다.
 */
export function useCVESocket(cveId?: string) {
  const queryClient = useQueryClient();
  const reconnectAttemptsRef = useRef(0);
  const isSubscribedRef = useRef(false);
  
  // 컴포넌트 ID - 식별을 위해 cveId 활용
  const componentId = cveId 
    ? `cve-socket-${cveId}` 
    : 'cve-socket-list';
  
  // 기본 소켓 훅 사용
  const { 
    connected, 
    emit, 
    on, 
    cleanup,
    socket
  } = useSocket(undefined, undefined, [], {
    componentId,
    useRxJS: true
  });
  
  // 디바운스된 쿼리 무효화 함수
  const invalidateCVEQueries = useCallback(
    _.debounce(() => {
      logger.debug('useCVESocket', '디바운스된 쿼리 무효화 실행');
      queryClient.invalidateQueries({
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
    }, 300),
    [queryClient]
  );
  
  // CVE 생성 이벤트 핸들러
  const onCVECreated = useCallback((data: any) => {
    handleCVECreated(queryClient, data);
  }, [queryClient]);
  
  // CVE 업데이트 이벤트 핸들러
  const onCVEUpdated = useCallback((data: any) => {
    handleCVEUpdated(queryClient, data);
  }, [queryClient]);
  
  // CVE 삭제 이벤트 핸들러
  const onCVEDeleted = useCallback((data: any) => {
    handleCVEDeleted(queryClient, data);
  }, [queryClient]);
  
  // CVE 목록 구독 기능
  const subscribeCVEList = useCallback(() => {
    if (connected && !isSubscribedRef.current) {
      logger.info('useCVESocket', 'CVE 목록 업데이트 구독 요청');
      
      // 서버에 구독 요청 전송
      emit(SOCKET_EVENTS.SUBSCRIBE_CVES, {});
      isSubscribedRef.current = true;
      
      return true;
    }
    return false;
  }, [connected, emit]);
  
  // CVE 목록 구독 해제 기능
  const unsubscribeCVEList = useCallback(() => {
    if (connected && isSubscribedRef.current) {
      logger.info('useCVESocket', 'CVE 목록 업데이트 구독 해제');
      
      // 서버에 구독 해제 요청 전송
      emit(SOCKET_EVENTS.UNSUBSCRIBE_CVES, {});
      isSubscribedRef.current = false;
      
      return true;
    }
    return false;
  }, [connected, emit]);
  
  // 단일 CVE 구독 기능
  const subscribeCVE = useCallback((id: string) => {
    if (connected && id) {
      logger.info('useCVESocket', `단일 CVE 구독: ${id}`);
      emit(SOCKET_EVENTS.SUBSCRIBE_CVE, { cve_id: id });
      return true;
    }
    return false;
  }, [connected, emit]);
  
  // 단일 CVE 구독 해제 기능
  const unsubscribeCVE = useCallback((id: string) => {
    if (connected && id) {
      logger.info('useCVESocket', `단일 CVE 구독 해제: ${id}`);
      emit(SOCKET_EVENTS.UNSUBSCRIBE_CVE, { cve_id: id });
      return true;
    }
    return false;
  }, [connected, emit]);
  
  return {
    // 기본 소켓 속성 및 메서드
    connected,
    socket,
    on,
    emit,
    cleanup,
    
    // CVE 특화 이벤트 핸들러
    onCVECreated,
    onCVEUpdated,
    onCVEDeleted,
    
    // CVE 특화 기능
    invalidateCVEQueries,
    subscribeCVEList,
    unsubscribeCVEList,
    subscribeCVE,
    unsubscribeCVE,
    
    // 상태 관리
    isSubscribed: isSubscribedRef.current,
    reconnectAttempts: reconnectAttemptsRef.current
  };
}

export default useCVESocket;



============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/socket/useCVEListSocketUpdates.ts
------------------------------------------------------------
// socket/useCVEListSocketUpdates.ts
import { useRef, useEffect } from 'react';
import { useTimers } from '../utils/cveQueryUtils';
import useCVESocket from './useCVESocket';
import logger from 'shared/utils/logging';
import { CVE_EVENTS } from 'core/socket/services/constants';

/**
 * CVE 목록 실시간 업데이트 훅
 * 웹소켓을 통해 CVE 목록 변경사항을 실시간으로 수신하고 쿼리 캐시를 업데이트
 * 
 * @returns 연결 상태 객체
 */
export function useCVEListUpdates() {
  // 코어 소켓 훅 사용
  const { 
    connected, 
    on, 
    cleanup,
    invalidateCVEQueries,
    onCVECreated,
    onCVEUpdated,
    onCVEDeleted,
    subscribeCVEList,
    unsubscribeCVEList
  } = useCVESocket();
  
  const { startTimer, clearTimer, clearAllTimers } = useTimers();
  
  // 재연결 상태 추적
  const reconnectAttemptsRef = useRef(0);
  
  // 구독 상태 관리용 ref
  const isSubscribedRef = useRef(false);
  
  // 연결 손실 및 복구 처리 기능 (간소화됨)
  const handleConnectionChange = (isConnected: boolean) => {
    if (!isConnected) {
      logger.warn('useCVEListUpdates', '웹소켓 연결 끊김 감지');
      reconnectAttemptsRef.current = 0;
    } else if (reconnectAttemptsRef.current > 0) {
      logger.info('useCVEListUpdates', '웹소켓 연결 복구됨');
      // 연결 복구 후 구독 복구 시도
      if (isSubscribedRef.current) {
        logger.info('useCVEListUpdates', '구독 상태 복구 시도');
        subscribeCVEList();
      }
    }
  };
  
  // 웹소켓 이벤트 구독 설정
  useEffect(() => {
    if (connected && !isSubscribedRef.current) {
      logger.info('useCVEListUpdates', 'CVE 업데이트 구독 요청 전송');
      
      // 이벤트 구독 설정
      const unsubCreated = on(CVE_EVENTS.CVE_CREATED, onCVECreated);
      const unsubUpdated = on(CVE_EVENTS.CVE_UPDATED, onCVEUpdated);
      const unsubDeleted = on(CVE_EVENTS.CVE_DELETED, onCVEDeleted);
      
      // 서버에 구독 요청 전송
      subscribeCVEList();
      
      isSubscribedRef.current = true;
      
      // 컴포넌트 언마운트 시 정리 작업 수행
      return () => {
        // 구독 해제
        unsubCreated();
        unsubUpdated();
        unsubDeleted();
        
        // 서버에 구독 해제 요청 전송
        if (connected) {
          logger.info('useCVEListUpdates', 'CVE 목록 업데이트 구독 해제');
          unsubscribeCVEList();
        }
        
        // 디바운스된 함수 취소
        invalidateCVEQueries.cancel();
        
        // 타이머 정리
        clearAllTimers();
        
        // 소켓 정리
        cleanup();
        
        // 구독 상태 초기화
        isSubscribedRef.current = false;
      };
    }
    
    // 연결 상태 변경 감지
    handleConnectionChange(connected);
    
    // 연결되지 않은 경우 정리 함수 제공
    return () => {
      invalidateCVEQueries.cancel();
      clearAllTimers();
    };
  }, [connected, on, cleanup, onCVECreated, onCVEUpdated, onCVEDeleted, subscribeCVEList, unsubscribeCVEList, invalidateCVEQueries, clearAllTimers]);

  // 연결 끊김 후 자동 재연결 시도
  useEffect(() => {
    if (!connected && isSubscribedRef.current) {
      const delay = Math.min(
        1000 * Math.pow(2, reconnectAttemptsRef.current),
        10000
      );
      
      logger.warn('useCVEListUpdates', '연결 끊김. 재연결 시도 예약', {
        재시도횟수: reconnectAttemptsRef.current + 1,
        지연시간: `${delay}ms`
      });
      
      // 지수 백오프로 재연결 시도
      const timerKey = 'reconnect-attempt';
      startTimer(timerKey, () => {
        reconnectAttemptsRef.current++;
        
        if (reconnectAttemptsRef.current > 3) {
          logger.error('useCVEListUpdates', '최대 재연결 시도 횟수 초과. 목록 업데이트가 중단됨.');
          clearTimer(timerKey);
          return;
        }
        
        // 서버에 구독 요청 재시도
        if (connected) {
          logger.info('useCVEListUpdates', '재연결 성공. 구독 갱신');
          subscribeCVEList();
        }
      }, delay);
      
      return () => {
        clearTimer(timerKey);
      };
    }
  }, [connected, startTimer, clearTimer, subscribeCVEList]);

  return { 
    isConnected: connected,
    reconnectAttempts: reconnectAttemptsRef.current
  };
}

export default useCVEListUpdates;


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/index.ts
------------------------------------------------------------
// hooks/index.ts

// 모든 import 문은 파일 상단에 배치
import { useCVEList, useCVEListQuery } from './query/useCVEListQuery';
import { useCVEDetail, useCVERefresh } from './query/useCVEDetailQuery';
import { useCVEStats, useTotalCVECount } from './query/useCVEStatsQuery';
import { useCVESubscription } from './socket/useCVESubscription';
import { useCVEListUpdates } from './socket/useCVEListSocketUpdates';
import { handleCVESubscriptionUpdate } from './socket/cveHandlers';
import * as mutations from './useCVEMutation';

// 개별 export
export { useCVEList, useCVEListQuery } from './query/useCVEListQuery';
export { useCVEDetail, useCVERefresh } from './query/useCVEDetailQuery';
export { useCVEStats, useTotalCVECount } from './query/useCVEStatsQuery';
export { useCVESubscription } from './socket/useCVESubscription';
export { useCVEListUpdates } from './socket/useCVEListSocketUpdates';
export { handleCVESubscriptionUpdate } from './socket/cveHandlers';

// 기존 mutation 파일 그대로 사용 (export 재내보내기)
export * from './useCVEMutation';

// 모든 훅을 기본 내보내기로 포함
export default {
  useCVEList,
  useCVEListQuery,
  useCVEDetail,
  useCVERefresh,
  useCVEStats,
  useTotalCVECount,
  useCVESubscription,
  useCVEListUpdates,
  handleCVESubscriptionUpdate,
  ...mutations
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/utils/cveQueryUtils.ts
------------------------------------------------------------
// utils/cveQueryUtils.ts
import { useCallback, useEffect, useRef } from 'react';
import _ from 'lodash';
import logger from 'shared/utils/logging';
import { LoggerType } from './types';
import { SubscriptionState, SubscriptionAction } from './types';

/**
 * 일반 함수용 로거 생성 함수 (non-React 컨텍스트에서 사용)
 * @param prefix - 로그 메시지 프리픽스
 * @returns 로거 객체
 */
export const createLogger = (prefix: string): LoggerType => ({
  info: (message, data) => {
    if (data !== undefined) {
      logger.info(prefix, message, data);
    } else {
      logger.info(prefix, message);
    }
  },
  warn: (message, data) => {
    if (data !== undefined) {
      logger.warn(prefix, message, data);
    } else {
      logger.warn(prefix, message);
    }
  },
  error: (message, error) => {
    if (error !== undefined) {
      logger.error(prefix, message, error);
    } else {
      logger.error(prefix, message);
    }
  },
  debug: (message, data) => {
    if (data !== undefined) {
      logger.debug(prefix, message, data);
    } else {
      logger.debug(prefix, message);
    }
  }
});

/**
 * 타이머 관리 유틸리티 훅
 * @returns 타이머 관리 함수들
 */
export function useTimers() {
  const timersRef = useRef<{ [key: string]: number }>({});

  const startTimer = useCallback((key: string, callback: () => void, delay: number) => {
    // 기존 타이머가 있으면 정리
    if (timersRef.current[key]) {
      clearTimeout(timersRef.current[key]);
    }
    // 새 타이머 설정
    timersRef.current[key] = window.setTimeout(callback, delay);
    return () => clearTimer(key);
  }, []);

  const clearTimer = useCallback((key: string) => {
    if (timersRef.current[key]) {
      clearTimeout(timersRef.current[key]);
      delete timersRef.current[key];
    }
  }, []);

  const clearAllTimers = useCallback(() => {
    Object.keys(timersRef.current).forEach(key => {
      clearTimeout(timersRef.current[key]);
    });
    timersRef.current = {};
  }, []);

  useEffect(() => {
    // 컴포넌트 언마운트 시 모든 타이머 정리
    return clearAllTimers;
  }, [clearAllTimers]);

  return { startTimer, clearTimer, clearAllTimers };
}

/**
 * 성능 측정 유틸리티
 * @param label - 측정 라벨
 * @param action - 측정할 함수
 * @returns 함수 실행 결과
 */
export const measurePerformance = <T extends any>(label: string, action: () => T): T => {
  if (process.env.NODE_ENV !== 'development') return action();
  
  const start = performance.now();
  const result = action();
  const end = performance.now();
  logger.debug(`성능[${label}]: ${end - start}ms`);
  return result;
};

/**
 * 구독 상태 리듀서
 * @param state - 현재 상태
 * @param action - 디스패치된 액션
 * @returns 새 상태
 */


export function subscriptionReducer(state: SubscriptionState, action: SubscriptionAction): SubscriptionState {
  switch (action.type) {
    case 'SUBSCRIBE_REQUEST':
      return { 
        ...state, 
        isLoading: true, 
        error: null, 
        isSubscribed: true // 낙관적 업데이트
      };
    
    case 'SUBSCRIBE_SUCCESS':
      return { 
        ...state, 
        isLoading: false, 
        subscribers: action.subscribers, 
        isSubscribed: true 
      };
    
    case 'SUBSCRIBE_FAILURE':
      return { 
        ...state, 
        isLoading: false, 
        error: action.error,
        isSubscribed: false // 실패 시 구독 취소
      };
    
    case 'UNSUBSCRIBE_REQUEST':
      return { 
        ...state, 
        isLoading: true, 
        error: null, 
        isSubscribed: false // 낙관적 업데이트
      };
    
    case 'UNSUBSCRIBE_SUCCESS':
      return { 
        ...state, 
        isLoading: false, 
        subscribers: action.subscribers, 
        isSubscribed: false 
      };
    
    case 'UNSUBSCRIBE_FAILURE':
      return { 
        ...state, 
        isLoading: false, 
        error: action.error,
        // 구독 상태는 변경하지 않음 (실패했기 때문)
      };
    
    case 'UPDATE_SUBSCRIBERS':
      return { 
        ...state, 
        subscribers: action.subscribers, 
        isSubscribed: action.isSubscribed,
        isLoading: false,
        error: null
      };
    
    case 'SET_LOADING':
      return { ...state, isLoading: action.isLoading };
    
    case 'SET_ERROR':
      return { ...state, error: action.error };
    
    case 'CONNECTION_LOST':
      return { 
        ...state, 
        connectionLost: true, 
        error: '연결이 끊어졌습니다. 재연결 중...',
        isLoading: true
      };
    
    case 'CONNECTION_RESTORED':
      return { 
        ...state, 
        connectionLost: false, 
        error: null
      };
    
    default:
      return state;
  }
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/utils/types.ts
------------------------------------------------------------
// utils/types.ts
import { UseQueryOptions } from '@tanstack/react-query';

/**
 * 로거 타입 인터페이스
 */
export interface LoggerType {
  info: (message: string, data?: any) => void;
  warn: (message: string, data?: any) => void;
  error: (message: string, error?: any) => void;
  debug: (message: string, data?: any) => void;
}

/**
 * 필터 타입 정의
 */
export type Filters = Record<string, any>;

/**
 * 쿼리 옵션 타입 정의
 */
export type QueryOptions<T = any> = Omit<UseQueryOptions<T, Error>, 'queryKey' | 'queryFn'>;

/**
 * CVE 항목 인터페이스
 */
export interface CVEItem {
  cveId: string;
  createdAt?: string | Date;
  lastModifiedAt?: string | Date;
  created_at?: string | Date;
  last_modified_at?: string | Date;
  [key: string]: any;
}

/**
 * CVE 통계 타입 정의
 */
export interface CVEStats {
  byStatus?: Record<string, number>;
  bySeverity?: Record<string, number>;
  byMonth?: Record<string, number>;
  total?: number;
  [key: string]: any;
}

/**
 * 구독 상태 액션 타입
 */
export type SubscriptionAction = 
  | { type: 'SUBSCRIBE_REQUEST' }
  | { type: 'SUBSCRIBE_SUCCESS', subscribers: any[] }
  | { type: 'SUBSCRIBE_FAILURE', error: string }
  | { type: 'UNSUBSCRIBE_REQUEST' }
  | { type: 'UNSUBSCRIBE_SUCCESS', subscribers: any[] }
  | { type: 'UNSUBSCRIBE_FAILURE', error: string }
  | { type: 'UPDATE_SUBSCRIBERS', subscribers: any[], isSubscribed: boolean }
  | { type: 'SET_LOADING', isLoading: boolean }
  | { type: 'SET_ERROR', error: string | null }
  | { type: 'CONNECTION_LOST' }
  | { type: 'CONNECTION_RESTORED' };

/**
 * 구독 상태 인터페이스
 */
export interface SubscriptionState {
  isSubscribed: boolean;
  subscribers: any[];
  isLoading: boolean;
  error: string | null;
  connectionLost: boolean;
}

/**
 * 재시도 관련 상수
 */
export const RETRY_CONFIG = {
  MAX_ATTEMPTS: 3,
  INITIAL_DELAY: 1000,
  MAX_DELAY: 10000,
  TIMEOUT: 5000
};

/**
 * 구독 관련 이벤트 상수
 */
export const LOCAL_SUBSCRIPTION_EVENTS = {
  SUBSCRIPTION_ERROR: 'SUBSCRIPTION_ERROR',
  UNSUBSCRIPTION_ERROR: 'UNSUBSCRIPTION_ERROR',
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/query/useCVEListQuery.ts
------------------------------------------------------------
// query/useCVEListQuery.ts
import { useQuery } from '@tanstack/react-query';
import { useRef } from 'react';
import cveService from 'features/cve/services/cveService';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { createLogger } from '../utils/cveQueryUtils';
import { Filters, QueryOptions } from '../utils/types';
import type { CVEListResponse } from 'features/cve/types/cve';

/**
 * CVE 목록 조회 훅
 * 필터링 옵션을 적용하여 CVE 목록을 조회
 * 
 * @param filters - 필터 옵션
 * @param options - 쿼리 옵션
 * @param customService - 커스텀 서비스 객체 (테스트용)
 * @returns 쿼리 결과
 */
export const useCVEList = (
  filters: Filters = {},
  options: QueryOptions<CVEListResponse> = {},
  customService = cveService
) => {
  const logger = createLogger('useCVEList');
  const requestIdRef = useRef<string>('');

  return useQuery<CVEListResponse, Error>({
    queryKey: QUERY_KEYS.CVE.list(filters),
    queryFn: async () => {
      try {
        // 요청 ID 생성 (디버깅/추적용)
        requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
        logger.info(`목록 조회 요청(${requestIdRef.current})`, { filters });
        
        const startTime = performance.now();
        const result = await customService.getCVEs(filters);
        const endTime = performance.now();

        // 응답 필드 정규화 (백엔드 응답이 일관되지 않을 경우 대비)
        if (!result.total && result.totalItems) {
          result.total = result.totalItems;
        }
        if (!result.items && result.results) {
          result.items = result.results;
        }

        logger.info(`목록 조회 결과(${requestIdRef.current})`, { 
          totalItems: result.total || result.totalItems || 0,
          itemsCount: result.items?.length || result.results?.length || 0,
          page: filters.page || 1,
          elapsedTime: `${(endTime - startTime).toFixed(2)}ms`
        });

        return result;
      } catch (error: any) {
        // 오류 분류 및 세분화된 로깅
        if (error.response) {
          logger.error(`목록 조회 HTTP 오류(${requestIdRef.current})`, {
            status: error.response.status,
            statusText: error.response.statusText,
            url: error.response.config?.url,
            errorData: error.response.data
          });
        } else if (error.request) {
          logger.error(`목록 조회 네트워크 오류(${requestIdRef.current})`, {
            message: error.message,
            code: error.code
          });
        } else {
          logger.error(`목록 조회 중 예상치 못한 오류(${requestIdRef.current})`, error);
        }
        throw error;
      }
    },
    placeholderData: (oldData) => oldData,
    staleTime: 10000,
    gcTime: 60000,
    refetchOnWindowFocus: true,
    ...options,
  });
};

/**
 * (하위 호환성) CVE 목록 조회 훅
 * 이전 버전 API와의 호환성을 위한 래퍼 함수
 * 
 * @param params - 조회 파라미터
 * @returns 쿼리 결과
 * @deprecated useCVEList를 직접 사용하세요
 */
export const useCVEListQuery = (params: {
  page?: number;
  rowsPerPage?: number;
  filters?: Filters;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
} = {}) => {
  const { 
    page = 0, 
    rowsPerPage = 10, 
    filters = {}, 
    sortBy = 'createdAt', 
    sortOrder = 'desc' 
  } = params;

  const convertedFilters = {
    page,
    rowsPerPage,
    search: filters.search,
    sortBy,
    sortOrder,
    filters
  };

  const logger = createLogger('useCVEListQuery');
  logger.info('호환성 모드로 호출됨 (deprecated)', { params });
  
  return useCVEList(convertedFilters);
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/query/useCVEStatsQuery.ts
------------------------------------------------------------
// query/useCVEStatsQuery.ts
import { useEffect, useRef, useCallback } from 'react';
import { useQuery } from '@tanstack/react-query';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import api from 'shared/api/config/axios';
import cveService from 'features/cve/services/cveService';
import { createLogger, useTimers } from '../utils/cveQueryUtils';
import { QueryOptions, CVEStats, RETRY_CONFIG } from '../utils/types';

/**
 * CVE 통계 정보 조회 훅
 * 시스템의 CVE 통계 정보를 조회
 * 
 * @param options - 쿼리 옵션
 * @returns 쿼리 결과
 */
export const useCVEStats = (options: QueryOptions<CVEStats> = {}) => {
  const logger = createLogger('useCVEStats');
  const requestIdRef = useRef('');
  
  return useQuery<CVEStats, Error>({
    queryKey: QUERY_KEYS.CVE.stats(),
    queryFn: async () => {
      try {
        requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
        logger.info(`CVE 통계 조회 요청(${requestIdRef.current})`);
        
        const startTime = performance.now();
        const response = await api.get('/cves/stats');
        const endTime = performance.now();
        
        const result = response.data;
        logger.info(`CVE 통계 조회 결과(${requestIdRef.current})`, { 
          stats: result,
          elapsedTime: `${(endTime - startTime).toFixed(2)}ms`
        });
        
        return result;
      } catch (error: any) {
        // 세분화된 오류 로깅
        if (error.response) {
          logger.error(`CVE 통계 조회 HTTP 오류(${requestIdRef.current})`, {
            status: error.response.status,
            statusText: error.response.statusText,
            url: error.response.config?.url,
            errorData: error.response.data
          });
        } else if (error.request) {
          logger.error(`CVE 통계 조회 네트워크 오류(${requestIdRef.current})`, {
            message: error.message,
            code: error.code
          });
        } else {
          logger.error(`CVE 통계 조회 중 예상치 못한 오류(${requestIdRef.current})`, error);
        }
        throw error;
      }
    },
    // 기본 옵션
    staleTime: 300000, // 5분
    gcTime: 600000, // 10분
    ...options
  });
};

/**
 * 전체 CVE 수 조회 훅
 * 시스템에 등록된 총 CVE 수를 조회
 * 
 * @param options - 쿼리 옵션
 * @returns 쿼리 결과
 */
export const useTotalCVECount = (options: QueryOptions<number> = {}) => {
  const logger = createLogger('useTotalCVECount');
  const requestIdRef = useRef('');
  const { startTimer, clearAllTimers } = useTimers();
  
  // 재시도 카운터
  const retryCountRef = useRef(0);
  
  // 재시도 함수
  const retryWithBackoff = useCallback(async (queryFn: () => Promise<number>) => {
    retryCountRef.current++;
    
    if (retryCountRef.current > RETRY_CONFIG.MAX_ATTEMPTS) {
      logger.error(`최대 재시도 횟수 초과(${requestIdRef.current})`);
      throw new Error(`최대 재시도 횟수(${RETRY_CONFIG.MAX_ATTEMPTS}회)를 초과했습니다.`);
    }
    
    const delay = Math.min(
      RETRY_CONFIG.INITIAL_DELAY * Math.pow(2, retryCountRef.current - 1),
      RETRY_CONFIG.MAX_DELAY
    );
    
    logger.info(`재시도 예약(${requestIdRef.current})`, {
      retryCount: retryCountRef.current,
      delay: `${delay}ms`
    });
    
    return new Promise<number>((resolve, reject) => {
      startTimer(`retry-total-count-${retryCountRef.current}`, async () => {
        try {
          const result = await queryFn();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      }, delay);
    });
  }, [startTimer]);
  
  const query = useQuery<number, Error>({
    queryKey: QUERY_KEYS.CVE.totalCount(),
    queryFn: async () => {
      try {
        requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
        logger.info(`전체 CVE 수 조회 요청(${requestIdRef.current})`);
        
        const startTime = performance.now();
        const result = await cveService.getTotalCVECount();
        const endTime = performance.now();
        
        retryCountRef.current = 0; // 성공 시 재시도 카운터 리셋
        
        logger.info(`전체 CVE 수 조회 결과(${requestIdRef.current})`, { 
          count: result,
          elapsedTime: `${(endTime - startTime).toFixed(2)}ms`
        });
        
        return result;
      } catch (error: any) {
        // 서버 오류인 경우 재시도
        if (error.response && error.response.status >= 500) {
          logger.warn(`서버 오류로 인한 재시도(${requestIdRef.current})`, {
            status: error.response.status,
            retry: retryCountRef.current + 1
          });
          return retryWithBackoff(() => cveService.getTotalCVECount());
        }
        
        // 네트워크 오류인 경우 재시도
        if (error.code === 'ECONNABORTED' || error.message?.includes('timeout') || !error.response) {
          logger.warn(`네트워크 오류로 인한 재시도(${requestIdRef.current})`, {
            message: error.message,
            retry: retryCountRef.current + 1
          });
          return retryWithBackoff(() => cveService.getTotalCVECount());
        }
        
        // 세분화된 오류 로깅
        if (error.response) {
          logger.error(`전체 CVE 수 조회 HTTP 오류(${requestIdRef.current})`, {
            status: error.response.status,
            statusText: error.response.statusText,
            url: error.response.config?.url,
            errorData: error.response.data
          });
        } else {
          logger.error(`전체 CVE 수 조회 중 예상치 못한 오류(${requestIdRef.current})`, error);
        }
        
        throw error;
      }
    },
    // 기본 옵션
    staleTime: 300000, // 5분
    gcTime: 600000, // 10분
    ...options
  });
  
  // 컴포넌트 언마운트 시 타이머 정리
  useEffect(() => {
    return clearAllTimers;
  }, [clearAllTimers]);
  
  return query;
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/query/useCVEDetailQuery.ts
------------------------------------------------------------
// query/useCVEDetailQuery.ts
import { useEffect, useRef, useCallback } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import cveService from 'features/cve/services/cveService';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { createLogger, useTimers, measurePerformance } from '../utils/cveQueryUtils';
import { QueryOptions, RETRY_CONFIG } from '../utils/types';
import type { CVEDetail } from 'features/cve/types/cve';

/**
 * CVE 상세 정보 조회 훅
 * 특정 CVE ID의 상세 정보를 조회
 * 
 * @param cveId - CVE ID
 * @param options - 쿼리 옵션
 * @param customService - 커스텀 서비스 객체 (테스트용)
 * @returns 쿼리 결과
 */
export const useCVEDetail = (
  cveId: string,
  options: QueryOptions<CVEDetail> = {},
  customService = cveService
) => {
  const logger = createLogger('useCVEDetail');
  const requestIdRef = useRef<string>('');

  const defaultOptions: QueryOptions<CVEDetail> = {
    enabled: !!cveId,
    retry: 1,
    retryDelay: 500,
    staleTime: 60000, // 1분으로 증가하여 불필요한 리페치 줄이기
    gcTime: 300000, // 5분으로 유지
    refetchOnWindowFocus: false, // 창 포커스 시 리페치 비활성화
    refetchOnMount: false, // 컴포넌트 마운트 시 자동 리페치 비활성화 (명시적 호출만 허용)
    refetchOnReconnect: false, // 재연결 시 자동 리페치 비활성화
  };

  const mergedOptions = { ...defaultOptions, ...options };

  return useQuery<CVEDetail, Error>({
    queryKey: QUERY_KEYS.CVE.detail(cveId),
    queryFn: async () => {
      try {
        requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
        logger.info(`CVE 상세 조회 요청(${requestIdRef.current})`, { cveId });
        
        const startTime = performance.now();
        const result = await customService.getCVEById(cveId);
        const endTime = performance.now();
        const elapsedTime = endTime - startTime;

        logger.info(`CVE 상세 조회 완료(${requestIdRef.current})`, { 
          cveId, 
          elapsedTime: `${elapsedTime.toFixed(2)}ms`,
          dataSize: JSON.stringify(result).length
        });

        return result;
      } catch (error: any) {
        // 세분화된 오류 처리 및 로깅
        if (error.response) {
          if (error.response.status === 404) {
            logger.warn(`CVE 상세 조회 - 항목 없음(${requestIdRef.current})`, { 
              cveId, 
              status: error.response.status 
            });
          } else {
            logger.error(`CVE 상세 조회 HTTP 오류(${requestIdRef.current})`, {
              cveId,
              status: error.response.status,
              statusText: error.response.statusText,
              url: error.response.config?.url,
              errorData: error.response.data
            });
          }
        } else if (error.request) {
          logger.error(`CVE 상세 조회 네트워크 오류(${requestIdRef.current})`, {
            cveId,
            message: error.message,
            code: error.code
          });
        } else {
          logger.error(`CVE 상세 조회 중 예상치 못한 오류(${requestIdRef.current})`, {
            cveId,
            error
          });
        }
        throw error;
      }
    },
    ...mergedOptions
  });
};

/**
 * CVE 새로고침 훅
 * 특정 CVE의 데이터를 강제로 새로고침 (캐시 무시)
 * 
 * @param cveId - CVE ID
 * @param options - 훅 옵션
 * @param customService - 커스텀 서비스 객체 (테스트용)
 * @returns 새로고침 함수와 상태
 */
export const useCVERefresh = (
  cveId: string,
  options: any = {},
  customService = cveService
) => {
  const queryClient = useQueryClient();
  const logger = createLogger('useCVERefresh');
  const { startTimer, clearAllTimers } = useTimers();
  const requestIdRef = useRef<string>('');
  
  // 재시도 메커니즘을 포함한 새로고침 함수
  const refreshFn = async (retryCount = 0) => {
    try {
      requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
      logger.info(`강제 새로고침 요청(${requestIdRef.current})`, { cveId, retryAttempt: retryCount });
      
      const data = await customService.getCVEByIdNoCache(cveId);
      
      // 성공 시 캐시 업데이트
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), data);
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.CVE.lists() });
      
      logger.info(`강제 새로고침 성공(${requestIdRef.current})`, { cveId });
      return data;
    } catch (error: any) {
      // 오류 유형에 따른 세분화된 처리
      if (error.response && error.response.status >= 500 && retryCount < RETRY_CONFIG.MAX_ATTEMPTS) {
        // 서버 오류의 경우 지수 백오프로 재시도
        const delay = Math.min(
          RETRY_CONFIG.INITIAL_DELAY * Math.pow(2, retryCount),
          RETRY_CONFIG.MAX_DELAY
        );
        
        logger.warn(`서버 오류로 재시도 예약(${requestIdRef.current})`, {
          cveId,
          retryAttempt: retryCount + 1,
          delay: `${delay}ms`,
          error: error.message
        });
        
        // 지정된 지연 후 재시도
        return new Promise((resolve, reject) => {
          startTimer(`refresh-retry-${retryCount}`, async () => {
            try {
              const result = await refreshFn(retryCount + 1);
              resolve(result);
            } catch (retryError) {
              reject(retryError);
            }
          }, delay);
        });
      }
      
      // 다른 오류는 자세히 로깅 후 throw
      logger.error(`강제 새로고침 실패(${requestIdRef.current})`, {
        cveId,
        retryAttempt: retryCount,
        errorType: error.response ? 'HTTP 오류' : error.request ? '네트워크 오류' : '예상치 못한 오류',
        status: error.response?.status,
        message: error.message
      });
      
      throw error;
    }
  };

  // 컴포넌트 언마운트 시 타이머 정리
  useEffect(() => {
    return clearAllTimers;
  }, [clearAllTimers]);

  return {
    mutate: refreshFn,
    isLoading: false,
    refresh: refreshFn
  };
};

/**
 * CVE 업데이트 훅
 * 특정 CVE 정보를 업데이트하기 위한 뮤테이션 훅
 * 
 * @param cveId - CVE ID
 * @param options - 뮤테이션 옵션
 * @returns 뮤테이션 결과
 */
export const useUpdateCVE = (
  cveId: string,
  options: any = {}
) => {
  const queryClient = useQueryClient();
  const logger = createLogger('useUpdateCVE');
  const requestIdRef = useRef('');
  const { startTimer, clearAllTimers } = useTimers();
  
  // 재시도 카운터
  const retryCountRef = useRef(0);
  
  // 재시도 함수
  const retryWithBackoff = useCallback(async (updateData: Partial<CVEDetail>) => {
    retryCountRef.current++;
    
    if (retryCountRef.current > RETRY_CONFIG.MAX_ATTEMPTS) {
      logger.error(`최대 재시도 횟수 초과(${requestIdRef.current})`);
      throw new Error(`최대 재시도 횟수(${RETRY_CONFIG.MAX_ATTEMPTS}회)를 초과했습니다.`);
    }
    
    const delay = Math.min(
      RETRY_CONFIG.INITIAL_DELAY * Math.pow(2, retryCountRef.current - 1),
      RETRY_CONFIG.MAX_DELAY
    );
    
    logger.info(`업데이트 재시도 예약(${requestIdRef.current})`, {
      cveId,
      retryCount: retryCountRef.current,
      delay: `${delay}ms`
    });
    
    return new Promise((resolve, reject) => {
      startTimer(`retry-update-${retryCountRef.current}`, async () => {
        try {
          const result = await cveService.updateCVE(cveId, updateData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      }, delay);
    });
  }, [cveId, startTimer]);

  const mutation = {
    mutate: async (updateData: Partial<CVEDetail>) => {
      try {
        requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
        logger.info(`CVE 업데이트 요청(${requestIdRef.current}): ${cveId}`, { 
          updateFields: Object.keys(updateData),
          updateData
        });
        
        const startTime = performance.now();
        const result = await cveService.updateCVE(cveId, updateData);
        const endTime = performance.now();
        
        retryCountRef.current = 0; // 성공 시 재시도 카운터 리셋
        
        logger.info(`CVE 업데이트 성공(${requestIdRef.current}): ${cveId}`, {
          elapsedTime: `${(endTime - startTime).toFixed(2)}ms`
        });
        
        // 캐시 업데이트 성능 측정
        measurePerformance('캐시 업데이트', () => {
          // 기존 데이터 가져오기
          const previousData = queryClient.getQueryData<CVEDetail>(QUERY_KEYS.CVE.detail(cveId));
          
          if (previousData) {
            // 업데이트된 데이터로 캐시 업데이트
            queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), {
              ...previousData,
              ...updateData,
              lastModifiedAt: new Date().toISOString()
            });
          }
          
          // 목록 쿼리 무효화
          queryClient.invalidateQueries({ 
            queryKey: QUERY_KEYS.CVE.lists(),
            refetchType: 'active'
          });
        });
        
        if (options.onSuccess) {
          options.onSuccess(result, updateData);
        }
        
        return result;
      } catch (error: any) {
        // 서버 오류인 경우 재시도
        if (error.response && error.response.status >= 500) {
          logger.warn(`서버 오류로 인한 재시도(${requestIdRef.current})`, {
            cveId,
            status: error.response.status,
            retry: retryCountRef.current + 1
          });
          return retryWithBackoff(updateData);
        }
        
        // 네트워크 오류인 경우 재시도
        if (error.code === 'ECONNABORTED' || error.message?.includes('timeout') || !error.response) {
          logger.warn(`네트워크 오류로 인한 재시도(${requestIdRef.current})`, {
            cveId,
            message: error.message,
            retry: retryCountRef.current + 1
          });
          return retryWithBackoff(updateData);
        }
        
        // 세분화된 오류 로깅
        if (error.response) {
          logger.error(`CVE 업데이트 HTTP 오류(${requestIdRef.current}): ${cveId}`, {
            status: error.response.status,
            statusText: error.response.statusText,
            url: error.response.config?.url,
            errorData: error.response.data
          });
        } else {
          logger.error(`CVE 업데이트 실패(${requestIdRef.current}): ${cveId}`, error);
        }
        
        if (options.onError) {
          options.onError(error, updateData);
        }
        
        throw error;
      }
    },
    isLoading: false
  };
  
  // 컴포넌트 언마운트 시 타이머 정리
  useEffect(() => {
    return clearAllTimers;
  }, [clearAllTimers]);
  
  return mutation;
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/useCVEMutation.ts
------------------------------------------------------------
/**
 * CVE 관련 mutation 훅 모음
 */
import { useMutation, useQueryClient, UseMutationOptions, UseMutationResult, QueryClient } from '@tanstack/react-query';
import cveService from '../services/cveService';
import { useSnackbar } from 'notistack';
import { 
  get, 
  merge, 
  defaultsDeep, 
  debounce, 
  set,
  isArray
} from 'lodash';
import { 
  CVEDetail, 
  CVEData, 
  CVEUpdateRequest, 
  OperationResponse 
} from '../types/cve';
import { QUERY_KEYS } from 'shared/api/queryKeys'
import { ApiResponse, ApiError } from 'shared/api/types/api';
import logger from 'shared/utils/logging';
import { SOCKET_EVENTS } from 'core/socket/services/constants';
/**
 * CVE 생성 요청 타입
 */
export type CreateCVERequest = CVEData;

/**
 * CVE 업데이트 요청 타입
 */
export interface UpdateCVEParams {
  cveId: string;
  data: CVEUpdateRequest;
}

/**
 * CVE 필드 업데이트 요청 타입
 */
export interface UpdateCVEFieldParams {
  cveId: string;
  fieldName: string;
  fieldValue: any;
}

/**
 * CVE 상태 업데이트 요청 타입
 */
export interface UpdateCVEStatusParams {
  cveId: string;
  status: string;
}

/**
 * 실시간 CVE 업데이트 이벤트 타입
 */
export interface RealtimeCVEUpdateEvent {
  type: string;
  cveId?: string;
  data?: any;
}

/**
 * 낙관적 업데이트를 위한 컨텍스트 타입
 */
export interface UpdateCVEFieldContext {
  previousData?: ApiResponse<CVEDetail>;
}

/**
 * CVE 생성을 위한 mutation 훅
 * 성공 시 CVE 목록 쿼리를 무효화하여 자동으로 최신 데이터를 가져옴
 * @param options - React Query 옵션
 * @returns useMutation 훅에서 반환되는 결과 객체
 */
export const useCreateCVE = (
  options: UseMutationOptions<
    ApiResponse<CVEDetail>, 
    ApiError, 
    CreateCVERequest
  > = {}
): UseMutationResult<
  ApiResponse<CVEDetail>, 
  ApiError, 
  CreateCVERequest
> => {
  const queryClient = useQueryClient();
  const { enqueueSnackbar } = useSnackbar();
  const { onSuccess: optionsOnSuccess, onError: optionsOnError, ...restOptions } = options;
  
  return useMutation<ApiResponse<CVEDetail>, ApiError, CreateCVERequest>({
    mutationFn: (cveData) => {
      logger.info('useCreateCVE', '생성 요청', { data: cveData });
      
      try {
        // 기본 옵션 설정
        return cveService.createCVE(cveData, { 
          meta: {
            source: 'useCreateCVE',
            skipAuthRefresh: false // 인증 갱신 허용
          }
        });
      } catch (error) {
        // 에러 발생 시 config 정보 보존
        const enhancedError = {
          ...error,
          config: {
            ...(error?.config || {}),
            skipAuthRefresh: false
          }
        } as ApiError;
        throw enhancedError;
      }
    },
    onSuccess: (data, variables, context) => {
      // CVE 목록 쿼리 무효화 (자동으로 다시 가져옴)
      queryClient.invalidateQueries({ 
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
      
      // 기본 성공 메시지 (options에 onSuccess가 없을 경우에만)
      if (!optionsOnSuccess) {
        enqueueSnackbar('CVE가 성공적으로 생성되었습니다.', { variant: 'success' });
      }
      
      logger.info('useCreateCVE', '생성 성공', { 
        id: data?.data?.id,
        cveId: data?.data?.cveId,
        title: data?.data?.title
      });
      
      // options에 onSuccess가 있으면 그것을 호출
      if (optionsOnSuccess) {
        optionsOnSuccess(data, variables, context);
      }
    },
    onError: (error, variables, context) => {
      // 에러 객체 안전하게 처리
      const safeError = ensureSafeErrorObject(error);
      
      // 기본 에러 메시지 (options에 onError가 없을 경우에만)
      if (!optionsOnError) {
        enqueueSnackbar(`CVE 생성 실패: ${safeError.message}`, { 
          variant: 'error',
          anchorOrigin: {
            vertical: 'bottom',
            horizontal: 'center',
          }
        });
      }
      
      // 409 에러 (중복 CVE)인 경우 경고 로그, 그 외에는 에러 로그
      if (safeError?.response?.status === 409) {
        logger.warn('useCreateCVE', 'CVE 중복 생성 시도', { 
          message: safeError.message,
          errorCode: safeError?.response?.data?.errorCode || 'DUPLICATE_CVE'
        });
      } else {
        logger.error('useCreateCVE', '생성 중 오류 발생', { 
          message: safeError.message,
          status: safeError.response?.status,
          errorCode: safeError?.response?.data?.errorCode
        });
      }
      
      // options에 onError가 있으면 그것을 호출
      if (optionsOnError) {
        optionsOnError(safeError, variables, context);
      }
      
      throw safeError;
    },
    ...restOptions
  });
};

/**
 * CVE 업데이트 훅
 * @param options - 훅 옵션
 * @returns 뮤테이션 결과
 */
export const useUpdateCVE = (
  options: UseMutationOptions<
    ApiResponse<CVEDetail>, 
    ApiError, 
    UpdateCVEParams
  > = {}
): UseMutationResult<
  ApiResponse<CVEDetail>, 
  ApiError, 
  UpdateCVEParams
> => {
  const queryClient = useQueryClient();
  const { enqueueSnackbar } = useSnackbar();
  const { onSuccess: optionsOnSuccess, onError: optionsOnError, ...restOptions } = options;
  
  return useMutation<ApiResponse<CVEDetail>, ApiError, UpdateCVEParams>({
    mutationFn: ({ cveId, data }) => {
      logger.info('useUpdateCVE', '업데이트 요청', { cveId, data });
      
      try {
        return cveService.updateCVE(cveId, data, {
          skipAuthRefresh: false
        });
      } catch (error) {
        // 에러 발생 시 config 정보 보존
        const enhancedError = {
          ...error,
          config: {
            ...(error?.config || {}),
            skipAuthRefresh: false
          }
        } as ApiError;
        throw enhancedError;
      }
    },
    onSuccess: (data, variables, context) => {
      const { cveId } = variables;
      // CVE 목록 및 상세 쿼리 무효화
      queryClient.invalidateQueries({ 
        queryKey: ['cves'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cve', cveId],
        refetchType: 'active'
      });
      
      // 기본 성공 메시지 (options에 onSuccess가 없을 경우에만)
      if (!optionsOnSuccess) {
        enqueueSnackbar('CVE가 성공적으로 업데이트되었습니다.', { variant: 'success' });
      }
      
      logger.info('useUpdateCVE', '업데이트 성공', { 
        cveId,
        data: data
      });
      
      // options에 onSuccess가 있으면 그것을 호출
      if (optionsOnSuccess) {
        optionsOnSuccess(data, variables, context);
      }
    },
    onError: (error, variables, context) => {
      // 에러 객체 안전하게 처리
      const safeError = ensureSafeErrorObject(error);
      
      // 기본 에러 메시지 (options에 onError가 없을 경우에만)
      if (!optionsOnError) {
        enqueueSnackbar(`CVE 업데이트 중 오류가 발생했습니다: ${safeError?.message}`, { variant: 'error' });
      }
      
      logger.error('useUpdateCVE', '업데이트 중 오류 발생', { 
        error: safeError?.message,
        code: safeError?.code,
        status: safeError?.response?.status
      });
      
      // options에 onError가 있으면 그것을 호출
      if (optionsOnError) {
        optionsOnError(safeError, variables, context);
      }
      
      throw safeError;
    },
    ...restOptions
  });
};

/**
 * CVE 삭제 훅
 * @param options - 훅 옵션
 * @returns 뮤테이션 결과
 */
export const useDeleteCVE = (
  options: UseMutationOptions<
    ApiResponse<OperationResponse>, 
    ApiError, 
    string
  > = {}
): UseMutationResult<
  ApiResponse<OperationResponse>, 
  ApiError, 
  string
> => {
  const queryClient = useQueryClient();
  const { enqueueSnackbar } = useSnackbar();
  const { onSuccess: optionsOnSuccess, onError: optionsOnError, ...restOptions } = options;
  
  return useMutation<ApiResponse<OperationResponse>, ApiError, string>({
    mutationFn: (cveId) => {
      logger.info('useDeleteCVE', '삭제 요청', { cveId });
      
      try {
        // boolean 대신 ApiResponse<OperationResponse> 형태로 반환하도록 수정
        return cveService.deleteCVE(cveId, {
          skipAuthRefresh: false
        }).then(success => {
          // boolean 결과를 ApiResponse<OperationResponse> 형태로 변환
          return {
            success: true,
            message: 'CVE가 성공적으로 삭제되었습니다.',
            data: {
              success: true,
              message: 'CVE가 성공적으로 삭제되었습니다.'
            }
          } as ApiResponse<OperationResponse>;
        });
      } catch (error) {
        // 에러 발생 시 config 정보 보존
        const enhancedError = {
          ...error,
          config: {
            ...(error?.config || {}),
            skipAuthRefresh: false
          }
        } as ApiError;
        throw enhancedError;
      }
    },
    onSuccess: (data, cveId, context) => {
      // CVE 목록 및 상세 쿼리 무효화
      queryClient.invalidateQueries({ 
        queryKey: ['cves'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cve', cveId],
        refetchType: 'active'
      });
      
      // 기본 성공 메시지 (options에 onSuccess가 없을 경우에만)
      if (!optionsOnSuccess) {
        enqueueSnackbar('CVE가 성공적으로 삭제되었습니다.', { variant: 'success' });
      }
      
      logger.info('useDeleteCVE', '삭제 성공', { cveId });
      
      // options에 onSuccess가 있으면 그것을 호출
      if (optionsOnSuccess) {
        optionsOnSuccess(data, cveId, context);
      }
    },
    onError: (error, cveId, context) => {
      // 에러 객체 안전하게 처리
      const safeError = ensureSafeErrorObject(error);
      
      // 기본 에러 메시지 (options에 onError가 없을 경우에만)
      if (!optionsOnError) {
        enqueueSnackbar(`CVE 삭제 중 오류가 발생했습니다: ${safeError?.message}`, { variant: 'error' });
      }
      
      logger.error('useDeleteCVE', '삭제 중 오류 발생', { 
        error: safeError?.message,
        code: safeError?.code,
        status: safeError?.response?.status
      });
      
      // options에 onError가 있으면 그것을 호출
      if (optionsOnError) {
        optionsOnError(safeError, cveId, context);
      }
      
      throw safeError;
    },
    ...restOptions
  });
};

/**
 * CVE 필드 단위 업데이트 Hook (상태, PoC, 코멘트 등)
 * @param options - React Query 옵션
 * @param customService - 선택적으로 주입할 서비스 객체
 * @returns useMutation 훅에서 반환되는 결과 객체
 */
export const useUpdateCVEField = (
  options: UseMutationOptions<
    ApiResponse<CVEDetail>, 
    ApiError, 
    UpdateCVEFieldParams,
    UpdateCVEFieldContext
  > = {}, 
  customService = cveService
): UseMutationResult<
  ApiResponse<CVEDetail>, 
  ApiError, 
  UpdateCVEFieldParams,
  UpdateCVEFieldContext
> => {
  const queryClient = useQueryClient();
  const { enqueueSnackbar } = useSnackbar();
  
  // options에서 onSuccess와 onError 추출
  const { onSuccess: optionsOnSuccess, onError: optionsOnError, ...restOptions } = options;
  
  return useMutation<ApiResponse<CVEDetail>, ApiError, UpdateCVEFieldParams, UpdateCVEFieldContext>({
    mutationFn: ({ cveId, fieldName, fieldValue }) => {
      logger.info('useUpdateCVEField', '필드 업데이트 요청', { cveId, fieldName, fieldValue });
      
      // PoC 필드 업데이트 시 last_modified_at과 last_modified_by 필드 자동 설정
      if (fieldName === 'poc' && isArray(fieldValue)) {
        // 현재 시간과 사용자 정보 설정
        const now = new Date().toISOString();
        const currentUser = localStorage.getItem('username') || 'unknown';
        
        // 각 PoC 항목에 last_modified_at과 last_modified_by 필드 설정
        const updatedPoc = fieldValue.map(poc => {
          // 새로 추가된 PoC인 경우 (last_modified_at이 없는 경우)
          if (!poc.last_modified_at) {
            return {
              ...poc,
              last_modified_at: now,
              last_modified_by: currentUser
            };
          }
          return poc;
        });
        
        logger.info('useUpdateCVEField', 'PoC 필드 자동 업데이트', { 
          cveId, 
          pocCount: updatedPoc.length 
        });
        
        return customService.updateCVEField(cveId, fieldName, updatedPoc);
      }
      
      return customService.updateCVEField(cveId, fieldName, fieldValue);
    },
    onMutate: async ({ cveId, fieldName, fieldValue }): Promise<UpdateCVEFieldContext> => {
      // 이전 쿼리를 취소하여 낙관적 업데이트 충돌 방지
      await queryClient.cancelQueries({ queryKey: QUERY_KEYS.CVE.detail(cveId) });
      
      // 이전 상태 스냅샷 저장
      const previousData = queryClient.getQueryData<ApiResponse<CVEDetail>>(QUERY_KEYS.CVE.detail(cveId));
      
      // 낙관적 업데이트
      if (previousData?.data) {
        logger.info('useUpdateCVEField', '낙관적 업데이트 적용', { cveId, fieldName });
        
        // PoC 필드 업데이트 시 낙관적 업데이트에도 last_modified_at과 last_modified_by 필드 설정
        let updatedFieldValue = fieldValue;
        if (fieldName === 'poc' && isArray(fieldValue)) {
          const now = new Date().toISOString();
          const currentUser = localStorage.getItem('username') || 'unknown';
          
          updatedFieldValue = fieldValue.map(poc => {
            if (!poc.last_modified_at) {
              return {
                ...poc,
                last_modified_at: now,
                last_modified_by: currentUser
              };
            }
            return poc;
          });
        }
        
        // lodash의 set 함수를 사용하여 중첩된 필드도 안전하게 업데이트
        const updatedData = { ...previousData };
        set(updatedData, `data.${fieldName}`, updatedFieldValue);
        
        queryClient.setQueryData<ApiResponse<CVEDetail>>(
          QUERY_KEYS.CVE.detail(cveId),
          updatedData
        );
      }
      
      return { previousData };
    },
    onError: (error, variables, context) => {
      const { cveId, fieldName } = variables;
      logger.error('useUpdateCVEField', '필드 업데이트 실패', { cveId, fieldName, error: error?.message });
      
      // 기본 에러 메시지 (options에 onError가 없을 경우에만)
      if (!optionsOnError) {
        enqueueSnackbar(`CVE 필드 업데이트 중 오류가 발생했습니다: ${error?.message}`, { variant: 'error' });
      }
      
      // 오류 시 이전 상태로 롤백
      if (context?.previousData) {
        logger.info('useUpdateCVEField', '이전 상태로 롤백', { cveId });
        queryClient.setQueryData(
          QUERY_KEYS.CVE.detail(cveId),
          context.previousData
        );
      }
      
      // options에 onError가 있으면 그것을 호출
      if (optionsOnError) {
        optionsOnError(error, variables, context);
      }
    },
    onSuccess: (data, variables, context) => {
      const { cveId, fieldName } = variables;
      logger.info('useUpdateCVEField', '필드 업데이트 성공', { cveId, fieldName });
      
      // 기본 성공 메시지 (options에 onSuccess가 없을 경우에만)
      if (!optionsOnSuccess) {
        enqueueSnackbar(`CVE ${fieldName} 필드가 성공적으로 업데이트되었습니다.`, { variant: 'success' });
      }
      
      // 상세 정보 캐시 업데이트
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), data);
      
      // 목록 쿼리 무효화 (필요한 경우)
      if (['status', 'severity', 'title'].includes(fieldName)) {
        logger.info('useUpdateCVEField', '목록 쿼리 무효화', { reason: '중요 필드 변경' });
        queryClient.invalidateQueries({ 
          queryKey: QUERY_KEYS.CVE.lists(),
          refetchType: 'active'
        });
      }
      
      // options에 onSuccess가 있으면 그것을 호출
      if (optionsOnSuccess) {
        optionsOnSuccess(data, variables, context);
      }
    },
    ...restOptions
  });
};

/**
 * CVE 상태 업데이트를 위한 mutation 훅
 * @param options - React Query 옵션
 * @param customService - 선택적으로 주입할 서비스 객체
 * @returns useMutation 훅에서 반환되는 결과 객체
 */
export const useUpdateCVEStatus = (
  options: UseMutationOptions<
    ApiResponse<CVEDetail>, 
    ApiError, 
    UpdateCVEStatusParams
  > = {}, 
  customService = cveService
): UseMutationResult<
  ApiResponse<CVEDetail>, 
  ApiError, 
  UpdateCVEStatusParams
> => {
  const queryClient = useQueryClient();
  const { enqueueSnackbar } = useSnackbar();
  
  // options에서 onSuccess와 onError 추출
  const { onSuccess: optionsOnSuccess, onError: optionsOnError, ...restOptions } = options;
  
  return useMutation<ApiResponse<CVEDetail>, ApiError, UpdateCVEStatusParams>({
    mutationFn: ({ cveId, status }) => {
      logger.info('useUpdateCVEStatus', '상태 업데이트 요청', { cveId, status });
      return customService.updateCVEStatus(cveId, status);
    },
    onSuccess: (data, variables, context) => {
      const { cveId } = variables;
      // CVE 목록 쿼리 무효화
      queryClient.invalidateQueries({ 
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
      // 해당 CVE 상세 쿼리 무효화
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.CVE.detail(cveId), refetchType: 'active' });
      
      // 기본 성공 메시지 (options에 onSuccess가 없을 경우에만)
      if (!optionsOnSuccess) {
        enqueueSnackbar('CVE 상태가 성공적으로 업데이트되었습니다.', { variant: 'success' });
      }
      
      logger.info('useUpdateCVEStatus', '상태 업데이트 성공', { cveId, status: data.data?.status });
      
      // options에 onSuccess가 있으면 그것을 호출
      if (optionsOnSuccess) {
        optionsOnSuccess(data, variables, context);
      }
      
      return data;
    },
    onError: (error, variables, context) => {
      // 기본 에러 메시지 (options에 onError가 없을 경우에만)
      if (!optionsOnError) {
        enqueueSnackbar(`CVE 상태 업데이트 중 오류가 발생했습니다: ${error?.message}`, { variant: 'error' });
      }
      
      logger.error('useUpdateCVEStatus', '상태 업데이트 중 오류 발생', { error: error?.message });
      
      // options에 onError가 있으면 그것을 호출
      if (optionsOnError) {
        optionsOnError(error, variables, context);
      }
      
      throw error;
    },
    ...restOptions
  });
};

/**
 * WebSocket을 통한 실시간 CVE 업데이트 처리 함수
 * 외부에서 socketIO 이벤트 핸들러로 사용
 * @param queryClient - QueryClient 인스턴스
 * @returns 이벤트 핸들러 함수
 */
export const handleRealtimeCVEUpdate = (queryClient: QueryClient) => {
  // 자주 발생할 수 있는 목록 쿼리 무효화를 디바운스 처리
  const debouncedInvalidateLists = debounce(() => {
    queryClient.invalidateQueries({ 
      queryKey: QUERY_KEYS.CVE.lists(),
      refetchType: 'active'
    });
  }, 300, { leading: true, trailing: true });

  // 특정 CVE 상세 정보 쿼리 무효화를 디바운스 처리
  const debouncedInvalidateDetail = debounce((cveId: string) => {
    queryClient.invalidateQueries({ 
      queryKey: QUERY_KEYS.CVE.detail(cveId), 
      refetchType: 'active' 
    });
  }, 300, { leading: true, trailing: true });

  return (event: RealtimeCVEUpdateEvent): void => {
    const { type, cveId } = event;
    
    logger.info('handleRealtimeCVEUpdate', '이벤트 수신', { type, cveId });
    
    // 이벤트 타입에 따라 적절한 쿼리 무효화
    switch (type) {
      case SOCKET_EVENTS.CVE_CREATED:
        debouncedInvalidateLists();
        break;
      case SOCKET_EVENTS.CVE_UPDATED:
        debouncedInvalidateLists();
        if (cveId) {
          debouncedInvalidateDetail(cveId);
        }
        break;
      case SOCKET_EVENTS.CVE_DELETED:
        debouncedInvalidateLists();
        if (cveId) {
          queryClient.removeQueries({ queryKey: QUERY_KEYS.CVE.detail(cveId) });
        }
        break;
      case SOCKET_EVENTS.CACHE_INVALIDATED:
        // 캐시 무효화 이벤트 처리
        debouncedInvalidateLists();
        if (cveId) {
          debouncedInvalidateDetail(cveId);
        } else {
          // 특정 CVE ID가 없는 경우 전체 CVE 관련 쿼리 무효화
          queryClient.invalidateQueries({ 
            predicate: (query) => 
              query.queryKey[0] === QUERY_KEYS.CVE.all
          });
        }
        break;
      default:
        logger.warn('handleRealtimeCVEUpdate', '알 수 없는 이벤트 타입', { type });
        break;
    }
  };
};

// 이전 버전과의 호환성을 위한 별칭
export const useCreateCVEMutation = useCreateCVE;
export const useUpdateCVEMutation = useUpdateCVE;
export const useDeleteCVEMutation = useDeleteCVE;
export const useUpdateCVEFieldMutation = useUpdateCVEField;
export const useUpdateCVEStatusMutation = useUpdateCVEStatus;

// 모든 CVE 관련 mutation 훅을 기본 내보내기로 묶어서 제공
export default {
  useCreateCVE,
  useUpdateCVE,
  useDeleteCVE,
  useUpdateCVEField,
  useUpdateCVEStatus,
  handleRealtimeCVEUpdate,
  // 이전 버전과의 호환성을 위한 별칭
  useCreateCVEMutation,
  useUpdateCVEMutation,
  useDeleteCVEMutation,
  useUpdateCVEFieldMutation,
  useUpdateCVEStatusMutation
};

/**
 * 안전한 에러 객체 생성 헬퍼 함수
 * @param error - 원본 에러 객체
 * @returns 안전하게 처리된 에러 객체
 */
const ensureSafeErrorObject = (error: any): ApiError => {
  // 이미 cveService에서 처리된 에러인 경우 그대로 반환
  if (get(error, 'isHandled', false)) {
    return error as ApiError;
  }
  
  // 기본 에러 응답 객체
  const defaultErrorResponse = { 
    status: 500, 
    data: { 
      detail: '알 수 없는 오류가 발생했습니다',
      errorCode: 'UNKNOWN_ERROR'
    } 
  };
  
  // lodash의 get을 사용하여 안전하게 속성에 접근
  const errorMessage = 
    get(error, 'response.data.detail') || 
    get(error, 'response.data.message') || 
    (get(error, 'message') && !get(error, 'message', '').includes('status code')) 
      ? get(error, 'message') 
      : '알 수 없는 오류가 발생했습니다';
  
  // 에러 객체 안전하게 구성 (lodash의 merge와 defaultsDeep 사용)
  const safeError: ApiError = merge({}, error, {
    name: get(error, 'name', 'Error'),
    code: get(error, 'response.status', get(error, 'code', 500)),
    message: errorMessage,
    response: defaultsDeep({}, get(error, 'response'), defaultErrorResponse)
  });
  
  // response.data가 없는 경우 생성
  if (!get(safeError, 'response.data')) {
    set(safeError, 'response.data', {
      detail: safeError.message,
      errorCode: `HTTP_${get(safeError, 'response.status', 500)}`
    });
  }
  
  // detail 필드가 없는 경우 생성
  if (!get(safeError, 'response.data.detail')) {
    set(safeError, 'response.data.detail', safeError.message);
  }
  
  // errorCode 필드가 없는 경우 생성
  if (!get(safeError, 'response.data.errorCode')) {
    set(safeError, 'response.data.errorCode', `HTTP_${get(safeError, 'response.status', 500)}`);
  }
  
  return safeError;
};



============================================================
File: /home/CVEHub/frontend/src/features/cve/CVEDetailHeader.tsx
------------------------------------------------------------
// CVEDetailHeader.tsx

import React, { memo } from 'react';
// PropTypes는 더 이상 필요 없으므로 제거합니다.
// import PropTypes from 'prop-types';
import {
  Box,
  Typography,
  Tooltip,
  Chip,
  IconButton,
} from '@mui/material';
import HistoryIcon from '@mui/icons-material/History';
import RefreshIcon from '@mui/icons-material/Refresh';
import CloseIcon from '@mui/icons-material/Close';
// SubscriberCount 컴포넌트 import (확장자 없이 또는 .tsx)
import SubscriberCount from './SubscriberCount';
// 유틸리티 함수 및 상수 import (타입 정의가 되어 있다고 가정)
import { formatDateTime, DATE_FORMATS } from 'shared/utils/dateUtils';
// Subscriber 타입 import
import { Subscriber, CVEDetailHeaderProps } from './types/cve';

// Props 인터페이스는 types/cve.ts에서 import 했으므로 중복 정의 제거

// React.memo와 함께 타입 적용 (React.FC 사용하지 않는 방식 선호)
const CVEDetailHeader = memo((props: CVEDetailHeaderProps) => {
  const {
    cveId,
    subscribers,
    createdAt,
    lastModifiedAt,
    isCached,
    isLoading,
    onRefresh,
    onClose,
  } = props;

  return (
    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
      {/* 좌측: CVE ID, 구독자 수 */}
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
        {/* cveId가 있을 때만 표시 (optional이므로) */}
        <Typography variant="h6">{cveId ? `${cveId} 상세 정보` : '상세 정보'}</Typography>
        {/* SubscriberCount에는 subscribers와 cveId 전달 */}
        {/* subscribers가 undefined일 수 있으므로 빈 배열([]) 전달 */}
        <SubscriberCount subscribers={subscribers || []} cveId={cveId} />
      </Box>

      {/* 우측: 시간 정보, 캐시 상태, 버튼 */}
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
        {/* 생성 시간 (createdAt이 있을 때만 렌더링 또는 formatDateTime이 null/undefined 처리 가능해야 함) */}
        {createdAt && (
          <Tooltip title="생성 시간">
            <Chip
              size="small"
              icon={<HistoryIcon fontSize="small" />}
              // formatDateTime이 null/undefined를 안전하게 처리한다고 가정
              label={`생성: ${formatDateTime(createdAt, DATE_FORMATS.DISPLAY.DEFAULT)}`}
              variant="outlined"
              sx={{ fontSize: '0.7rem', height: 24 }}
            />
          </Tooltip>
        )}

        {/* 마지막 수정 시간 (lastModifiedAt이 있을 때만 렌더링) */}
        {lastModifiedAt && (
          <Tooltip title="마지막 업데이트 시간">
            <Chip
              size="small"
              icon={<HistoryIcon fontSize="small" />}
              label={`수정: ${formatDateTime(lastModifiedAt, DATE_FORMATS.DISPLAY.DEFAULT)}`}
              variant="outlined"
              sx={{ fontSize: '0.7rem', height: 24 }}
            />
          </Tooltip>
        )}

        {/* 캐시 상태 */}
        {isCached && (
          <Tooltip title="캐시된 데이터입니다. 새로고침을 클릭하여 최신 데이터를 불러올 수 있습니다.">
            <Chip
              size="small"
              label="캐시됨"
              color="warning"
              variant="outlined"
              sx={{ fontSize: '0.7rem', height: 24 }}
            />
          </Tooltip>
        )}

        {/* 새로고침 버튼 */}
        <Tooltip title="새로고침">
          <span> {/* Tooltip과 disabled 버튼 호환성 위한 span */}
            <IconButton onClick={onRefresh} disabled={isLoading}>
              <RefreshIcon />
            </IconButton>
          </span>
        </Tooltip>

        {/* 닫기 버튼 */}
        <Tooltip title="닫기">
          <span> {/* Tooltip과 disabled 버튼 호환성 위한 span */}
            <IconButton onClick={onClose} disabled={isLoading}>
              <CloseIcon />
            </IconButton>
          </span>
        </Tooltip>
      </Box>
    </Box>
  );
});

// DisplayName 설정 (React DevTools에서 컴포넌트 이름 식별 용이)
CVEDetailHeader.displayName = 'CVEDetailHeader';

// PropTypes 정의는 제거합니다.

export default CVEDetailHeader;


============================================================
File: /home/CVEHub/frontend/src/features/cve/CVEDetailTabs.tsx
------------------------------------------------------------
// CVEDetailTabs.tsx

import React, { useState, useCallback, memo, ReactNode, ElementType, useMemo } from 'react';
// PropTypes는 더 이상 필요 없으므로 제거
// import PropTypes from 'prop-types';
import { Box, Tabs, Tab, Typography } from '@mui/material';
import { SvgIconComponent } from '@mui/icons-material'; // MUI 아이콘 타입
import ScienceIcon from '@mui/icons-material/Science';
import ShieldIcon from '@mui/icons-material/Shield';
import LinkIcon from '@mui/icons-material/Link';
import CommentIcon from '@mui/icons-material/Comment';
import HistoryIcon from '@mui/icons-material/History';

// 필요한 컴포넌트 import
import GenericDataTab from './components/GenericDataTab';
import CommentsTab from './components/CommentsTab';
import HistoryTab from './components/HistoryTab';

// CVE 관련 타입 import
import { CVEDetailData, TabCounts, RefreshTriggers, CVEDetailTabsProps } from './types/cve';
import {
  pocTabConfig, // 실제 타입 정의 필요 (e.g., PocTabConfigType)
  snortRuleTabConfig, // 실제 타입 정의 필요
  referenceTabConfig // 실제 타입 정의 필요
} from './components/tabConfigs';

// 타입 정의는 types/cve.ts로 이동

// TabPanelWrapper의 Props 타입
interface TabPanelWrapperProps {
  children: ReactNode;
  active: boolean;
  index: number;
  // Box 컴포넌트에 전달될 수 있는 다른 속성들 허용
  [key: string]: any; 
}

// 탭 키 타입 (TabCounts의 키)
type TabKey = keyof TabCounts;

// 탭 구성 항목 타입
interface TabItemConfig {
  label: string;
  iconComponent: SvgIconComponent | ElementType;
  color: string;
  hoverColor: string;
  description: string;
  countKey: TabKey | null;
  component: React.ComponentType<any>;
  config: object | null;
};


// --- 상수 정의 ---

// tabItemsConfig 타입 명시
const tabItemsConfig: TabItemConfig[] = [
  { label: 'PoC', iconComponent: ScienceIcon, color: '#2196f3', hoverColor: '#1976d2', description: '증명 코드 및 취약점 검증', countKey: 'poc', component: GenericDataTab, config: pocTabConfig },
  { label: 'Snort Rule', iconComponent: ShieldIcon, color: '#4caf50', hoverColor: '#388e3c', description: '탐지 규칙 및 방어 정책', countKey: 'snortRule', component: GenericDataTab, config: snortRuleTabConfig },
  { label: 'Reference', iconComponent: LinkIcon, color: '#ff9800', hoverColor: '#f57c00', description: '관련 문서 및 참고 자료', countKey: 'reference', component: GenericDataTab, config: referenceTabConfig },
  { label: 'Comments', iconComponent: CommentIcon, color: '#9c27b0', hoverColor: '#7b1fa2', description: '토론 및 의견 공유', countKey: 'comments', component: CommentsTab, config: null },
  { label: 'History', iconComponent: HistoryIcon, color: '#757575', hoverColor: '#757575', description: '수정 이력', countKey: null, component: HistoryTab, config: null }
];

// --- 컴포넌트 구현 ---

// 탭 패널 Wrapper 컴포넌트
const TabPanelWrapper = memo(({ children, active, index, ...other }: TabPanelWrapperProps) => (
  <Box
    sx={{
      display: active ? 'block' : 'none',
      height: '100%',
      p: 3,
      overflowY: 'auto',
      '&::-webkit-scrollbar': { width: '8px', backgroundColor: 'transparent' },
      '&::-webkit-scrollbar-thumb': { backgroundColor: 'rgba(0, 0, 0, 0.1)', borderRadius: '4px', '&:hover': { backgroundColor: 'rgba(0, 0, 0, 0.2)' } }
    }}
    role="tabpanel"
    hidden={!active} // active가 false일 때 숨김
    id={`tabpanel-${index}`}
    aria-labelledby={`tab-${index}`}
    {...other} // 다른 props 전달 (예: sx)
  >
    {/* active일 때만 children을 렌더링하도록 최적화 */}
    {active && children}
  </Box>
));
TabPanelWrapper.displayName = 'TabPanelWrapper'; // DevTools 이름 설정

// 메인 탭 컴포넌트
const CVEDetailTabs = memo((props: CVEDetailTabsProps) => {
  const {
    cveData,
    currentUser,
    refreshTriggers,
    tabCounts,
    onCountChange,
    parentSendMessage,
    highlightCommentId,
  } = props;

  const [activeTab, setActiveTab] = useState<number>(0);

  // 탭 변경 핸들러 - 의존성 배열 최적화
  const handleTabChange = useCallback((_event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  }, []);

  // 탭 카운트 변경 핸들러 - 구체적인 탭에 대한 변경을 처리하도록 최적화
  const handleTabSpecificCountChange = useCallback((tabKey: TabKey) => {
    return (count: number) => {
      // 상위 컴포넌트에 전달된 콜백에 변경사항 통보
      if (onCountChange) {
        onCountChange(tabKey, count);
      }
    };
  }, [onCountChange]);

  // cveData를 cve라는 이름으로 내부 컴포넌트에 전달하므로, 일관성을 위해 변수 준비
  const commonProps = useMemo(() => ({
    cve: cveData,
    currentUser: currentUser ?? undefined,
    parentSendMessage,
  }), [cveData, currentUser, parentSendMessage]);

  return (
    <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden', bgcolor: 'background.paper' }}>
      {/* 탭 헤더 */}
      <Tabs
        value={activeTab}
        onChange={handleTabChange}
        variant="fullWidth"
        sx={{
          borderBottom: 1,
          borderColor: 'divider',
          bgcolor: 'background.paper',
          flexShrink: 0,
        }}
        aria-label="CVE Detail Tabs"
      >
        {tabItemsConfig.map((tab, index) => {
          // countKey가 null이 아니고, tabCounts에 해당 키가 있는지 확인
          const count = tab.countKey && tabCounts.hasOwnProperty(tab.countKey) ? tabCounts[tab.countKey] : undefined;
          const labelText = count !== undefined ? `${tab.label} (${count})` : tab.label;

          return (
            <Tab
              key={tab.label}
              label={
                <Box sx={{ textAlign: 'center', py: 1 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 1, mb: 0.5 }}>
                    {/* 아이콘 컴포넌트 생성 */}
                    {React.createElement(tab.iconComponent, { sx: { fontSize: 20 } })}
                    <Typography component="span" sx={{ fontSize: '0.9rem' }}>
                      {labelText}
                    </Typography>
                  </Box>
                  <Typography variant="caption" color="text.secondary" sx={{ display: 'block' }}>
                    {tab.description}
                  </Typography>
                </Box>
              }
              sx={{
                minHeight: 72,
                textTransform: 'none',
                fontWeight: 500,
                color: activeTab === index ? tab.color : 'text.primary',
                opacity: 1,
                '&:hover': {
                  color: tab.hoverColor,
                  bgcolor: 'action.hover'
                },
                '&.Mui-selected': {
                  color: tab.color,
                  fontWeight: 600,
                },
                '&.Mui-focusVisible': {
                  backgroundColor: 'action.focus'
                }
              }}
              id={`tab-${index}`}
              aria-controls={`tabpanel-${index}`}
            />
          );
        })}
      </Tabs>

      {/* 탭 컨텐츠 영역 */}
      <Box sx={{ flex: 1, overflow: 'hidden', bgcolor: 'background.paper' }}>
        {tabItemsConfig.map((tab, index) => {
          // 각 탭 컴포넌트에 전달될 공통 Props
          // currentUser가 null일 수 있으므로 명시적 처리
          let tabSpecificProps: Record<string, any> = {};

          if (tab.component === GenericDataTab && tab.countKey) {
            tabSpecificProps = {
              // refreshTriggers가 undefined일 수 있으므로 optional chaining 및 기본값 0 사용
              refreshTrigger: refreshTriggers?.[tab.countKey] ?? 0,
              // 탭에 해당하는 설정 객체 전달
              tabConfig: tab.config,
              onCountChange: handleTabSpecificCountChange(tab.countKey),
            };
          } else if (tab.component === CommentsTab) {
            tabSpecificProps = {
              refreshTrigger: refreshTriggers?.comments ?? 0,
              onCountChange: handleTabSpecificCountChange('comments'),
              // highlightCommentId가 null일 수 있으므로 ?? undefined 사용
              highlightCommentId: highlightCommentId ?? undefined,
            };
          } else if (tab.component === HistoryTab) {
            tabSpecificProps = {
              // cveData.modificationHistory가 없을 수 있으므로 빈 배열([]) 전달
              modificationHistory: cveData?.modificationHistory || [],
            };
          }

          // 최종 Props 객체 결합
          const finalProps = { ...commonProps, ...tabSpecificProps };

          return (
            <TabPanelWrapper key={tab.label} active={activeTab === index} index={index}>
              {/* React.createElement 사용 시 타입 주의 */}
              {React.createElement(tab.component, finalProps)}
            </TabPanelWrapper>
          );
        })}
      </Box>
    </Box>
  );
});

CVEDetailTabs.displayName = 'CVEDetailTabs'; // DevTools 이름 설정

// PropTypes는 제거

export default CVEDetailTabs;


============================================================
File: /home/CVEHub/frontend/src/features/cve/SubscriberCount.tsx
------------------------------------------------------------
import React, { memo, useMemo, useEffect } from 'react';
import {
  Box,
  Typography,
  Tooltip,
  AvatarGroup,
  Avatar,
} from '@mui/material';
import VisibilityIcon from '@mui/icons-material/Visibility';
import { Subscriber, SubscriberCountProps } from './types/cve';

// SubscriberCount 컴포넌트 (기존 CVEDetail에서 분리)
const SubscriberCount = memo(({ subscribers = [], cveId }: SubscriberCountProps) => {
  // 디버깅용 로그 추가
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      console.debug('SubscriberCount 렌더링:', {
        cveId,
        subscribersCount: subscribers?.length || 0,
        subscribers
      });
    }
  }, [subscribers, cveId]);

  // 유효한 구독자만 필터링 (개선된 버전)
  const validSubscribers = useMemo(() => {
    if (!Array.isArray(subscribers)) return [];
    
    return subscribers
      .filter(sub => sub && typeof sub === 'object')
      .map(sub => ({
        ...sub,
        id: sub.id || sub.userId || '',
        userId: sub.userId || sub.id || '',
        username: sub.username || 'User',
        displayName: sub.displayName || sub.username || 'User',
        profileImage: sub.profileImage || sub.profile_image || ''
      }))
      .filter(sub => sub.id || sub.userId); // ID가 있는 경우만 유효
  }, [subscribers]);
  
  const hasSubscribers = validSubscribers.length > 0;

  return (
    <Box
      sx={{
        display: 'flex',
        alignItems: 'center',
        gap: 1,
        bgcolor: 'action.hover',
        borderRadius: 2,
        py: 0.5,
        px: 1.5
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
        <VisibilityIcon
          sx={{
            fontSize: 16,
            color: 'text.secondary'
          }}
        />
        <Typography variant="body2" color="text.secondary">
          {hasSubscribers ? `${validSubscribers.length}명이 보는 중` : '보는 중'}
        </Typography>
      </Box>
      {hasSubscribers && (
        <AvatarGroup
          max={5}
          sx={{
            '& .MuiAvatar-root': {
              width: 24,
              height: 24,
              fontSize: '0.75rem',
              border: '2px solid #fff',
              cursor: 'pointer',
              transition: 'all 0.2s ease-in-out',
              '&:hover': {
                transform: 'scale(1.1)',
                zIndex: 1
              }
            }
          }}
        >
          {validSubscribers.map((subscriber, index) => {
            // 구독자 정보 추출 및 검증
            const key = subscriber.id || subscriber.userId || `subscriber-${index}`;
            const username = subscriber.displayName || subscriber.username || '사용자';
            const profileImage = subscriber.profileImage || subscriber.profile_image || '';
            const hasProfileImage = Boolean(profileImage && profileImage.length > 0);

            return (
              <Tooltip
                key={key}
                title={username}
                placement="bottom"
                arrow
                enterDelay={200}
                leaveDelay={0}
              >
                <Avatar
                  alt={username}
                  src={hasProfileImage ? profileImage : undefined}
                  sx={{
                    bgcolor: !hasProfileImage ?
                      `hsl(${(username.length * 30) % 360}, 70%, 50%)` : // 이름 기반 색상
                      undefined
                  }}
                >
                  {/* 프로필 이미지 없을 때 첫 글자 표시 */}
                  {!hasProfileImage && (username.charAt(0) || 'U').toUpperCase()}
                </Avatar>
              </Tooltip>
            );
          })}
        </AvatarGroup>
      )}
    </Box>
  );
});

// 컴포넌트 이름 지정 (디버깅용)
SubscriberCount.displayName = 'SubscriberCount';

export default SubscriberCount;


============================================================
File: /home/CVEHub/frontend/src/features/activities/pages/ActivitiesPage.jsx
------------------------------------------------------------
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { 
  Container, 
  Typography, 
  Box, 
  Paper,
  Divider,
  Fade,
  Alert,
  Backdrop,
  CircularProgress
} from '@mui/material';
import { Helmet } from 'react-helmet-async';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { useActivityQuery } from '../hooks/useActivityQuery';
import ActivityList from '../components/ActivityList';
import ActivitiesFilter from '../components/ActivitiesFilter';
import useSocket from 'core/socket/hooks/useSocket';
import { useQueryClient } from '@tanstack/react-query';

/**
 * 개선된 사용자 활동 이력 페이지 컴포넌트
 * - 응답형 디자인 개선
 * - 로딩 상태 개선
 * - 성능 최적화
 * 
 * @returns {JSX.Element} 렌더링된 컴포넌트
 */
const ActivitiesPage = () => {
  
  /** @type {Object} 현재 인증된 사용자 정보 */
  const { user } = useAuth();
  
  /** @type {string} 현재 사용자의 사용자명 */
  const username = user?.username || '';
  
  /**
   * 필터 상태 관리
   * @type {[Object, function]} 필터 상태와 상태 변경 함수
   */
  const [filters, setFilters] = useState({
    username: username, // 기본값으로 현재 사용자 설정
    page: 1,
    limit: 10,
    action: '',
    target_type: '',
    target_id: '',
    start_date: null,
    end_date: null
  });

  // 상태 변경 감지용 초기 마운트 플래그
  const [initialLoad, setInitialLoad] = useState(true);

  /**
   * 필터 상태 변경 시 페이지 리셋
   * 사용자가 필터를 변경할 때마다 페이지를 1로 리셋하여
   * 필터링된 결과의 첫 페이지를 보여줍니다.
   */
  useEffect(() => {
    if (initialLoad) {
      setInitialLoad(false);
      return;
    }
    
    // 페이지 변경이 아닌 다른 필터 변경 시에만 페이지 번호 초기화
    // 필터 변경 시 페이지 번호를 1로 리셋
    setFilters(prev => ({ ...prev, page: 1 }));
  }, [filters.action, filters.target_type, filters.target_id, filters.username, filters.start_date, filters.end_date, initialLoad]);

  /**
   * 사용자 변경 시 필터 업데이트
   * 로그인 상태가 변경되면 필터의 사용자명을 업데이트합니다.
   */
  useEffect(() => {
    if (username && initialLoad) {
      setFilters(prev => ({ ...prev, username }));
    }
  }, [username, initialLoad]);

  /**
   * 활동 데이터 가져오기
   * useActivityQuery 훅을 사용하여 선택된 필터에 따라 활동 데이터를 조회합니다.
   */
  const { 
    data, 
    isLoading, 
    isRefetching,
    error, 
    refetch 
  } = useActivityQuery(filters);

  // 로딩 중 상태 - 첫 로딩과 리페칭 구분
  const isFullPageLoading = isLoading && !isRefetching;
  const isRefreshLoading = !isLoading && isRefetching;

  // queryClient 선언은 유지하지만 배경에서 자동으로 데이터를 갱신하는 코드는 제거
  // 사용자가 수동으로 새로고침할 때만 데이터가 갱신됨
  const queryClient = useQueryClient();

  /**
   * 필터 변경 핸들러
   * 
   * @param {Object} newFilters - 새로운 필터 값
   */
  const handleFilterChange = (newFilters) => {
    setFilters(newFilters);
  };

  /**
   * 필터 적용 핸들러
   */
  const handleFilterApply = () => {
    refetch();
  };

  /**
   * 필터 초기화 핸들러
   */
  const handleFilterReset = () => {
    setFilters({
      username: username, // 현재 로그인한 사용자로 설정
      page: 1,
      limit: 10,
      action: '',
      target_type: '',
      target_id: '',
      start_date: null,
      end_date: null
    });
    
    // 초기화 후 바로 데이터 다시 불러오기
    setTimeout(() => refetch(), 0);
  };

  /**
   * 페이지 변경 핸들러
   * 
   * @param {number} newPage - 새로운 페이지 번호
   */
  const handlePageChange = (newPage) => {
    setFilters(prev => ({ ...prev, page: newPage }));
  };

  /**
   * 페이지당 항목 수 변경 핸들러
   * 
   * @param {number} newLimit - 새로운 페이지당 항목 수
   */
  const handleLimitChange = (newLimit) => {
    setFilters(prev => ({ ...prev, limit: newLimit, page: 1 }));
  };
  
  // 현재 적용된 활동 타입에 따른 제목 텍스트
  const titleText = useMemo(() => {
    if (filters.username === username) {
      return '내 활동';
    } else if (filters.username) {
      const selectedUser = data?.users?.find(u => u.username === filters.username);
      const displayName = selectedUser ? (selectedUser.display_name || selectedUser.username) : filters.username;
      return `${displayName}님의 활동`;
    } else {
      return '모든 활동';
    }
  }, [filters.username, username, data?.users]);

  return (
    <>
      <Helmet>
        <title>활동 이력 | CVEHub</title>
      </Helmet>
      
      {/* 전체 페이지 로딩 인디케이터 */}
      <Backdrop
        sx={{ color: '#fff', zIndex: (theme) => theme.zIndex.drawer + 1 }}
        open={isFullPageLoading}
      >
        <CircularProgress color="inherit" />
      </Backdrop>
      
      <Container maxWidth="lg" sx={{ mt: { xs: 2, sm: 4 }, mb: 4 }}>
        {/* 페이지 타이틀 */}
        <Box sx={{ mb: { xs: 2, sm: 3 } }}>
          <Typography variant="h4" component="h1" gutterBottom>
            활동 이력
          </Typography>
          <Typography variant="body1" color="text.secondary">
            CVEHub에서의 사용자 활동 내역을 확인하세요. 필터를 사용하여 특정 사용자, 기간, 활동 유형 등으로 검색할 수 있습니다.
          </Typography>
        </Box>

        {/* 필터 영역 */}
        <Box sx={{ mb: { xs: 2, sm: 3 } }}>
          <ActivitiesFilter 
            filters={filters}
            onFilterChange={handleFilterChange}
            onFilterApply={handleFilterApply}
            onFilterReset={handleFilterReset}
          />
        </Box>

        {/* 리프레시 중 알림 */}
        {isRefreshLoading && (
          <Fade in={isRefreshLoading}>
            <Alert 
              severity="info" 
              sx={{ mb: 2 }}
              icon={<CircularProgress size={20} />}
            >
              데이터를 갱신 중입니다...
            </Alert>
          </Fade>
        )}

        {/* 활동 목록 영역 */}
        <Paper sx={{ p: { xs: 2, sm: 3 } }}>
          <Box sx={{ mb: 2 }}>
            <Typography variant="h6" component="h2">
              {titleText}
            </Typography>
            <Divider sx={{ my: 1 }} />
          </Box>
          
          <ActivityList 
            activities={data?.items || []}
            total={data?.total || 0}
            page={filters.page}
            limit={filters.limit}
            isLoading={isLoading || isRefetching}
            error={error}
            onPageChange={handlePageChange}
            onLimitChange={handleLimitChange}
          />
        </Paper>
      </Container>
    </>
  );
};

export default React.memo(ActivitiesPage);


============================================================
File: /home/CVEHub/frontend/src/features/activities/components/ActivitiesFilter.jsx
------------------------------------------------------------
import React, { useState, useEffect, useMemo } from 'react';
import { 
  Box, 
  Grid, 
  TextField, 
  InputAdornment,
  FormControl, 
  InputLabel, 
  Select, 
  MenuItem, 
  Button,
  Chip,
  Stack,
  Typography,
  Paper,
  Divider,
  IconButton,
  Tooltip,
  useMediaQuery,
  useTheme,
  CircularProgress,
  Collapse,
  Autocomplete,
  Fade
} from '@mui/material';
import FilterListIcon from '@mui/icons-material/FilterList';
import ClearIcon from '@mui/icons-material/Clear';
import PersonIcon from '@mui/icons-material/Person';
import PublicIcon from '@mui/icons-material/Public';
import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import DateRangeIcon from '@mui/icons-material/DateRange';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import SearchIcon from '@mui/icons-material/Search';
import CategoryIcon from '@mui/icons-material/Category';
import TargetIcon from '@mui/icons-material/Adjust';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { ko } from 'date-fns/locale';
import { format, subDays, subMonths } from 'date-fns';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { useUsers } from 'features/auth/hooks/useUsersQuery';

// 동작 유형 목록 (간소화됨)
const actionOptions = [
  { value: 'create', label: '생성' },
  { value: 'update', label: '수정' },
  { value: 'add', label: '추가' },
  { value: 'delete', label: '삭제' }
];

// 대상 유형 목록
const targetTypeOptions = [
  { value: 'cve', label: 'CVE' },
  { value: 'poc', label: 'PoC' },
  { value: 'snort_rule', label: 'Snort 규칙' },
  { value: 'reference', label: '참조문서' },
  { value: 'comment', label: '댓글' },
  { value: 'user', label: '사용자' },
  { value: 'system', label: '시스템' }
];

/**
 * 개선된 활동 필터링 컴포넌트
 * - 직관적인 UI로 간소화
 * - 모바일 대응 강화
 * - 통합 검색바 추가
 * 
 * @param {Object} props 컴포넌트 속성
 * @param {Object} props.filters 현재 필터 값
 * @param {Function} props.onFilterChange 필터 변경 핸들러
 * @param {Function} props.onFilterApply 필터 적용 핸들러
 * @param {Function} props.onFilterReset 필터 초기화 핸들러
 * @returns {JSX.Element} 렌더링된 컴포넌트
 */
const ActivitiesFilter = ({ filters, onFilterChange, onFilterApply, onFilterReset }) => {
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const theme = useTheme();
  // PC 환경에 최적화
  const isTablet = useMediaQuery(theme.breakpoints.down('md'));
  const { user } = useAuth();
  const currentUsername = user?.username || '';
  
  // 사용자 목록 가져오기
  const { data: usersData, isLoading: isLoadingUsers } = useUsers();
  const users = usersData?.items || [];
  
  // 적용된 필터 개수 계산
  const appliedFiltersCount = useMemo(() => {
    let count = 0;
    if (filters.target_type && filters.target_type.length > 0) count += filters.target_type.length;
    if (filters.target_id) count++;
    if (filters.action && filters.action.length > 0) count += filters.action.length;
    if (filters.start_date) count++;
    if (filters.end_date) count++;
    if (filters.username && filters.username !== currentUsername) count++;
    return count;
  }, [filters, currentUsername]);

  // 검색어 적용 (target_id나 대상 검색에 활용)
  useEffect(() => {
    if (searchTerm.trim()) {
      // 검색어가 CVE 형식인지 확인 (CVE-YYYY-NNNNN)
      if (/^CVE-\d{4}-\d{4,}$/i.test(searchTerm.trim())) {
        onFilterChange({
          ...filters,
          target_type: 'cve',
          target_id: searchTerm.trim()
        });
      } else {
        onFilterChange({
          ...filters,
          target_id: searchTerm.trim()
        });
      }
    } else if (filters.target_id && !searchTerm) {
      // 검색어가 지워졌을 때 target_id 필터 제거
      onFilterChange({
        ...filters,
        target_id: ''
      });
    }
  }, [searchTerm]);

  // 필터 변경 핸들러 (즉시 적용)
  const handleQuickFilterChange = (field, value) => {
    let newValue = value;
    
    // 배열 필드 처리 (동작 유형, 대상 유형)
    if (field === 'action' || field === 'target_type') {
      if (Array.isArray(filters[field])) {
        // 이미 값이 있는지 확인
        const index = filters[field].indexOf(value);
        
        if (index === -1) {
          // 값이 없으면 추가
          newValue = [...filters[field], value];
        } else {
          // 값이 있으면 제거
          newValue = filters[field].filter(item => item !== value);
        }
      } else {
        // 배열이 아닌 경우 배열로 변환
        newValue = [value];
      }
    }
    
    const newFilters = {
      ...filters,
      [field]: newValue
    };
    onFilterChange(newFilters);
    onFilterApply();
  };

  // 필터 변경 핸들러 (적용 버튼 필요)
  const handleAdvancedFilterChange = (field, value) => {
    onFilterChange({
      ...filters,
      [field]: value
    });
  };

  // 폼 제출 핸들러
  const handleSubmit = (e) => {
    e.preventDefault();
    onFilterApply();
  };

  // 날짜 형식 포맷팅
  const formatDateForDisplay = (date) => {
    if (!date) return '';
    return format(new Date(date), 'yyyy-MM-dd');
  };
  
  // 현재 날짜
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  // 기간 텍스트 계산
  const getPeriodText = () => {
    if (!filters.start_date || !filters.end_date) {
      return null;
    }
    
    const start = new Date(filters.start_date);
    const end = new Date(filters.end_date);
    
    // 오늘인지 확인
    const isToday = (date) => {
      const today = new Date();
      return date.getDate() === today.getDate() && 
             date.getMonth() === today.getMonth() && 
             date.getFullYear() === today.getFullYear();
    };
    
    // 오늘 필터 확인
    if (start.getDate() === end.getDate() && 
        start.getMonth() === end.getMonth() && 
        start.getFullYear() === end.getFullYear() && 
        isToday(end)) {
      return "오늘";
    }
    
    // 최근 7일 필터 확인
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    sevenDaysAgo.setHours(0, 0, 0, 0);
    
    if (Math.abs(start.getTime() - sevenDaysAgo.getTime()) < 86400000 && isToday(end)) {
      return "최근 7일";
    }
    
    // 최근 30일 필터 확인
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    thirtyDaysAgo.setHours(0, 0, 0, 0);
    
    if (Math.abs(start.getTime() - thirtyDaysAgo.getTime()) < 86400000 && isToday(end)) {
      return "최근 30일";
    }
    
    // 사용자 지정 기간
    return `${formatDateForDisplay(start)} ~ ${formatDateForDisplay(end)}`;
  };

  // 빠른 필터 설정 함수들
  const handleSetToday = () => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const endOfDay = new Date();
    endOfDay.setHours(23, 59, 59, 999);
    
    // 두 필터를 한번에 변경하고 한번만 API 호출하도록
    onFilterChange({
      ...filters,
      start_date: today,
      end_date: endOfDay
    });
    onFilterApply();
  };

  const handleSetLastWeek = () => {
    const oneWeekAgo = subDays(new Date(), 7);
    oneWeekAgo.setHours(0, 0, 0, 0);
    const endOfDay = new Date();
    endOfDay.setHours(23, 59, 59, 999);
    
    onFilterChange({
      ...filters,
      start_date: oneWeekAgo,
      end_date: endOfDay
    });
    onFilterApply();
  };

  const handleSetLastMonth = () => {
    const oneMonthAgo = subMonths(new Date(), 1);
    oneMonthAgo.setHours(0, 0, 0, 0);
    const endOfDay = new Date();
    endOfDay.setHours(23, 59, 59, 999);
    
    onFilterChange({
      ...filters,
      start_date: oneMonthAgo,
      end_date: endOfDay
    });
    onFilterApply();
  };

  const handleSetMyActivities = () => {
    handleQuickFilterChange('username', currentUsername);
  };

  const handleSetAllActivities = () => {
    handleQuickFilterChange('username', null);
  };

  // 현재 적용된 필터 칩 렌더링
  const renderFilterChips = () => {
    const chips = [];

    // 사용자 필터 칩 추가
    if (filters.username) {
      let userLabel = "";
      if (filters.username === currentUsername) {
        userLabel = "내 활동";
      } else if (filters.username === "system") {
        userLabel = "시스템";
      } else {
        const selectedUser = users.find(u => u.username === filters.username);
        userLabel = selectedUser ? (selectedUser.display_name || selectedUser.username) : filters.username;
      }
      
      chips.push(
        <Chip
          key="username"
          label={`사용자: ${userLabel}`}
          onDelete={() => handleQuickFilterChange('username', null)}
          color="primary"
          size="small"
        />
      );
    }

    if (filters.action && filters.action.length > 0) {
      filters.action.forEach(actionValue => {
        const actionLabel = actionOptions.find(opt => opt.value === actionValue)?.label || actionValue;
        chips.push(
          <Chip
            key={`action-${actionValue}`}
            label={`동작: ${actionLabel}`}
            onDelete={() => {
              const newActions = filters.action.filter(a => a !== actionValue);
              handleQuickFilterChange('action', actionValue); // 토글 방식으로 제거
            }}
            color="primary"
            size="small"
          />
        );
      });
    }

    if (filters.target_type && filters.target_type.length > 0) {
      filters.target_type.forEach(typeValue => {
        const targetTypeLabel = targetTypeOptions.find(opt => opt.value === typeValue)?.label || typeValue;
        chips.push(
          <Chip
            key={`target_type-${typeValue}`}
            label={`대상 유형: ${targetTypeLabel}`}
            onDelete={() => {
              handleQuickFilterChange('target_type', typeValue); // 토글 방식으로 제거
            }}
            color="primary"
            size="small"
          />
        );
      });
    }

    if (filters.target_id) {
      chips.push(
        <Chip
          key="target_id"
          label={`대상 ID: ${filters.target_id}`}
          onDelete={() => {
            handleQuickFilterChange('target_id', '');
            setSearchTerm('');
          }}
          color="primary"
          size="small"
        />
      );
    }

    // 시작일과 종료일 필터 칩 (기간으로 통합)
    const periodText = getPeriodText();
    if (periodText) {
      chips.push(
        <Chip
          key="period"
          label={`기간: ${periodText}`}
          onDelete={() => {
            handleQuickFilterChange('start_date', null);
            handleQuickFilterChange('end_date', null);
          }}
          color="primary"
          size="small"
        />
      );
    } else {
      // 시작일, 종료일이 개별적으로 설정된 경우 (기간이 아닌 경우)
      if (filters.start_date) {
        chips.push(
          <Chip
            key="start_date"
            label={`시작일: ${formatDateForDisplay(filters.start_date)}`}
            onDelete={() => handleQuickFilterChange('start_date', null)}
            color="primary"
            size="small"
          />
        );
      }

      if (filters.end_date) {
        chips.push(
          <Chip
            key="end_date"
            label={`종료일: ${formatDateForDisplay(filters.end_date)}`}
            onDelete={() => handleQuickFilterChange('end_date', null)}
            color="primary"
            size="small"
          />
        );
      }
    }

    return chips;
  };

  // 버튼 활성화 상태 확인
  const isMyActivitiesActive = filters.username === currentUsername;
  const isAllActivitiesActive = !filters.username;

  return (
    <Paper sx={{ p: { xs: 1.5, sm: 2 } }} elevation={1}>
      {/* 헤더 영역 */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
        <Typography variant="h6" component="h2" sx={{ display: 'flex', alignItems: 'center' }}>
          <FilterListIcon sx={{ mr: 1 }} />
          필터
          {appliedFiltersCount > 0 && (
            <Chip
              label={appliedFiltersCount}
              color="primary"
              size="small"
              sx={{ ml: 1 }}
            />
          )}
        </Typography>
        
        {/* 필터 초기화 버튼 */}
        <Box>
          {appliedFiltersCount > 0 && (
            <Button
              variant="outlined"
              color="error"
              size="small"
              startIcon={<ClearIcon />}
              onClick={onFilterReset}
            >
              초기화
            </Button>
          )}
        </Box>
      </Box>

      {/* 통합 검색바 */}
      <TextField
        fullWidth
        placeholder="CVE-2023-1234와 같은 대상 ID 또는 키워드 검색"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        size="small"
        sx={{ mb: 2 }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <SearchIcon />
            </InputAdornment>
          ),
          endAdornment: searchTerm && (
            <InputAdornment position="end">
              <IconButton size="small" onClick={() => setSearchTerm('')}>
                <ClearIcon fontSize="small" />
              </IconButton>
            </InputAdornment>
          )
        }}
        onKeyPress={(e) => e.key === 'Enter' && onFilterApply()}
      />

      {/* 빠른 필터 버튼 그룹 */}
      <Box sx={{ mb: 2 }}>
        <Grid container spacing={1}>
          {/* 사용자 필터 그룹 */}
          <Grid item xs={12} sm={6}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <PersonIcon fontSize="small" sx={{ mr: 0.5 }} />
              <Typography variant="body2" color="text.secondary">사용자</Typography>
            </Box>
            <Stack 
              direction="row" 
              spacing={1} 
              sx={{ 
                flexWrap: 'wrap', 
                gap: 1,
                '& > button': { mb: 0 }
              }}
            >
              <Button 
                size="small" 
                variant={isMyActivitiesActive ? "contained" : "outlined"}
                onClick={handleSetMyActivities}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                내 활동
              </Button>
              <Button 
                size="small" 
                variant={isAllActivitiesActive ? "contained" : "outlined"}
                onClick={handleSetAllActivities}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                모든 활동
              </Button>
              <FormControl size="small" sx={{ minWidth: 120 }}>
                <Select
                  value={filters.username || ''}
                  onChange={(e) => handleQuickFilterChange('username', e.target.value)}
                  displayEmpty
                  renderValue={(selected) => {
                    if (!selected) return "사용자 선택";
                    
                    if (selected === currentUsername) {
                      return "내 활동";
                    }
                    
                    if (selected === 'system') {
                      return "시스템";
                    }
                    
                    const selectedUser = users.find(u => u.username === selected);
                    return selectedUser ? (selectedUser.display_name || selectedUser.username) : selected;
                  }}
                  sx={{ height: 32 }}
                >
                  <MenuItem value={null}>모든 사용자</MenuItem>
                  <MenuItem value={currentUsername}>내 활동</MenuItem>
                  <MenuItem value="system">시스템</MenuItem>
                  {users
                    .filter(u => u.username !== currentUsername && u.username !== 'system')
                    .map((user) => (
                      <MenuItem key={user.id} value={user.username}>
                        {user.display_name || user.username}
                      </MenuItem>
                    ))
                  }
                </Select>
              </FormControl>
            </Stack>
          </Grid>

          {/* 기간 필터 그룹 */}
          <Grid item xs={12} sm={6}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <CalendarTodayIcon fontSize="small" sx={{ mr: 0.5 }} />
              <Typography variant="body2" color="text.secondary">기간</Typography>
            </Box>
            <Stack 
              direction="row" 
              spacing={1} 
              sx={{ 
                flexWrap: 'wrap', 
                gap: 1,
                '& > button': { mb: 0 }
              }}
            >
              <Button 
                size="small" 
                variant="outlined"
                onClick={handleSetToday}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                오늘
              </Button>
              <Button 
                size="small" 
                variant="outlined"
                onClick={handleSetLastWeek}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                최근 7일
              </Button>
              <Button 
                size="small" 
                variant="outlined"
                onClick={handleSetLastMonth}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                최근 30일
              </Button>
            </Stack>
          </Grid>
        </Grid>
      </Box>
      
      {/* 타입 필터 - 위치 변경 및 동작 유형 버튼으로 변경 */}
      <Grid container spacing={2} sx={{ mb: 2 }}>
        <Grid item xs={12} sm={6}>
          <FormControl size="small" fullWidth>
            <InputLabel id="target-type-label">대상 유형</InputLabel>
            <Select
              labelId="target-type-label"
              multiple
              value={filters.target_type || []}
              onChange={(e) => onFilterChange({
                ...filters,
                target_type: e.target.value
              })}
              onClose={() => onFilterApply()}
              label="대상 유형"
              renderValue={(selected) => (
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                  {selected.map((value) => {
                    const label = targetTypeOptions.find(opt => opt.value === value)?.label || value;
                    return (
                      <Chip key={value} label={label} size="small" />
                    );
                  })}
                </Box>
              )}
            >
              {targetTypeOptions.map((option) => (
                <MenuItem key={option.value} value={option.value}>
                  {option.label}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Grid>
        <Grid item xs={12} sm={6}>
          <Box>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <Typography variant="body2" color="text.secondary">동작 유형</Typography>
            </Box>
            <Stack direction="row" spacing={1} sx={{ flexWrap: 'wrap', gap: 1 }}>
              <Button 
                size="small" 
                variant={(filters.action.length === 0) ? "contained" : "outlined"}
                onClick={() => onFilterChange({
                  ...filters,
                  action: []
                })}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                전체
              </Button>
              {actionOptions.map((option) => (
                <Button 
                  key={option.value}
                  size="small" 
                  variant={filters.action.includes(option.value) ? "contained" : "outlined"}
                  onClick={() => handleQuickFilterChange('action', option.value)}
                  sx={{ minWidth: 0, px: 1.5 }}
                >
                  {option.label}
                </Button>
              ))}
            </Stack>
          </Box>
        </Grid>
      </Grid>

      {/* 현재 적용된 필터 칩 표시 */}
      {appliedFiltersCount > 0 && (
        <Fade in={appliedFiltersCount > 0}>
          <Box sx={{ mt: 2 }}>
            <Divider sx={{ mb: 1.5 }} />
            <Typography variant="body2" color="text.secondary" gutterBottom>
              적용된 필터
            </Typography>
            <Stack direction="row" spacing={1} flexWrap="wrap" sx={{ gap: 0.5 }}>
              {renderFilterChips()}
            </Stack>
          </Box>
        </Fade>
      )}

      {/* 고급 필터 토글 버튼 */}
      <Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
        <Button
          size="small"
          onClick={() => setShowAdvanced(!showAdvanced)}
          endIcon={<ExpandMoreIcon sx={{ 
            transform: showAdvanced ? 'rotate(180deg)' : 'rotate(0deg)',
            transition: 'transform 0.3s'
          }} />}
          sx={{ textTransform: 'none' }}
        >
          {showAdvanced ? '고급 필터 닫기' : '고급 필터 열기'}
        </Button>
      </Box>

      {/* 고급 필터 패널 */}
      <Collapse in={showAdvanced}>
        <Box sx={{ mt: 2, p: 2, bgcolor: 'background.default', borderRadius: 1 }}>
          <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ko}>
            <form onSubmit={handleSubmit}>
              <Grid container spacing={2}>
                {/* 날짜 필터 */}
                <Grid item xs={12} sm={6}>
                  <DatePicker
                    label="시작일"
                    value={filters.start_date ? new Date(filters.start_date) : null}
                    onChange={(date) => handleAdvancedFilterChange('start_date', date)}
                    slotProps={{ textField: { size: 'small', fullWidth: true } }}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <DatePicker
                    label="종료일"
                    value={filters.end_date ? new Date(filters.end_date) : null}
                    onChange={(date) => handleAdvancedFilterChange('end_date', date)}
                    slotProps={{ textField: { size: 'small', fullWidth: true } }}
                  />
                </Grid>

                <Grid item xs={12}>
                  <Box display="flex" justifyContent="flex-end" gap={1}>
                    <Button
                      variant="text"
                      color="inherit"
                      onClick={onFilterReset}
                      size="small"
                    >
                      초기화
                    </Button>
                    <Button
                      variant="contained"
                      color="primary"
                      type="submit"
                      size="small"
                    >
                      필터 적용
                    </Button>
                  </Box>
                </Grid>
              </Grid>
            </form>
          </LocalizationProvider>
        </Box>
      </Collapse>
    </Paper>
  );
};

export default React.memo(ActivitiesFilter);


============================================================
File: /home/CVEHub/frontend/src/features/activities/components/ActivityItem.jsx
------------------------------------------------------------
import React, { useState } from 'react';
import { TIME_ZONES, DATE_FORMATS, formatDateTime } from '../../../shared/utils/dateUtils';
import { 
  Box, 
  Typography, 
  Paper, 
  Chip, 
  Divider, 
  Collapse,
  Link,
  Card,
  CardContent,
  Avatar,
  Tooltip,
  IconButton,
  useTheme,
  useMediaQuery
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
import CreateIcon from '@mui/icons-material/Create';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';
import AssignmentIcon from '@mui/icons-material/Assignment';
import CommentIcon from '@mui/icons-material/Comment';
import PermIdentityIcon from '@mui/icons-material/PermIdentity';
import { Link as RouterLink } from 'react-router-dom';

// 활동 동작에 따른 아이콘 및 색상 매핑
const actionIcons = {
  create: <CreateIcon fontSize="small" />,
  update: <EditIcon fontSize="small" />,
  delete: <DeleteIcon fontSize="small" />,
  add: <AddIcon fontSize="small" />,
  assign: <AssignmentIcon fontSize="small" />,
  comment: <CommentIcon fontSize="small" />,
  comment_update: <EditIcon fontSize="small" />,
  comment_delete: <DeleteIcon fontSize="small" />
};

const actionColors = {
  create: 'success',
  update: 'primary',
  delete: 'error',
  add: 'success',
  assign: 'info',
  comment: 'secondary',
  comment_update: 'secondary',
  comment_delete: 'error'
};

// 활동 대상 유형에 따른 라우팅 경로 매핑
const getTargetRoute = (targetType, targetId) => {
  switch (targetType) {
    case 'cve':
      return `/cves/${targetId}`;
    case 'poc':
      return `/cves/${targetId.split('-poc-')[0]}/poc/${targetId}`;
    case 'snort_rule':
      return `/cves/${targetId.split('-snort-')[0]}/snort-rule/${targetId}`;
    case 'comment':
      // 댓글 ID에서 부모 리소스 ID를 추출 (가정)
      const parentId = targetId.split('-comment-')[0];
      return `/cves/${parentId}#comment-${targetId}`;
    default:
      return '#';
  }
};

// 활동 동작에 따른 표시 텍스트 매핑
const getActionText = (action) => {
  switch (action) {
    case 'create': return '생성';
    case 'update': return '수정';
    case 'delete': return '삭제';
    case 'add': return '추가';
    case 'assign': return '할당';
    case 'comment': return '댓글 작성';
    case 'comment_update': return '댓글 수정';
    case 'comment_delete': return '댓글 삭제';
    default: return action;
  }
};

// 대상 유형에 따른 표시 텍스트 매핑
const getTargetTypeText = (targetType) => {
  switch (targetType) {
    case 'cve': return 'CVE';
    case 'poc': return 'PoC';
    case 'snort_rule': return 'Snort 규칙';
    case 'comment': return '댓글';
    case 'reference': return '참조문서';
    case 'user': return '사용자';
    case 'system': return '시스템';
    default: return targetType;
  }
};

/**
 * 개선된 개별 활동 항목 컴포넌트
 * - 디자인 개선
 * - 변경 사항 프리뷰 개선
 * - 인터랙션 개선
 * 
 * @param {Object} props 컴포넌트 속성
 * @param {Object} props.activity 활동 데이터
 * @returns {JSX.Element} 렌더링된 컴포넌트
 */
const ActivityItem = ({ activity }) => {
  const [expanded, setExpanded] = useState(false);
  const theme = useTheme();
  // PC 환경에 최적화
  
  const {
    username,
    timestamp,
    action,
    targetType,
    targetId,
    targetTitle,
    changes
  } = activity;

  // UTC 시간을 KST로 변환하여 표시
  const dateTimeDisplay = formatDateTime(timestamp, DATE_FORMATS.DISPLAY.FULL, TIME_ZONES.KST);
  
  // 툴팁용 상세 한글 포맷 - 이미 KST로 변환된 날짜 사용
  const dateTimeDetail = formatDateTime(timestamp, 'yyyy년 MM월 dd일 HH시 mm분 ss초');
  
  // 변경 사항이 있는지 확인
  const hasChanges = changes && changes.length > 0;
  
  // 색상 계산 - 투명도를 포함한 색상으로 변환
  const getBorderColor = () => {
    const color = actionColors[action] || 'grey';
    return theme.palette[color].main;
  };
  
  // 액션 배경색 계산
  const getActionBgColor = () => {
    const color = actionColors[action] || 'grey';
    return theme.palette[color].light;
  };

  // 추가 정보 요약 생성 함수 (PoC, Reference 등)
  const getAdditionalInfo = () => {
    if (!changes || changes.length === 0) return '';
    
    const additionalData = [];
    
    // PoC 정보 찾기
    const pocChange = changes.find(c => c.field === 'poc' && c.action === 'add');
    if (pocChange && pocChange.items && pocChange.items.length > 0) {
      additionalData.push(`PoC ${pocChange.items.length}개`);
    }
    
    // 참조문서 정보 찾기
    const refChange = changes.find(c => c.field === 'reference' && c.action === 'add');
    if (refChange && refChange.items && refChange.items.length > 0) {
      additionalData.push(`참조문서 ${refChange.items.length}개`);
    }
    
    // Snort 규칙 정보 찾기
    const ruleChange = changes.find(c => c.field === 'snort_rule' && c.action === 'add');
    if (ruleChange && ruleChange.items && ruleChange.items.length > 0) {
      additionalData.push(`Snort 규칙 ${ruleChange.items.length}개`);
    }
    
    // 추가 정보가 있는 경우 문자열로 결합하여 반환
    if (additionalData.length > 0) {
      return ` (${additionalData.join(', ')} 포함)`;
    }
    
    // 추가 정보가 없는 경우 빈 문자열 반환
    return '';
  };

  // 요약 텍스트 생성
  const summaryText = () => {
    // 타입이 CVE인지 확인
    const isCveActivity = targetType === 'cve';
    
    // 표시할 ID 결정
    let displayId = isCveActivity ? targetId : (targetTitle || targetId);
    
    // ID가 없는 경우 처리
    if (!displayId) {
      displayId = targetId || '';
    }
    
    return (
      <>
        <Typography 
          component="span" 
          variant="body2" 
          fontWeight="medium"
          color="text.primary"
        >
          {username}
        </Typography>
        님이 {' '}
        <Link
          component={RouterLink}
          to={getTargetRoute(targetType, targetId)}
          sx={{ fontWeight: 'medium' }}
          underline="hover"
        >
          {displayId}
        </Link>
        {/* CVE가 아닌 타입에만 괄호로 타입 표시 */}
        {!isCveActivity ? ` (${getTargetTypeText(targetType)})` : ''}
        {action && ` ${getActionText(action)}`}함{getAdditionalInfo()}
      </>
    );
  };

  return (
    <Card 
      elevation={1} 
      sx={{ 
        mb: 2,
        overflow: 'visible',
        position: 'relative',
        border: `1px solid ${theme.palette.divider}`,
        borderLeft: `3px solid ${getBorderColor()}`,
        transition: 'all 0.2s ease-in-out',
        '&:hover': {
          transform: 'translateY(-2px)',
          boxShadow: theme.shadows[3],
        }
      }}
    >
      <CardContent sx={{ pt: 2, pb: 2, '&:last-child': { pb: 2 } }}>
        {/* 액션 아이콘 */}
        <Box 
          sx={{ 
            position: 'absolute',
            top: -12,
            left: 12,
            width: 24,
            height: 24,
            borderRadius: '50%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            bgcolor: getActionBgColor(),
            color: getBorderColor(),
            border: `1px solid ${getBorderColor()}`,
            zIndex: 1
          }}
        >
          {actionIcons[action] || <CreateIcon fontSize="small" />}
        </Box>

        {/* 헤더 영역 */}
        <Box display="flex" flexDirection="row" 
          justifyContent="space-between" alignItems="center">
          <Box display="flex" alignItems="center" ml={4} mb={0}>
            <Avatar
              sx={{ 
                width: 24, 
                height: 24, 
                fontSize: '0.875rem',
                mr: 1,
                bgcolor: theme.palette.primary.main
              }}
            >
              {username ? username.charAt(0).toUpperCase() : <PermIdentityIcon fontSize="small" />}
            </Avatar>
            
            <Typography variant="body2" color="text.primary">
              {summaryText()}
            </Typography>
          </Box>

          <Box display="flex" alignItems="center" ml={0}>
            <Tooltip title={dateTimeDetail}>
              <Typography variant="caption" color="text.secondary">
                {dateTimeDisplay}
              </Typography>
            </Tooltip>
          </Box>
        </Box>

        {/* 변경 사항이 있을 경우 표시 */}
        {hasChanges && (
          <>
            <Box 
              display="flex" 
              alignItems="center" 
              justifyContent="space-between"
              mt={1.5}
              sx={{ 
                cursor: 'pointer',
                '&:hover': { bgcolor: 'action.hover' },
                p: 1,
                mx: -1,
                borderRadius: 1
              }}
              onClick={() => setExpanded(!expanded)}
            >
              <Typography variant="caption" color="text.secondary">
                {changes.length}개의 변경 사항 {action === 'delete' ? '삭제됨' : ''}
              </Typography>
              <IconButton size="small" onClick={(e) => {
                e.stopPropagation();
                setExpanded(!expanded);
              }}>
                {expanded ? <KeyboardArrowUpIcon /> : <KeyboardArrowDownIcon />}
              </IconButton>
            </Box>

            <Collapse in={expanded} timeout="auto">
              <Divider sx={{ my: 1 }} />
              <Box sx={{ mt: 1 }}>
                {changes.map((change, index) => (
                  <Box key={index} sx={{ mb: 1.5 }}>
                    <Typography variant="caption" fontWeight="bold" gutterBottom>
                      {change.field_name || change.field}:
                    </Typography>
                    
                    {change.action === 'edit' && (
                      <Box sx={{ display: 'flex', flexDirection: 'column', mt: 0.5 }}>
                        <Box sx={{ 
                          backgroundColor: 'rgba(244, 67, 54, 0.1)', 
                          p: 1, 
                          borderRadius: 1,
                          border: '1px solid rgba(244, 67, 54, 0.2)'
                        }}>
                          <Typography variant="caption">
                            - {String(change.before || '').substring(0, 100)}
                            {String(change.before || '').length > 100 ? '...' : ''}
                          </Typography>
                        </Box>
                        <Box sx={{ 
                          backgroundColor: 'rgba(76, 175, 80, 0.1)', 
                          p: 1, 
                          mt: 0.5, 
                          borderRadius: 1,
                          border: '1px solid rgba(76, 175, 80, 0.2)'
                        }}>
                          <Typography variant="caption">
                            + {String(change.after || '').substring(0, 100)}
                            {String(change.after || '').length > 100 ? '...' : ''}
                          </Typography>
                        </Box>
                      </Box>
                    )}
                    
                    {change.action === 'add' && change.items && change.items.length > 0 && (
                      <Box sx={{ mt: 0.5 }}>
                        {change.items.map((item, itemIndex) => (
                          <Box key={itemIndex} sx={{ 
                            backgroundColor: 'rgba(76, 175, 80, 0.1)', 
                            p: 1, 
                            mt: 0.5, 
                            borderRadius: 1,
                            border: '1px solid rgba(76, 175, 80, 0.2)'
                          }}>
                            <Typography variant="caption">
                              + {typeof item === 'object' ? JSON.stringify(item).substring(0, 100) : String(item).substring(0, 100)}
                              {(typeof item === 'object' ? JSON.stringify(item).length : String(item).length) > 100 ? '...' : ''}
                            </Typography>
                          </Box>
                        ))}
                      </Box>
                    )}
                    
                    {change.action === 'delete' && (
                      <Box sx={{ 
                        backgroundColor: 'rgba(244, 67, 54, 0.1)', 
                        p: 1, 
                        mt: 0.5, 
                        borderRadius: 1,
                        border: '1px solid rgba(244, 67, 54, 0.2)'
                      }}>
                        <Typography variant="caption">
                          삭제됨
                        </Typography>
                      </Box>
                    )}
                    
                    {change.summary && (
                      <Typography variant="caption" display="block" sx={{ mt: 0.5, color: 'text.secondary' }}>
                        {change.summary}
                      </Typography>
                    )}
                  </Box>
                ))}
              </Box>
            </Collapse>
          </>
        )}
      </CardContent>
    </Card>
  );
};

export default React.memo(ActivityItem);


============================================================
File: /home/CVEHub/frontend/src/features/activities/components/ActivityList.jsx
------------------------------------------------------------
import React from 'react';
import { 
  Box, 
  Typography, 
  CircularProgress, 
  Pagination, 
  Alert,
  Skeleton,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Stack,
  useMediaQuery,
  useTheme
} from '@mui/material';
import ActivityItem from './ActivityItem';

/**
 * 스켈레톤 로딩 컴포넌트
 * 
 * @returns {JSX.Element} 스켈레톤 UI
 */
const ActivitySkeleton = () => {
  const theme = useTheme();
  // PC 환경에 최적화
  
  return (
    <Box sx={{ 
      mb: 2, 
      p: 2, 
      borderRadius: 1, 
      border: `1px solid ${theme.palette.divider}`,
      borderLeft: `3px solid ${theme.palette.grey[400]}`
    }}>
      <Box display="flex" flexDirection="row" justifyContent="space-between" alignItems="center">
        <Box display="flex" alignItems="center" width="100%">
          <Skeleton variant="circular" width={24} height={24} sx={{ mr: 1 }} />
          <Skeleton variant="text" width="40%" height={24} />
        </Box>
        <Skeleton variant="text" width={100} />
      </Box>
      
      {/* PC 환경에서는 필요 없는 모바일 코드 제거 */}
      
      <Box mt={2}>
        <Skeleton variant="rectangular" width="100%" height={40} sx={{ borderRadius: 1 }} />
      </Box>
    </Box>
  );
};

/**
 * 개선된 활동 목록 컴포넌트
 * - 스켈레톤 로딩 UI 적용
 * - 페이지네이션 및 표시 개수 컨트롤 개선
 * - 성능 최적화
 * 
 * @param {Object} props 컴포넌트 속성
 * @param {Array} props.activities 활동 목록 데이터
 * @param {number} props.total 전체 항목 수
 * @param {boolean} props.isLoading 로딩 상태
 * @param {Object} props.error 에러 객체
 * @param {number} props.page 현재 페이지
 * @param {number} props.limit 페이지당 항목 수
 * @param {Function} props.onPageChange 페이지 변경 핸들러
 * @param {Function} props.onLimitChange 표시 개수 변경 핸들러
 * @returns {JSX.Element} 렌더링된 컴포넌트
 */
const ActivityList = ({ 
  activities = [], 
  total = 0,
  isLoading = false, 
  error = null, 
  page = 1, 
  limit = 10, 
  onPageChange,
  onLimitChange
}) => {
  const theme = useTheme();
  // PC 환경에 최적화
  
  // 총 페이지 수 계산
  const totalPages = Math.max(1, Math.ceil(total / limit));
  
  // 에러 표시
  if (error) {
    // 에러 메시지 추출 (객체인 경우 message 속성 사용, 아니면 문자열로 변환)
    const errorMessage = typeof error === 'object' ? 
      (error.message || JSON.stringify(error)) : 
      String(error);
      
    return (
      <Alert 
        severity="error" 
        sx={{ 
          mb: 2,
          borderRadius: 1,
          '& .MuiAlert-message': { width: '100%' }
        }}
      >
        <Typography variant="body2">
          활동 내역을 불러오는 중 오류가 발생했습니다
        </Typography>
        <Typography variant="caption" component="pre" sx={{ 
          mt: 1, 
          p: 1, 
          bgcolor: 'rgba(0, 0, 0, 0.04)', 
          borderRadius: 1,
          overflow: 'auto',
          maxHeight: '100px',
          whiteSpace: 'pre-wrap',
          wordBreak: 'break-word'
        }}>
          {errorMessage}
        </Typography>
      </Alert>
    );
  }

  // 로딩 중 스켈레톤 UI 표시
  if (isLoading) {
    return (
      <>
        {[...Array(Math.min(limit, 5))].map((_, index) => (
          <ActivitySkeleton key={index} />
        ))}
      </>
    );
  }

  // 데이터가 없을 경우
  if (!activities || activities.length === 0) {
    return (
      <Box 
        display="flex" 
        flexDirection="column"
        justifyContent="center" 
        alignItems="center" 
        height="200px"
        bgcolor="background.paper"
        borderRadius={1}
        p={3}
        border={`1px dashed ${theme.palette.divider}`}
      >
        <Typography variant="body1" color="text.secondary" gutterBottom>
          표시할 활동 내역이 없습니다
        </Typography>
        <Typography variant="caption" color="text.secondary">
          다른 필터 조건을 적용해보세요
        </Typography>
      </Box>
    );
  }

  return (
    <Box>
      {/* 활동 목록 - 항상 고유한 키 보장 (인덱스를 항상 포함) */}
      {activities.map((activity, index) => (
        <ActivityItem 
          key={activity?.id ? `item-${activity.id}-${index}` : `activity-${index}`} 
          activity={activity} 
        />
      ))}

      {/* 페이지네이션 및 표시 개수 컨트롤 */}
      {total > 0 && (
        <Box 
          sx={{ 
            mt: 3, 
            display: 'flex', 
            flexDirection: 'row',
            alignItems: 'center',
            justifyContent: 'space-between',
            gap: 2
          }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center', order: 1 }}>
            <Typography variant="body2" color="text.secondary" mr={2}>
              총 {total}개 항목
            </Typography>
            
            <FormControl size="small" sx={{ minWidth: 100 }}>
              <Select
                value={limit}
                onChange={(e) => onLimitChange(e.target.value)}
                displayEmpty
                variant="outlined"
              >
                <MenuItem value={5}>5개씩</MenuItem>
                <MenuItem value={10}>10개씩</MenuItem>
                <MenuItem value={20}>20개씩</MenuItem>
                <MenuItem value={50}>50개씩</MenuItem>
              </Select>
            </FormControl>
          </Box>

          {totalPages > 1 && (
            <Stack 
              direction="row" 
              spacing={2} 
              justifyContent="center"
              order={2}
              width="auto"
            >
              <Pagination 
                count={totalPages} 
                page={page} 
                onChange={(event, value) => onPageChange(value)}
                color="primary"
                size="medium"
                showFirstButton={true}
                showLastButton={true}
                siblingCount={1}
              />
            </Stack>
          )}
        </Box>
      )}
    </Box>
  );
};

export default React.memo(ActivityList);


============================================================
File: /home/CVEHub/frontend/src/features/activities/hooks/useActivityQuery.js
------------------------------------------------------------
import { useQuery } from "@tanstack/react-query";
import axios from "../../../shared/api/config/axios";

/**
 * 캐시 키 생성 유틸리티 함수
 * 
 * @param {Object} options 필터 옵션
 * @returns {Array} 쿼리 키 배열
 */
const createActivitiesQueryKey = (options) => {
  const {
    username,
    target_type,
    target_id,
    action,
    start_date,
    end_date,
    page,
    limit,
  } = options;

  return [
    "activities",
    username,
    target_type,
    target_id,
    action,
    start_date ? start_date.toISOString() : null,
    end_date ? end_date.toISOString() : null,
    page,
    limit,
  ];
};

/**
 * 개선된 활동 이력 조회를 위한 쿼리 훅
 * - 쿼리 키 관리 최적화
 * - 성능 향상을 위한 옵션 조정
 * - 데이터 가공 통합
 * 
 * @param {Object} options 필터 및 페이지네이션 옵션
 * @param {string} options.username 사용자명 필터
 * @param {string} options.target_type 대상 유형 필터
 * @param {string} options.target_id 대상 ID 필터
 * @param {string} options.action 동작 필터
 * @param {Date} options.start_date 시작 날짜
 * @param {Date} options.end_date 종료 날짜
 * @param {number} options.page 페이지 번호
 * @param {number} options.limit 페이지당 항목 수
 * @returns {Object} 쿼리 결과
 */
export const useActivityQuery = (options = {}) => {
  const {
    username,
    target_type,
    target_id,
    action,
    start_date,
    end_date,
    page = 1,
    limit = 10,
  } = options;

  return useQuery({
    queryKey: createActivitiesQueryKey(options),
    queryFn: async () => {
      try {
        let url = "/activities";
        const params = {
          page,
          limit,
        };

        // 사용자명으로 필터링하는 경우 해당 엔드포인트 사용
        if (username) {
          url = `/activities/users/${username}`;
        } 
        // 대상 유형과 ID로 필터링하는 경우 해당 엔드포인트 사용
        else if (target_type && target_id) {
          url = `/activities/targets/${target_type}/${target_id}`;
        } else {
          // 기본 엔드포인트에서 필터 적용
          if (action) {
            // action이 배열인 경우, 쉼표로 구분된 문자열로 변환
            if (Array.isArray(action) && action.length > 0) {
              params.action = action.join(',');
            } else if (typeof action === 'string') {
              params.action = action;
            }
          }
          if (target_type) {
            // target_type이 배열인 경우, 쉼표로 구분된 문자열로 변환
            if (Array.isArray(target_type) && target_type.length > 0) {
              params.target_type = target_type.join(',');
            } else if (typeof target_type === 'string') {
              params.target_type = target_type;
            }
          }
          if (start_date) params.start_date = start_date.toISOString();
          if (end_date) params.end_date = end_date.toISOString();
        }

        // 디버깅 로그는 개발 모드에서만 출력
        if (process.env.NODE_ENV === 'development') {
          console.log(`활동 이력 API 요청: ${url}`, params);
        }
        
        const { data } = await axios.get(url, { params });
        
        // 날짜 필드는 이미 axios 인터셉터에서 normalizeDateFieldsFromApi를 통해 처리됨
        // 디버깅: 활동 내역 조회 결과 출력
        console.log(`[활동 내역 디버그] 데이터 조회 결과:`, {
          url,
          params,
          총건수: data.total,
          현재페이지: params.page,
          페이지당항목수: params.limit,
          필터: {
            사용자: username || '모든 사용자',
            대상유형: target_type || '전체',
            대상ID: target_id || '전체',
            액션: action || '전체',
            시작일: start_date ? new Date(start_date).toLocaleDateString() : '전체',
            종료일: end_date ? new Date(end_date).toLocaleDateString() : '전체'
          }
        });
        
        // 조회된 첫 5개 항목 샘플 출력 (항목이 많을 경우)
        if (Array.isArray(data.items) && data.items.length > 0) {
          console.log(`[활동 내역 디버그] 조회된 항목 샘플 (최대 5개):`, 
            data.items.slice(0, 5).map(item => ({
              ID: item.id,
              사용자: item.username,
              액션: item.action,
              대상: `${item.target_type}${item.target_id ? ` (${item.target_id})` : ''}`,
              시간: item.timestamp.toLocaleString(),
              상세: item.details
            }))
          );
        }
        
        return data;
      } catch (error) {
        console.error('활동 이력 조회 중 오류 발생:', error);
        throw error;
      }
    },
    keepPreviousData: true,
    staleTime: 30000, // 30초
    refetchOnWindowFocus: false,
    retry: 1, // 요청 실패 시 1번만 재시도
  });
};

/**
 * 특정 대상의 활동 이력 조회를 위한 쿼리 훅
 * 
 * @param {string} target_type 대상 유형
 * @param {string} target_id 대상 ID
 * @param {Object} options 페이지네이션 옵션
 * @returns {Object} 쿼리 결과
 */
export const useTargetActivities = (target_type, target_id, options = {}) => {
  const { page = 1, limit = 10 } = options;

  return useQuery({
    queryKey: ["targetActivities", target_type, target_id, page, limit],
    queryFn: async () => {
      try {
        const params = {
          page,
          limit,
        };

        const { data } = await axios.get(`/activities/targets/${target_type}/${target_id}`, { params });
        
        // 날짜 필드는 이미 axios 인터셉터에서 처리됨
        return data;
      } catch (error) {
        console.error(`${target_type} ${target_id}의 활동 이력 조회 중 오류 발생:`, error);
        throw error;
      }
    },
    keepPreviousData: true,
    enabled: Boolean(target_type && target_id),
    staleTime: 30000,
    refetchOnWindowFocus: false,
    retry: 1,
  });
};

/**
 * 현재 사용자의 활동 이력 조회를 위한 쿼리 훅
 * 
 * @param {string} username 사용자명
 * @param {Object} options 페이지네이션 옵션
 * @returns {Object} 쿼리 결과
 */
export const useUserActivities = (username, options = {}) => {
  const { page = 1, limit = 10 } = options;

  return useQuery({
    queryKey: ["userActivities", username, page, limit],
    queryFn: async () => {
      try {
        const params = {
          page,
          limit,
        };

        const { data } = await axios.get(`/activities/users/${username}`, { params });
        
        // 날짜 필드는 이미 axios 인터셉터에서 처리됨
        return data;
      } catch (error) {
        console.error(`사용자 ${username}의 활동 이력 조회 중 오류 발생:`, error);
        throw error;
      }
    },
    keepPreviousData: true,
    enabled: Boolean(username),
    staleTime: 30000,
    refetchOnWindowFocus: false,
    retry: 1,
  });
};


============================================================
File: /home/CVEHub/frontend/src/features/crawler/types/index.ts
------------------------------------------------------------
/**
 * 크롤러 관련 타입 정의 파일
 */
import { CVEBase } from 'features/cve/types/cve';

/** 
 * 단일 크롤러 정보 
 */
export interface Crawler {
  id: string;
  name: string;
  type: string;
}

/** 
 * 진행 상태 인터페이스 
 */
export interface ProgressState {
  stage: string;
  percent: number;
  message: string;
}

/** 
 * 업데이트된 CVEs 구조 
 */
export interface UpdatedCVEs {
  count: number;
  items: CVEBase[];
}

/**
 * 크롤러 업데이트 소켓 이벤트 데이터
 */
export interface CrawlerUpdateData {
  stage?: string;
  stage_label?: string;
  percent?: number;
  message?: string;
  isRunning?: boolean;
  hasError?: boolean;
  updatedCves?: string[];
}

/** 
 * 크롤러 상태 API에서 가져온 구조
 */
export interface CrawlerStatusResponse {
  isRunning: boolean;
  lastUpdate: unknown;
  currentStatus?: {
    stage: string;
    stage_label?: string;
    percent?: number;
    message?: string;
  };
  results?: Record<string, any>;
}

/** 
 * 단계 정의 
 */
export interface StageInfo {
  key: string;
  label: string;
  description: string;
  icon: React.ReactNode;
  color: string;
  backendValues: string[];
}

/**
 * 웹소켓 연결 상태 변경 이벤트 데이터
 */
export interface ConnectionStateChangeData {
  state: string;
  timestamp?: string;
  message?: string;
}



============================================================
File: /home/CVEHub/frontend/src/features/crawler/services/crawlerService.js
------------------------------------------------------------
import api from 'shared/api/config/axios';

const CRAWLER = {
  RUN: (type) => `/crawler/run/${type}`,
  STATUS: '/crawler/status'
};

export const crawlerService = {
  // 특정 크롤러 실행
  runCrawler: async (type) => {
    try {
      const response = await api.post(CRAWLER.RUN(type));
      return response.data;
    } catch (error) {
      console.error('Error running crawler:', error.response?.data || error);
      throw error;
    }
  },

  // 크롤러 상태 및 마지막 업데이트 시간 조회
  getCrawlerStatus: async () => {
    try {
      const response = await api.get(CRAWLER.STATUS);
      return response.data;
    } catch (error) {
      console.error('Error getting crawler status:', error.response?.data || error);
      throw error;
    }
  },

  // DB 상태 확인 함수 추가
  getDBStatus: async () => {
    try {
      const response = await api.get('/crawler/db-status');
      return response.data;
    } catch (error) {
      console.error('Error checking DB status:', error.response?.data || error);
      throw error;
    }
  }
};

export default crawlerService; 


