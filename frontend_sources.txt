============================================================
File: /home/CVEHub/frontend/webpack.config.js
------------------------------------------------------------
// ë²ˆë“¤ ë¶„ì„ ë° ìµœì í™”
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  // ê¸°ì¡´ ì„¤ì •...
  plugins: [
    // ê°œë°œ ëª¨ë“œì—ì„œë§Œ ì‚¬ìš©
    process.env.ANALYZE && new BundleAnalyzerPlugin()
  ].filter(Boolean),
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendors: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        }
      }
    }
  }
}; 


============================================================
File: /home/CVEHub/frontend/src/App.jsx
------------------------------------------------------------
import React, { useState, useCallback, useEffect, lazy, Suspense } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate, useParams } from 'react-router-dom';
import { Box } from '@mui/material';
import { Alert, Snackbar } from '@mui/material';
import Header from './layout/Header';
import Sidebar from './layout/Sidebar';
import CVEList from './features/cve/CVEList';
import CreateCVE from './features/cve/CreateCVE';
import SignUp from './features/auth/SignUp';
import Login from './features/auth/Login.tsx';
import PrivateRoute from './features/auth/PrivateRoute';
import AuthRoute from 'features/auth/AuthRoute';
import { AuthProvider } from 'features/auth/contexts/AuthContext';
import { SnackbarProvider } from 'notistack';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import theme from './theme';
import { injectErrorHandler, injectQueryClient } from 'features/auth/services/authService';
import { ErrorProvider, useError } from 'shared/contexts/ErrorContext';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import WebSocketQueryBridge from 'core/socket/bridge/WebSocketQueryBridge';
import { getAccessToken } from 'shared/utils/storage/tokenStorage';
import socketService from 'core/socket/services/socketService';  // Socket.IO ì„œë¹„ìŠ¤ ì„í¬íŠ¸
import { HelmetProvider } from 'react-helmet-async';
import { setQueryClient } from 'shared/utils/reactQuery';

// CVEDetail ì»´í¬ë„ŒíŠ¸ë¥¼ lazy ë¡œë”©ìœ¼ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤
const CVEDetail = lazy(() => import('./features/cve/CVEDetail'));
// CacheVisualization ì»´í¬ë„ŒíŠ¸ë¥¼ lazy ë¡œë”©ìœ¼ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤
const CacheVisualization = lazy(() => import('./features/cache/CacheVisualization'));
// ActivitiesPage ì»´í¬ë„ŒíŠ¸ë¥¼ lazy ë¡œë”©ìœ¼ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤
const ActivitiesPage = lazy(() => import('./features/activities/pages/ActivitiesPage'));

// URL íŒŒë¼ë¯¸í„°ë¥¼ ê°€ì ¸ì™€ CVEDetailì— ì „ë‹¬í•˜ëŠ” ë˜í¼ ì»´í¬ë„ŒíŠ¸
const CVEDetailWrapper = () => {
  const params = useParams();
  const cveId = params.cveId;
  const [isOpen, setIsOpen] = useState(true);
  
  // ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê¹… ì¶”ê°€
  useEffect(() => {
    console.log('[CVEDetailWrapper] ë§ˆìš´íŠ¸ë¨, cveId:', cveId);
  }, [cveId]);
  
  const handleClose = useCallback(() => {
    console.log('[CVEDetailWrapper] ë‹«ê¸° ì´ë²¤íŠ¸ ë°œìƒ');
    setIsOpen(false);
    // ë‹«ê¸° í›„ ëª©ë¡ í˜ì´ì§€ë¡œ ì´ë™
    window.history.back();
  }, []);

  if (!cveId) {
    console.error('[CVEDetailWrapper] cveIdê°€ ì—†ìŠµë‹ˆë‹¤!');
    return <div>CVE IDê°€ í•„ìš”í•©ë‹ˆë‹¤</div>;
  }

  console.log('[CVEDetailWrapper] ë Œë”ë§:', { cveId, isOpen });
  
  return (
    <Suspense fallback={<div>ë¡œë”© ì¤‘...</div>}>
      <CVEDetail 
        cveId={cveId}
        open={isOpen}
        onClose={handleClose}
      />
    </Suspense>
  );
};

const MainLayout = React.memo(({ children }) => {
  const [selectedCVE, setSelectedCVE] = useState(null);
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'info'
  });

  const handleSnackbarClose = useCallback(() => {
    setSnackbar(prev => ({ ...prev, open: false }));
  }, []);

  const handleOpenCVEDetail = useCallback((cveId, commentId) => {
    setSelectedCVE(cveId);
  }, []);

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100vh' }}>
      <Header onOpenCVEDetail={handleOpenCVEDetail} />
      <Box sx={{ display: 'flex', flexGrow: 1, height: 'calc(100vh - 64px)', mt: '64px' }}>
        <Sidebar />
        <Box
          component="main"
          sx={{
            flexGrow: 1,
            p: { xs: 2, md: 4 },
            backgroundColor: '#F8F9FA',
            overflow: 'auto',
            position: 'relative',
            zIndex: 0
          }}
        >
          {React.cloneElement(children, { selectedCVE, setSelectedCVE })}
        </Box>
      </Box>
      <Snackbar
        open={snackbar.open}
        autoHideDuration={5000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'top', horizontal: 'right' }}
      >
        <Alert 
          onClose={handleSnackbarClose} 
          severity={snackbar.severity} 
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
});

const AuthLayout = ({ children }) => (
  <Box
    sx={{
      minHeight: '100vh',
      backgroundColor: '#F8F9FA'
    }}
  >
    {children}
  </Box>
);

const ErrorHandlerSetup = ({ children }) => {
  const { handleError } = useError();
  
  useEffect(() => {
    injectErrorHandler(handleError);
  }, [handleError]);
  
  return children;
};

const MainRoutes = ({ setSelectedCVE, selectedCVE }) => {
  return (
    <Routes>
      {/* Authentication Routes */}
      <Route
        path="/signup"
        element={
          <AuthRoute>
            <AuthLayout>
              <SignUp />
            </AuthLayout>
          </AuthRoute>
        }
      />
      <Route
        path="/login"
        element={
          <AuthRoute>
            <AuthLayout>
              <Login />
            </AuthLayout>
          </AuthRoute>
        }
      />

      {/* Protected Routes */}
      <Route
        path="/cves"
        element={
          <PrivateRoute>
            <MainLayout>
              <CVEList />
            </MainLayout>
          </PrivateRoute>
        }
      />
      <Route
        path="/cves/:cveId"
        element={
          <PrivateRoute>
            <MainLayout>
              <CVEDetailWrapper />
            </MainLayout>
          </PrivateRoute>
        }
      />
      <Route
        path="/create-cve"
        element={
          <PrivateRoute>
            <MainLayout>
              <CreateCVE />
            </MainLayout>
          </PrivateRoute>
        }
      />
      <Route
        path="/cache"
        element={
          <PrivateRoute>
            <MainLayout>
              <Suspense fallback={<div>ë¡œë”© ì¤‘...</div>}>
                <CacheVisualization />
              </Suspense>
            </MainLayout>
          </PrivateRoute>
        }
      />
      <Route
        path="/activities"
        element={
          <PrivateRoute>
            <MainLayout>
              <Suspense fallback={<div>ë¡œë”© ì¤‘...</div>}>
                <ActivitiesPage />
              </Suspense>
            </MainLayout>
          </PrivateRoute>
        }
      />

      {/* Default Route */}
      <Route
        path="/"
        element={
          getAccessToken() ? <Navigate to="/cves" replace /> : <Navigate to="/login" replace />
        }
      />

      {/* Catch-all Route */}
      <Route path="*" element={<Navigate to="/" replace />} />
      
      {/* Render CVEDetail as modal when selectedCVE is set */}
      {selectedCVE && (
        <Route
          path="*"
          element={
            <Suspense fallback={<div>ë¡œë”© ì¤‘...</div>}>
              <CVEDetail 
                cveId={selectedCVE}
                open={true}
                onClose={() => setSelectedCVE(null)}
              />
            </Suspense>
          }
        />
      )}
    </Routes>
  );
};

// React Query Client ìƒì„±
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
      staleTime: 1000 * 60 * 5,  // 5ë¶„ ìŠ¤í…Œì¼ íƒ€ì„
    },
  },
});

// ì „ì—­ QueryClient ì¸ìŠ¤í„´ìŠ¤ ì„¤ì •
setQueryClient(queryClient);

// auth.jsì— queryClient ì£¼ì…
injectQueryClient(queryClient);

// Socket.IO ë””ë²„ê¹…ì„ ìœ„í•œ ì „ì—­ ê°ì²´ ë…¸ì¶œ
window._socketDebug = socketService;

const App = () => {
  const [selectedCVE, setSelectedCVE] = useState(null);

  // í˜„ì¬ ê²½ë¡œ í™•ì¸ì„ ìœ„í•œ ì¶”ê°€ ìƒíƒœ
  const [currentPath, setCurrentPath] = useState(window.location.pathname);

  // í˜„ì¬ ê²½ë¡œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
  useEffect(() => {
    // ì´ˆê¸° ê²½ë¡œ ì„¤ì •
    setCurrentPath(window.location.pathname);

    // ê²½ë¡œ ë³€ê²½ ê°ì§€
    const handleRouteChange = () => {
      setCurrentPath(window.location.pathname);
    };

    // popstate ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (ë’¤ë¡œê°€ê¸°/ì•ìœ¼ë¡œê°€ê¸° ê°ì§€)
    window.addEventListener('popstate', handleRouteChange);

    // ì •ë¦¬ í•¨ìˆ˜
    return () => {
      window.removeEventListener('popstate', handleRouteChange);
    };
  }, []);

  // ì•± ì‹œì‘ ì‹œ ì†Œì¼“ ì—°ê²° ì´ˆê¸°í™” (ë¡œê·¸ì¸/íšŒì›ê°€ì… í˜ì´ì§€ ì œì™¸)
  useEffect(() => {
    console.log('[App] Socket connection initialization, current path:', currentPath);
    
    // ë¡œê·¸ì¸/íšŒì›ê°€ì… í˜ì´ì§€ì¸ì§€ í™•ì¸
    const isAuthPage = currentPath === '/login' || currentPath === '/signup';
    
    // ì¸ì¦ í† í° í™•ì¸
    const token = getAccessToken();
    
    if (token && !isAuthPage) {
      console.log('[App] Token exists and not on auth page, connecting socket');
      socketService.connect(token);
    } else if (token && isAuthPage) {
      console.log('[App] On auth page, not connecting socket despite token presence');
      // ì¸ì¦ í˜ì´ì§€ì— ìˆì„ ë•ŒëŠ” ì—°ê²°í•˜ì§€ ì•ŠìŒ
      socketService.disconnect();
    } else {
      console.log('[App] No token, not connecting socket');
    }

    // ì•± ì¢…ë£Œ ì‹œ ì†Œì¼“ ì—°ê²° ì •ë¦¬
    return () => {
      console.log('[App] Cleaning up socket connection');
      socketService.disconnect();
    };
  }, [currentPath]);

  // ì¸ì¦ ìƒíƒœ ë³€ê²½ ê°ì§€ ë° ì†Œì¼“ ì—°ê²° ì—…ë°ì´íŠ¸
  useEffect(() => {
    // AuthContextì—ì„œ ì¸ì¦ ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ êµ¬ë…
    const handleAuthChange = (e) => {
      const isAuthenticated = e.detail.isAuthenticated;
      console.log('[App] Auth state changed:', isAuthenticated);
      
      // ë¡œê·¸ì¸/íšŒì›ê°€ì… í˜ì´ì§€ì¸ì§€ í™•ì¸
      const isAuthPage = currentPath === '/login' || currentPath === '/signup';
      
      if (isAuthenticated && !isAuthPage) {
        // ì¸ì¦ë˜ì—ˆê³  ì¸ì¦ í˜ì´ì§€ê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì—°ê²°
        socketService.handleAuthStateChange(isAuthenticated);
      } else if (!isAuthenticated) {
        // ì¸ì¦ë˜ì§€ ì•Šì€ ê²½ìš° ì—°ê²° í•´ì œ
        socketService.disconnect();
      }
    };

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    window.addEventListener('auth-state-changed', handleAuthChange);

    // ì •ë¦¬ í•¨ìˆ˜
    return () => {
      window.removeEventListener('auth-state-changed', handleAuthChange);
    };
  }, [currentPath]);

  // í˜ì´ì§€ ê°€ì‹œì„± ë³€ê²½ ê°ì§€
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        console.log('[App] Page visibility changed to visible');
        const token = getAccessToken();
        // ë¡œê·¸ì¸/íšŒì›ê°€ì… í˜ì´ì§€ì¸ì§€ í™•ì¸
        const isAuthPage = currentPath === '/login' || currentPath === '/signup';
        
        if (token && !socketService.isSocketConnected() && !isAuthPage) {
          console.log('[App] Reconnecting socket on visibility change (not on auth page)');
          socketService.connect(token);
        }
      }
    };

    // ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸ ìƒíƒœ ê°ì§€
    const handleOnline = () => {
      console.log('[App] Browser went online');
      const token = getAccessToken();
      // ë¡œê·¸ì¸/íšŒì›ê°€ì… í˜ì´ì§€ì¸ì§€ í™•ì¸
      const isAuthPage = currentPath === '/login' || currentPath === '/signup';
      
      if (token && !socketService.isSocketConnected() && !isAuthPage) {
        console.log('[App] Reconnecting socket on online state (not on auth page)');
        socketService.connect(token);
      }
    };

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('online', handleOnline);

    // ì •ë¦¬ í•¨ìˆ˜
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('online', handleOnline);
    };
  }, [currentPath]);

  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider theme={theme}>
        <HelmetProvider>
          <SnackbarProvider
            maxSnack={3}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
            autoHideDuration={3000}
          >
            <AuthProvider>
              <Router>
                <ErrorProvider>
                  <ErrorHandlerSetup>
                    <CssBaseline />
                    <WebSocketQueryBridge />
                    <MainRoutes setSelectedCVE={setSelectedCVE} selectedCVE={selectedCVE} />
                  </ErrorHandlerSetup>
                </ErrorProvider>
              </Router>
            </AuthProvider>
          </SnackbarProvider>
        </HelmetProvider>
      </ThemeProvider>
    {process.env.NODE_ENV === 'development' && <ReactQueryDevtools />}
    </QueryClientProvider>
  );
};

export default App;


============================================================
File: /home/CVEHub/frontend/src/layout/Navbar_bak.jsx
------------------------------------------------------------
import React, { memo } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
  AppBar,
  Box,
  Toolbar,
  Typography,
  Button,
  IconButton,
  Tooltip
} from '@mui/material';
import { Menu as MenuIcon, ExitToApp as LogoutIcon } from '@mui/icons-material';
import api from 'shared/api/config/axios';
import NotificationBell from './NotificationBell';
import { clearAuthStorage } from 'shared/utils/utils/storage/tokenStorage';

const Navbar = memo(() => {
  const navigate = useNavigate();

  const handleLogout = async () => {
    try {
      // ë°±ì—”ë“œ ë¡œê·¸ì•„ì›ƒ API í˜¸ì¶œ
      await api.post('/auth/logout');
      
      // ëª¨ë“  ì¸ì¦ ê´€ë ¨ ë°ì´í„° ì œê±°
      clearAuthStorage();
      
      // ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
      navigate('/login', { 
        state: { message: 'Successfully logged out' }
      });
    } catch (error) {
      console.error('Logout error:', error);
      // ì—ëŸ¬ê°€ ë°œìƒí•˜ë”ë¼ë„ ì¸ì¦ ë°ì´í„°ëŠ” í´ë¦¬ì–´í•˜ê³  ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
      clearAuthStorage();
      navigate('/login');
    }
  };

  return (
    <Box sx={{ flexGrow: 1 }}>
      <AppBar position="static">
        <Toolbar>
          <IconButton
            size="large"
            edge="start"
            color="inherit"
            aria-label="menu"
            sx={{ mr: 2 }}
          >
            <MenuIcon />
          </IconButton>
          
          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            CVE Hub
          </Typography>

          <Button
            color="inherit"
            onClick={() => navigate('/cves')}
          >
            CVE List
          </Button>
          
          <Button
            color="inherit"
            onClick={() => navigate('/create-cve')}
          >
            Create CVE
          </Button>

          <NotificationBell />

          <Tooltip title="Logout">
            <IconButton
              color="inherit"
              onClick={handleLogout}
              edge="end"
            >
              <LogoutIcon />
            </IconButton>
          </Tooltip>
        </Toolbar>
      </AppBar>
    </Box>
  );
});

// displayName ì¶”ê°€
Navbar.displayName = 'Navbar';

export default Navbar;



============================================================
File: /home/CVEHub/frontend/src/layout/Sidebar.jsx
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import {
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Box,
  Typography,
  IconButton,
  ListItemButton,
  alpha
} from '@mui/material';
import DashboardIcon from '@mui/icons-material/Dashboard';
import SecurityIcon from '@mui/icons-material/Security';
import StorageIcon from '@mui/icons-material/Storage';
import HistoryIcon from '@mui/icons-material/History';
import MenuIcon from '@mui/icons-material/Menu';
import ChevronLeftIcon from '@mui/icons-material/ChevronLeft';
import { useTheme } from '@mui/material/styles';
import { Link, useLocation } from 'react-router-dom';

const drawerWidth = 240;

const Sidebar = () => {
  const theme = useTheme();
  const location = useLocation();
  // PC í™˜ê²½ì—ì„œëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì‚¬ì´ë“œë°” ì˜¤í”ˆ
  const [open, setOpen] = useState(true);

  const handleDrawerToggle = () => {
    setOpen(!open);
  };

  return (
    <Drawer
      variant="permanent"
      sx={{
        width: open ? drawerWidth : 64,
        flexShrink: 0,
        '& .MuiDrawer-paper': {
          width: open ? drawerWidth : 64,
          boxSizing: 'border-box',
          background: 'rgba(255, 255, 255, 0.2)',
          backdropFilter: 'blur(10px)',
          borderRight: `1px solid ${alpha(theme.palette.common.white, 0.2)}`,
          overflowX: 'hidden',
          transition: theme.transitions.create('width', {
            easing: theme.transitions.easing.sharp,
            duration: theme.transitions.duration.enteringScreen,
          }),
          boxShadow: `4px 0 20px ${alpha('#000', 0.05)}`,
          mt: '64px', // Header ë†’ì´ë§Œí¼ ì—¬ë°± ì¶”ê°€
          height: 'calc(100% - 64px)', // Header ë†’ì´ ì œì™¸
        },
      }}
    >
      <Box sx={{ 
        p: open ? 1.5 : 1, 
        display: 'flex', 
        alignItems: 'center',
        justifyContent: open ? 'flex-end' : 'center',
        borderBottom: `1px solid ${alpha(theme.palette.common.white, 0.2)}`
      }}>
        {open ? (
          <IconButton 
            onClick={handleDrawerToggle}
            sx={{
              color: theme.palette.mode === 'dark' ? '#fff' : '#333',
              '&:hover': {
                backgroundColor: alpha(theme.palette.common.white, 0.1)
              },
              transition: 'transform 0.2s ease',
              '&:hover': {
                transform: 'scale(1.1)',
                backgroundColor: alpha(theme.palette.common.white, 0.1)
              }
            }}
          >
            <ChevronLeftIcon />
          </IconButton>
        ) : (
          <IconButton 
            onClick={handleDrawerToggle} 
            sx={{ 
              color: theme.palette.mode === 'dark' ? '#fff' : '#333',
              '&:hover': {
                backgroundColor: alpha(theme.palette.common.white, 0.1)
              },
              transition: 'transform 0.2s ease',
              '&:hover': {
                transform: 'scale(1.1)',
                backgroundColor: alpha(theme.palette.common.white, 0.1)
              }
            }}
          >
            <MenuIcon />
          </IconButton>
        )}
      </Box>
      <List sx={{ mt: 2 }}>
        <ListItem disablePadding>
          <ListItemButton 
            component={Link} 
            to="/"
            selected={location.pathname === '/'}
            sx={{
              borderRadius: open ? '0 20px 20px 0' : '50%',
              mx: open ? 1 : 'auto',
              my: 0.5,
              pl: open ? 2 : 1.5,
              justifyContent: open ? 'flex-start' : 'center',
              '&.Mui-selected': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.1) 0%, rgba(255, 0, 110, 0.1) 100%)',
              },
              '&:hover': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.05) 0%, rgba(255, 0, 110, 0.05) 100%)',
              }
            }}
          >
            <ListItemIcon sx={{ 
              minWidth: open ? 40 : 'auto',
              color: location.pathname === '/' ? '#3a86ff' : alpha(theme.palette.text.primary, 0.7)
            }}>
              <DashboardIcon />
            </ListItemIcon>
            {open && (
              <ListItemText 
                primary="Dashboard" 
                primaryTypographyProps={{
                  color: location.pathname === '/' ? '#3a86ff' : theme.palette.text.primary,
                  fontWeight: location.pathname === '/' ? 500 : 400,
                  fontSize: '0.95rem'
                }}
              />
            )}
          </ListItemButton>
        </ListItem>
        <ListItem disablePadding>
          <ListItemButton 
            component={Link} 
            to="/cves"
            selected={location.pathname.startsWith('/cves')}
            sx={{
              borderRadius: open ? '0 20px 20px 0' : '50%',
              mx: open ? 1 : 'auto',
              my: 0.5,
              pl: open ? 2 : 1.5,
              justifyContent: open ? 'flex-start' : 'center',
              '&.Mui-selected': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.1) 0%, rgba(255, 0, 110, 0.1) 100%)',
              },
              '&:hover': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.05) 0%, rgba(255, 0, 110, 0.05) 100%)',
              }
            }}
          >
            <ListItemIcon sx={{ 
              minWidth: open ? 40 : 'auto',
              color: location.pathname.startsWith('/cves') ? '#3a86ff' : alpha(theme.palette.text.primary, 0.7)
            }}>
              <SecurityIcon />
            </ListItemIcon>
            {open && (
              <ListItemText 
                primary="CVEs" 
                primaryTypographyProps={{
                  color: location.pathname.startsWith('/cves') ? '#3a86ff' : theme.palette.text.primary,
                  fontWeight: location.pathname.startsWith('/cves') ? 500 : 400,
                  fontSize: '0.95rem'
                }}
              />
            )}
          </ListItemButton>
        </ListItem>
        <ListItem disablePadding>
          <ListItemButton 
            component={Link} 
            to="/cache"
            selected={location.pathname.startsWith('/cache')}
            sx={{
              borderRadius: open ? '0 20px 20px 0' : '50%',
              mx: open ? 1 : 'auto',
              my: 0.5,
              pl: open ? 2 : 1.5,
              justifyContent: open ? 'flex-start' : 'center',
              '&.Mui-selected': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.1) 0%, rgba(255, 0, 110, 0.1) 100%)',
              },
              '&:hover': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.05) 0%, rgba(255, 0, 110, 0.05) 100%)',
              }
            }}
          >
            <ListItemIcon sx={{ 
              minWidth: open ? 40 : 'auto',
              color: location.pathname.startsWith('/cache') ? '#3a86ff' : alpha(theme.palette.text.primary, 0.7)
            }}>
              <StorageIcon />
            </ListItemIcon>
            {open && (
              <ListItemText 
                primary="Cache" 
                primaryTypographyProps={{
                  color: location.pathname.startsWith('/cache') ? '#3a86ff' : theme.palette.text.primary,
                  fontWeight: location.pathname.startsWith('/cache') ? 500 : 400,
                  fontSize: '0.95rem'
                }}
              />
            )}
          </ListItemButton>
        </ListItem>
        
        {/* ë³€ê²½ ë‚´ì—­ ì¡°íšŒ ë©”ë‰´ ì¶”ê°€ */}
        <ListItem disablePadding>
          <ListItemButton 
            component={Link} 
            to="/activities"
            selected={location.pathname.startsWith('/activities')}
            sx={{
              borderRadius: open ? '0 20px 20px 0' : '50%',
              mx: open ? 1 : 'auto',
              my: 0.5,
              pl: open ? 2 : 1.5,
              justifyContent: open ? 'flex-start' : 'center',
              '&.Mui-selected': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.1) 0%, rgba(255, 0, 110, 0.1) 100%)',
              },
              '&:hover': {
                background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.05) 0%, rgba(255, 0, 110, 0.05) 100%)',
              }
            }}
          >
            <ListItemIcon sx={{ 
              minWidth: open ? 40 : 'auto',
              color: location.pathname.startsWith('/activities') ? '#3a86ff' : alpha(theme.palette.text.primary, 0.7)
            }}>
              <HistoryIcon />
            </ListItemIcon>
            {open && (
              <ListItemText 
                primary="ë³€ê²½ ë‚´ì—­" 
                primaryTypographyProps={{
                  color: location.pathname.startsWith('/activities') ? '#3a86ff' : theme.palette.text.primary,
                  fontWeight: location.pathname.startsWith('/activities') ? 500 : 400,
                  fontSize: '0.95rem'
                }}
              />
            )}
          </ListItemButton>
        </ListItem>
        
      </List>
    </Drawer>
  );
};

export default Sidebar;



============================================================
File: /home/CVEHub/frontend/src/layout/Header.tsx
------------------------------------------------------------
import React, { useEffect, useCallback, useMemo, useState } from 'react';
import {
  AppBar,
  Toolbar,
  IconButton,
  Typography,
  Avatar,
  Menu,
  MenuItem,
  Box,
  Tooltip,
  Divider,
  Button,
  useTheme,
  alpha,
  Container,
} from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { useSnackbar } from 'notistack';
import PersonIcon from '@mui/icons-material/Person';
import SettingsIcon from '@mui/icons-material/Settings';
import LogoutIcon from '@mui/icons-material/Logout';
import WifiIcon from '@mui/icons-material/Wifi';
import WifiOffIcon from '@mui/icons-material/WifiOff';
import NotificationBell from '../features/notification/NotificationBell';
import logger from 'shared/utils/logging';
import { useAuth } from 'features/auth/contexts/AuthContext';
import useSocket from 'core/socket/hooks/useSocket';
import SOCKET_EVENTS from 'core/socket/services/constants';
import { getAnimalEmoji } from 'shared/utils/avatarUtils';

interface HeaderProps {
  onOpenCVEDetail?: (cveId: string, commentId?: string) => void;
}

const Header: React.FC<HeaderProps> = ({ onOpenCVEDetail }) => {
  const theme = useTheme();
  const { user, logout } = useAuth();
  
  // ìƒˆë¡œìš´ useSocket í›… ì‚¬ìš©
  const socket = useSocket();
  const { connected } = socket;

  const { enqueueSnackbar } = useSnackbar();
  const navigate = useNavigate();
  
  // ì†Œì¼“ ìƒíƒœ ë³€í™” í•¸ë“¤ëŸ¬ - ê°„ì†Œí™”ëœ ë²„ì „
  const handleSocketStateChange = useCallback((data: { state: string }) => {
    logger.debug('Header', 'ì†Œì¼“ ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ ìˆ˜ì‹ ', {
      state: data.state,
      connected: connected
    });
    // í•¸ë“¤ëŸ¬ëŠ” ë‹¨ìˆœ ë¡œê¹…ë§Œ ìˆ˜í–‰. ìƒíƒœ ì—…ë°ì´íŠ¸ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì´ë¯¸ ì²˜ë¦¬ë¨
  }, [connected]);

  // ê¸°ì¡´ useSocketEventListener ëŒ€ì‹ ì— useEffectì™€ socket.on ì‚¬ìš©
  useEffect(() => {
    // ì´ë²¤íŠ¸ êµ¬ë… ì„¤ì •
    const unsubscribe = socket.on(SOCKET_EVENTS.CONNECTION_STATE_CHANGE, handleSocketStateChange);
    
    // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ êµ¬ë… í•´ì œ
    return () => {
      unsubscribe();
    };
  }, [handleSocketStateChange]);
  

  // ì¬ì—°ê²° í•¸ë“¤ëŸ¬ - useSocket ì‚¬ìš© ë°©ì‹ìœ¼ë¡œ ì—…ë°ì´íŠ¸
  const handleReconnect = useCallback(() => {
    if (!connected) {
      logger.info('Header', 'ì¬ì—°ê²° ì‹œë„');
      enqueueSnackbar('ì„œë²„ì— ì¬ì—°ê²° ì‹œë„ ì¤‘...', { variant: 'info' });
      
      // í† í° ìƒˆë¡œ ë°›ì•„ì„œ ì¬ì—°ê²° ì‹œë„ 
      const token = localStorage.getItem('token');
      if (token) {
        // ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ ì—°ê²° ì¬ì‹œë„
        window.location.reload();
      } else {
        enqueueSnackbar('ì¸ì¦ ì •ë³´ê°€ ì—†ì–´ ì¬ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.', {
          variant: 'warning'
        });
        navigate('/login');
      }
    }
  }, [connected, navigate, enqueueSnackbar]);

  // ì‚¬ìš©ì ë©”ë‰´ ê´€ë ¨ ìƒíƒœ
  const [anchorElUser, setAnchorElUser] = useState<null | HTMLElement>(null);
  
  const handleOpenUserMenu = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorElUser(event.currentTarget);
  };
  
  const handleCloseUserMenu = () => {
    setAnchorElUser(null);
  };
  
  const handleLogout = async () => {
    handleCloseUserMenu();
    try {
      await logout();
      enqueueSnackbar('ë¡œê·¸ì•„ì›ƒ ë˜ì—ˆìŠµë‹ˆë‹¤.', { 
        variant: 'success',
        anchorOrigin: { vertical: 'bottom', horizontal: 'center' }
      });
      navigate('/login');
    } catch (error) {
      console.error('ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨:', error);
      enqueueSnackbar('ë¡œê·¸ì•„ì›ƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', { 
        variant: 'error',
        anchorOrigin: { vertical: 'bottom', horizontal: 'center' }
      });
    }
  };
  
  const handleProfileClick = () => {
    handleCloseUserMenu();
    navigate('/profile');
  };
  
  const handleSettingsClick = () => {
    handleCloseUserMenu();
    navigate('/settings');
  };
  
  // ì—°ê²° ìƒíƒœ ì•„ì´ì½˜ - connected ì§ì ‘ ì‚¬ìš©
  const connectionIcon = useMemo(() => {
    return connected ? (
      <WifiIcon color="success" fontSize="small" />
    ) : (
      <WifiOffIcon color="error" fontSize="small" />
    );
  }, [connected]);
  
  const userAvatar = useMemo(() => {
    if (!user) return 'ğŸ‘¤';
    return getAnimalEmoji(user.username || user.email || '');
  }, [user]);

  return (
    <AppBar 
      position="fixed" 
      elevation={0}
      sx={{ 
        height: 'auto',
        minHeight: '64px',
        maxHeight: '64px',
        background: 'rgba(255, 255, 255, 0.2)', 
        backdropFilter: 'blur(10px)',
        borderBottom: `1px solid ${alpha(theme.palette.common.white, 0.2)}`,
        boxShadow: `0 4px 30px ${alpha('#000', 0.1)}`,
        zIndex: theme.zIndex.drawer + 1,
      }}
    >
      <Container maxWidth={false} sx={{ px: { xs: 1, sm: 2 } }}>
        <Toolbar 
          disableGutters
          sx={{ 
            minHeight: '64px',
            py: 0,
            display: 'flex',
            justifyContent: 'space-between'
          }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <Box
              sx={{
                display: 'flex',
                alignItems: 'center',
                cursor: 'pointer',
                transition: 'transform 0.2s ease',
                '&:hover': {
                  transform: 'scale(1.05)'
                }
              }}
              onClick={() => navigate('/')}
            >
              <Box 
                component="img"
                src="/cvehub_logo.png"
                alt="CVEHub Logo"
                sx={{
                  height: '60px',
                  mr: 1
                }}
              />
            </Box>
          </Box>

          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            {/* ì›¹ì†Œì¼“ ì—°ê²° ìƒíƒœ */}
            <Tooltip title={connected ? "ì„œë²„ì™€ ì‹¤ì‹œê°„ ì—°ê²° ë¨" : "ì„œë²„ ì—°ê²° ëŠê¹€ (í´ë¦­í•˜ì—¬ ì¬ì—°ê²°)"}>
              <span>
                <IconButton
                  size="small"
                  onClick={handleReconnect}
                  disabled={connected}
                  sx={{ 
                    mr: 1,
                    backgroundColor: connected 
                      ? alpha(theme.palette.success.main, 0.1) 
                      : alpha(theme.palette.error.main, 0.1),
                    backdropFilter: 'blur(5px)',
                    border: `1px solid ${alpha(
                      connected ? theme.palette.success.main : theme.palette.error.main, 
                      0.2
                    )}`,
                    '&:hover': { 
                      backgroundColor: connected 
                        ? alpha(theme.palette.success.main, 0.2) 
                        : alpha(theme.palette.error.main, 0.2)
                    }
                  }}
                  aria-label="ì„œë²„ ì—°ê²° ìƒíƒœ"
                >
                  {connectionIcon}
                </IconButton>
              </span>
            </Tooltip>

            {/* ì•Œë¦¼ ë²¨ */}
            {user && (
              <Box 
                sx={{ 
                  mx: 1,
                  transition: 'all 0.3s ease',
                  '& .MuiIconButton-root': {
                    color: '#ff006e'
                  },
                  '& .MuiSvgIcon-root': {
                    fontSize: '1.8rem'
                  }
                }}
              >
                {onOpenCVEDetail ? (
                  <NotificationBell onOpenCVEDetail={onOpenCVEDetail} />
                ) : (
                  <NotificationBell />
                )}
              </Box>
            )}
            
            {/* ì‚¬ìš©ì ë©”ë‰´ */}
            {user ? (
              <Tooltip title={user.displayName || user.username || ''}>
                <IconButton
                  onClick={handleOpenUserMenu}
                  sx={{ 
                    ml: 1,
                    transition: 'transform 0.2s',
                    '&:hover': { transform: 'scale(1.05)' },
                    backgroundColor: 'rgba(255, 255, 255, 0.2)',
                    backdropFilter: 'blur(5px)',
                    border: `1px solid rgba(255, 255, 255, 0.3)`,
                    padding: '4px'
                  }}
                >
                  <Avatar 
                    sx={{ 
                      background: 'linear-gradient(135deg, #3a86ff 0%, #ff006e 100%)',
                      color: theme.palette.common.white,
                      fontWeight: 'bold',
                      boxShadow: `0 0 0 2px rgba(255, 255, 255, 0.3)`
                    }}
                  >
                    {userAvatar}
                  </Avatar>
                </IconButton>
              </Tooltip>
            ) : (
              <Button 
                variant="outlined" 
                color="inherit" 
                onClick={() => navigate('/login')}
                sx={{ 
                  borderRadius: '20px',
                  px: 2,
                  backgroundColor: 'rgba(255, 255, 255, 0.1)',
                  backdropFilter: 'blur(5px)',
                  borderColor: 'rgba(255, 255, 255, 0.3)',
                  color: theme.palette.mode === 'dark' ? '#fff' : '#333',
                  '&:hover': { 
                    borderColor: 'rgba(255, 255, 255, 0.5)',
                    backgroundColor: 'rgba(255, 255, 255, 0.2)'
                  }
                }}
              >
                ë¡œê·¸ì¸
              </Button>
            )}
          </Box>

          <Menu
            id="menu-appbar"
            anchorEl={anchorElUser}
            open={Boolean(anchorElUser)}
            onClose={handleCloseUserMenu}
            onClick={handleCloseUserMenu}
            PaperProps={{
              elevation: 0,
              sx: {
                mt: 1.5,
                minWidth: 220,
                overflow: 'visible',
                background: 'rgba(255, 255, 255, 0.8)',
                backdropFilter: 'blur(10px)',
                border: `1px solid rgba(255, 255, 255, 0.3)`,
                borderRadius: '12px',
                boxShadow: `0 10px 30px ${alpha('#000', 0.15)}`,
                '&:before': {
                  content: '""',
                  display: 'block',
                  position: 'absolute',
                  top: 0,
                  right: 14,
                  width: 10,
                  height: 10,
                  background: 'rgba(255, 255, 255, 0.8)',
                  backdropFilter: 'blur(10px)',
                  transform: 'translateY(-50%) rotate(45deg)',
                  zIndex: 0,
                  border: `1px solid rgba(255, 255, 255, 0.3)`,
                  borderBottom: 'none',
                  borderRight: 'none'
                },
                '& .MuiMenuItem-root': {
                  px: 2,
                  py: 1.5,
                  gap: 1.5,
                  borderRadius: '8px',
                  mx: 0.5,
                  my: 0.2,
                  transition: 'all 0.2s ease',
                  '&:hover': {
                    background: 'linear-gradient(90deg, rgba(58, 134, 255, 0.08) 0%, rgba(255, 0, 110, 0.08) 100%)',
                    transform: 'translateX(5px)'
                  }
                },
              },
            }}
            transformOrigin={{ horizontal: 'right', vertical: 'top' }}
            anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
          >
            <Box sx={{ px: 2, py: 1.5 }}>
              {user && (
                <>
                  <Typography variant="subtitle1" component="div" sx={{ fontWeight: 'bold' }}>
                    {user.displayName || user.username || 'ì‚¬ìš©ì'}
                  </Typography>
                  <Typography variant="body2" color="text.secondary" sx={{ wordBreak: 'break-all' }}>
                    {user.email || ''}
                  </Typography>
                </>
              )}
            </Box>
            <Divider sx={{ my: 1 }} />
            <MenuItem onClick={handleProfileClick}>
              <PersonIcon fontSize="small" sx={{ color: theme.palette.primary.main }} />
              í”„ë¡œí•„
            </MenuItem>
            <MenuItem onClick={handleSettingsClick}>
              <SettingsIcon fontSize="small" sx={{ color: theme.palette.primary.main }} />
              ì„¤ì •
            </MenuItem>
            <Divider sx={{ my: 1 }} />
            <MenuItem 
              onClick={handleLogout}
              sx={{ color: theme.palette.error.main }}
            >
              <LogoutIcon fontSize="small" />
              ë¡œê·¸ì•„ì›ƒ
            </MenuItem>
          </Menu>
        </Toolbar>
      </Container>
    </AppBar>
  );
};

export default Header;


============================================================
File: /home/CVEHub/frontend/src/core/socket/types/index.ts
------------------------------------------------------------
/**
 * ì›¹ì†Œì¼“ ê´€ë ¨ íƒ€ì… ì •ì˜ íŒŒì¼
 */

import { Socket } from 'socket.io-client';
import SOCKET_EVENTS from '../services/constants';
import { CVEDetail } from 'features/cve/types/cve';
import { User } from 'features/auth/types';

/**
 * ë¡œê·¸ ë ˆë²¨ ìƒìˆ˜
 */
export enum LOG_LEVEL {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4
}

/**
 * ì†Œì¼“ ì„¤ì • ìƒìˆ˜
 */
export const SOCKET_CONFIG = {
  RECONNECTION: true,
  RECONNECTION_ATTEMPTS: 10,
  RECONNECTION_DELAY: 1000,
  RECONNECTION_DELAY_MAX: 5000,
  TIMEOUT: 20000,
  AUTO_CONNECT: true
};

/**
 * ì†Œì¼“ ê²½ë¡œ ìƒìˆ˜
 */
export const SOCKET_IO_PATH = '/socket.io';

/**
 * ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ íƒ€ì… ì •ì˜
 */
export type EventHandler<T = any> = (data: T) => void;

/**
 * ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì €ì¥ì†Œ ì¸í„°í˜ì´ìŠ¤
 */
export interface EventHandlers {
  [key: string]: EventHandler[];
}

/**
 * ëŒ€ê¸° ì¤‘ì¸ êµ¬ë… ì¸í„°í˜ì´ìŠ¤
 */
export interface PendingSubscriptions {
  [key: string]: EventHandler[];
}

/**
 * ì›¹ì†Œì¼“ ì—°ê²° ìƒíƒœ ì¸í„°í˜ì´ìŠ¤
 */
export interface SocketConnectionState {
  connected: boolean;
  lastConnected?: Date;
  reconnectAttempts?: number;
  error?: Error;
}

/**
 * ì†Œì¼“ ì´ë²¤íŠ¸ ì½œë°± í•¨ìˆ˜ íƒ€ì…
 */
export type SocketEventCallback = (data?: any) => void;

/**
 * ì†Œì¼“ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë§µ íƒ€ì…
 */
export interface SocketEventListeners {
  [event: string]: SocketEventCallback[];
}

/**
 * ì¼€ì´ìŠ¤ ë³€í™˜ ì˜µì…˜ íƒ€ì…
 */
export interface SocketCaseConverterOptions {
  excludeFields?: string[];
  isTopLevel?: boolean;
  [key: string]: any;
}

/**
 * ì†Œì¼“ ì˜µì…˜ íƒ€ì…
 */
export interface SocketOptions {
  path: string;
  transports: string[];
  reconnection: boolean;
  reconnectionAttempts: number;
  reconnectionDelay: number;
  reconnectionDelayMax: number;
  timeout: number;
  autoConnect: boolean;
  auth: {
    token: string;
    userId?: string; // ì¸ì¦ëœ ì‚¬ìš©ì ID
    username?: string; // ì‚¬ìš©ìëª…
    session_id?: string;
    client_id?: string;
  };
  extraHeaders: {
    Authorization: string;
  };
}

/**
 * ì†Œì¼“ ì„œë¹„ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface ISocketIOService {
  socket: Socket | null;
  isConnected: boolean;
  listeners: SocketEventListeners;
  options: SocketOptions | null;
  connect(url?: string): void;
  disconnect(): void;
  on(event: string, callback: SocketEventCallback): () => void;
  addEventListener(event: string, callback: SocketEventCallback): () => void;
  off(event: string, callback: SocketEventCallback): void;
  emit(event: string, data?: any): void;
  isSocketConnected(): boolean;
  getSocket(): Socket | null;
  getConnectionStatus(): boolean;
  handleAuthStateChange(isAuthenticated: boolean): void;
  subscribeCVE(cveId: string): void;
  unsubscribeCVE(cveId: string): void;
  convertKeysRecursive(data: any, toCamelCase: boolean, options?: SocketCaseConverterOptions): any;
}

/**
 * ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ ë¡œê¹… ë°ì´í„° íƒ€ì…
 */
export interface WebSocketLogData {
  eventName: string;
  direction: string;
  status: string;
  error?: {
    message: string;
    [key: string]: any;
  };
  message: string;
  context: string;
  dataSummary?: string;
  origin?: string;
  timestamp?: string | number;
}

/**
 * ê¸°ë³¸ ì†Œì¼“ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface SocketMessage {
  type: string;
  timestamp: string | Date;
  sender?: string;
}

/**
 * ì—°ê²° ì‘ë‹µ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface ConnectionAckMessage {
  user_id: string;
  username: string;
  connected_at: string;
  session_id?: string;
  client_id?: string;
}

/**
 * ì„¸ì…˜ ì •ë³´ ì‘ë‹µ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface SessionInfoAckMessage {
  session_id: string;
  subscribed_cves: string[];
  last_activity?: string;
}

/**
 * CVE ì—…ë°ì´íŠ¸ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEUpdateMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.CVE_UPDATED;
  cveId: string;
  field_key?: string;
  updateId?: string | number;
  updatedBy?: string;
  data?: Partial<CVEDetail>;
}

/**
 * êµ¬ë… ìƒíƒœ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface SubscriptionStatusMessage {
  cve_id: string;
  subscribed: boolean;
  subscriber_count: number;
  username: string;
  success: boolean;
  error?: string;
}

/**
 * ëŒ“ê¸€ ì¶”ê°€ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface CommentAddedMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.COMMENT_ADDED;
  cveId: string;
  commentId: string;
  comment: Comment;
  parentId?: string;
}

/**
 * ëŒ“ê¸€ ì—…ë°ì´íŠ¸ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface CommentUpdatedMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.COMMENT_UPDATED;
  cveId: string;
  commentId: string;
  updatedContent: string;
  updatedAt: string | Date;
}

/**
 * ëŒ“ê¸€ ì‚­ì œ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface CommentDeletedMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.COMMENT_DELETED;
  cveId: string;
  commentId: string;
}

/**
 * ì‚¬ìš©ì êµ¬ë… ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface UserSubscribedMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.USER_ONLINE;
  cveId: string;
  user: Pick<User, 'id' | 'username' | 'displayName' | 'profileImage'>;
}

/**
 * ì‚¬ìš©ì êµ¬ë… ì·¨ì†Œ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface UserUnsubscribedMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.USER_OFFLINE;
  cveId: string;
  userId: string;
}

/**
 * ì•Œë¦¼ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface NotificationMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.NOTIFICATION;
  notification_id: string;
  message: string;
  related_id?: string;
  related_type?: string;
  user_id: string;
  read: boolean;
  created_at: string;
}

/**
 * ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì¸í„°í˜ì´ìŠ¤
 */
export interface SystemMessage extends SocketMessage {
  type: typeof SOCKET_EVENTS.SYSTEM_MESSAGE;
  message: string;
  level: 'info' | 'warning' | 'error' | 'success';
  action?: string;
  data?: any;
}

/**
 * ì†Œì¼“ ì»¨í…ìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤
 */
export interface SocketContextType {
  socket: Socket | null;
  connected: boolean;
  isReady: boolean;
  error: Error | null;
  connecting: boolean;
  reconnectAttempts: number;
  connect: () => void;
  disconnect: () => void;
  subscribeEvent: <T = any>(event: string, handler: (data: T) => void) => () => void;
  unsubscribeEvent: (event: string, handler: (data: any) => void) => void;
  isSubscribed: (event: string, handler: (data: any) => void) => boolean;
  emit: <T = any>(event: string, data?: T, callback?: (response: any) => void) => boolean;
  subscribeCVEDetail: (cveId: string) => boolean;
  unsubscribeCVEDetail: (cveId: string) => boolean;
  getActiveSubscriptions: () => Record<string, number>;
  subscribeWhenReady: (event: string, handler: EventHandler) => boolean;
  handleAuthStateChange: () => void;
  publishInternalEvent: (event: string, data: any) => void; // ë‚´ë¶€ ì´ë²¤íŠ¸ ë°œí–‰ í•¨ìˆ˜
}


============================================================
File: /home/CVEHub/frontend/src/core/socket/services/socketEventBus.ts
------------------------------------------------------------
// services/socketEventBus.ts
import { Subject, Observable } from 'rxjs';
import { filter, map } from 'rxjs/operators';
import logger from 'shared/utils/logging';

/**
 * ì†Œì¼“ ì´ë²¤íŠ¸ íƒ€ì… ì •ì˜
 */
export interface SocketEvent<T = any> {
  type: string;
  payload: T;
}

/**
 * ì†Œì¼“ ì„œë¹„ìŠ¤ ì»´í¬ë„ŒíŠ¸ ê°„ í†µì‹ ì„ ìœ„í•œ ì´ë²¤íŠ¸ ë²„ìŠ¤
 * 
 * ì´ í´ë˜ìŠ¤ëŠ” SocketService, SocketEventManager, SocketMetrics ê°„ì˜
 * ìˆœí™˜ ì°¸ì¡°ë¥¼ ì œê±°í•˜ê¸° ìœ„í•œ ì´ë²¤íŠ¸ ì¤‘ì¬ì ì—­í• ì„ í•©ë‹ˆë‹¤.
 */
class SocketEventBus {
  private eventSubject = new Subject<SocketEvent>();
  
  /**
   * ì´ë²¤íŠ¸ ë°œí–‰
   * @param type ì´ë²¤íŠ¸ íƒ€ì…
   * @param payload ì´ë²¤íŠ¸ ë°ì´í„°
   */
  publish<T = any>(type: string, payload: T): void {
    logger.debug('SocketEventBus', `ì´ë²¤íŠ¸ ë°œí–‰: ${type}`, { type, hasPayload: !!payload });
    this.eventSubject.next({ type, payload });
  }
  
  /**
   * íŠ¹ì • íƒ€ì…ì˜ ì´ë²¤íŠ¸ êµ¬ë…
   * @param type êµ¬ë…í•  ì´ë²¤íŠ¸ íƒ€ì…
   * @returns ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
   */
  on<T = any>(type: string): Observable<T> {
    return this.eventSubject.pipe(
      filter(event => event.type === type),
      map(event => event.payload as T)
    );
  }
  
  /**
   * ëª¨ë“  ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ê°€ì ¸ì˜¤ê¸°
   * @returns ëª¨ë“  ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
   */
  allEvents(): Observable<SocketEvent> {
    return this.eventSubject.asObservable();
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
const socketEventBus = new SocketEventBus();

export default socketEventBus;



============================================================
File: /home/CVEHub/frontend/src/core/socket/services/socketMetrics.ts
------------------------------------------------------------
// services/socketMetrics.ts
import { Socket } from 'socket.io-client';
import logger from 'shared/utils/logging';
import socketEventBus from './socketEventBus';

/**
 * Socket ì—°ê²° í’ˆì§ˆ ë° ë©”íŠ¸ë¦­ ê´€ë¦¬ í´ë˜ìŠ¤
 * ì†Œì¼“ ì—°ê²°ì˜ ì„±ëŠ¥ ë° í’ˆì§ˆì„ ëª¨ë‹ˆí„°ë§í•˜ê³  í†µê³„ë¥¼ ìˆ˜ì§‘í•©ë‹ˆë‹¤.
 */
export class SocketMetrics {
  // ì—°ê²° ì§„ë‹¨ ë° ëª¨ë‹ˆí„°ë§
  private pingInterval: NodeJS.Timeout | null = null;
  private pingTimeoutId: NodeJS.Timeout | null = null;
  private lastPingTime: number | null = null;
  
  // ì—°ê²° ë©”íŠ¸ë¦­
  private connectionMetrics = {
    connectAttempts: 0,
    lastConnectTime: null as number | null,
    disconnectCount: 0,
    errorCount: 0,
    lastErrorTime: null as number | null,
    averageLatency: null as number | null,
    pingHistory: [] as number[]
  };
  
  // ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ ë° ìƒíƒœ
  private socket: Socket | null = null;
  private isConnected: boolean = false;
  private connectionState: string = '';
  
  constructor() {
    // ì´ë²¤íŠ¸ ë²„ìŠ¤ êµ¬ë… ì„¤ì •
    this._setupEventBusSubscriptions();
    
    logger.debug('SocketMetrics', 'ë©”íŠ¸ë¦­ ê´€ë¦¬ì ì´ˆê¸°í™” ì™„ë£Œ');
  }
  
  /**
   * ì´ë²¤íŠ¸ ë²„ìŠ¤ êµ¬ë… ì„¤ì •
   */
  private _setupEventBusSubscriptions(): void {
    // ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì´ë²¤íŠ¸ êµ¬ë…
    socketEventBus.on('socketService:socketCreated').subscribe((socket: Socket) => {
      this.socket = socket;
      logger.debug('SocketMetrics', 'ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ ì—…ë°ì´íŠ¸ë¨');
    });
    
    // ì†Œì¼“ ì—°ê²° ì´ë²¤íŠ¸ êµ¬ë…
    socketEventBus.on('socketService:connected').subscribe(() => {
      this.isConnected = true;
      this.startConnectionQualityMonitoring();
      logger.debug('SocketMetrics', 'ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸ë¨: ì—°ê²°ë¨');
    });
    
    // ì†Œì¼“ ì—°ê²° í•´ì œ ì´ë²¤íŠ¸ êµ¬ë…
    socketEventBus.on('socketService:disconnected').subscribe(() => {
      this.isConnected = false;
      this.socket = null;
      this.stopConnectionQualityMonitoring();
      logger.debug('SocketMetrics', 'ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸ë¨: ì—°ê²° í•´ì œë¨');
    });
    
    // ì†Œì¼“ ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ êµ¬ë…
    socketEventBus.on('socketService:connectionState').subscribe((state: string) => {
      this.connectionState = state;
      logger.debug('SocketMetrics', `ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸ë¨: ${state}`);
    });
    
    // ì†Œì¼“ ëª¨ë‹ˆí„°ë§ ìš”ì²­ ì´ë²¤íŠ¸ êµ¬ë…
    socketEventBus.on('socketService:monitorSocket').subscribe((socket: Socket) => {
      this.socket = socket;
      this.startConnectionQualityMonitoring();
    });
  }
  
  /**
   * ì—°ê²° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§ ì‹œì‘
   */
  startConnectionQualityMonitoring(): void {
    // ì†Œì¼“ ìƒíƒœ ë° ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
    if (!this.socket || !this.isConnected || this.pingInterval) {
      return;
    }
    
    // 60ì´ˆ ê°„ê²©ìœ¼ë¡œ í•‘ ì¸¡ì •
    this.pingInterval = setInterval(() => {
      this._measurePing();
    }, 60000);
    
    logger.debug('SocketMetrics', 'ì—°ê²° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§ ì‹œì‘');
  }
  
  /**
   * ì—°ê²° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€
   */
  stopConnectionQualityMonitoring(): void {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
    
    if (this.pingTimeoutId) {
      clearTimeout(this.pingTimeoutId);
      this.pingTimeoutId = null;
    }
    
    logger.debug('SocketMetrics', 'ì—°ê²° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€');
  }
  
  /**
   * í•‘ ì¸¡ì •
   */
  private _measurePing(): void {
    if (!this.socket || !this.isConnected) {
      return;
    }
    
    const startTime = Date.now();
    
    // í•‘-í ìš”ì²­
    this.socket.emit('ping', () => {
      const pingTime = Date.now() - startTime;
      
      // í•‘ ê¸°ë¡ ì—…ë°ì´íŠ¸
      this.connectionMetrics.pingHistory.push(pingTime);
      
      // ìµœëŒ€ 10ê°œë§Œ ìœ ì§€
      if (this.connectionMetrics.pingHistory.length > 10) {
        this.connectionMetrics.pingHistory.shift();
      }
      
      // í‰ê·  ì§€ì—° ì‹œê°„ ê³„ì‚°
      const sum = this.connectionMetrics.pingHistory.reduce((a, b) => a + b, 0);
      this.connectionMetrics.averageLatency = 
        this.connectionMetrics.pingHistory.length > 0 
          ? sum / this.connectionMetrics.pingHistory.length 
          : null;
      
      logger.debug('SocketMetrics', 'í•‘ ì¸¡ì • ì™„ë£Œ', {
        pingTime,
        averageLatency: this.connectionMetrics.averageLatency
      });
    });
    
    // í•‘ íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬
    this.pingTimeoutId = setTimeout(() => {
      logger.warn('SocketMetrics', 'í•‘ íƒ€ì„ì•„ì›ƒ ë°œìƒ');
      this.pingTimeoutId = null;
    }, 5000);
  }
  
  /**
   * ì—°ê²° ë©”íŠ¸ë¦­ ê°€ì ¸ì˜¤ê¸°
   */
  getConnectionMetrics(): any {
    return {
      ...this.connectionMetrics,
      currentState: this.connectionState,
      isConnected: this.isConnected,
      socketId: this.socket?.id || null,
      timestamp: new Date().toISOString()
    };
  }
  
  /**
   * ì—°ê²° ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
   * @param metrics ì—…ë°ì´íŠ¸í•  ë©”íŠ¸ë¦­ ê°ì²´
   */
  updateConnectionMetrics(metrics: Partial<typeof this.connectionMetrics>): void {
    // ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
    Object.assign(this.connectionMetrics, metrics);
    
    logger.debug('SocketMetrics', 'ì—°ê²° ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸ë¨', metrics);
  }
  
  /**
   * ë©”íŠ¸ë¦­ ë¦¬ì…‹
   */
  resetMetrics(): void {
    this.connectionMetrics = {
      connectAttempts: 0,
      lastConnectTime: null,
      disconnectCount: 0,
      errorCount: 0,
      lastErrorTime: null,
      averageLatency: null,
      pingHistory: []
    };
    
    logger.debug('SocketMetrics', 'ì—°ê²° ë©”íŠ¸ë¦­ ì´ˆê¸°í™”');
  }
}



============================================================
File: /home/CVEHub/frontend/src/core/socket/services/socketEventManager.ts
------------------------------------------------------------
// services/socketEventManager.ts
import { Observable, Subject, fromEvent, EMPTY, throwError } from 'rxjs';
import { shareReplay, map, filter, catchError, retry, takeUntil, finalize } from 'rxjs/operators';
import _ from 'lodash';
import { LRUCache } from 'lru-cache';
import { Socket } from 'socket.io-client';
import logger from 'shared/utils/logging';
import { camelToSnake, snakeToCamel } from 'shared/utils/caseConverter';
import { SUBSCRIPTION_EVENTS } from './constants';
import socketEventBus from './socketEventBus';

import {
  SocketEventCallback,
  SocketEventListeners,
  SocketCaseConverterOptions
} from '../types';

// ë³€í™˜ì—ì„œ ì œì™¸í•  í•„ë“œ ëª©ë¡
const EXCLUDED_FIELDS: string[] = ['id', 'uuid', 'created_at', 'updated_at', 'deleted_at'];

// êµ¬ë… ê´€ë ¨ ì´ë²¤íŠ¸ì—ì„œ ë³€í™˜ì´ í•„ìš”í•œ í•„ë“œ ë§¤í•‘
const SUBSCRIPTION_FIELD_MAPPINGS: Record<string, string> = {
  'cve_id': 'cveId',
  'cveId': 'cve_id',
  'user_id': 'userId',
  'userId': 'user_id',
  'display_name': 'displayName',
  'displayName': 'display_name',
  'profile_image': 'profileImage',
  'profileImage': 'profile_image'
};

// ë³€í™˜ ë°”ì´íŒ¨ìŠ¤ê°€ í•„ìš”í•œ ì´ë²¤íŠ¸ ëª©ë¡
const BYPASS_CONVERSION_EVENTS: string[] = [
  SUBSCRIPTION_EVENTS.SUBSCRIBE_CVE,
  SUBSCRIPTION_EVENTS.UNSUBSCRIBE_CVE,
  SUBSCRIPTION_EVENTS.SUBSCRIPTION_STATUS,
  SUBSCRIPTION_EVENTS.CVE_SUBSCRIBERS_UPDATED
];

/**
 * Socket ì´ë²¤íŠ¸ ê´€ë¦¬ í´ë˜ìŠ¤
 * ì´ë²¤íŠ¸ ë“±ë¡, ë°œìƒ, ì²˜ë¦¬ ë° ì¼€ì´ìŠ¤ ë³€í™˜ì„ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 */
export class SocketEventManager {
  // ì´ë²¤íŠ¸ ë° ë¦¬ìŠ¤ë„ˆ ê´€ë¦¬
  private listeners: SocketEventListeners = {};
  private eventObservables: Map<string, Observable<any>> = new Map();
  private destroySubjects: Map<string, Subject<void>> = new Map();
  
  // ìºì‹± ë° ì„±ëŠ¥ ìµœì í™”
  private eventCache: LRUCache<string, { data: any, timestamp: number }>;
  private caseConversionCache: LRUCache<string, any>;
  
  // ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤
  private socket: Socket | null = null;
  
  constructor() {
    // ìºì‹œ ì´ˆê¸°í™”
    this.eventCache = new LRUCache<string, { data: any, timestamp: number }>({
      max: 100,          // ìµœëŒ€ í•­ëª© ìˆ˜
      ttl: 5 * 60000     // 5ë¶„ TTL
    });
    
    this.caseConversionCache = new LRUCache<string, any>({
      max: 500,          // ìµœëŒ€ í•­ëª© ìˆ˜
      ttl: 10 * 60000    // 10ë¶„ TTL
    });
    
    // ì´ë²¤íŠ¸ ë²„ìŠ¤ êµ¬ë… ì„¤ì •
    this._setupEventBusSubscriptions();
    
    logger.debug('SocketEventManager', 'ì´ë²¤íŠ¸ ê´€ë¦¬ì ì´ˆê¸°í™” ì™„ë£Œ');
  }
  
  /**
   * ì´ë²¤íŠ¸ ë²„ìŠ¤ êµ¬ë… ì„¤ì •
   */
  private _setupEventBusSubscriptions(): void {
    // ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì´ë²¤íŠ¸ êµ¬ë…
    socketEventBus.on('socketService:socketCreated').subscribe((socket: Socket) => {
      this.socket = socket;
      logger.debug('SocketEventManager', 'ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ ì—…ë°ì´íŠ¸ë¨');
    });
    
    // ì†Œì¼“ ì—°ê²° í•´ì œ ì´ë²¤íŠ¸ êµ¬ë…
    socketEventBus.on('socketService:disconnected').subscribe(() => {
      this.socket = null;
      logger.debug('SocketEventManager', 'ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ ì œê±°ë¨');
    });
  }
  
  /**
   * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
   * @param event ì´ë²¤íŠ¸ ì´ë¦„
   * @param callback ì½œë°± í•¨ìˆ˜
   * @returns ë¦¬ìŠ¤ë„ˆ ì œê±° í•¨ìˆ˜
   */
  on(event: string, callback: SocketEventCallback): () => void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    
    // ì´ë¯¸ ë“±ë¡ëœ ì½œë°±ì¸ì§€ í™•ì¸
    const isCallbackRegistered = this.listeners[event].some(cb => cb === callback);
    
    if (!isCallbackRegistered) {
      this.listeners[event].push(callback);
      
      // ì†Œì¼“ì´ ìˆëŠ” ê²½ìš° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
      if (this.socket) {
        this.socket.on(event, (data: any) => {
          // ë°ì´í„° ì¼€ì´ìŠ¤ ë³€í™˜ ì²˜ë¦¬
          const convertedData = this._convertDataCasing(data, {
            direction: 'incoming',
            sourceName: `ì†Œì¼“ì´ë²¤íŠ¸[${event}]`,
            eventName: event
          });
          
          callback(convertedData);
        });
      }
      
      logger.debug('SocketEventManager', `ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡: ${event}`);
    }
    
    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° í•¨ìˆ˜ ë°˜í™˜
    return () => {
      this.off(event, callback);
    };
  }
  
  /**
   * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
   * @param event ì´ë²¤íŠ¸ ì´ë¦„
   * @param callback ì½œë°± í•¨ìˆ˜
   */
  off(event: string, callback: SocketEventCallback): void {
    if (this.listeners[event]) {
      // ì½œë°± ì œê±°
      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
      
      // ì†Œì¼“ì´ ìˆëŠ” ê²½ìš° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
      if (this.socket) {
        this.socket.off(event);
      }
      
      logger.debug('SocketEventManager', `ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°: ${event}`);
    }
  }
  
  /**
   * ëª¨ë“  ë¦¬ìŠ¤ë„ˆ ì œê±°
   */
  clearAllListeners(): void {
    // ëª¨ë“  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
    for (const event in this.listeners) {
      if (Object.prototype.hasOwnProperty.call(this.listeners, event)) {
        this.listeners[event] = [];
      }
    }
    
    // ì†Œì¼“ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
    if (this.socket) {
      this.socket.removeAllListeners();
    }
    
    // ì´ë²¤íŠ¸ ê´€ì°°ì ì •ë¦¬
    this.eventObservables.clear();
    
    // êµ¬ë… í•´ì œ íŠ¸ë¦¬ê±° ë° ì •ë¦¬
    this.destroySubjects.forEach((subject) => {
      subject.next();
      subject.complete();
    });
    
    // êµ¬ë… í•´ì œ ì£¼ì²´ ì •ë¦¬
    this.destroySubjects.clear();
    
    logger.debug('SocketEventManager', 'ëª¨ë“  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬ ì™„ë£Œ');
  }
  
  /**
   * ì´ë²¤íŠ¸ ë°œìƒ
   * @param event ì´ë²¤íŠ¸ ì´ë¦„
   * @param data ì´ë²¤íŠ¸ ë°ì´í„°
   * @param callback ì½œë°± í•¨ìˆ˜ (ì˜µì…˜)
   */
  emit(event: string, data?: any, callback?: Function): void {
    // ìŠ¤ë¡œí‹€ë§ ë˜ëŠ” ë””ë°”ìš´ì‹± ì ìš© ì—¬ë¶€ ê²°ì •
    if (this._shouldThrottleEvent(event)) {
      // ìŠ¤ë¡œí‹€ë§ ì ìš©í•˜ì—¬ ì´ë²¤íŠ¸ ë°œìƒ
      _.throttle(() => this._emitImmediate(event, data, callback), 300)();
    } else if (this._shouldDebounceEvent(event)) {
      // ë””ë°”ìš´ì‹± ì ìš©í•˜ì—¬ ì´ë²¤íŠ¸ ë°œìƒ
      _.debounce(() => this._emitImmediate(event, data, callback), 300)();
    } else {
      // ì¦‰ì‹œ ì´ë²¤íŠ¸ ë°œìƒ
      this._emitImmediate(event, data, callback);
    }
  }
  
  /**
   * ì¦‰ì‹œ ì´ë²¤íŠ¸ ë°œìƒ (ë‚´ë¶€ ë©”ì„œë“œ)
   */
  private _emitImmediate(event: string, data: any, callback?: Function): void {
    if (!this.socket) {
      // ì†Œì¼“ì´ ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš° ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ ìš”ì²­
      socketEventBus.publish('socketManager:getSocket', null);
      logger.warn('SocketEventManager', 'ì†Œì¼“ ì—°ê²°ì´ ì—†ëŠ” ìƒíƒœì—ì„œ ì´ë²¤íŠ¸ ë°œìƒ ì‹œë„', {
        event,
        hasData: !!data
      });
      return;
    }
    
    try {
      // ë°ì´í„° ì¼€ì´ìŠ¤ ë³€í™˜ ì²˜ë¦¬ (ì„œë²„ í˜•ì‹ìœ¼ë¡œ ë³€í™˜)
      const convertedData = this._convertDataCasing(data, {
        direction: 'outgoing',
        sourceName: `emit[${event}]`,
        eventName: event
      });
      
      // ì´ë²¤íŠ¸ ë°œìƒ
      if (callback) {
        this.socket.emit(event, convertedData, callback);
      } else {
        this.socket.emit(event, convertedData);
      }
      
      logger.debug('SocketEventManager', `ì´ë²¤íŠ¸ ë°œìƒ: ${event}`, {
        event,
        hasData: !!data
      });
    } catch (error) {
      logger.error('SocketEventManager', `ì´ë²¤íŠ¸ ë°œìƒ ì¤‘ ì˜¤ë¥˜: ${event}`, error);
    }
  }
  
  /**
   * ì´ë²¤íŠ¸ ìŠ¤ë¡œí‹€ë§ ì ìš© ì—¬ë¶€ ê²°ì •
   */
  private _shouldThrottleEvent(event: string): boolean {
    // ìŠ¤ë¡œí‹€ë§ì´ í•„ìš”í•œ ì´ë²¤íŠ¸ ëª©ë¡
    const throttleEvents = [
      'typing',
      'cursor_position',
      'scroll_position'
    ];
    
    return throttleEvents.includes(event);
  }
  
  /**
   * ì´ë²¤íŠ¸ ë””ë°”ìš´ì‹± ì ìš© ì—¬ë¶€ ê²°ì •
   */
  private _shouldDebounceEvent(event: string): boolean {
    // ë””ë°”ìš´ì‹±ì´ í•„ìš”í•œ ì´ë²¤íŠ¸ ëª©ë¡
    const debounceEvents = [
      'search_query',
      'filter_change'
    ];
    
    return debounceEvents.includes(event);
  }
  
  /**
   * Observable í˜•íƒœë¡œ ì´ë²¤íŠ¸ êµ¬ë…
   * @param event ì´ë²¤íŠ¸ ì´ë¦„
   * @returns ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
   */
  fromEvent<T = any>(eventName: string, componentId: string = 'global'): Observable<T> {
    const cacheKey = `${eventName}_${componentId}`;
    const socket = this.socket as Socket;
    
    // ìºì‹œëœ Observableì´ ìˆìœ¼ë©´ ë°˜í™˜
    if (this.eventObservables.has(cacheKey)) {
      return this.eventObservables.get(cacheKey) as Observable<T>;
    }
    
    // ì†Œì¼“ ìƒíƒœ ë° ì¸ìŠ¤í„´ìŠ¤ í™•ì¸
    if (!socket) {
      logger.warn('SocketEventManager', `ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ê°€ ì—†ì–´ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ìƒì„± ë¶ˆê°€: ${eventName}`);
      return EMPTY;
    }
    
    // ì»´í¬ë„ŒíŠ¸ë³„ ì •ë¦¬ë¥¼ ìœ„í•œ Subject ìƒì„± ë˜ëŠ” ê°€ì ¸ì˜¤ê¸°
    if (!this.destroySubjects.has(componentId)) {
      this.destroySubjects.set(componentId, new Subject<void>());
    }
    const destroySubject = this.destroySubjects.get(componentId)!;
    
    // fromEventë¥¼ ì‚¬ìš©í•˜ì—¬ ì†Œì¼“ ì´ë²¤íŠ¸ë¥¼ Observableë¡œ ë³€í™˜
    const observable = fromEvent<T>(socket, eventName).pipe(
      // ë°ì´í„° ì¼€ì´ìŠ¤ ë³€í™˜ ë° ë¡œê¹…
      map(data => {
        logger.debug('SocketEventManager', `ì´ë²¤íŠ¸ ìˆ˜ì‹ : ${eventName}`, data);
        // ë°ì´í„° ì¼€ì´ìŠ¤ ë³€í™˜ ì²˜ë¦¬ (snake_case -> camelCase)
        return this._convertDataCasing(data, {
          direction: 'incoming',
          eventName: eventName
        }) as T;
      }),
      // ì˜¤ë¥˜ ì²˜ë¦¬
      catchError(error => {
        logger.error('SocketEventManager', `ì´ë²¤íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ${eventName}`, error);
        return throwError(() => error);
      }),
      // ìë™ ì¬ì‹œë„ (ìµœëŒ€ 3íšŒ)
      retry({ count: 3, delay: 1000 }),
      // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ êµ¬ë… í•´ì œ
      takeUntil(destroySubject),
      // ì—¬ëŸ¬ êµ¬ë…ìê°€ ë™ì¼í•œ Observableì„ ê³µìœ í•˜ë„ë¡ ì„¤ì •
      shareReplay(1),
      // ì™„ë£Œ ì‹œ ì •ë¦¬
      finalize(() => {
        logger.debug('SocketEventManager', `ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì¢…ë£Œ: ${eventName}`);
        this.eventObservables.delete(cacheKey);
      })
    );
    
    // ìºì‹œì— ì €ì¥
    this.eventObservables.set(cacheKey, observable);
    
    return observable;
  }
  
  /**
   * ì»´í¬ë„ŒíŠ¸ ì •ë¦¬
   */
  cleanup(componentId: string): void {
    if (this.destroySubjects.has(componentId)) {
      const subject = this.destroySubjects.get(componentId)!;
      subject.next();
      subject.complete();
      this.destroySubjects.delete(componentId);
      
      // í•´ë‹¹ ì»´í¬ë„ŒíŠ¸ì™€ ê´€ë ¨ëœ ëª¨ë“  ìºì‹œëœ Observable ì œê±°
      const keysToRemove: string[] = [];
      this.eventObservables.forEach((_, key) => {
        if (key.endsWith(`_${componentId}`)) {
          keysToRemove.push(key);
        }
      });
      
      keysToRemove.forEach(key => {
        this.eventObservables.delete(key);
      });
      
      logger.debug('SocketEventManager', `ì»´í¬ë„ŒíŠ¸ ì •ë¦¬ ì™„ë£Œ: ${componentId}`);
    }
  }
  
  /**
   * ë°ì´í„° ì¼€ì´ìŠ¤ ë³€í™˜ ì²˜ë¦¬
   * @param data ë³€í™˜í•  ë°ì´í„°
   * @param options ë³€í™˜ ì˜µì…˜
   * @returns ë³€í™˜ëœ ë°ì´í„°
   */
  private _convertDataCasing(data: any, options?: SocketCaseConverterOptions): any {
    // ìºì‹œ í‚¤ ìƒì„±
    const cacheKey = this._createCacheKey(data, options);
    if (cacheKey && this.caseConversionCache.has(cacheKey)) {
      return this.caseConversionCache.get(cacheKey);
    }
    
    // ê¸°ë³¸ ì˜µì…˜ ì„¤ì •
    const direction = options?.direction || 'incoming';
    const converter = direction === 'outgoing' ? camelToSnake : snakeToCamel;
    const sourceName = options?.sourceName || 'ì•Œ ìˆ˜ ì—†ëŠ” ì†ŒìŠ¤';
    const eventName = options?.eventName || '';
    
    // êµ¬ë… ê´€ë ¨ ì´ë²¤íŠ¸ëŠ” íŠ¹ë³„ ì²˜ë¦¬
    const isSubscriptionEvent = BYPASS_CONVERSION_EVENTS.includes(eventName);
    
    try {
      // null ì²˜ë¦¬
      if (data === null) {
        return null;
      }
      
      // ë°ì´í„° íƒ€ì…ì— ë”°ë¼ ë³€í™˜ ì²˜ë¦¬
      if (typeof data === 'object') {
        // ë°°ì—´ ì²˜ë¦¬
        if (Array.isArray(data)) {
          const result = data.map(item => this._convertDataCasing(item, options));
          
          // ìºì‹œì— ì €ì¥
          if (cacheKey) {
            this.caseConversionCache.set(cacheKey, result);
          }
          
          return result;
        }
        
        // ê°ì²´ ì²˜ë¦¬
        const result: Record<string, any> = {};
        
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            // êµ¬ë… ê´€ë ¨ ì´ë²¤íŠ¸ì—ì„œ íŠ¹ì • í•„ë“œ ì²˜ë¦¬
            if (isSubscriptionEvent && (key in SUBSCRIPTION_FIELD_MAPPINGS)) {
              const mappedKey = SUBSCRIPTION_FIELD_MAPPINGS[key];
              
              // ë°©í–¥ì— ë”°ë¼ ë§¤í•‘ëœ í‚¤ ë˜ëŠ” ì›ë˜ í‚¤ ì‚¬ìš©
              result[direction === 'outgoing' ? mappedKey : key] = data[key];
              continue;
            }
            
            // ë³€í™˜ì—ì„œ ì œì™¸í•  í•„ë“œ í™•ì¸
            if (EXCLUDED_FIELDS.includes(key)) {
              result[key] = data[key];
              continue;
            }
            
            // ì¼ë°˜ í•„ë“œëŠ” ì¼€ì´ìŠ¤ ë³€í™˜ ì ìš©
            const convertedKey = converter(key);
            
            // ì¤‘ì²©ëœ ê°ì²´ë‚˜ ë°°ì—´ì€ ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬
            if (typeof data[key] === 'object' && data[key] !== null) {
              result[convertedKey] = this._convertDataCasing(data[key], options);
            } else {
              result[convertedKey] = data[key];
            }
          }
        }
        
        // êµ¬ë… ê´€ë ¨ ì´ë²¤íŠ¸ì—ì„œ íŠ¹ì • í•„ë“œ ì¶”ê°€ ì²˜ë¦¬ (ì–‘ë°©í–¥ í˜¸í™˜ì„± ë³´ì¥)
        if (isSubscriptionEvent && typeof data === 'object' && !Array.isArray(data)) {
          // cve_idì™€ cveId ë™ì‹œ ì§€ì›
          if ('cve_id' in data && !('cveId' in data)) {
            result.cveId = data.cve_id;
          } else if ('cveId' in data && !('cve_id' in data)) {
            result.cve_id = data.cveId;
          }
        }
        
        // ìºì‹œì— ì €ì¥
        if (cacheKey) {
          this.caseConversionCache.set(cacheKey, result);
        }
        
        return result;
      }
      
      // ê°ì²´ë‚˜ ë°°ì—´ì´ ì•„ë‹Œ ê²½ìš° ì›ë˜ ê°’ ë°˜í™˜
      return data;
    } catch (error) {
      logger.error('SocketEventManager', 'ë°ì´í„° ì¼€ì´ìŠ¤ ë³€í™˜ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
      return data;
    }
  }
  
  /**
   * ìºì‹œ í‚¤ ìƒì„±
   */
  private _createCacheKey(data: any, options?: SocketCaseConverterOptions): string | null {
    if (!data || typeof data !== 'object') {
      return null;
    }
    
    try {
      const direction = options?.direction || 'incoming';
      const sourceName = options?.sourceName || '';
      
      // ê°„ë‹¨í•œ ê°ì²´ëŠ” ì§ì ‘ í‚¤ ìƒì„±
      if (!Array.isArray(data) && Object.keys(data).length <= 5) {
        return `${direction}:${sourceName}:${JSON.stringify(data)}`;
      }
      
      // ë³µì¡í•œ ê°ì²´ëŠ” ì¼ë¶€ í”„ë¡œí¼í‹°ì™€ ê¸¸ì´ ê¸°ë°˜ í‚¤ ìƒì„±
      const keys = Object.keys(data);
      const keyPreview = keys.slice(0, 3).join(',');
      
      if (Array.isArray(data)) {
        return `${direction}:${sourceName}:array:${data.length}:${keyPreview}`;
      }
      
      return `${direction}:${sourceName}:object:${keys.length}:${keyPreview}`;
    } catch (error) {
      return null;
    }
  }
  
  /**
   * ì¬ê·€ì  í‚¤ ë³€í™˜ (ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ìš©)
   */
  convertKeysRecursive(data: any, toCamelCase: boolean, options?: SocketCaseConverterOptions): any {
    const direction = toCamelCase ? 'incoming' : 'outgoing';
    return this._convertDataCasing(data, { ...options, direction });
  }
}



============================================================
File: /home/CVEHub/frontend/src/core/socket/services/socketService.ts
------------------------------------------------------------
// services/socketService.ts
import { io, Socket, ManagerOptions, SocketOptions as IOSocketOptions } from 'socket.io-client';
import { Observable, Subject, fromEvent, EMPTY, throwError, BehaviorSubject } from 'rxjs';
import { shareReplay, map, filter, catchError, retry, takeUntil, finalize } from 'rxjs/operators';
import _ from 'lodash';
import { getAccessToken } from 'shared/utils/storage/tokenStorage';
import logger from 'shared/utils/logging';
import socketStoreAdapter from './socketStoreAdapter';
import { socketActions } from '../state/socketStore';
import { getQueryClient } from 'shared/utils/reactQuery';
import socketEventBus from './socketEventBus';
import {
  SOCKET_EVENTS,
  SOCKET_STATE,
  CONNECTION_EVENTS
} from './constants';
import {
  SocketEventCallback,
  SocketOptions
} from '../types';
import { SocketEventManager } from 'core/socket/services/socketEventManager';
import { SocketMetrics } from 'core/socket/services/socketMetrics';

// Socket.io ê²½ë¡œ ìƒìˆ˜ (constants.tsì— ì—†ì–´ì„œ ì—¬ê¸°ì— ì§ì ‘ ì •ì˜)
const SOCKET_IO_PATH = '/socket.io';

// ì¶”ê°€ ì†Œì¼“ ìƒíƒœ ì •ì˜
const EXTENDED_SOCKET_STATE = {
  ...SOCKET_STATE,
  DISCONNECTING: 'disconnecting'
};

/**
 * Socket.IO ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
 * 
 * WebSocket í†µì‹ ì„ ê´€ë¦¬í•˜ê³  RxJSë¥¼ í†µí•œ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 * ì´ í´ë˜ìŠ¤ëŠ” ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„ë˜ì–´ ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì²´ì—ì„œ ì¼ê´€ëœ ì†Œì¼“ ì—°ê²°ì„ ìœ ì§€í•©ë‹ˆë‹¤.
 */
class SocketService {
  // === ì†Œì¼“ ë° ì—°ê²° ìƒíƒœ ê´€ë¦¬ ===
  socket: Socket | null = null;
  isConnected: boolean = false;
  private _connectionState: string = SOCKET_STATE.DISCONNECTED;
  private connectionStateSubject: BehaviorSubject<string>;
  private autoReconnectEnabled: boolean = true;
  private maxReconnectAttempts: number = 10;
  private currentReconnectAttempts: number = 0;
  
  // === ì´ë²¤íŠ¸ ë° ë¦¬ìŠ¤ë„ˆ ê´€ë¦¬ ===
  private options: SocketOptions | null = null;
  
  // ì´ë²¤íŠ¸ ê´€ë¦¬ì ë° ë©”íŠ¸ë¦­ ë§¤ë‹ˆì €
  private eventManager: SocketEventManager;
  private metricsManager: SocketMetrics;
  
  constructor() {
    // ìƒíƒœ ì´ˆê¸°í™”
    this.connectionStateSubject = new BehaviorSubject<string>(SOCKET_STATE.DISCONNECTED);
    
    // ì´ë²¤íŠ¸ ë²„ìŠ¤ì— ì´ˆê¸° ì†Œì¼“ ì„œë¹„ìŠ¤ ìƒì„± ì´ë²¤íŠ¸ ë°œí–‰
    socketEventBus.publish('socketService:created', null);
    
    // ì´ë²¤íŠ¸ ê´€ë¦¬ì ë° ë©”íŠ¸ë¦­ ë§¤ë‹ˆì € ì´ˆê¸°í™” (ì§ì ‘ ì°¸ì¡° ì—†ì´ ìƒì„±)
    this.eventManager = new SocketEventManager();
    this.metricsManager = new SocketMetrics();
    
    // ë¸Œë¼ìš°ì € í™˜ê²½ì—ì„œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
    if (typeof window !== 'undefined') {
      this._setupBrowserListeners();
    }
    
    // ì´ë²¤íŠ¸ êµ¬ë… ì„¤ì •
    this._setupEventBusSubscriptions();
  }
  
  /**
   * ì´ë²¤íŠ¸ ë²„ìŠ¤ êµ¬ë… ì„¤ì •
   */
  private _setupEventBusSubscriptions(): void {
    // ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ ìš”ì²­ ì´ë²¤íŠ¸ êµ¬ë…
    socketEventBus.on('socketManager:getSocket').subscribe(() => {
      socketEventBus.publish('socketService:socket', this.socket);
    });
    
    // ì—°ê²° ìƒíƒœ ìš”ì²­ ì´ë²¤íŠ¸ êµ¬ë…
    socketEventBus.on('socketManager:getConnectionState').subscribe(() => {
      socketEventBus.publish('socketService:connectionState', this._connectionState);
    });
    
    // ì—°ê²° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§ ì‹œì‘ ìš”ì²­ ì´ë²¤íŠ¸ êµ¬ë…
    socketEventBus.on('metrics:startMonitoring').subscribe(() => {
      // ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì´ë²¤íŠ¸ í˜ì´ë¡œë“œë¡œ ì „ë‹¬
      if (this.socket) {
        socketEventBus.publish('socketService:monitorSocket', this.socket);
      }
    });
  }
  
  /**
   * ì†Œì¼“ ì—°ê²° ìƒì„±
   * @param token JWT í† í° (ì˜µì…˜)
   * @returns ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤
   */
  connect(token?: string): Socket {
    try {
      // ì´ë¯¸ ì—°ê²°ëœ ê²½ìš° ê¸°ì¡´ ì†Œì¼“ ë°˜í™˜
      if (this.socket && this.isConnected) {
        return this.socket;
      }
      
      // í† í°ì´ ì—†ëŠ” ê²½ìš° í† í° ê°€ì ¸ì˜¤ê¸° ì‹œë„
      const accessToken = token || getAccessToken();
      
      // í† í°ì´ ì—†ìœ¼ë©´ ì‹¤íŒ¨ ì²˜ë¦¬
      if (!accessToken) {
        this._updateConnectionState(SOCKET_STATE.AUTH_ERROR);
        throw new Error('ì¸ì¦ í† í°ì´ ì—†ì–´ WebSocket ì—°ê²°ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      // ì†Œì¼“ ì˜µì…˜ ìƒì„±
      this.options = this._createOptions(accessToken);
      
      if (!this.options) {
        this._updateConnectionState(SOCKET_STATE.CONFIG_ERROR);
        throw new Error('WebSocket ì„¤ì •ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      // ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
      this._updateConnectionState(SOCKET_STATE.CONNECTING);
      
      // Socket.IO ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
      const socketURL = this._getSocketIOURL();
      this.socket = io(socketURL, this.options);
      socketStoreAdapter.registerSocket(this.socket);
      
      // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì •
      this._setupEventHandlers();
      
      // ê°œë°œ í™˜ê²½ì—ì„œ ë””ë²„ê·¸ ë¡œê¹… ì„¤ì •
      if (process.env.NODE_ENV === 'development') {
        this._setupDebugLogging();
      }
      
      // ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ì´ë²¤íŠ¸ ë°œí–‰
      if (this.socket) {
        socketEventBus.publish('socketService:socketCreated', this.socket);
      }
      
      // ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œì‘ ì´ë²¤íŠ¸ ë°œí–‰
      socketEventBus.publish('socketService:connected', null);
      
      return this.socket;
    } catch (error) {
      this._updateConnectionState(SOCKET_STATE.ERROR);
      logger.error('SocketService', 'Socket.IO ì—°ê²° ì‹¤íŒ¨', error);
      throw error;
    }
  }
  
  /**
   * ì†Œì¼“ ì—°ê²° í•´ì œ
   */
  disconnect(): void {
    if (!this.socket) {
      return;
    }
    
    try {
      logger.info('SocketService', 'ì†Œì¼“ ì—°ê²° í•´ì œ ì‹œì‘');
      
      // ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
      this._updateConnectionState(EXTENDED_SOCKET_STATE.DISCONNECTING);
      
      // ì—°ê²° í•´ì œ ì´ë²¤íŠ¸ ë°œí–‰
      socketEventBus.publish('socketService:disconnecting', null);
      
      // ìë™ ì¬ì—°ê²° ë¹„í™œì„±í™”
      this.autoReconnectEnabled = false;
      
      // ì†Œì¼“ ì—°ê²° í•´ì œ
      this.socket.disconnect();
      this.socket = null;
      this.isConnected = false;
      
      // ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
      this._updateConnectionState(SOCKET_STATE.DISCONNECTED);
      
      // ì—°ê²° í•´ì œ ì™„ë£Œ ì´ë²¤íŠ¸ ë°œí–‰
      socketEventBus.publish('socketService:disconnected', null);
      
      logger.info('SocketService', 'ì†Œì¼“ ì—°ê²° í•´ì œ ì™„ë£Œ');
    } catch (error) {
      logger.error('SocketService', 'ì†Œì¼“ ì—°ê²° í•´ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
    }
  }

  /**
   * ê°œë°œ í™˜ê²½ì—ì„œ ë””ë²„ê·¸ ë¡œê¹… ì„¤ì •
   */
  private _setupDebugLogging(): void {
    if (!this.socket || process.env.NODE_ENV !== 'development') {
      return;
    }
    
    // ë””ë²„ê·¸ ëª¨ë“œ í™œì„±í™”
    this.socket.onAny((event, ...args) => {
      console.log(`[ì†Œì¼“ ìˆ˜ì‹ ] ${event}:`, ...args);
    });
    
    // ì›ë³¸ emit í•¨ìˆ˜ ì €ì¥
    const originalEmit = this.socket.emit;
    
    // emit í•¨ìˆ˜ ì˜¤ë²„ë¼ì´ë“œ (ë¡œê¹… ì¶”ê°€)
    this.socket.emit = function (event: string, ...args: any[]): any {
      console.log(`[ì†Œì¼“ ì „ì†¡] ${event}:`, ...args);
      return originalEmit.apply(this, [event, ...args]);
    };
  }
  
  /**
   * ì†Œì¼“ ì—°ê²° ìƒíƒœ í™•ì¸
   */
  isSocketConnected(): boolean {
    return this.socket !== null && this.isConnected;
  }
  
  /**
   * ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ ê°€ì ¸ì˜¤ê¸°
   */
  getSocket(): Socket | null {
    return this.socket;
  }
  
  /**
   * ì—°ê²° ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
   */
  getConnectionStatus(): boolean {
    return this.isConnected;
  }
  
  /**
   * ì¸ì¦ ìƒíƒœ ë³€ê²½ ì²˜ë¦¬
   * @param isAuthenticated ì¸ì¦ ì—¬ë¶€
   */
  handleAuthStateChange(isAuthenticated: boolean): void {
    if (isAuthenticated) {
      // ì¸ì¦ë˜ì—ˆìœ¼ë©´ ì—°ê²° ì‹œë„
      if (!this.isConnected && !this.socket) {
        this.connect();
      }
    } else {
      // ì¸ì¦ì´ í•´ì œë˜ì—ˆìœ¼ë©´ ì—°ê²° í•´ì œ
      if (this.isConnected || this.socket) {
        this.disconnect();
      }
    }
  }
  
  /**
   * Socket.IO URL ê°€ì ¸ì˜¤ê¸°
   */
  private _getSocketIOURL(): string {
    const host = window.location.hostname;
    const port = process.env.NODE_ENV === 'development' ? '8000' : window.location.port;
    return `${window.location.protocol}//${host}${port ? `:${port}` : ''}`;
  }
  
  /**
   * ì†Œì¼“ ì˜µì…˜ ìƒì„±
   */
  private _createOptions(token: string): SocketOptions | null {
    if (!token) {
      return null;
    }
    
    return {
      autoConnect: true,
      reconnection: true,
      reconnectionAttempts: this.maxReconnectAttempts,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      timeout: 20000,
      transports: ['websocket'],
      auth: {
        token
      },
      path: SOCKET_IO_PATH,
      extraHeaders: {
        Authorization: `Bearer ${token}`
      }
    };
  }
  
  /**
   * ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸
   */
  private _updateConnectionState(state: string): void {
    if (this._connectionState === state) {
      return;
    }
    
    this._connectionState = state;
    this.connectionStateSubject.next(state);
    
    // ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
    socketStoreAdapter.dispatch(() => {
      socketActions.updateConnectionState({
        connectionState: state,
        isConnected: state === SOCKET_STATE.CONNECTED
      });
    });
    
    // ë¡œê·¸ ì¶œë ¥
    logger.debug('SocketService', 'ì†Œì¼“ ì—°ê²° ìƒíƒœ ë³€ê²½', { state });
  }
  
  /**
   * ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì •
   */
  private _setupEventHandlers(): void {
    if (!this.socket) {
      return;
    }
    
    // ì£¼ìš” ì—°ê²° ì´ë²¤íŠ¸ ì„¤ì •
    this.socket.on(CONNECTION_EVENTS.CONNECT, this._handleConnect.bind(this));
    this.socket.on(CONNECTION_EVENTS.DISCONNECT, this._handleDisconnect.bind(this));
    this.socket.on(CONNECTION_EVENTS.CONNECT_ERROR, this._handleConnectError.bind(this));
    
    // ì¬ì—°ê²° ê´€ë ¨ ì´ë²¤íŠ¸
    this.socket.on(CONNECTION_EVENTS.RECONNECT_ATTEMPT, (attempt: number) => {
      this._updateConnectionState(SOCKET_STATE.RECONNECTING);
      logger.debug('SocketService', 'ì†Œì¼“ ì¬ì—°ê²° ì‹œë„', { attempt });
    });
    
    this.socket.on(CONNECTION_EVENTS.RECONNECT, () => {
      this._updateConnectionState(SOCKET_STATE.CONNECTED);
      logger.debug('SocketService', 'ì†Œì¼“ ì¬ì—°ê²° ì„±ê³µ');
    });
  }
  
  /**
   * ì—°ê²° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
   */
  private _handleConnect(): void {
    this.isConnected = true;
    this.currentReconnectAttempts = 0;
    this._updateConnectionState(SOCKET_STATE.CONNECTED);
    
    // ì—°ê²° ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
    this.metricsManager.updateConnectionMetrics({
      lastConnectTime: Date.now(),
      connectAttempts: this.metricsManager.getConnectionMetrics().connectAttempts + 1
    });
    
    logger.info('SocketService', 'ì†Œì¼“ ì—°ê²° ì„±ê³µ');
    
    // React Query í´ë¼ì´ì–¸íŠ¸ ë¬´íš¨í™” (ì„ íƒì )
    if (getQueryClient()) {
      getQueryClient().invalidateQueries({ queryKey: ['socket-connected'] });
    }
    
    // ì„œë²„ë¡œ ì‚¬ìš©ì ì •ë³´ ì „ì†¡ (í•„ìš”ì‹œ)
    if (this.socket) {
      this.emit('client_connected', { timestamp: new Date().toISOString() });
    }
  }
  
  /**
   * ì—°ê²° í•´ì œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
   */
  private _handleDisconnect(reason: string): void {
    this.isConnected = false;
    this._updateConnectionState(SOCKET_STATE.DISCONNECTED);
    
    // ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
    this.metricsManager.updateConnectionMetrics({
      disconnectCount: this.metricsManager.getConnectionMetrics().disconnectCount + 1
    });
    
    logger.info('SocketService', 'ì†Œì¼“ ì—°ê²° í•´ì œ', { reason });
    
    // ìë™ ì¬ì—°ê²° ì²˜ë¦¬
    if (this.autoReconnectEnabled && this.currentReconnectAttempts < this.maxReconnectAttempts) {
      this._attemptReconnect();
    }
  }
  
  /**
   * ì—°ê²° ì˜¤ë¥˜ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
   */
  private _handleConnectError(error: any): void {
    this.isConnected = false;
    this._updateConnectionState(SOCKET_STATE.ERROR);
    
    // ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
    this.metricsManager.updateConnectionMetrics({
      errorCount: this.metricsManager.getConnectionMetrics().errorCount + 1,
      lastErrorTime: Date.now()
    });
    
    // ì—ëŸ¬ ë¡œê¹…
    logger.error('SocketService', 'ì†Œì¼“ ì—°ê²° ì˜¤ë¥˜', error);
    
    // ìë™ ì¬ì—°ê²° ë¡œì§
    if (this.autoReconnectEnabled && this.currentReconnectAttempts < this.maxReconnectAttempts) {
      this._attemptReconnect();
    } else if (this.currentReconnectAttempts >= this.maxReconnectAttempts) {
      logger.error('SocketService', 'ìµœëŒ€ ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜ ì´ˆê³¼');
      this._updateConnectionState(SOCKET_STATE.FAILED);
    }
  }
  
  /**
   * ë¸Œë¼ìš°ì € ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
   */
  private _setupBrowserListeners(): void {
    // í˜ì´ì§€ ê°€ì‹œì„± ë³€ê²½ ì´ë²¤íŠ¸
    document.addEventListener('visibilitychange', this._handleVisibilityChange.bind(this));
    
    // ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸ ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸
    window.addEventListener('online', this._handleOnlineStatus.bind(this));
    window.addEventListener('offline', this._handleOfflineStatus.bind(this));
    
    // í˜ì´ì§€ ì–¸ë¡œë“œ ì´ë²¤íŠ¸
    window.addEventListener('beforeunload', () => {
      if (this.socket && this.isConnected) {
        this.socket.emit('client_disconnecting');
      }
    });
  }
  
  /**
   * í˜ì´ì§€ ê°€ì‹œì„± ë³€ê²½ ì²˜ë¦¬
   */
  private _handleVisibilityChange(): void {
    if (document.visibilityState === 'visible') {
      // í˜ì´ì§€ê°€ ë‹¤ì‹œ í‘œì‹œë˜ë©´ ì—°ê²° ìƒíƒœ í™•ì¸ ë° í•„ìš”ì‹œ ì¬ì—°ê²°
      if (this.socket && !this.isConnected && this.autoReconnectEnabled) {
        logger.debug('SocketService', 'í˜ì´ì§€ í¬ì»¤ìŠ¤ë¡œ ì¬ì—°ê²° ì‹œë„');
        this._attemptReconnect();
      }
      
      // í™œì„± ìƒíƒœ ì•Œë¦¼ (ì˜µì…˜)
      if (this.socket && this.isConnected) {
        this.socket.emit('client_active');
      }
    } else if (document.visibilityState === 'hidden') {
      // í˜ì´ì§€ê°€ ìˆ¨ê²¨ì§€ë©´ í™œë™ ì¤‘ì§€ ìƒíƒœ ì•Œë¦¼ (ì˜µì…˜)
      if (this.socket && this.isConnected) {
        this.socket.emit('client_inactive');
      }
    }
  }
  
  /**
   * ì˜¨ë¼ì¸ ìƒíƒœ ì²˜ë¦¬
   */
  private _handleOnlineStatus(): void {
    logger.debug('SocketService', 'ë„¤íŠ¸ì›Œí¬ ì˜¨ë¼ì¸ ìƒíƒœ ê°ì§€');
    
    if (!this.isConnected && this.autoReconnectEnabled) {
      this._attemptReconnect();
    }
  }
  
  /**
   * ì˜¤í”„ë¼ì¸ ìƒíƒœ ì²˜ë¦¬
   */
  private _handleOfflineStatus(): void {
    logger.debug('SocketService', 'ë„¤íŠ¸ì›Œí¬ ì˜¤í”„ë¼ì¸ ìƒíƒœ ê°ì§€');
    this._updateConnectionState(SOCKET_STATE.OFFLINE);
  }
  
  /**
   * ì¬ì—°ê²° ì‹œë„
   */
  private _attemptReconnect(): void {
    // ì´ë¯¸ ì—°ê²° ì¤‘ì´ê±°ë‚˜ ì¬ì—°ê²° ì¤‘ì¸ ê²½ìš° ê±´ë„ˆë›°ê¸°
    if (
      this.isConnected || 
      this._connectionState === SOCKET_STATE.CONNECTING || 
      this._connectionState === SOCKET_STATE.RECONNECTING
    ) {
      return;
    }
    
    this.currentReconnectAttempts++;
    this._updateConnectionState(SOCKET_STATE.RECONNECTING);
    
    // ì§€ìˆ˜ ë°±ì˜¤í”„ ì‚¬ìš©í•œ ì¬ì—°ê²° ì§€ì—° ê³„ì‚°
    const delay = this._calculateReconnectDelay();
    
    logger.debug('SocketService', 'ì†Œì¼“ ì¬ì—°ê²° ì‹œë„ ì˜ˆì•½', {
      attempt: this.currentReconnectAttempts,
      delay,
      maxAttempts: this.maxReconnectAttempts
    });
    
    // ì§€ì—° í›„ ì¬ì—°ê²°
    setTimeout(() => {
      if (!this.isConnected && this.autoReconnectEnabled) {
        this.connect();
      }
    }, delay);
  }
  
  /**
   * ì§€ìˆ˜ ë°±ì˜¤í”„ë¥¼ ì‚¬ìš©í•œ ì¬ì—°ê²° ì§€ì—° ì‹œê°„ ê³„ì‚°
   */
  private _calculateReconnectDelay(): number {
    // ê¸°ë³¸ ì§€ì—° ì‹œê°„ (1ì´ˆ)
    const baseDelay = 1000;
    
    // ìµœëŒ€ ì§€ì—° ì‹œê°„ (1ë¶„)
    const maxDelay = 60000;
    
    // ë¬´ì‘ìœ„ì„± ì¶”ê°€ (ì§€í„°)
    const jitter = 0.5 * Math.random();
    
    // ì§€ìˆ˜ ë°±ì˜¤í”„ ê³„ì‚° (2^n * ê¸°ë³¸ì§€ì—°)
    const exponentialDelay = Math.min(
      maxDelay,
      baseDelay * Math.pow(2, this.currentReconnectAttempts - 1)
    );
    
    // ì§€í„°ë¥¼ ì ìš©í•œ ìµœì¢… ì§€ì—° ì‹œê°„
    return Math.floor(exponentialDelay * (1 + jitter));
  }
  
  /**
   * ì´ë²¤íŠ¸ êµ¬ë…
   * @param event ì´ë²¤íŠ¸ ì´ë¦„
   * @param callback ì½œë°± í•¨ìˆ˜
   * @returns êµ¬ë… í•´ì œ í•¨ìˆ˜
   */
  on(event: string, callback: SocketEventCallback): () => void {
    return this.eventManager.on(event, callback);
  }
  
  /**
   * addEventListenerëŠ” onì˜ ë³„ì¹­ìœ¼ë¡œ êµ¬í˜„
   */
  addEventListener(event: string, callback: SocketEventCallback): () => void {
    return this.on(event, callback);
  }
  
  /**
   * ì´ë²¤íŠ¸ êµ¬ë… í•´ì œ
   * @param event ì´ë²¤íŠ¸ ì´ë¦„
   * @param callback ì½œë°± í•¨ìˆ˜
   */
  off(event: string, callback: SocketEventCallback): void {
    this.eventManager.off(event, callback);
  }
  
  /**
   * removeEventListenerëŠ” offì˜ ë³„ì¹­ìœ¼ë¡œ êµ¬í˜„
   */
  removeEventListener(event: string, callback: SocketEventCallback): void {
    this.off(event, callback);
  }
  
  /**
   * ì´ë²¤íŠ¸ ë°œìƒ
   * @param event ì´ë²¤íŠ¸ ì´ë¦„
   * @param data ì´ë²¤íŠ¸ ë°ì´í„°
   */
  emit(event: string, data?: any): void {
    this.eventManager.emit(event, data);
  }
  
  /**
   * Observable í˜•íƒœë¡œ ì´ë²¤íŠ¸ êµ¬ë…
   * @param event ì´ë²¤íŠ¸ ì´ë¦„
   * @returns ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
   */
  fromEvent<T = any>(event: string): Observable<T> {
    return this.eventManager.fromEvent<T>(event);
  }
  
  /**
   * ì—°ê²° ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼
   */
  connectionState$(): Observable<string> {
    return this.connectionStateSubject.asObservable();
  }
  
  /**
   * ì—°ê²° í’ˆì§ˆ ë©”íŠ¸ë¦­ ê°€ì ¸ì˜¤ê¸°
   */
  getConnectionMetrics(): any {
    return this.metricsManager.getConnectionMetrics();
  }
  
  /**
   * íŠ¹ì • CVE êµ¬ë… ìƒíƒœ ì—…ë°ì´íŠ¸
   * @param cveId CVE ID
   * @param isSubscribed êµ¬ë… ìƒíƒœ
   */
  updateSubscription(cveId: string, isSubscribed: boolean): void {
    try {
      const socket = this.socket;
      
      // êµ¬ë… ì´ë²¤íŠ¸ ì²˜ë¦¬ ë° ì „ì†¡
      if (isSubscribed) {
        // êµ¬ë… ì¶”ê°€
        logger.debug('SocketService', `CVE êµ¬ë… ì—…ë°ì´íŠ¸: ${cveId} (êµ¬ë…)`, { isSubscribed });
        
        // ì†Œì¼“ì´ ì—°ê²°ëœ ê²½ìš° ì„œë²„ì— ì´ë²¤íŠ¸ ì „ì†¡
        if (socket && this.isConnected) {
          this.emit('subscribe_cve', { cve_id: cveId });
        }
      } else {
        // êµ¬ë… ì·¨ì†Œ
        logger.debug('SocketService', `CVE êµ¬ë… ì—…ë°ì´íŠ¸: ${cveId} (êµ¬ë… ì·¨ì†Œ)`, { isSubscribed });
        
        // ì†Œì¼“ì´ ì—°ê²°ëœ ê²½ìš° ì„œë²„ì— ì´ë²¤íŠ¸ ì „ì†¡
        if (socket && this.isConnected) {
          this.emit('unsubscribe_cve', { cve_id: cveId });
        }
      }
    } catch (error) {
      logger.error('SocketService', 'êµ¬ë… ìƒíƒœ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
    }
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
const socketService = new SocketService();

export default socketService;


============================================================
File: /home/CVEHub/frontend/src/core/socket/services/socketStoreAdapter.ts
------------------------------------------------------------
import { Socket } from 'socket.io-client';
import { CONNECTION_EVENTS, SOCKET_STATE } from './constants';
import logger from 'shared/utils/logging';
import _ from 'lodash';
import useSocketStore, { socketActions } from '../state/socketStore';

/**
 * Socket.IO ì„œë¹„ìŠ¤ì™€ Zustand ìŠ¤í† ì–´ ê°„ì˜ ì–´ëŒ‘í„°
 * 
 * ì´ í´ë˜ìŠ¤ëŠ” Socket.IO ì„œë¹„ìŠ¤ì˜ ì´ë²¤íŠ¸ì™€ ìƒíƒœë¥¼ Zustand ìŠ¤í† ì–´ì— ë™ê¸°í™”í•˜ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤.
 * ì†Œì¼“ ì—°ê²° ìƒíƒœ ë³€í™”, ì´ë²¤íŠ¸ ë°œìƒ, ì˜¤ë¥˜ ì²˜ë¦¬ ë“±ì„ ê°ì§€í•˜ì—¬ ì¤‘ì•™í™”ëœ ìŠ¤í† ì–´ì— ë°˜ì˜í•©ë‹ˆë‹¤.
 * ì´ë¥¼ í†µí•´ ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì²´ì—ì„œ ì¼ê´€ëœ ì†Œì¼“ ìƒíƒœë¥¼ ìœ ì§€í•˜ê³  ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 */
class SocketStoreAdapter {
  private networkListenersAttached: boolean = false;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private connectionDiagnostics = {
    lastConnectedTime: null as Date | null,
    reconnectAttempts: 0,
    maxReconnectAttempts: 5,
    pingTimes: [] as number[]
  };

  /**
   * ìƒì„±ì
   * 
   * ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€í™” ê°ì§€ ì´ˆê¸°í™”ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
   */
  constructor() {
    // ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€í™” ê°ì§€ ì´ˆê¸°í™”
    this.handleNetworkStatusChange();
  }

  /**
   * ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìŠ¤í† ì–´ì— ë“±ë¡í•©ë‹ˆë‹¤.
   * 
   * ìƒˆ ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ê°€ ìƒì„±ë˜ë©´ ì´ ë©”ì„œë“œë¥¼ í†µí•´ Zustand ìŠ¤í† ì–´ì— ë“±ë¡í•©ë‹ˆë‹¤.
   * ì†Œì¼“ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ì„¤ì •í•˜ê³  ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ëª¨ë‹ˆí„°ë§ì„ ì‹œì‘í•©ë‹ˆë‹¤.
   * 
   * @param socket - ë“±ë¡í•  Socket.IO ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤
   */
  registerSocket(socket: Socket | null): void {
    socketActions.setSocket(socket);
    
    if (socket) {
      this.setupSocketListeners(socket);
      this.handleReconnection(socket);
    }
  }
  
  /**
   * ì†Œì¼“ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
   * 
   * ì†Œì¼“ì˜ ì—°ê²°, ì—°ê²° í•´ì œ, ì˜¤ë¥˜ ë“± ë‹¤ì–‘í•œ ì´ë²¤íŠ¸ì— ëŒ€í•œ ë¦¬ìŠ¤ë„ˆë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.
   * ê° ì´ë²¤íŠ¸ ë°œìƒ ì‹œ Zustand ìŠ¤í† ì–´ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ì—¬ UIì— ë°˜ì˜ë©ë‹ˆë‹¤.
   * 
   * @param socket - ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ì„¤ì •í•  Socket.IO ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤
   */
  private setupSocketListeners(socket: Socket): void {
    // ì—°ê²° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    socket.on(CONNECTION_EVENTS.CONNECT, () => {
      socketActions.setConnected(true);
      socketActions.setConnectionError(null);
      
      // ì—°ê²° ì§„ë‹¨ ì •ë³´ ì—…ë°ì´íŠ¸
      this.connectionDiagnostics.lastConnectedTime = new Date();
      this.connectionDiagnostics.reconnectAttempts = 0;
      
      logger.info('SocketStoreAdapter', 'ì†Œì¼“ ì—°ê²°ë¨', {
        socketId: socket.id,
        timestamp: new Date().toISOString()
      });
      
      // ì—°ê²° í’ˆì§ˆ ì¸¡ì • ì‹œì‘
      this.startConnectionQualityMonitoring(socket);
    });
    
    // ì—°ê²° í•´ì œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    socket.on(CONNECTION_EVENTS.DISCONNECT, (reason) => {
      socketActions.setConnected(false);
      
      // ê³„íšëœ ì—°ê²° í•´ì œì¸ì§€ í™•ì¸
      const isPlannedDisconnect = reason === 'io client disconnect';
      
      logger.info('SocketStoreAdapter', 'ì†Œì¼“ ì—°ê²° í•´ì œë¨', {
        reason,
        isPlannedDisconnect,
        timestamp: new Date().toISOString()
      });
      
      // ê³„íšë˜ì§€ ì•Šì€ ì—°ê²° í•´ì œì¸ ê²½ìš° ì¬ì—°ê²° ì „ëµ ì‹¤í–‰
      if (!isPlannedDisconnect) {
        this.handleUnplannedDisconnect(reason);
      }
    });
    
    // ì—°ê²° ì˜¤ë¥˜ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    socket.on(CONNECTION_EVENTS.CONNECT_ERROR, (error) => {
      socketActions.setConnected(false);
      socketActions.setConnectionError(error);
      socketActions.setConnectionState(SOCKET_STATE.ERROR);
      
      // ì˜¤ë¥˜ ì„¸ë¶€ ì •ë³´ ê¸°ë¡
      const errorDetails = {
        message: error.message,
        type: error.name,
        timestamp: new Date().toISOString()
      };
      
      logger.error('SocketStoreAdapter', 'ì†Œì¼“ ì—°ê²° ì˜¤ë¥˜', errorDetails);
      
      // ì˜¤ë¥˜ ìœ í˜•ì— ë”°ë¥¸ ì°¨ë³„í™”ëœ ì²˜ë¦¬
      this.handleConnectionError(error);
    });
  }
  
  /**
   * ì•¡ì…˜ì„ ë””ìŠ¤íŒ¨ì¹˜í•˜ëŠ” ë©”ì„œë“œ
   * 
   * Zustand ìŠ¤í† ì–´ ì•¡ì…˜ì„ ì‹¤í–‰í•˜ëŠ” í—¬í¼ ë©”ì„œë“œì…ë‹ˆë‹¤.
   * 
   * @param action - ì‹¤í–‰í•  ìŠ¤í† ì–´ ì•¡ì…˜
   */
  dispatch(action: Function): void {
    if (typeof action === 'function') {
      action();
    }
  }

  /**
   * ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡
   * 
   * ì´ë²¤íŠ¸ ì´ë¦„ê³¼ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ë¥¼ ë“±ë¡í•˜ì—¬ ì´ë²¤íŠ¸ ë°œìƒ ì‹œ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
   * 
   * @param event - ì´ë²¤íŠ¸ ì´ë¦„
   * @param handler - ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ í•¨ìˆ˜
   */
  registerEventHandler(event: string, handler: (data: any) => void): void {
    socketActions.addEventHandler(event, handler);
    logger.debug('SocketStoreAdapter', `ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡: ${event}`);
  }
  
  /**
   * ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì œê±°
   * 
   * ë“±ë¡ëœ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë¥¼ ì œê±°í•˜ì—¬ ì´ë²¤íŠ¸ ë°œìƒ ì‹œ í˜¸ì¶œë˜ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.
   * 
   * @param event - ì´ë²¤íŠ¸ ì´ë¦„
   * @param handler - ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ í•¨ìˆ˜
   */
  unregisterEventHandler(event: string, handler: (data: any) => void): void {
    socketActions.removeEventHandler(event, handler);
    logger.debug('SocketStoreAdapter', `ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì œê±°: ${event}`);
  }
  
  /**
   * ì´ë²¤íŠ¸ ë°œìƒ ê¸°ë¡
   * 
   * ì†Œì¼“ ì´ë²¤íŠ¸ê°€ ë°œìƒí•  ë•Œ ì´ë¥¼ ìŠ¤í† ì–´ì— ê¸°ë¡í•©ë‹ˆë‹¤.
   * ì´ë²¤íŠ¸ ì´ë¦„, ë°ì´í„°, íƒ€ì„ìŠ¤íƒ¬í”„ ë“±ì„ ì €ì¥í•˜ì—¬ ë””ë²„ê¹… ë° ë¶„ì„ì— í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
   * 
   * @param socket - ì´ë²¤íŠ¸ê°€ ë°œìƒí•œ Socket.IO ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤
   * @param event - ë°œìƒí•œ ì´ë²¤íŠ¸ ì´ë¦„
   * @param data - ì´ë²¤íŠ¸ì™€ í•¨ê»˜ ì „ì†¡ëœ ë°ì´í„°
   */
  recordEventEmission(socket: Socket, event: string, data: any): void {
    socketActions.emitEvent(socket, event, data);
    logger.debug('SocketStoreAdapter', `ì´ë²¤íŠ¸ ë°œìƒ ê¸°ë¡: ${event}`);
  }
  
  /**
   * ì—°ê²° ì¬ì‹œë„ ê´€ë ¨ ê¸°ëŠ¥ ê°•í™”
   * 
   * ì—°ê²°ì´ ëŠì–´ì§„ ê²½ìš° ì¬ì—°ê²°ì„ ì‹œë„í•©ë‹ˆë‹¤.
   * ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜, ì§€ì—° ì‹œê°„ ë“±ì„ ê´€ë¦¬í•˜ì—¬ íš¨ìœ¨ì ì¸ ì¬ì—°ê²° ì „ëµì„ êµ¬í˜„í•©ë‹ˆë‹¤.
   * 
   * @param socket - ì¬ì—°ê²°ì„ ì‹œë„í•  Socket.IO ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤
   */
  handleReconnection(socket: Socket): void {
    // ì¬ì—°ê²° ì‹œë„ ì´ë²¤íŠ¸
    socket.on('reconnect_attempt', (attemptNumber) => {
      this.connectionDiagnostics.reconnectAttempts = attemptNumber;
      
      // ìŠ¤í† ì–´ ìƒíƒœ ì—…ë°ì´íŠ¸
      socketActions.setConnectionState(SOCKET_STATE.RECONNECTING);
      
      // ë¡œê·¸ ê¸°ë¡
      logger.info('SocketStoreAdapter', `ì¬ì—°ê²° ì‹œë„ ì¤‘ (${attemptNumber}/${this.connectionDiagnostics.maxReconnectAttempts})`, {
        attemptNumber,
        maxAttempts: this.connectionDiagnostics.maxReconnectAttempts,
        timestamp: new Date().toISOString()
      });
    });
    
    // ì¬ì—°ê²° ì‹¤íŒ¨ ì´ë²¤íŠ¸
    socket.on('reconnect_failed', () => {
      // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼
      socketActions.setConnectionState(SOCKET_STATE.ERROR);
      socketActions.setConnectionError(new Error('ìµœëŒ€ ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤.'));
      
      logger.error('SocketStoreAdapter', 'ì¬ì—°ê²° ì‹¤íŒ¨', {
        attempts: this.connectionDiagnostics.reconnectAttempts,
        maxAttempts: this.connectionDiagnostics.maxReconnectAttempts,
        timestamp: new Date().toISOString()
      });
      
      // ë°±ì˜¤í”„ ì „ëµìœ¼ë¡œ ì¬ì‹œë„ 
      this.executeReconnectBackoffStrategy();
    });
    
    // ì¬ì—°ê²° ì„±ê³µ ì´ë²¤íŠ¸
    socket.on('reconnect', (attemptNumber) => {
      socketActions.setConnected(true);
      socketActions.setConnectionState(SOCKET_STATE.CONNECTED);
      socketActions.setConnectionError(null);
      
      // ì—°ê²° ì§„ë‹¨ ì •ë³´ ì—…ë°ì´íŠ¸
      this.connectionDiagnostics.lastConnectedTime = new Date();
      this.connectionDiagnostics.reconnectAttempts = 0;
      
      logger.info('SocketStoreAdapter', `ì¬ì—°ê²° ì„±ê³µ (${attemptNumber}íšŒ ì‹œë„)`, {
        attemptNumber,
        timestamp: new Date().toISOString()
      });
      
      // ì¬ì‹œë„ íƒ€ì´ë¨¸ ì •ë¦¬
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = null;
      }
    });
  }
  
  /**
   * ê³„íšë˜ì§€ ì•Šì€ ì—°ê²° í•´ì œ ì²˜ë¦¬
   * 
   * ì—°ê²°ì´ ëŠì–´ì¡Œì„ ë•Œ í˜¸ì¶œë©ë‹ˆë‹¤.
   * ì—°ê²° í•´ì œ ì´ìœ ì— ë”°ë¼ ë‹¤ë¥¸ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   * ì˜ˆ: ì „ì†¡ ê³„ì¸µ ë‹«í˜, í•‘ íƒ€ì„ì•„ì›ƒ, ì „ì†¡ ì˜¤ë¥˜ ë“±
   * ì´ë¥¼ í†µí•´ UIì—ì„œ ì‚¬ìš©ìì—ê²Œ ì ì ˆí•œ í”¼ë“œë°±ì„ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
   * 
   * @param reason - ì—°ê²° í•´ì œ ì´ìœ 
   */
  private handleUnplannedDisconnect(reason: string): void {
    // ì›ì¸ì— ë”°ë¥¸ ì ì ˆí•œ ìƒíƒœ ì„¤ì •
    switch (reason) {
      case 'transport close':
        socketActions.setConnectionState(SOCKET_STATE.TRANSPORT_CLOSED);
        break;
      case 'ping timeout':
        socketActions.setConnectionState(SOCKET_STATE.PING_TIMEOUT);
        break;
      case 'transport error':
        socketActions.setConnectionState(SOCKET_STATE.TRANSPORT_ERROR);
        break;
      default:
        socketActions.setConnectionState(SOCKET_STATE.DISCONNECTED);
    }
    
    // ì¬ì—°ê²° ì „ëµ ì‹¤í–‰ ì—¬ë¶€ ê²°ì •
    const shouldAttemptReconnect = !navigator.onLine ? false : 
      this.connectionDiagnostics.reconnectAttempts < this.connectionDiagnostics.maxReconnectAttempts;
    
    if (shouldAttemptReconnect) {
      logger.info('SocketStoreAdapter', 'ìë™ ì¬ì—°ê²° ì‹œë„ ì˜ˆì•½ë¨', {
        reason,
        reconnectAttempts: this.connectionDiagnostics.reconnectAttempts,
        delay: this.calculateReconnectDelay()
      });
    }
  }
  
  /**
   * ì—°ê²° ì˜¤ë¥˜ ì²˜ë¦¬
   * 
   * ì—°ê²° ì¤‘ ì˜¤ë¥˜ ë°œìƒ ì‹œ í˜¸ì¶œë©ë‹ˆë‹¤. ì˜¤ë¥˜ ìœ í˜•ì— ë”°ë¼ ë‹¤ë¥¸ ì²˜ë¦¬ë¥¼ í•©ë‹ˆë‹¤.
   * ì¸ì¦ ì˜¤ë¥˜, íƒ€ì„ì•„ì›ƒ ë“± íŠ¹ì • ì˜¤ë¥˜ ìœ í˜•ì— ëŒ€í•´ ë§ì¶¤í˜• ì²˜ë¦¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
   * ìŠ¤í† ì–´ì— ì˜¤ë¥˜ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•˜ì—¬ UIì—ì„œ ì ì ˆí•œ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ í‘œì‹œí•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.
   * 
   * @param error - ë°œìƒí•œ ì˜¤ë¥˜ ê°ì²´
   */
  private handleConnectionError(error: Error): void {
    // ì˜¤ë¥˜ ìœ í˜•ì— ë”°ë¥¸ ì°¨ë³„í™”ëœ ì²˜ë¦¬
    if (error.message.includes('auth')) {
      // ì¸ì¦ ê´€ë ¨ ì˜¤ë¥˜
      socketActions.setConnectionState(SOCKET_STATE.AUTH_ERROR);
      logger.error('SocketStoreAdapter', 'ì¸ì¦ ì˜¤ë¥˜ë¡œ ì¸í•œ ì—°ê²° ì‹¤íŒ¨', { message: error.message });
      
      // ì¸ì¦ ì˜¤ë¥˜ëŠ” ì¦‰ì‹œ ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ (ì‚¬ìš©ì ê°œì… í•„ìš”)
      return;
    }
    
    if (error.message.includes('timeout')) {
      // íƒ€ì„ì•„ì›ƒ ì˜¤ë¥˜
      socketActions.setConnectionState(SOCKET_STATE.TIMEOUT);
      logger.error('SocketStoreAdapter', 'íƒ€ì„ì•„ì›ƒìœ¼ë¡œ ì¸í•œ ì—°ê²° ì‹¤íŒ¨', { message: error.message });
    }
    
    // ê¸°ë³¸ ì¬ì—°ê²° ì „ëµ ì‹¤í–‰
    this.executeReconnectBackoffStrategy();
  }
  
  /**
   * ë°±ì˜¤í”„ ì „ëµì„ ì‚¬ìš©í•œ ì¬ì—°ê²° ì‹¤í–‰
   * 
   * ì¬ì—°ê²° ì‹œë„ ê°„ê²©ì„ ì ì§„ì ìœ¼ë¡œ ëŠ˜ë ¤ê°€ë©° ì¬ì—°ê²°ì„ ì‹œë„í•©ë‹ˆë‹¤.
   * ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ì— ë„ë‹¬í•˜ë©´ ì˜¤ë¥˜ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
   */
  private executeReconnectBackoffStrategy(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }
    
    const delay = this.calculateReconnectDelay();
    
    logger.info('SocketStoreAdapter', `${delay}ms í›„ ì¬ì—°ê²° ì‹œë„ ì˜ˆì•½ë¨`, {
      attempts: this.connectionDiagnostics.reconnectAttempts,
      delay
    });
    
    this.reconnectTimer = setTimeout(() => {
      // ì¬ì—°ê²° ì‹œë„
      this.attemptReconnect();
    }, delay);
  }
  
  /**
   * ì§€ìˆ˜ ë°±ì˜¤í”„ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•œ ì¬ì—°ê²° ì§€ì—° ì‹œê°„ ê³„ì‚°
   * 
   * ì¬ì—°ê²° ì‹œë„ ê°„ê²©ì„ ê³„ì‚°í•˜ì—¬ ì ì§„ì ìœ¼ë¡œ ëŠ˜ë ¤ê°€ë©° ì¬ì—°ê²°ì„ ì‹œë„í•©ë‹ˆë‹¤.
   * 
   * @returns ì¬ì—°ê²° ì§€ì—° ì‹œê°„ (ms)
   */
  private calculateReconnectDelay(): number {
    const baseDelay = 1000; // ê¸°ë³¸ 1ì´ˆ
    const attempts = this.connectionDiagnostics.reconnectAttempts;
    const maxDelay = 30000; // ìµœëŒ€ 30ì´ˆ
    
    // ì§€ìˆ˜ ë°±ì˜¤í”„: ê¸°ë³¸ ì§€ì—° * 2^ì‹œë„íšŸìˆ˜ + ëœë¤ ì§€í„°(0-1000ms)
    const exponentialDelay = baseDelay * Math.pow(2, Math.min(attempts, 5));
    const jitter = Math.random() * 1000;
    
    return Math.min(exponentialDelay + jitter, maxDelay);
  }
  
  /**
   * ì¬ì—°ê²° ì‹œë„
   * 
   * ì¬ì—°ê²°ì„ ì‹œë„í•©ë‹ˆë‹¤. ì¬ì—°ê²° ì„±ê³µ ë˜ëŠ” ì‹¤íŒ¨ ì‹œ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   */
  private attemptReconnect(): void {
    this.connectionDiagnostics.reconnectAttempts++;
    
    logger.info('SocketStoreAdapter', 'ì¬ì—°ê²° ì‹œë„ ì¤‘', {
      attempt: this.connectionDiagnostics.reconnectAttempts,
      maxAttempts: this.connectionDiagnostics.maxReconnectAttempts
    });
    
    socketActions.setConnectionState(SOCKET_STATE.RECONNECTING);
    
    // ì¬ì—°ê²° ë¡œì§ ì‹¤í–‰ (ì™¸ë¶€ í•¨ìˆ˜ í˜¸ì¶œ í•„ìš” - socketIOService.connect)
    // ì´ ë¶€ë¶„ì€ ì‹¤ì œ êµ¬í˜„ ì‹œ socketIOServiceë¥¼ ì–´ëŒ‘í„°ì— ì£¼ì…ë°›ì•„ ì²˜ë¦¬í•´ì•¼ í•¨
    // í˜„ì¬ëŠ” ì™¸ë¶€ì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ ìƒíƒœë§Œ ì—…ë°ì´íŠ¸
  }
  
  /**
   * ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€í™” ê°ì§€ ë° ì²˜ë¦¬
   * 
   * ë¸Œë¼ìš°ì €ì˜ ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸ ì´ë²¤íŠ¸ë¥¼ ê°ì§€í•˜ì—¬ ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€í™”ì— ëŒ€ì‘í•©ë‹ˆë‹¤.
   * ë„¤íŠ¸ì›Œí¬ê°€ ë³µêµ¬ë˜ë©´ ìë™ ì¬ì—°ê²°ì„ ì‹œë„í•˜ê³ , ë„¤íŠ¸ì›Œí¬ê°€ ëŠê¸°ë©´ ì˜¤ë¥˜ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
   * ì¤‘ë³µ ì„¤ì •ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ë¦¬ìŠ¤ë„ˆ ë¶€ì°© ì—¬ë¶€ë¥¼ ì¶”ì í•©ë‹ˆë‹¤.
   */
  handleNetworkStatusChange(): void {
    if (this.networkListenersAttached) {
      return;
    }
    
    // ì˜¨ë¼ì¸/ì˜¤í”„ë¼ì¸ ìƒíƒœ ë³€í™” ê°ì§€
    window.addEventListener('online', this.handleOnline);
    window.addEventListener('offline', this.handleOffline);
    
    this.networkListenersAttached = true;
    logger.debug('SocketStoreAdapter', 'ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë³€í™” ê°ì§€ ì‹œì‘');
  }
  
  /**
   * ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë³µêµ¬ ì²˜ë¦¬
   * 
   * ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ë³µêµ¬ë˜ì—ˆì„ ë•Œ í˜¸ì¶œë©ë‹ˆë‹¤.
   * í˜„ì¬ ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•˜ê³ , ì—°ê²°ì´ ëŠì–´ì§„ ìƒíƒœë¼ë©´ ì¬ì—°ê²°ì„ ì‹œë„í•©ë‹ˆë‹¤.
   * ì§€ì—° ì‹œê°„ì„ ë‘ì–´ ë„¤íŠ¸ì›Œí¬ ì•ˆì •í™”ë¥¼ ê¸°ë‹¤ë¦° í›„ ì¬ì—°ê²°ì„ ì‹œë„í•©ë‹ˆë‹¤.
   */
  private handleOnline = (): void => {
    logger.info('SocketStoreAdapter', 'ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë³µêµ¬ë¨');
    
    // ì—°ê²°ì´ ëŠì–´ì§„ ìƒíƒœì—ì„œ ë„¤íŠ¸ì›Œí¬ê°€ ë³µêµ¬ë˜ë©´ ì¬ì—°ê²° ì‹œë„
    const { connectionState } = useSocketStore.getState();
    const isDisconnected = connectionState === SOCKET_STATE.DISCONNECTED || 
                           connectionState === SOCKET_STATE.ERROR ||
                           connectionState === SOCKET_STATE.NETWORK_ERROR;
    
    if (isDisconnected) {
      // ì•½ê°„ì˜ ì§€ì—° í›„ ì¬ì—°ê²° ì‹œë„ (ë„¤íŠ¸ì›Œí¬ ì•ˆì •í™”ë¥¼ ìœ„í•´)
      setTimeout(() => {
        logger.info('SocketStoreAdapter', 'ë„¤íŠ¸ì›Œí¬ ë³µêµ¬ í›„ ì¬ì—°ê²° ì‹œë„');
        // ì†Œì¼“ ì—°ê²° ì¬ì‹œë„ ë¡œì§ì€ ì™¸ë¶€ì—ì„œ ì²˜ë¦¬
        this.connectionDiagnostics.reconnectAttempts = 0;
        socketActions.setConnectionState(SOCKET_STATE.RECONNECTING);
      }, 2000);
    }
  };
  
  /**
   * ë„¤íŠ¸ì›Œí¬ ì—°ê²° ëŠê¹€ ì²˜ë¦¬
   * 
   * ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ëŠì–´ì¡Œì„ ë•Œ í˜¸ì¶œë©ë‹ˆë‹¤.
   * ìŠ¤í† ì–´ ìƒíƒœë¥¼ 'NETWORK_ERROR'ë¡œ ì—…ë°ì´íŠ¸í•˜ê³ , ì ì ˆí•œ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
   * ì´ë¥¼ í†µí•´ UIì—ì„œ ë„¤íŠ¸ì›Œí¬ ë¬¸ì œë¥¼ ì‚¬ìš©ìì—ê²Œ ì•Œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
   */
  private handleOffline = (): void => {
    logger.info('SocketStoreAdapter', 'ë„¤íŠ¸ì›Œí¬ ì—°ê²° ëŠê¹€');
    
    // ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ëŠì–´ì§„ ìƒíƒœë¥¼ ìŠ¤í† ì–´ì— ë°˜ì˜
    socketActions.setConnectionState(SOCKET_STATE.NETWORK_ERROR);
    socketActions.setConnectionError(new Error('ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.'));
  };
  
  /**
   * ì—°ê²° í’ˆì§ˆ ëª¨ë‹ˆí„°ë§ ì‹œì‘
   * 
   * ì†Œì¼“ ì—°ê²° í’ˆì§ˆì„ ëª¨ë‹ˆí„°ë§í•˜ì—¬ í‰ê·  ì‘ë‹µ ì‹œê°„ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
   * ì´ë¥¼ í†µí•´ ë„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ í‰ê°€í•˜ê³ , ë¬¸ì œê°€ ë°œìƒí•  ê²½ìš° ì¡°ì¹˜ë¥¼ ì·¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
   * 
   * @param socket - ì—°ê²° í’ˆì§ˆì„ ëª¨ë‹ˆí„°ë§í•  Socket.IO ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤
   */
  private startConnectionQualityMonitoring(socket: Socket): void {
    // 60ì´ˆ ê°„ê²©ìœ¼ë¡œ í•‘ ì¸¡ì •
    const pingInterval = setInterval(() => {
      const startTime = Date.now();
      
      socket.emit('ping', () => {
        const rtt = Date.now() - startTime;
        this.connectionDiagnostics.pingTimes.push(rtt);
        
        // ìµœëŒ€ 10ê°œê¹Œì§€ë§Œ ì €ì¥
        if (this.connectionDiagnostics.pingTimes.length > 10) {
          this.connectionDiagnostics.pingTimes.shift();
        }
        
        // í‰ê·  RTT ê³„ì‚°
        const avgRtt = this.connectionDiagnostics.pingTimes.reduce((sum, time) => sum + time, 0) / 
                       this.connectionDiagnostics.pingTimes.length;
        
        logger.debug('SocketStoreAdapter', 'ì—°ê²° í’ˆì§ˆ ì¸¡ì •', {
          rtt,
          avgRtt: Math.round(avgRtt),
          measurements: this.connectionDiagnostics.pingTimes.length
        });
      });
    }, 60000);
    
    // ì—°ê²° í•´ì œ ì‹œ ì •ë¦¬
    socket.on(CONNECTION_EVENTS.DISCONNECT, () => {
      clearInterval(pingInterval);
    });
  }
  
  /**
   * ì—°ê²° ì§„ë‹¨ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
   * 
   * í˜„ì¬ ì—°ê²° ìƒíƒœ, í‰ê·  ì‘ë‹µ ì‹œê°„, ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ë“±ì„ í¬í•¨í•œ ì§„ë‹¨ ì •ë³´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
   * ì´ë¥¼ í†µí•´ í˜„ì¬ ë„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ í‰ê°€í•˜ê³ , ë¬¸ì œê°€ ë°œìƒí•  ê²½ìš° ì¡°ì¹˜ë¥¼ ì·¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
   * 
   * @returns ì—°ê²° ì§„ë‹¨ ì •ë³´
   */
  getConnectionDiagnostics(): any {
    const { connectionState, connected } = useSocketStore.getState();
    
    return {
      ...this.connectionDiagnostics,
      currentState: connectionState,
      connected,
      networkOnline: navigator.onLine,
      averagePing: this.getAveragePing(),
      connectionQuality: this.getConnectionQualityRating(),
      timestamp: new Date().toISOString()
    };
  }
  
  /**
   * í‰ê·  í•‘ ì‹œê°„ ê³„ì‚°
   * 
   * ìµœê·¼ ì¸¡ì •ëœ í•‘ ì‹œê°„ì˜ í‰ê· ì„ ê³„ì‚°í•˜ì—¬ ë°˜í™˜í•©ë‹ˆë‹¤.
   * 
   * @returns í‰ê·  í•‘ ì‹œê°„
   */
  private getAveragePing(): number {
    if (this.connectionDiagnostics.pingTimes.length === 0) {
      return 0;
    }
    
    const sum = this.connectionDiagnostics.pingTimes.reduce((total, time) => total + time, 0);
    return Math.round(sum / this.connectionDiagnostics.pingTimes.length);
  }
  
  /**
   * ì—°ê²° í’ˆì§ˆ ë“±ê¸‰ ê°€ì ¸ì˜¤ê¸°
   * 
   * í‰ê·  í•‘ ì‹œê°„ì„ ê¸°ì¤€ìœ¼ë¡œ ì—°ê²° í’ˆì§ˆ ë“±ê¸‰ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
   * 
   * @returns ì—°ê²° í’ˆì§ˆ ë“±ê¸‰
   */
  private getConnectionQualityRating(): string {
    const avgPing = this.getAveragePing();
    
    if (avgPing === 0) return 'ì¸¡ì • ì „';
    if (avgPing < 100) return 'ìš°ìˆ˜';
    if (avgPing < 300) return 'ì–‘í˜¸';
    if (avgPing < 600) return 'ë³´í†µ';
    return 'ë¶ˆëŸ‰';
  }
  
  /**
   * ì •ë¦¬ ë° ë¦¬ì†ŒìŠ¤ í•´ì œ
   * 
   * ì†Œì¼“ ì—°ê²°ì„ í•´ì œí•˜ê³ , ë¦¬ì†ŒìŠ¤ë¥¼ í•´ì œí•˜ì—¬ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
   */
  cleanup(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    
    if (this.networkListenersAttached) {
      window.removeEventListener('online', this.handleOnline);
      window.removeEventListener('offline', this.handleOffline);
      this.networkListenersAttached = false;
    }
    
    logger.debug('SocketStoreAdapter', 'ì–´ëŒ‘í„° ì •ë¦¬ ì™„ë£Œ');
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
const socketStoreAdapter = new SocketStoreAdapter();

export default socketStoreAdapter;



============================================================
File: /home/CVEHub/frontend/src/core/socket/services/constants.ts
------------------------------------------------------------
/**
 * Socket.IO ì´ë²¤íŠ¸ ìƒìˆ˜ ì •ì˜
 * ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ ê°„ì˜ ì¼ê´€ëœ ì´ë²¤íŠ¸ ì´ë¦„ì„ ìœ ì§€í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•©ë‹ˆë‹¤.
 * ë°±ì—”ë“œì˜ WSMessageType ì—´ê±°í˜•ê³¼ ì¼ì¹˜í•˜ë„ë¡ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤.
 */

// ì—°ê²° ê´€ë ¨ ì´ë²¤íŠ¸
export const CONNECTION_EVENTS = {
  CONNECT: 'connect',
  DISCONNECT: 'disconnect',
  CONNECT_ERROR: 'connect_error',
  RECONNECT: 'reconnect',
  RECONNECT_ATTEMPT: 'reconnect_attempt',
  CONNECT_ACK: 'connect_ack', // ë°±ì—”ë“œ WSMessageType.CONNECT_ACKì™€ ì¼ì¹˜
  CONNECTED: 'connected', // ë°±ì—”ë“œ WSMessageType.CONNECTEDì™€ ì¼ì¹˜
  SESSION_INFO_ACK: 'session_info_ack', // ë°±ì—”ë“œ WSMessageType.SESSION_INFO_ACKì™€ ì¼ì¹˜
  CONNECTION_STATE_CHANGE: 'connection_state_change', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: ì—°ê²° ìƒíƒœ ë³€ê²½
};

// í•‘/í ê´€ë ¨ ì´ë²¤íŠ¸
export const PING_PONG_EVENTS = {
  PING: 'ping', // ë°±ì—”ë“œ WSMessageType.PINGì™€ ì¼ì¹˜
  PONG: 'pong', // ë°±ì—”ë“œ WSMessageType.PONGì™€ ì¼ì¹˜
};

// ì˜¤ë¥˜ ê´€ë ¨ ì´ë²¤íŠ¸
export const ERROR_EVENTS = {
  ERROR: 'error', // ë°±ì—”ë“œ WSMessageType.ERRORì™€ ì¼ì¹˜
};

// CVE ê´€ë ¨ ì´ë²¤íŠ¸
export const CVE_EVENTS = {
  CVE_UPDATED: 'cve_updated', // ë°±ì—”ë“œ WSMessageType.CVE_UPDATEDì™€ ì¼ì¹˜
  CVE_CREATED: 'cve_created', // ë°±ì—”ë“œ WSMessageType.CVE_CREATEDì™€ ì¼ì¹˜
  CVE_DELETED: 'cve_deleted', // ë°±ì—”ë“œ WSMessageType.CVE_DELETEDì™€ ì¼ì¹˜
  CVE_DETAIL_UPDATED: 'cve_detail_updated', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: CVE ìƒì„¸ ì •ë³´ ì—…ë°ì´íŠ¸
};

// êµ¬ë… ê´€ë ¨ ì´ë²¤íŠ¸
export const SUBSCRIPTION_EVENTS = {
  SUBSCRIBE_CVE: 'subscribe_cve', // ë°±ì—”ë“œ WSMessageType.SUBSCRIBE_CVEì™€ ì¼ì¹˜
  UNSUBSCRIBE_CVE: 'unsubscribe_cve', // ë°±ì—”ë“œ WSMessageType.UNSUBSCRIBE_CVEì™€ ì¼ì¹˜
  SUBSCRIPTION_STATUS: 'subscription_status', // ë°±ì—”ë“œ WSMessageType.SUBSCRIPTION_STATUSì™€ ì¼ì¹˜
  SUBSCRIPTION_UPDATED: 'subscription_updated', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: êµ¬ë… ìƒíƒœ ì—…ë°ì´íŠ¸
  SUBSCRIBE_ACK: 'subscribe_ack', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: êµ¬ë… ìš”ì²­ í™•ì¸
  UNSUBSCRIBE_ACK: 'unsubscribe_ack', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: êµ¬ë… ì·¨ì†Œ ìš”ì²­ í™•ì¸
  SUBSCRIPTION_ERROR: 'subscription_error', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: êµ¬ë… ì˜¤ë¥˜
  UNSUBSCRIPTION_ERROR: 'unsubscription_error', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: êµ¬ë… ì·¨ì†Œ ì˜¤ë¥˜
  SUBSCRIBE_CVES: 'subscribe:cves', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: CVE ëª©ë¡ êµ¬ë… ìš”ì²­
  UNSUBSCRIBE_CVES: 'unsubscribe:cves', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: CVE ëª©ë¡ êµ¬ë… ì·¨ì†Œ ìš”ì²­
  GET_CVE_SUBSCRIBERS: 'get_cve_subscribers', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: CVE êµ¬ë…ì ëª©ë¡ ìš”ì²­
  SUBSCRIBE_CVE_SUCCESS: 'subscribe_cve_success', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: CVE êµ¬ë… ì„±ê³µ
  UNSUBSCRIBE_CVE_SUCCESS: 'unsubscribe_cve_success', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: CVE êµ¬ë… ì·¨ì†Œ ì„±ê³µ
  CVE_SUBSCRIBERS_UPDATED: 'cve_subscribers_updated', // ë°±ì—”ë“œ WSMessageType.CVE_SUBSCRIBERS_UPDATEDì™€ ì¼ì¹˜
  SUBSCRIPTIONS_CHANGED: 'subscriptions_changed', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: êµ¬ë… ëª©ë¡ ë³€ê²½
  SUBSCRIBED_CVES_UPDATED: 'subscribed_cves_updated', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: êµ¬ë… ì¤‘ì¸ CVE ëª©ë¡ ì—…ë°ì´íŠ¸
};

// ëŒ“ê¸€ ê´€ë ¨ ì´ë²¤íŠ¸
export const COMMENT_EVENTS = {
  COMMENT_ADDED: 'comment_added', // ë°±ì—”ë“œ WSMessageType.COMMENT_ADDEDì™€ ì¼ì¹˜
  COMMENT_UPDATED: 'comment_updated', // ë°±ì—”ë“œ WSMessageType.COMMENT_UPDATEDì™€ ì¼ì¹˜
  COMMENT_DELETED: 'comment_deleted', // ë°±ì—”ë“œ WSMessageType.COMMENT_DELETEDì™€ ì¼ì¹˜
  COMMENT_REACTION_ADDED: 'comment_reaction_added', // ë°±ì—”ë“œ WSMessageType.COMMENT_REACTION_ADDEDì™€ ì¼ì¹˜
  COMMENT_REACTION_REMOVED: 'comment_reaction_removed', // ë°±ì—”ë“œ WSMessageType.COMMENT_REACTION_REMOVEDì™€ ì¼ì¹˜
  COMMENT_MENTION_ADDED: 'comment_mention_added', // ë°±ì—”ë“œ WSMessageType.COMMENT_MENTION_ADDEDì™€ ì¼ì¹˜
  COMMENT_REPLY_ADDED: 'comment_reply_added', // ë°±ì—”ë“œ WSMessageType.COMMENT_REPLY_ADDEDì™€ ì¼ì¹˜
  COMMENT_COUNT_UPDATE: 'comment_count_update', // ë°±ì—”ë“œ WSMessageType.COMMENT_COUNT_UPDATEì™€ ì¼ì¹˜
};

// ì•Œë¦¼ ê´€ë ¨ ì´ë²¤íŠ¸
export const NOTIFICATION_EVENTS = {
  NOTIFICATION: 'notification', // ë°±ì—”ë“œ WSMessageType.NOTIFICATIONì™€ ì¼ì¹˜
  NOTIFICATION_READ: 'notification_read', // ë°±ì—”ë“œ WSMessageType.NOTIFICATION_READì™€ ì¼ì¹˜
  NEW_NOTIFICATION: 'new_notification', // ë°±ì—”ë“œ WSMessageType.NEW_NOTIFICATIONì™€ ì¼ì¹˜
  ALL_NOTIFICATIONS_READ: 'all_notifications_read', // ë°±ì—”ë“œ WSMessageType.ALL_NOTIFICATIONS_READì™€ ì¼ì¹˜
  MENTION_ADDED: 'mention_added', // ë°±ì—”ë“œ WSMessageType.MENTION_ADDEDì™€ ì¼ì¹˜
};

// ì‚¬ìš©ì í™œë™ ê´€ë ¨ ì´ë²¤íŠ¸
export const USER_EVENTS = {
  USER_ONLINE: 'user_online', // ë°±ì—”ë“œ WSMessageType.USER_ONLINEì™€ ì¼ì¹˜
  USER_OFFLINE: 'user_offline', // ë°±ì—”ë“œ WSMessageType.USER_OFFLINEì™€ ì¼ì¹˜
  USER_STATUS_UPDATE: 'user_status_update', // ë°±ì—”ë“œ WSMessageType.USER_STATUS_UPDATEì™€ ì¼ì¹˜
  USER_ACTIVITY: 'user_activity', // ë°±ì—”ë“œ WSMessageType.USER_ACTIVITYì™€ ì¼ì¹˜
  USER_ACTIVITY_UPDATED: 'user_activity_updated', // ë°±ì—”ë“œ WSMessageType.USER_ACTIVITY_UPDATEDì™€ ì¼ì¹˜
  TARGET_ACTIVITY_UPDATED: 'target_activity_updated', // ë°±ì—”ë“œ WSMessageType.TARGET_ACTIVITY_UPDATEDì™€ ì¼ì¹˜
  GLOBAL_ACTIVITY_UPDATED: 'global_activity_updated', // ë°±ì—”ë“œ WSMessageType.GLOBAL_ACTIVITY_UPDATEDì™€ ì¼ì¹˜
};

// í¬ë¡¤ëŸ¬ ê´€ë ¨ ì´ë²¤íŠ¸
export const CRAWLER_EVENTS = {
  CRAWLER_UPDATE_PROGRESS: 'crawler_update_progress', // ë°±ì—”ë“œ WSMessageType.CRAWLER_UPDATE_PROGRESSì™€ ì¼ì¹˜
  CRAWLER_COMPLETED: 'crawler_completed', // ë°±ì—”ë“œ WSMessageType.CRAWLER_COMPLETEDì™€ ì¼ì¹˜
  CRAWLER_ERROR: 'crawler_error', // ë°±ì—”ë“œ WSMessageType.CRAWLER_ERRORì™€ ì¼ì¹˜
};

// ì‹œìŠ¤í…œ ìƒíƒœ ê´€ë ¨ ì´ë²¤íŠ¸
export const SYSTEM_EVENTS = {
  SYSTEM_MESSAGE: 'system_message', // ë°±ì—”ë“œ WSMessageType.SYSTEM_MESSAGEì™€ ì¼ì¹˜
  SYSTEM_STATUS: 'system_status', // ë°±ì—”ë“œ WSMessageType.SYSTEM_STATUSì™€ ì¼ì¹˜
  MAINTENANCE_NOTICE: 'maintenance_notice', // ë°±ì—”ë“œ WSMessageType.MAINTENANCE_NOTICEì™€ ì¼ì¹˜
};

// ìºì‹œ ê´€ë ¨ ì´ë²¤íŠ¸
export const CACHE_EVENTS = {
  CACHE_INVALIDATED: 'cache_invalidated', // ë°±ì—”ë“œ WSMessageType.CACHE_INVALIDATEDì™€ ì¼ì¹˜
  CACHE_STATUS: 'cache_status', // ë°±ì—”ë“œ WSMessageType.CACHE_STATUSì™€ ì¼ì¹˜
};

// ë°ì´í„° ì—…ë°ì´íŠ¸ ê´€ë ¨ ì´ë²¤íŠ¸
export const DATA_EVENTS = {
  DATA_UPDATED: 'data_updated', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: íŠ¹ì • í•„ë“œ ë°ì´í„° ì—…ë°ì´íŠ¸
  DATA_CREATED: 'data_created', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: ìƒˆë¡œìš´ ë°ì´í„° ìƒì„±
  DATA_DELETED: 'data_deleted', // í”„ë¡ íŠ¸ì—”ë“œ ì „ìš©: ë°ì´í„° ì‚­ì œ
};

// ëª¨ë“  ì´ë²¤íŠ¸ë¥¼ í•˜ë‚˜ì˜ ê°ì²´ë¡œ í†µí•© (ê¸°ì¡´ ì½”ë“œì™€ì˜ í˜¸í™˜ì„± ìœ ì§€)
export const SOCKET_EVENTS = {
  ...CONNECTION_EVENTS,
  ...PING_PONG_EVENTS,
  ...ERROR_EVENTS,
  ...CVE_EVENTS,
  ...SUBSCRIPTION_EVENTS,
  ...COMMENT_EVENTS,
  ...NOTIFICATION_EVENTS,
  ...USER_EVENTS,
  ...CRAWLER_EVENTS,
  ...SYSTEM_EVENTS,
  ...CACHE_EVENTS,
  ...DATA_EVENTS,
};

// WebSocket ì—°ê²° ìƒíƒœì— ëŒ€í•œ ìƒìˆ˜
/**
 * ì†Œì¼“ ì—°ê²° ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” ìƒìˆ˜ ì§‘í•©
 * 
 * @property DISCONNECTED - ì†Œì¼“ ì—°ê²°ì´ ëŠì–´ì§„ ìƒíƒœ
 * @property CONNECTING - ì†Œì¼“ ì—°ê²°ì„ ì‹œë„í•˜ëŠ” ì¤‘ì¸ ìƒíƒœ
 * @property CONNECTED - ì†Œì¼“ì´ ì„±ê³µì ìœ¼ë¡œ ì—°ê²°ëœ ìƒíƒœ
 * @property ERROR - ì¼ë°˜ì ì¸ ì˜¤ë¥˜ ìƒíƒœ
 * @property RECONNECTING - ì¬ì—°ê²°ì„ ì‹œë„í•˜ëŠ” ì¤‘ì¸ ìƒíƒœ
 * @property TRANSPORT_CLOSED - ì „ì†¡ ê³„ì¸µì´ ë‹«íŒ ìƒíƒœ (ì„œë²„ ì¢…ë£Œ, ë„¤íŠ¸ì›Œí¬ ë¬¸ì œ ë“±)
 * @property PING_TIMEOUT - í•‘ ìš”ì²­ì— ëŒ€í•œ ì‘ë‹µì´ íƒ€ì„ì•„ì›ƒëœ ìƒíƒœ
 * @property TRANSPORT_ERROR - ì „ì†¡ ê³„ì¸µì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•œ ìƒíƒœ
 * @property AUTH_ERROR - ì¸ì¦ ê´€ë ¨ ì˜¤ë¥˜ê°€ ë°œìƒí•œ ìƒíƒœ
 * @property TIMEOUT - ì¼ë°˜ì ì¸ íƒ€ì„ì•„ì›ƒ ì˜¤ë¥˜ê°€ ë°œìƒí•œ ìƒíƒœ
 * @property NETWORK_ERROR - ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë¬¸ì œê°€ ë°œìƒí•œ ìƒíƒœ
 * @property OFFLINE - ë„¤íŠ¸ì›Œí¬ ì˜¤í”„ë¼ì¸ ìƒíƒœ
 * @property FAILED - ì¬ì—°ê²° ì‹œë„ ì‹¤íŒ¨ ìƒíƒœ
 * @property CONFIG_ERROR - ì„¤ì • ê´€ë ¨ ì˜¤ë¥˜ ìƒíƒœ
 */
export const SOCKET_STATE = {
  DISCONNECTED: 'disconnected',
  CONNECTING: 'connecting',
  CONNECTED: 'connected',
  ERROR: 'error',
  RECONNECTING: 'reconnecting',
  TRANSPORT_CLOSED: 'transport_closed',
  PING_TIMEOUT: 'ping_timeout',
  TRANSPORT_ERROR: 'transport_error',
  AUTH_ERROR: 'auth_error',
  TIMEOUT: 'timeout',
  NETWORK_ERROR: 'network_error',
  OFFLINE: 'offline',
  FAILED: 'failed',
  CONFIG_ERROR: 'config_error'
};

// ì›¹ì†Œì¼“ ë¡œê·¸ ë¬¸ë§¥
export const WS_LOG_CONTEXT = {
  CLIENT: 'client',
  SERVER: 'server',
  TRANSPORT: 'transport',
  HANDLER: 'handler',
  CONNECTION: 'connection',
  SUBSCRIPTION: 'subscription',
  EVENT: 'event'
};

// ì›¹ì†Œì¼“ ë©”ì‹œì§€ ë°©í–¥
export const WS_DIRECTION = {
  INCOMING: 'incoming',
  OUTGOING: 'outgoing',
  INTERNAL: 'internal'
};

// ì›¹ì†Œì¼“ ìƒíƒœ ì½”ë“œ
export const WS_STATUS = {
  SUCCESS: 'success',
  ERROR: 'error',
  WARNING: 'warning',
  INFO: 'info',
  FAILURE: 'failure',
  PENDING: 'pending'
};

// íƒ€ì… ìœ í‹¸ë¦¬í‹°: ê°ì²´ì˜ ê°’ íƒ€ì…ì„ ì¶”ì¶œ
export type ValueOf<T> = T[keyof T];

// ê° ìƒìˆ˜ì— ëŒ€í•œ íƒ€ì… ì •ì˜
export type SocketEvent = ValueOf<typeof SOCKET_EVENTS>;
export type SocketState = ValueOf<typeof SOCKET_STATE>;
export type WSLogContext = ValueOf<typeof WS_LOG_CONTEXT>;
export type WSDirection = ValueOf<typeof WS_DIRECTION>;
export type WSStatus = ValueOf<typeof WS_STATUS>;

// ê° ì´ë²¤íŠ¸ ê·¸ë£¹ì— ëŒ€í•œ íƒ€ì… ì •ì˜
export type ConnectionEvent = ValueOf<typeof CONNECTION_EVENTS>;
export type PingPongEvent = ValueOf<typeof PING_PONG_EVENTS>;
export type ErrorEvent = ValueOf<typeof ERROR_EVENTS>;
export type CVEEvent = ValueOf<typeof CVE_EVENTS>;
export type SubscriptionEvent = ValueOf<typeof SUBSCRIPTION_EVENTS>;
export type CommentEvent = ValueOf<typeof COMMENT_EVENTS>;
export type NotificationEvent = ValueOf<typeof NOTIFICATION_EVENTS>;
export type UserEvent = ValueOf<typeof USER_EVENTS>;
export type CrawlerEvent = ValueOf<typeof CRAWLER_EVENTS>;
export type SystemEvent = ValueOf<typeof SYSTEM_EVENTS>;
export type CacheEvent = ValueOf<typeof CACHE_EVENTS>;
export type DataEvent = ValueOf<typeof DATA_EVENTS>;

// ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ íƒ€ì…
export type SocketEventHandler<T = any> = (data: T) => void;

// ConnectionStateChangeEvent íƒ€ì… ì •ì˜
export interface ConnectionStateChangeEvent {
  state: SocketState;
}

export default SOCKET_EVENTS;



============================================================
File: /home/CVEHub/frontend/src/core/socket/state/socketStore.ts
------------------------------------------------------------
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { Socket } from 'socket.io-client';
import { 
  CONNECTION_EVENTS, 
  SOCKET_STATE, 
  SocketState 
} from 'core/socket/services/constants';
import logger from 'shared/utils/logging';

/**
 * Socket.IO ìƒíƒœ ê´€ë¦¬ë¥¼ ìœ„í•œ Zustand ìŠ¤í† ì–´ íƒ€ì… ì •ì˜
 */
interface SocketStore {
  // ìƒíƒœ
  socket: Socket | null;
  connected: boolean;
  connectionState: SocketState;
  connectionError: Error | null;
  lastActivity: Date | null;
  eventSubscriptions: Map<string, Set<(data: any) => void>>;
  
  // ì•¡ì…˜
  setSocket: (socket: Socket | null) => Socket | null;
  setConnected: (connected: boolean) => void;
  setConnectionState: (state: SocketState) => void;
  setConnectionError: (error: Error | null) => void;
  updateLastActivity: () => void;
  
  // ì´ë²¤íŠ¸ êµ¬ë… ê´€ë¦¬
  addEventHandler: (event: string, handler: (data: any) => void) => () => void;
  removeEventHandler: (event: string, handler: (data: any) => void) => void;
  clearEventHandlers: (event: string) => void;
  clearAllSubscriptions: () => void;
  
  // ì´ë²¤íŠ¸ ë°œìƒ ê´€ë ¨
  emitEvent: (socket: Socket | null, event: string, data: any) => void;
  
  // ìœ í‹¸ë¦¬í‹°
  getEventHandlers: (event: string) => Set<(data: any) => void> | undefined;
  hasEventHandlers: (event: string) => boolean;
  getSubscribedEvents: () => string[];
}

/**
 * Socket.IO ìƒíƒœ ê´€ë¦¬ë¥¼ ìœ„í•œ Zustand ìŠ¤í† ì–´
 * 
 * ê¸°ì¡´ SocketIOContextì™€ ë³‘í–‰í•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì„¤ê³„
 */
export const useSocketStore = create<SocketStore>()(
  devtools(
    persist(
      (set, get) => ({
        // ì´ˆê¸° ìƒíƒœ
        socket: null,
        connected: false,
        connectionState: SOCKET_STATE.DISCONNECTED,
        connectionError: null,
        lastActivity: null,
        eventSubscriptions: new Map(),
        
        // ì•¡ì…˜: ì†Œì¼“ ì„¤ì •
        setSocket: (socket) => {
          set({ 
            socket,
            lastActivity: new Date()
          });
          return socket;
        },
        
        // ì•¡ì…˜: ì—°ê²° ìƒíƒœ ì„¤ì •
        setConnected: (connected) => set({ 
          connected,
          connectionState: connected ? SOCKET_STATE.CONNECTED : SOCKET_STATE.DISCONNECTED,
          lastActivity: new Date()
        }),
        
        // ì•¡ì…˜: ì—°ê²° ìƒíƒœ ì„¤ì • (ìƒì„¸)
        setConnectionState: (state) => set({ 
          connectionState: state,
          connected: state === SOCKET_STATE.CONNECTED,
          lastActivity: new Date()
        }),
        
        // ì•¡ì…˜: ì—°ê²° ì˜¤ë¥˜ ì„¤ì •
        setConnectionError: (error) => set({ 
          connectionError: error,
          connectionState: error ? SOCKET_STATE.ERROR : get().connectionState,
          lastActivity: new Date()
        }),
        
        // ì•¡ì…˜: ë§ˆì§€ë§‰ í™œë™ ì‹œê°„ ì—…ë°ì´íŠ¸
        updateLastActivity: () => set({ 
          lastActivity: new Date() 
        }),
        
        // ì•¡ì…˜: ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¶”ê°€
        addEventHandler: (event, handler) => {
          const { eventSubscriptions } = get();
          const handlers = eventSubscriptions.get(event) || new Set();
          handlers.add(handler);
          
          const newSubscriptions = new Map(eventSubscriptions);
          newSubscriptions.set(event, handlers);
          
          set({ 
            eventSubscriptions: newSubscriptions,
            lastActivity: new Date()
          });
          
          logger.debug('socketStore', `ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¶”ê°€: ${event}`, { 
            handlerCount: handlers.size 
          });
          
          // í´ë¦°ì—… í•¨ìˆ˜ ë°˜í™˜
          return () => get().removeEventHandler(event, handler);
        },
        
        // ì•¡ì…˜: ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì œê±°
        removeEventHandler: (event, handler) => {
          const { eventSubscriptions } = get();
          const handlers = eventSubscriptions.get(event);
          
          if (handlers) {
            handlers.delete(handler);
            
            const newSubscriptions = new Map(eventSubscriptions);
            if (handlers.size === 0) {
              newSubscriptions.delete(event);
              logger.debug('socketStore', `ì´ë²¤íŠ¸ ${event}ì— ëŒ€í•œ ëª¨ë“  í•¸ë“¤ëŸ¬ ì œê±°`);
            } else {
              newSubscriptions.set(event, handlers);
              logger.debug('socketStore', `ì´ë²¤íŠ¸ ${event}ì— ëŒ€í•œ í•¸ë“¤ëŸ¬ ì œê±°`, { 
                remainingHandlers: handlers.size 
              });
            }
            
            set({ 
              eventSubscriptions: newSubscriptions,
              lastActivity: new Date()
            });
          }
        },
        
        // ì•¡ì…˜: íŠ¹ì • ì´ë²¤íŠ¸ì˜ ëª¨ë“  í•¸ë“¤ëŸ¬ ì œê±°
        clearEventHandlers: (event) => {
          const { eventSubscriptions } = get();
          
          if (eventSubscriptions.has(event)) {
            const newSubscriptions = new Map(eventSubscriptions);
            newSubscriptions.delete(event);
            
            set({ 
              eventSubscriptions: newSubscriptions,
              lastActivity: new Date()
            });
            
            logger.debug('socketStore', `ì´ë²¤íŠ¸ ${event}ì— ëŒ€í•œ ëª¨ë“  í•¸ë“¤ëŸ¬ ì œê±°`);
          }
        },
        
        // ì•¡ì…˜: ëª¨ë“  ì´ë²¤íŠ¸ êµ¬ë… ì œê±°
        clearAllSubscriptions: () => {
          set({ 
            eventSubscriptions: new Map(),
            lastActivity: new Date()
          });
          
          logger.debug('socketStore', 'ëª¨ë“  ì´ë²¤íŠ¸ êµ¬ë… ì œê±°');
        },
        
        // ì•¡ì…˜: ì´ë²¤íŠ¸ ë°œìƒ
        emitEvent: (socket, event, data) => {
          if (!socket) {
            logger.warn('socketStore', `ì†Œì¼“ ì—†ì´ ì´ë²¤íŠ¸ ë°œìƒ ì‹œë„: ${event}`);
            return;
          }
          
          try {
            socket.emit(event, data);
            get().updateLastActivity();
            
            logger.debug('socketStore', `ì´ë²¤íŠ¸ ë°œìƒ: ${event}`, { 
              dataType: typeof data 
            });
          } catch (error) {
            logger.error('socketStore', `ì´ë²¤íŠ¸ ë°œìƒ ì¤‘ ì˜¤ë¥˜: ${event}`, error);
          }
        },
        
        // ìœ í‹¸ë¦¬í‹°: ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ê°€ì ¸ì˜¤ê¸°
        getEventHandlers: (event) => {
          return get().eventSubscriptions.get(event);
        },
        
        // ìœ í‹¸ë¦¬í‹°: ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        hasEventHandlers: (event) => {
          const handlers = get().eventSubscriptions.get(event);
          return !!handlers && handlers.size > 0;
        },
        
        // ìœ í‹¸ë¦¬í‹°: êµ¬ë… ì¤‘ì¸ ì´ë²¤íŠ¸ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        getSubscribedEvents: () => {
          return Array.from(get().eventSubscriptions.keys());
        }
      }),
      { 
        name: 'socket-storage',
        partialize: (state) => ({
          connected: state.connected,
          connectionState: state.connectionState,
          connectionError: state.connectionError,
          lastActivity: state.lastActivity
        }),
        onRehydrateStorage: () => (state) => {
          // ì¬ìˆ˜í™” ì‹œ Map ê°ì²´ ì´ˆê¸°í™”
          if (state) {
            // ì•ˆì „í•˜ê²Œ eventSubscriptions Map ì´ˆê¸°í™”
            state.eventSubscriptions = new Map();
            
            logger.debug('socketStore', 'ìŠ¤í† ì–´ ìƒíƒœ ì¬ìˆ˜í™” ì™„ë£Œ', {
              connected: state.connected,
              connectionState: state.connectionState
            });
          }
        }
      }
    )
  )
);

// ìŠ¤í† ì–´ ìƒíƒœ ë³€ê²½ êµ¬ë… í•¨ìˆ˜
export const subscribeToSocketStore = (
  selector: (state: SocketStore) => any,
  callback: (selectedState: any, previousState: any) => void
) => {
  let previousState = selector(useSocketStore.getState());
  
  return useSocketStore.subscribe((state) => {
    const currentState = selector(state);
    if (currentState !== previousState) {
      callback(currentState, previousState);
      previousState = currentState;
    }
  });
};

// ìŠ¤í† ì–´ ìƒíƒœ ì§ì ‘ ì ‘ê·¼ í•¨ìˆ˜ (ì»´í¬ë„ŒíŠ¸ ì™¸ë¶€ ì‚¬ìš©)
export const getSocketState = () => useSocketStore.getState();

// ìŠ¤í† ì–´ ì•¡ì…˜ ì§ì ‘ ì ‘ê·¼ í•¨ìˆ˜ (ì»´í¬ë„ŒíŠ¸ ì™¸ë¶€ ì‚¬ìš©)
export const socketActions = {
  setSocket: (socket: Socket | null) => {
    useSocketStore.getState().setSocket(socket);
    return socket;
  },
  setConnected: (connected: boolean) => useSocketStore.getState().setConnected(connected),
  setConnectionState: (state: SocketState) => useSocketStore.getState().setConnectionState(state),
  setConnectionError: (error: Error | null) => useSocketStore.getState().setConnectionError(error),
  updateConnectionState: (data: { connectionState: SocketState; isConnected: boolean }) => {
    useSocketStore.getState().setConnectionState(data.connectionState);
    useSocketStore.getState().setConnected(data.isConnected);
  },
  emitEvent: (socket: Socket | null, event: string, data: any) => 
    useSocketStore.getState().emitEvent(socket, event, data),
  addEventHandler: (event: string, handler: (data: any) => void) => 
    useSocketStore.getState().addEventHandler(event, handler),
  removeEventHandler: (event: string, handler: (data: any) => void) => 
    useSocketStore.getState().removeEventHandler(event, handler),
  clearEventHandlers: (event: string) => 
    useSocketStore.getState().clearEventHandlers(event),
  clearAllSubscriptions: () => 
    useSocketStore.getState().clearAllSubscriptions()
};

export default useSocketStore;



============================================================
File: /home/CVEHub/frontend/src/core/socket/hooks/useSocket.ts
------------------------------------------------------------
import { useEffect, useRef, useState, useCallback } from 'react';
import { Subscription, Observable } from 'rxjs';
import { useQueryClient, QueryKey } from '@tanstack/react-query';

import { v4 as uuidv4 } from 'uuid';
import _ from 'lodash';
import useSocketStore from '../state/socketStore';
import logger from 'shared/utils/logging';
import socketService from '../services/socketService';

/**
 * ì†Œì¼“ í›… ì˜µì…˜ ì¸í„°í˜ì´ìŠ¤
 */
export interface SocketHookOptions<TData = any, TPayload = any> {
  /**
   * RxJS Observable ì‚¬ìš© ì—¬ë¶€
   */
  useRxJS?: boolean;
  
  /**
   * ì—°ê²° ì¦‰ì‹œ êµ¬ë… ì—¬ë¶€
   */
  subscribeImmediately?: boolean;
  
  /**
   * ì´ë²¤íŠ¸ í•„í„°ë§ ì¡°ê±´
   */
  filterPredicate?: (data: TPayload) => boolean;
  
  /**
   * ì»´í¬ë„ŒíŠ¸ ID (ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ê´€ë¦¬ìš©)
   */
  componentId?: string;
  
  /**
   * ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì‚¬ìš© ì—¬ë¶€
   */
  optimisticUpdate?: boolean;
  
  /**
   * ì¿¼ë¦¬ í‚¤
   */
  queryKey?: QueryKey;
  
  /**
   * ì¿¼ë¦¬ ë¬´íš¨í™” ëŒ€ì‹  ì§ì ‘ ì—…ë°ì´íŠ¸ë¥¼ ìˆ˜í–‰í• ì§€ ì—¬ë¶€
   */
  directUpdate?: boolean;
  
  /**
   * ë°ì´í„° ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ë‚™ê´€ì  ì—…ë°ì´íŠ¸ì— ì‚¬ìš©)
   */
  updateDataFn?: (oldData: TData, newData: TPayload) => TData;
  
  /**
   * ë””ë°”ìš´ìŠ¤ ì§€ì—° ì‹œê°„ (ë°€ë¦¬ì´ˆ)
   */
  debounceDelay?: number;
  
  /**
   * ì“°ë¡œí‹€ ì§€ì—° ì‹œê°„ (ë°€ë¦¬ì´ˆ)
   */
  throttleDelay?: number;
  
  /**
   * ì´ë²¤íŠ¸ ì—ëŸ¬ í•¸ë“¤ëŸ¬
   */
  onError?: (error: Error) => void;
  
  /**
   * ì—°ê²° ìƒíƒœ ë³€ê²½ ì‹œ í˜¸ì¶œë  ì½œë°±
   */
  onConnectionChange?: (connected: boolean) => void;
}

/**
 * ì†Œì¼“ í›… ë°˜í™˜ ì¸í„°í˜ì´ìŠ¤
 */
export interface SocketHookResult<TPayload = any> {
  /** ì´ë²¤íŠ¸ êµ¬ë… ì—¬ë¶€ */
  isSubscribed: boolean;
  
  /** ì´ë²¤íŠ¸ êµ¬ë… í•¨ìˆ˜ */
  subscribe: (event?: string) => void;
  
  /** ì´ë²¤íŠ¸ êµ¬ë… í•´ì œ í•¨ìˆ˜ */
  unsubscribe: (event?: string) => void;
  
  /** ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ í•¨ìˆ˜ */
  on: <T = any>(eventName: string, callback: (data: T) => void) => () => void;
  
  /** ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ í•¨ìˆ˜ (onì˜ ë³„ì¹­) */
  addEventListener: <T = any>(eventName: string, callback: (data: T) => void) => () => void;
  
  /** ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° í•¨ìˆ˜ */
  off: <T = any>(eventName: string, callback: (data: T) => void) => void;
  
  /** ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° í•¨ìˆ˜ (offì˜ ë³„ì¹­) */
  removeEventListener: <T = any>(eventName: string, callback: (data: T) => void) => void;
  
  /** ì¼ë°˜ ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜ */
  emit: (messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => void;
  
  /** ë””ë°”ìš´ìŠ¤ëœ ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜ */
  emitDebounced: (messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => void;
  
  /** ì“°ë¡œí‹€ëœ ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜ */
  emitThrottled: (messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => void;
  
  /** ì†Œì¼“ ì—°ê²° ìƒíƒœ */
  connected: boolean;
  
  /** ì—°ê²° ìƒíƒœ ë¬¸ìì—´ */
  connectionState: string;
  
  /** ì—°ê²° ì˜¤ë¥˜ */
  connectionError: Error | null;
  
  /** ì†Œì¼“ ì¸ìŠ¤í„´ìŠ¤ */
  socket: any;
  
  /** ê°€ì¥ ìµœê·¼ì— ìˆ˜ì‹ í•œ ë°ì´í„° */
  lastReceivedData: TPayload | null;
  
  /** ì—°ê²° ìƒíƒœ Observable */
  connectionState$: Observable<string>;
  
  /** ì›¹ì†Œì¼“ ì •ë¦¬ í•¨ìˆ˜ */
  cleanup: () => void;
  
  /** CVE êµ¬ë… í•¨ìˆ˜ */
  subscribeCVE: (cveId: string) => void;
  
  /** CVE êµ¬ë… í•´ì œ í•¨ìˆ˜ */
  unsubscribeCVE: (cveId: string) => void;
  
  /** CVE êµ¬ë… ìƒíƒœ í™•ì¸ í•¨ìˆ˜ */
  isSubscribedToCVE: (cveId: string) => boolean;
  
  /** êµ¬ë… ì¤‘ì¸ CVE ëª©ë¡ */
  subscribedCVEs: string[];
}

/**
 * í†µí•© ì›¹ì†Œì¼“ í›…
 * 
 * socketServiceë¥¼ í™œìš©í•˜ì—¬ ì›¹ì†Œì¼“ ì—°ê²° ë° ì´ë²¤íŠ¸ ì²˜ë¦¬ë¥¼ ê°„ì†Œí™”í•˜ëŠ” í†µí•© í›…ì…ë‹ˆë‹¤.
 * 
 * @param event - êµ¬ë…í•  ì´ë²¤íŠ¸ ì´ë¦„ (ì˜µì…˜)
 * @param callback - ì´ë²¤íŠ¸ ë°œìƒ ì‹œ í˜¸ì¶œë  ì½œë°± í•¨ìˆ˜ (ì˜µì…˜)
 * @param deps - ì½œë°± í•¨ìˆ˜ì˜ ì˜ì¡´ì„± ë°°ì—´
 * @param options - í›… ì˜µì…˜
 * @returns ì†Œì¼“ í›… ê²°ê³¼
 */
export function useSocket<TData = any, TPayload = any>(
  event?: string,
  callback?: (data: TPayload) => void,
  deps: React.DependencyList = [],
  options: SocketHookOptions<TData, TPayload> = {}
): SocketHookResult<TPayload> {
  // ì˜µì…˜ ì„¤ì •
  const {
    useRxJS = false,
    subscribeImmediately = true,
    filterPredicate,
    componentId = uuidv4(),
    optimisticUpdate = false,
    queryKey,
    directUpdate = false,
    updateDataFn,
    debounceDelay = 300,
    throttleDelay = 300,
    onError,
    onConnectionChange
  } = options;
  
  // í›… ìƒíƒœ
  const [isSubscribed, setIsSubscribed] = useState<boolean>(false);
  const [lastReceivedData, setLastReceivedData] = useState<TPayload | null>(null);
  
  // ì¿¼ë¦¬ í´ë¼ì´ì–¸íŠ¸
  const queryClient = useQueryClient();
  
  // ë ˆí¼ëŸ°ìŠ¤
  const callbackRef = useRef<((data: TPayload) => void) | undefined>(callback);
  const eventRef = useRef<string | undefined>(event);
  const subscriptionRef = useRef<Subscription | null>(null);
  const eventHandlersRef = useRef<Map<string, Set<(data: any) => void>>>(new Map());
  const eventNamesRef = useRef<Set<string>>(new Set());
  const debouncedFnRef = useRef<{[key: string]: _.DebouncedFunc<any>}>({});
  const throttledFnRef = useRef<{[key: string]: _.ThrottleFunc<any>}>({});
  const subscribedCVEsRef = useRef<Set<string>>(new Set());
  const onErrorRef = useRef<((error: Error) => void) | undefined>(onError);
  
  // ì†Œì¼“ ìŠ¤í† ì–´ì—ì„œ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
  const socketState = useSocketStore();
  const {
    connected,
    connectionState,
    connectionError
  } = socketState;
  
  // ì½œë°± ì—…ë°ì´íŠ¸
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);
  
  // ì´ë²¤íŠ¸ ì—…ë°ì´íŠ¸
  useEffect(() => {
    eventRef.current = event;
  }, [event]);
  
  // onError ì½œë°± ì—…ë°ì´íŠ¸
  useEffect(() => {
    onErrorRef.current = onError;
  }, [onError]);
  
  // í•„í„°ë§ëœ ì½œë°± ìƒì„±
  const filteredCallback = useCallback((data: TPayload) => {
    // í•„í„°ë§ ì¡°ê±´ì´ ìˆê³  ë°ì´í„°ê°€ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•Šìœ¼ë©´ ë¬´ì‹œ
    if (filterPredicate && !filterPredicate(data)) {
      return;
    }
    
    // ìµœê·¼ ìˆ˜ì‹  ë°ì´í„° ì—…ë°ì´íŠ¸
    setLastReceivedData(data);
    
    // ì½œë°± í˜¸ì¶œ
    if (callbackRef.current) {
      callbackRef.current(data);
    }
    
    // React Query í†µí•© - ìµœì í™”ëœ ë¡œì»¬ ì—…ë°ì´íŠ¸ ë˜ëŠ” ë¬´íš¨í™”
    if (queryKey && data) {
      if (directUpdate && updateDataFn) {
        // ì§ì ‘ ì—…ë°ì´íŠ¸
        queryClient.setQueryData(queryKey, (oldData: TData) => {
          return updateDataFn(oldData, data);
        });
      } else if (optimisticUpdate) {
        // ë‚™ê´€ì  ì—…ë°ì´íŠ¸ (ë¬´íš¨í™” + ë¡œì»¬ ì—…ë°ì´íŠ¸)
        queryClient.invalidateQueries({ queryKey });
      } else {
        // ê¸°ë³¸ ë¬´íš¨í™”
        queryClient.invalidateQueries({ queryKey });
      }
    }
  }, [queryKey, optimisticUpdate, filterPredicate, directUpdate, updateDataFn, queryClient]);
  
  // ì´ë²¤íŠ¸ êµ¬ë… í•¨ìˆ˜
  const subscribe = useCallback((newEvent?: string) => {
    try {
      const targetEvent = newEvent || eventRef.current;
      
      if (!targetEvent) {
        logger.warn('useSocket', 'êµ¬ë…í•  ì´ë²¤íŠ¸ë¥¼ ì§€ì •í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        return;
      }
      
      // ì´ë¯¸ ê°™ì€ ì´ë²¤íŠ¸ë¥¼ êµ¬ë… ì¤‘ì´ë©´ ë¬´ì‹œ
      if (eventNamesRef.current.has(targetEvent)) {
        return;
      }
      
      // ì´ë²¤íŠ¸ êµ¬ë… (RxJS ì‚¬ìš© ì—¬ë¶€ì— ë”°ë¼ ë‹¤ë¥¸ ë°©ì‹ ì ìš©)
      if (useRxJS) {
        if (subscriptionRef.current) {
          subscriptionRef.current.unsubscribe();
        }
        
        // RxJS ì‚¬ìš© ì‹œ Observable êµ¬ë…
        subscriptionRef.current = socketService.fromEvent<TPayload>(targetEvent)
          .subscribe({
            next: filteredCallback,
            error: (error) => {
              if (onErrorRef.current) {
                onErrorRef.current(error);
              } else {
                logger.error('useSocket', `ì´ë²¤íŠ¸ [${targetEvent}] ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ`, error);
              }
            }
          });
      } else {
        // ì¼ë°˜ ì½œë°± ê¸°ë°˜ êµ¬ë…
        const handler = (data: TPayload) => filteredCallback(data);
        
        // ì½œë°±ì„ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë§µì— ì¶”ê°€
        if (!eventHandlersRef.current.has(targetEvent)) {
          eventHandlersRef.current.set(targetEvent, new Set());
        }
        
        const handlers = eventHandlersRef.current.get(targetEvent);
        if (handlers) {
          handlers.add(handler);
        }
        
        // ì´ë²¤íŠ¸ ìˆ˜ì‹  ì‹œì‘
        socketService.on(targetEvent, handler);
      }
      
      // ì´ë²¤íŠ¸ ì´ë¦„ ì¶”ê°€ ë° êµ¬ë… ìƒíƒœ ì—…ë°ì´íŠ¸
      eventNamesRef.current.add(targetEvent);
      setIsSubscribed(true);
      logger.debug('useSocket', `ì´ë²¤íŠ¸ [${targetEvent}] êµ¬ë… ì‹œì‘`);
      
    } catch (error) {
      logger.error('useSocket', 'ì´ë²¤íŠ¸ êµ¬ë… ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [filteredCallback, useRxJS]);
  
  // ì´ë²¤íŠ¸ êµ¬ë… í•´ì œ í•¨ìˆ˜
  const unsubscribe = useCallback((targetEvent?: string) => {
    try {
      // ëª¨ë“  ì´ë²¤íŠ¸ ì²˜ë¦¬ ë˜ëŠ” íŠ¹ì • ì´ë²¤íŠ¸ ì²˜ë¦¬
      const eventsToUnsubscribe = targetEvent 
        ? (eventNamesRef.current.has(targetEvent) ? [targetEvent] : [])
        : Array.from(eventNamesRef.current);
      
      if (eventsToUnsubscribe.length === 0) {
        return;
      }
      
      // ê° ì´ë²¤íŠ¸ êµ¬ë… í•´ì œ
      for (const evt of eventsToUnsubscribe) {
        // RxJS ì‚¬ìš© ì‹œ êµ¬ë… ì·¨ì†Œ
        if (useRxJS && subscriptionRef.current) {
          subscriptionRef.current.unsubscribe();
          subscriptionRef.current = null;
        } else {
          // ë“±ë¡ëœ ëª¨ë“  í•¸ë“¤ëŸ¬ ì œê±°
          const handlers = eventHandlersRef.current.get(evt);
          if (handlers) {
            handlers.forEach(handler => {
              socketService.off(evt, handler);
            });
            handlers.clear();
          }
        }
        
        // ì´ë²¤íŠ¸ ì´ë¦„ ëª©ë¡ì—ì„œ ì œê±°
        eventNamesRef.current.delete(evt);
        eventHandlersRef.current.delete(evt);
        logger.debug('useSocket', `ì´ë²¤íŠ¸ [${evt}] êµ¬ë… í•´ì œ`);
      }
      
      // êµ¬ë… ì¤‘ì¸ ì´ë²¤íŠ¸ê°€ ì—†ìœ¼ë©´ êµ¬ë… ìƒíƒœ ì—…ë°ì´íŠ¸
      if (eventNamesRef.current.size === 0) {
        setIsSubscribed(false);
      }
      
    } catch (error) {
      logger.error('useSocket', 'ì´ë²¤íŠ¸ êµ¬ë… í•´ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [useRxJS]);
  
  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ í•¨ìˆ˜
  const on = useCallback(<T = any>(eventName: string, callback: (data: T) => void) => {
    try {
      // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë§µì— ì´ë²¤íŠ¸ ì¶”ê°€
      if (!eventHandlersRef.current.has(eventName)) {
        eventHandlersRef.current.set(eventName, new Set());
      }
      
      // í•¸ë“¤ëŸ¬ ì¶”ê°€
      const handlers = eventHandlersRef.current.get(eventName);
      if (handlers) {
        handlers.add(callback as any);
      }
      
      // ì´ë²¤íŠ¸ ìˆ˜ì‹  ì‹œì‘
      socketService.on(eventName, callback);
      
      // ì´ë²¤íŠ¸ ì´ë¦„ ì¶”ê°€
      eventNamesRef.current.add(eventName);
      
      // ì œê±° í•¨ìˆ˜ ë°˜í™˜
      return () => {
        const handlers = eventHandlersRef.current.get(eventName);
        if (handlers) {
          handlers.delete(callback as any);
        }
        socketService.off(eventName, callback);
        
        // í•¸ë“¤ëŸ¬ê°€ ì—†ìœ¼ë©´ ì´ë²¤íŠ¸ ì´ë¦„ ì œê±°
        if (handlers && handlers.size === 0) {
          eventNamesRef.current.delete(eventName);
          eventHandlersRef.current.delete(eventName);
        }
      };
    } catch (error) {
      logger.error('useSocket', `ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${eventName})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
      // ë”ë¯¸ ì œê±° í•¨ìˆ˜ ë°˜í™˜
      return () => {};
    }
  }, []);
  
  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° í•¨ìˆ˜
  const off = useCallback(<T = any>(eventName: string, callback: (data: T) => void) => {
    try {
      // í•¸ë“¤ëŸ¬ ì œê±°
      const handlers = eventHandlersRef.current.get(eventName);
      if (handlers) {
        handlers.delete(callback as any);
      }
      
      // ì†Œì¼“ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
      socketService.off(eventName, callback);
      
      // í•¸ë“¤ëŸ¬ê°€ ì—†ìœ¼ë©´ ì´ë²¤íŠ¸ ì´ë¦„ ì œê±°
      if (handlers && handlers.size === 0) {
        eventNamesRef.current.delete(eventName);
        eventHandlersRef.current.delete(eventName);
      }
      
    } catch (error) {
      logger.error('useSocket', `ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${eventName})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, []);
  
  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ í•¨ìˆ˜ (onì˜ ë³„ì¹­)
  const addEventListener = useCallback(<T = any>(eventName: string, callback: (data: T) => void) => {
    return on(eventName, callback);
  }, [on]);
  
  // ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜
  const emit = useCallback((messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => {
    try {
      if (!connected) {
        logger.warn('useSocket', 'ì†Œì¼“ì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë©”ì‹œì§€ë¥¼ ì „ì†¡í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      
      // ë¡œì»¬ ì—…ë°ì´íŠ¸ (ì œê³µëœ ê²½ìš°)
      if (localUpdateCallback) {
        localUpdateCallback(data);
      }
      
      // ë©”ì‹œì§€ ì „ì†¡
      socketService.emit(messageEvent, data);
      
    } catch (error) {
      logger.error('useSocket', `ë©”ì‹œì§€ ì „ì†¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${messageEvent})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [connected]);
  
  // ë””ë°”ìš´ìŠ¤ëœ ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜
  const debouncedEmit = useCallback((messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => {
    try {
      // ë””ë°”ìš´ìŠ¤ í•¨ìˆ˜ê°€ ì—†ìœ¼ë©´ ìƒì„±
      if (!debouncedFnRef.current[messageEvent]) {
        debouncedFnRef.current[messageEvent] = _.debounce(
          (eventData: any, callback?: (data: any) => void) => {
            emit(messageEvent, eventData, callback);
          },
          debounceDelay
        );
      }
      
      // ë””ë°”ìš´ìŠ¤ëœ í•¨ìˆ˜ í˜¸ì¶œ
      debouncedFnRef.current[messageEvent](data, localUpdateCallback);
      
    } catch (error) {
      logger.error('useSocket', `ë””ë°”ìš´ìŠ¤ëœ ë©”ì‹œì§€ ì „ì†¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${messageEvent})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [emit, debounceDelay]);
  
  // ì“°ë¡œí‹€ëœ ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜
  const throttledEmit = useCallback((messageEvent: string, data: any, localUpdateCallback?: (data: any) => void) => {
    try {
      // ì“°ë¡œí‹€ í•¨ìˆ˜ê°€ ì—†ìœ¼ë©´ ìƒì„±
      if (!throttledFnRef.current[messageEvent]) {
        throttledFnRef.current[messageEvent] = _.throttle(
          (eventData: any, callback?: (data: any) => void) => {
            emit(messageEvent, eventData, callback);
          },
          throttleDelay
        );
      }
      
      // ì“°ë¡œí‹€ëœ í•¨ìˆ˜ í˜¸ì¶œ
      throttledFnRef.current[messageEvent](data, localUpdateCallback);
      
    } catch (error) {
      logger.error('useSocket', `ì“°ë¡œí‹€ëœ ë©”ì‹œì§€ ì „ì†¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${messageEvent})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [emit, throttleDelay]);
  
  // CVE êµ¬ë… ê´€ë ¨ ë©”ì„œë“œë“¤
  // ë¦¬íŒ©í† ë§: ì´ì „ ê°ê°ì˜ ë©”ì„œë“œ ëŒ€ì‹  socketServiceì˜ updateSubscription ë©”ì„œë“œ ì‚¬ìš©
  const subscribeCVE = useCallback((cveId: string) => {
    try {
      if (!connected) {
        logger.warn('useSocket', 'ì†Œì¼“ì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. CVEë¥¼ êµ¬ë…í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      
      // ì´ë¯¸ êµ¬ë… ì¤‘ì¸ ê²½ìš° ì¤‘ë³µ ìš”ì²­ ë°©ì§€
      if (subscribedCVEsRef.current.has(cveId)) {
        return;
      }
      
      // êµ¬ë… ìƒíƒœ ì—…ë°ì´íŠ¸
      socketService.updateSubscription(cveId, true);
      
      // ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸
      subscribedCVEsRef.current.add(cveId);
      
    } catch (error) {
      logger.error('useSocket', `CVE êµ¬ë… ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${cveId})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [connected]);
  
  // CVE êµ¬ë… í•´ì œ ë©”ì„œë“œ
  const unsubscribeCVE = useCallback((cveId: string) => {
    try {
      if (!connected) {
        logger.warn('useSocket', 'ì†Œì¼“ì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. CVE êµ¬ë…ì„ í•´ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        return;
      }
      
      // êµ¬ë… ì¤‘ì´ ì•„ë‹Œ ê²½ìš° ì¤‘ë³µ ìš”ì²­ ë°©ì§€
      if (!subscribedCVEsRef.current.has(cveId)) {
        return;
      }
      
      // êµ¬ë… ìƒíƒœ ì—…ë°ì´íŠ¸
      socketService.updateSubscription(cveId, false);
      
      // ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸
      subscribedCVEsRef.current.delete(cveId);
      
    } catch (error) {
      logger.error('useSocket', `CVE êµ¬ë… í•´ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (${cveId})`, error);
      if (onErrorRef.current) {
        onErrorRef.current(error as Error);
      }
    }
  }, [connected]);
  
  // CVE êµ¬ë… ìƒíƒœ í™•ì¸ ë©”ì„œë“œ
  const isSubscribedToCVE = useCallback((cveId: string) => {
    return subscribedCVEsRef.current.has(cveId);
  }, []);
  
  // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í•¨ìˆ˜ì˜ ì—°ê²° ìƒíƒœì— ëŒ€í•œ íš¨ê³¼
  useEffect(() => {
    // ì—°ê²° ìƒíƒœ ë³€ê²½ ì‹œ ì½œë°± í˜¸ì¶œ
    if (onConnectionChange) {
      onConnectionChange(connected);
    }
    
    // ì—°ê²°ëì„ ë•Œ ì¦‰ì‹œ êµ¬ë… ì„¤ì •
    // ì¤‘ìš”: ì†Œì¼“ ì—°ê²°ì€ App.jsxì—ì„œ ê´€ë¦¬
    if (connected && subscribeImmediately && event) {
      subscribe(event);
    }
    
  }, [connected, subscribeImmediately, event, subscribe, onConnectionChange]);

  // ì†Œì¼“ ì—°ê²° ìƒíƒœ ê²€ì‚¬
  useEffect(() => {
    // ê²½ê³ : ì—¬ê¸°ì„œëŠ” ì†Œì¼“ ì—°ê²°ì„ ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ (ìµœìƒìœ„ App.jsxì—ì„œ ê´€ë¦¬)
    if (!socketService.isSocketConnected() && process.env.NODE_ENV === 'development') {
      logger.warn('useSocket', 'ì†Œì¼“ì´ ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì—°ê²°ì€ App.jsxì—ì„œ ê´€ë¦¬ë©ë‹ˆë‹¤.');
    }
  }, []);
  
  // ì •ë¦¬ í•¨ìˆ˜
  const cleanup = useCallback(() => {
    try {
      // êµ¬ë… ìƒíƒœì¸ ê²½ìš° êµ¬ë… í•´ì œ
      if (isSubscribed) {
        unsubscribe();
      }
      
      // RxJS êµ¬ë… ì·¨ì†Œ
      if (subscriptionRef.current) {
        subscriptionRef.current.unsubscribe();
        subscriptionRef.current = null;
      }
      
      // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë§µ ì •ë¦¬
      eventHandlersRef.current.clear();
      eventNamesRef.current.clear();
      setIsSubscribed(false);
      setLastReceivedData(null);
      
      // ì¤‘ìš”: ì—¬ê¸°ì„œëŠ” ì†Œì¼“ ì—°ê²°ì„ í•´ì œí•˜ì§€ ì•ŠìŒ (ìµœìƒìœ„ App.jsxì—ì„œ ê´€ë¦¬)
      logger.debug('useSocket', 'ì´ ì»´í¬ë„ŒíŠ¸ì˜ ì´ë²¤íŠ¸ êµ¬ë… ì •ë¦¬ ì™„ë£Œ');
    } catch (error) {
      logger.error('useSocket', 'ì •ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
    }
  }, [isSubscribed, unsubscribe]);
  
  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì •ë¦¬
  useEffect(() => {
    return () => {
      cleanup();
    };
  }, [cleanup]);
  
  // ì†Œì¼“ ì—°ê²° ìƒíƒœ Observable ìƒì„± (ìºì‹± ì ìš©)
  const connectionState$ = useRef<Observable<string>>(
    socketService.connectionState$()
  ).current;
  
  // í›… ê²°ê³¼ ë°˜í™˜
  return {
    // ê¸°ë³¸ ì†ì„±
    isSubscribed,
    subscribe,
    unsubscribe,
    on,
    addEventListener,
    off,
    removeEventListener: off,
    emit,
    emitDebounced: debouncedEmit,
    emitThrottled: throttledEmit,
    
    // ì—°ê²° ìƒíƒœ ì •ë³´
    connected,
    connectionState,
    connectionError,
    socket: socketService.getSocket(),
    lastReceivedData,
    connectionState$,
    
    // ì¶”ê°€ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
    cleanup,
    
    // CVE êµ¬ë… ê´€ë ¨ ë©”ì†Œë“œ
    subscribeCVE,
    unsubscribeCVE,
    isSubscribedToCVE,
    subscribedCVEs: Array.from(subscribedCVEsRef.current)
  };
}

// ì „ì—­ ì˜¤ë¥˜ í•¸ë“¤ëŸ¬ ì¶”ê°€
useSocket.error = function(error: Error): void {
  logger.error('useSocket.global', 'ì†Œì¼“ ì˜¤ë¥˜ ë°œìƒ', error);
};

// export default useSocketë¡œë„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì„¤ì •
export default useSocket;


============================================================
File: /home/CVEHub/frontend/src/core/socket/bridge/WebSocketQueryBridge.tsx
------------------------------------------------------------
import React, { useEffect, useRef, useMemo, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { useSocket } from 'core/socket/hooks/useSocket';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { 
  SOCKET_EVENTS, 
  SOCKET_STATE, 
  SUBSCRIPTION_EVENTS,
  COMMENT_EVENTS
} from 'core/socket/services/constants';
import _ from 'lodash';
import logger from 'shared/utils/logging';
import socketEventBus from 'core/socket/services/socketEventBus';
import { Subscription } from 'rxjs';

// ì´ë²¤íŠ¸-ì¿¼ë¦¬ ë§¤í•‘ ì •ì˜ (ì„ ì–¸ì  ë°©ì‹)
interface EventQueryMapping {
  event: string;
  queries: string[][];
  getDetailQuery?: (data: any) => string[] | null;
}

// êµ¬ë…ì ì •ë³´ íƒ€ì… ì •ì˜
interface Subscriber {
  id: string;
  userId: string;
  username: string;
  displayName: string;
  profileImage?: string;
}

// êµ¬ë… ìƒíƒœ ì´ë²¤íŠ¸ íƒ€ì… ì •ì˜
interface SubscriptionStatusEvent {
  cve_id: string;
  cveId?: string;
  user_id?: string;
  userId?: string;
  username?: string;
  display_name?: string;
  displayName?: string;
  profile_image?: string;
  profileImage?: string;
  subscribed: boolean;
  timestamp?: number;
  subscribers?: Subscriber[] | string[];
}

/**
 * Socket.IOì™€ React Queryë¥¼ ì—°ê²°í•˜ëŠ” ë¸Œë¦¿ì§€ ì»´í¬ë„ŒíŠ¸
 * ì†Œì¼“ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•˜ì—¬ ì ì ˆí•œ ì¿¼ë¦¬ ìºì‹œë¥¼ ë¬´íš¨í™”í•©ë‹ˆë‹¤.
 * RxJS ê¸°ë°˜ ì›¹ì†Œì¼“ êµ¬ë…ì„ ì‚¬ìš©í•˜ì—¬ ì•ˆì •ì ì¸ ì´ë²¤íŠ¸ ì²˜ë¦¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
 */
const WebSocketQueryBridge: React.FC = () => {
  // useSocket í›…ì„ ì‚¬ìš©í•˜ì§€ë§Œ, ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆëŠ” ì´ë²¤íŠ¸ ë²„ìŠ¤ë¥¼ í†µí•´ ì²˜ë¦¬
  const { connected } = useSocket();
  
  const queryClient = useQueryClient();
  const initAttemptRef = useRef(0);
  const maxInitAttempts = 5;
  const eventHandlersSetupRef = useRef(false);
  const subscriptionsRef = useRef<Subscription[]>([]);
  
  // ì²˜ë¦¬ëœ êµ¬ë… ì´ë²¤íŠ¸ë¥¼ ì¶”ì í•˜ê¸° ìœ„í•œ ì°¸ì¡°
  const processedSubscriptionEventsRef = useRef<Record<string, boolean>>({});
  
  // êµ¬ë…ì ì •ë³´ë¥¼ ì¤‘ì•™ì—ì„œ ê´€ë¦¬í•˜ëŠ” í•¨ìˆ˜
  const setCVESubscribers = useCallback((cveId: string, subscribers: Subscriber[]) => {
    // ê¸°ì¡´ êµ¬ë…ì ì •ë³´ ë¡œë“œ
    const subscribersKey = [QUERY_KEYS.CVE_SUBSCRIBERS, cveId];
    
    // ì¿¼ë¦¬ í´ë¼ì´ì–¸íŠ¸ì— ì €ì¥
    queryClient.setQueryData(subscribersKey, subscribers);
    logger.debug('WebSocketQueryBridge', `CVE ${cveId}ì˜ êµ¬ë…ì ì •ë³´ ì—…ë°ì´íŠ¸`, { subscribers });
    
    return subscribers;
  }, [queryClient]);
  
  // êµ¬ë… ìƒíƒœ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  const handleSubscriptionStatus = useCallback((data: SubscriptionStatusEvent) => {
    // ë¡œê·¸ ì¶œë ¥
    logger.info('WebSocketQueryBridge', 'êµ¬ë… ìƒíƒœ ì´ë²¤íŠ¸ ìˆ˜ì‹ ', data);
    
    if (!data || !(data.cve_id || data.cveId)) {
      logger.warn('WebSocketQueryBridge', 'êµ¬ë… ì´ë²¤íŠ¸ì— ìœ íš¨í•œ CVE IDê°€ ì—†ìŠµë‹ˆë‹¤');
      return;
    }
    
    // CVE ID ì •ê·œí™”
    const cveId = data.cve_id || data.cveId || '';
    
    // ì¤‘ë³µ ì´ë²¤íŠ¸ ì²˜ë¦¬ ë°©ì§€
    const eventId = `${cveId}_${data.timestamp || Date.now()}`;
    if (processedSubscriptionEventsRef.current[eventId]) {
      logger.debug('WebSocketQueryBridge', `ì´ë¯¸ ì²˜ë¦¬ëœ êµ¬ë… ì´ë²¤íŠ¸ ë¬´ì‹œ: ${eventId}`);
      return;
    }
    
    // ì´ë²¤íŠ¸ ì²˜ë¦¬ í‘œì‹œ
    processedSubscriptionEventsRef.current[eventId] = true;
    
    // êµ¬ë…ì ëª©ë¡ í‚¤
    const subscribersKey = [QUERY_KEYS.CVE_SUBSCRIBERS, cveId];
    
    // í˜„ì¬ êµ¬ë…ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    let subscribers: Subscriber[] = queryClient.getQueryData(subscribersKey) || [];
    
    try {
      if (data.subscribed) {
        // êµ¬ë…ì ì •ë³´ ìƒì„±
        const subscriber: Subscriber = {
          id: data.user_id || data.userId || '1', // IDê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì œê³µ
          userId: data.user_id || data.userId || '1',
          username: data.username || 'User',
          displayName: data.display_name || data.displayName || data.username || 'User',
          profileImage: data.profile_image || data.profileImage || ''
        };
        
        // êµ¬ë…ì ì¶”ê°€ (ì¤‘ë³µ ë°©ì§€)
        const exists = subscribers.some(s => s.userId === subscriber.userId);
        if (!exists) {
          subscribers = [...subscribers, subscriber];
          setCVESubscribers(cveId, subscribers);
        }
      } else {
        // êµ¬ë…ì ì œê±°
        const userId = data.user_id || data.userId;
        if (userId) {
          subscribers = subscribers.filter(s => s.userId !== userId);
          setCVESubscribers(cveId, subscribers);
        }
      }
      
      // Subscribe/Unsubscribe ìƒíƒœë¥¼ React Query ìºì‹œë¥¼ í†µí•´ ê³µìœ 
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.CVE_DETAIL, cveId] });
      
    } catch (error) {
      logger.error('WebSocketQueryBridge', 'êµ¬ë… ì´ë²¤íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
    }
  }, [queryClient, setCVESubscribers]);
  
  // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ìƒì„±
  const createEventHandler = useCallback((mapping: EventQueryMapping) => {
    return (data: any) => {
      try {
        // ë¡œê·¸ ì¶œë ¥
        logger.debug('WebSocketQueryBridge', `ì´ë²¤íŠ¸ ìˆ˜ì‹ : ${mapping.event}`, { data });
        
        // ê¸°ë³¸ ì¿¼ë¦¬ ë¬´íš¨í™” ì²˜ë¦¬
        if (mapping.queries && mapping.queries.length > 0) {
          mapping.queries.forEach(queryKey => {
            queryClient.invalidateQueries({ queryKey });
            logger.debug('WebSocketQueryBridge', `ì¿¼ë¦¬ ë¬´íš¨í™”: ${queryKey.join('.')}`, {
              queryKey
            });
          });
        }
        
        // ìƒì„¸ ì¿¼ë¦¬ ë¬´íš¨í™” ì²˜ë¦¬ (ìˆëŠ” ê²½ìš°)
        if (mapping.getDetailQuery && data) {
          const detailQueryKey = mapping.getDetailQuery(data);
          if (detailQueryKey) {
            queryClient.invalidateQueries({ queryKey: detailQueryKey });
            logger.debug('WebSocketQueryBridge', `ìƒì„¸ ì¿¼ë¦¬ ë¬´íš¨í™”: ${detailQueryKey.join('.')}`, {
              detailQueryKey
            });
          }
        }
      } catch (error) {
        logger.error('WebSocketQueryBridge', `ì´ë²¤íŠ¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${mapping.event}`, error);
      }
    };
  }, [queryClient]);
  
  // ì´ë²¤íŠ¸-ì¿¼ë¦¬ ë§¤í•‘ ì •ì˜ (ë©”ëª¨ì´ì œì´ì…˜)
  const eventQueryMapping = useMemo<EventQueryMapping[]>(() => [
    { 
      event: SOCKET_EVENTS.CVE_CREATED, 
      queries: [[QUERY_KEYS.CVE_LIST]]
    },
    { 
      event: SOCKET_EVENTS.CVE_UPDATED, 
      queries: [[QUERY_KEYS.CVE_LIST]],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
    { 
      event: SOCKET_EVENTS.CVE_DELETED, 
      queries: [[QUERY_KEYS.CVE_LIST]],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
    { 
      event: COMMENT_EVENTS.COMMENT_ADDED, 
      queries: [],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
    { 
      event: COMMENT_EVENTS.COMMENT_UPDATED, 
      queries: [],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
    { 
      event: COMMENT_EVENTS.COMMENT_DELETED, 
      queries: [],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
    { 
      event: SUBSCRIPTION_EVENTS.CVE_SUBSCRIBERS_UPDATED, 
      queries: [],
      getDetailQuery: (data) => data?.cveId ? [QUERY_KEYS.CVE_DETAIL, data.cveId] : null
    },
  ], []);
  
  // ì†Œì¼“ ì—°ê²° ì„¤ì • - useEffect ì•ˆì—ì„œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
  useEffect(() => {
    // ì—°ê²° ìƒíƒœ í™•ì¸
    if (!connected) {
      if (initAttemptRef.current < maxInitAttempts) {
        logger.warn('WebSocketQueryBridge', 'ì†Œì¼“ ì—°ê²° ëŒ€ê¸° ì¤‘...', {
          attempt: initAttemptRef.current + 1,
          maxAttempts: maxInitAttempts,
          connectedFlag: connected,
        });
        initAttemptRef.current++;
        return;
      } else if (!eventHandlersSetupRef.current) {
        logger.error('WebSocketQueryBridge', 'ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼: ì†Œì¼“ ì—°ê²° ë¶ˆê°€ëŠ¥');
        return;
      }
    }
    
    if (!eventHandlersSetupRef.current) {
      logger.info('WebSocketQueryBridge', 'ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ì‹œì‘');
      
      // ê¸°ì¡´ êµ¬ë… ì •ë¦¬
      subscriptionsRef.current.forEach(subscription => {
        if (subscription && !subscription.closed) {
          subscription.unsubscribe();
        }
      });
      subscriptionsRef.current = [];
      
      // ê° ì´ë²¤íŠ¸-ì¿¼ë¦¬ ë§¤í•‘ì— ëŒ€í•´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
      eventQueryMapping.forEach(mapping => {
        try {
          const handler = createEventHandler(mapping);
          
          // ì´ë²¤íŠ¸ ë²„ìŠ¤ë¥¼ í†µí•œ ì´ë²¤íŠ¸ êµ¬ë…
          const subscription = socketEventBus.on(mapping.event).subscribe(handler);
          
          // êµ¬ë… ê°ì²´ ì €ì¥ (ì •ë¦¬ì— ì‚¬ìš©)
          subscriptionsRef.current.push(subscription);
          
          logger.debug('WebSocketQueryBridge', `ì´ë²¤íŠ¸ "${mapping.event}" êµ¬ë… ì™„ë£Œ`);
        } catch (error) {
          logger.error('WebSocketQueryBridge', `ì´ë²¤íŠ¸ "${mapping.event}" êµ¬ë… ì¤‘ ì˜¤ë¥˜ ë°œìƒ`, error);
        }
      });
      
      // êµ¬ë… ìƒíƒœ ì´ë²¤íŠ¸ ì¶”ê°€ ì²˜ë¦¬
      try {
        const subscription = socketEventBus.on<SubscriptionStatusEvent>(SUBSCRIPTION_EVENTS.SUBSCRIPTION_STATUS)
          .subscribe(handleSubscriptionStatus);
        subscriptionsRef.current.push(subscription);
        logger.debug('WebSocketQueryBridge', 'êµ¬ë… ìƒíƒœ ì´ë²¤íŠ¸ êµ¬ë… ì™„ë£Œ');
      } catch (error) {
        logger.error('WebSocketQueryBridge', 'êµ¬ë… ìƒíƒœ ì´ë²¤íŠ¸ êµ¬ë… ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
      }
      
      eventHandlersSetupRef.current = true;
      logger.info('WebSocketQueryBridge', 'ëª¨ë“  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ì™„ë£Œ');
    }
    
    // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì •ë¦¬
    return () => {
      logger.info('WebSocketQueryBridge', 'ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬');
      subscriptionsRef.current.forEach(subscription => {
        if (subscription && !subscription.closed) {
          subscription.unsubscribe();
        }
      });
      subscriptionsRef.current = [];
    };
  }, [connected, eventQueryMapping, createEventHandler, handleSubscriptionStatus]);
  
  // ì†Œì¼“ ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§ ë° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¬ì„¤ì •
  useEffect(() => {
    // ì—°ê²° ìƒíƒœê°€ ë³€ê²½ë˜ì–´ ì—°ê²°ë˜ì—ˆì„ ë•Œ, ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ì¬ì‹œë„
    if (connected && !eventHandlersSetupRef.current) {
      logger.info('WebSocketQueryBridge', 'ì†Œì¼“ì´ ì—°ê²°ë˜ì–´ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì„¤ì • ì¬ì‹œë„');
      initAttemptRef.current = 0; // ì‹œë„ íšŸìˆ˜ ì´ˆê¸°í™”
    }
  }, [connected]);
  
  // ë¸Œë¦¿ì§€ ì»´í¬ë„ŒíŠ¸ëŠ” UIë¥¼ ë Œë”ë§í•˜ì§€ ì•ŠìŒ
  return null;
};

export default WebSocketQueryBridge;


============================================================
File: /home/CVEHub/frontend/src/index.js
------------------------------------------------------------
import React from 'react';
import { createRoot } from 'react-dom/client';
import './styles/index.css';
import App from './App.jsx';  // .jsx í™•ì¥ì ëª…ì‹œ
import logger, { LOG_LEVEL } from 'shared/utils/logging';

// ë¡œê·¸ ë ˆë²¨ ì„¤ì • (ê°œë°œ í™˜ê²½ì—ì„œ INFO ë ˆë²¨ë¡œ ì„¤ì •í•˜ì—¬ ë¡œê·¸ ì–‘ ê°ì†Œ)
if (process.env.NODE_ENV === 'development') {
  logger.setLogLevel(LOG_LEVEL.DEBUG);
  logger.setEnabled(true);
  console.log('[App] ë¡œê¹… ì‹œìŠ¤í…œ ì´ˆê¸°í™” - ê°œë°œ í™˜ê²½ì—ì„œ INFO ë ˆë²¨ë¡œ ì„¤ì •ë¨');
} else {
  logger.setLogLevel(LOG_LEVEL.WARN);
  logger.setEnabled(true);
  console.log('[App] ë¡œê¹… ì‹œìŠ¤í…œ ì´ˆê¸°í™” - í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ WARN ë ˆë²¨ë¡œ ì„¤ì •ë¨');
}

// ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì´ˆê¸°í™”
// localStorage.clear();

const root = createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);



============================================================
File: /home/CVEHub/frontend/src/shared/api/types/api.ts
------------------------------------------------------------
/**
 * API ê´€ë ¨ íƒ€ì… ì •ì˜ íŒŒì¼
 */

/**
 * API ì‘ë‹µ ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤
 */
export interface ApiResponse<T = any> {
    success: boolean;
    message?: string;
    data?: T;
    error?: string;
    errorCode?: string;
  }
  
  /**
   * í˜ì´ì§€ë„¤ì´ì…˜ ì •ë³´ ì¸í„°í˜ì´ìŠ¤
   */
  export interface PaginationInfo {
    page: number;
    limit: number;
    total: number;
    totalPages?: number;
  }
  
  /**
   * í˜ì´ì§€ë„¤ì´ì…˜ ì‘ë‹µ ì¸í„°í˜ì´ìŠ¤
   */
  export interface PaginatedResponse<T = any> {
    items: T[];
    total: number;
    page: number;
    limit: number;
    pagination?: PaginationInfo;
  }
  
  /**
   * API ìš”ì²­ ì˜µì…˜ ì¸í„°í˜ì´ìŠ¤
   */
  export interface ApiRequestOptions {
    skipAuthRefresh?: boolean;
    bypassCache?: boolean;
    headers?: Record<string, string>;
    meta?: Record<string, any>;
  }
  
  /**
   * API ì—ëŸ¬ ì¸í„°í˜ì´ìŠ¤
   */
  export interface ApiError extends Error {
    status?: number;
    code?: number | string;
    response?: {
      data?: {
        detail?: string;
        message?: string;
        errorCode?: string;
      };
      status?: number;
    };
  }
  
  /**
   * API ìƒíƒœ ì½”ë“œ íƒ€ì…
   */
  export type StatusCode = 
    | 200 // OK
    | 201 // Created
    | 204 // No Content
    | 400 // Bad Request
    | 401 // Unauthorized
    | 403 // Forbidden
    | 404 // Not Found
    | 409 // Conflict
    | 422 // Unprocessable Entity
    | 500 // Internal Server Error
    | 503; // Service Unavailable


============================================================
File: /home/CVEHub/frontend/src/shared/api/types/components.ts
------------------------------------------------------------
/**
 * ì»´í¬ë„ŒíŠ¸ ê´€ë ¨ íƒ€ì… ì •ì˜ íŒŒì¼
 */

import { ReactNode } from 'react';
import { Theme } from '@mui/material/styles';
import { SxProps } from '@mui/system';
import { CVEDetail } from 'features/cve/types/cve';
import { User } from 'features/auth/types';

/**
 * ê³µí†µ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface CommonComponentProps {
  children?: ReactNode;
  className?: string;
  style?: React.CSSProperties;
  sx?: SxProps<Theme>;
}

/**
 * ë ˆì´ì•„ì›ƒ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface LayoutProps extends CommonComponentProps {
  title?: string;
}

/**
 * CVE ì»´í¬ë„ŒíŠ¸ ê´€ë ¨ í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */

// CVE ìƒì„¸ ì •ë³´ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤
export interface CVEDetailProps {
  cveId: string;
  open?: boolean;
  onClose: () => void;
  highlightCommentId?: string | null;
}

// CVE ëª©ë¡ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤
export interface CVEListProps extends CommonComponentProps {
  selectedCVE?: string;
  setSelectedCVE?: (cveId: string) => void;
}

// CVE ìƒì„± ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤
export interface CreateCVEProps extends CommonComponentProps {
  onSuccess?: (cveId: string) => void;
  onCancel?: () => void;
}

// ì¸ë¼ì¸ ìˆ˜ì • í…ìŠ¤íŠ¸ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤
export interface InlineEditTextProps {
  value?: string;
  onSave: (newValue: string) => void;
  placeholder?: string;
  multiline?: boolean;
  disabled?: boolean;
  fontSize?: string | number;
  externalEdit?: boolean;
  onEditingStart?: () => void;
  onEditingEnd?: () => void;
}

// ëŒ“ê¸€ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤
export interface CommentProps {
  comment: any; // Comment íƒ€ì…
  cveId: string;
  currentUser: User;
  onReply?: (commentId: string) => void;
  onEdit?: (commentId: string, newContent: string) => void;
  onDelete?: (commentId: string) => void;
  sendMessage?: (type: string, data: any) => Promise<any>;
  depth?: number;
  refreshTrigger?: number;
}

// ëŒ“ê¸€ íƒ­ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤
export interface CommentsTabProps {
  cve: CVEDetail;
  currentUser: User;
  refreshTrigger?: number;
  onCountChange?: (count: number) => void;
  parentSendMessage?: (type: string, data: any) => Promise<any>;
}

// íˆìŠ¤í† ë¦¬ íƒ­ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤
export interface HistoryTabProps {
  modificationHistory: any[]; // ModificationHistory[]
}

// ì¼ë°˜ ë°ì´í„° íƒ­ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤
export interface GenericDataTabProps {
  cve: CVEDetail;
  currentUser: User;
  refreshTrigger?: number;
  tabConfig: any; // TabConfig
  onCountChange?: (count: number) => void;
  parentSendMessage?: (type: string, data: any) => Promise<any>;
}

// íƒœê·¸ ìƒíƒœ
export interface TagState {
  id: string | number;
  text: string;
}

// ë©˜ì…˜ ì…ë ¥ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤
export interface MentionInputProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
  disabled?: boolean;
  mentions?: any[]; // User[]
  onMention?: (user: any) => void;
  onSubmit?: () => void;
}

/**
 * ì•Œë¦¼ ì»´í¬ë„ŒíŠ¸ ê´€ë ¨ í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface NotificationBellProps extends CommonComponentProps {
  count?: number;
  onClick?: () => void;
  onOpenCVEDetail?: (cveId: string, commentId?: string) => void;
}

/**
 * ì‚¬ìš©ì ì¸ì¦ ì»´í¬ë„ŒíŠ¸ ê´€ë ¨ í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface LoginFormProps extends CommonComponentProps {
  onSuccess?: () => void;
  onError?: (error: Error) => void;
}

export interface SignUpProps extends CommonComponentProps {
  onSuccess?: () => void;
  onError?: (error: Error) => void;
}

/**
 * íƒ­ íŒ¨ë„ ì»´í¬ë„ŒíŠ¸ í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface TabPanelProps {
  children?: ReactNode;
  index: number;
  value: number;
}


============================================================
File: /home/CVEHub/frontend/src/shared/api/config/endpoints.js
------------------------------------------------------------
import { WS_BASE_URL, SOCKET_IO_PATH } from 'config';
import logger from 'shared/utils/logging';


// Auth endpoints
export const AUTH = {
  LOGIN: '/auth/token',
  SIGNUP: '/auth/signup',
  REFRESH: '/auth/refresh',
  LOGOUT: '/auth/logout',
  ME: '/auth/me',
  SEARCH: '/auth/search'
};

// CVE endpoints
export const CVE = {
  BASE: '/cves',
  DETAIL: (id) => `/cves/${id}`,
  SEARCH: '/cves/search',
  COMMENTS: (id) => `/cves/${id}/comments`,
  COMMENT: (cveId, commentId) => `/cves/${cveId}/comments/${commentId}`,
  POC: (id) => `/cves/${id}/poc`,
  SNORT_RULE: (id) => `/cves/${id}/snort-rules`,
  LOCK: (id) => `/cves/${id}/lock`
};

// Notification endpoints
export const NOTIFICATION = {
  BASE: '/notifications',
  READ: (id) => `/notifications/${id}/read`,
  READ_ALL: '/notifications/read-all',
  UNREAD_COUNT: '/notifications/unread/count',
};

// WebSocket endpoints
export const WEBSOCKET = {
  BASE_URL: WS_BASE_URL || 'http://localhost:8000',
  getWebSocketURL: (token) => {
    if (!token) {
      logger.error('WEBSOCKET.CONNECT', 'í† í°ì´ ì œê³µë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
      return null;
    }
    
    try {
      // ê¸°ë³¸ URL ì„¤ì • (config.jsì—ì„œ ê°€ì ¸ì˜´)
      const baseUrl = WS_BASE_URL || 'http://localhost:8000';
      
      // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ë¡œê¹…
      if (process.env.NODE_ENV === 'development') {
        logger.debug('WEBSOCKET.CONNECT', 'WebSocket URL êµ¬ì„±:', {
          baseUrl,
          socketIOPath: SOCKET_IO_PATH,
          tokenLength: token.length
        });
      }
      
      // URL ëì— ìŠ¬ë˜ì‹œê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ì ì ˆíˆ ì²˜ë¦¬
      const normalizedUrl = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
      
      // í† í° ì¸ì½”ë”©
      const encodedToken = encodeURIComponent(token);
      
      // Socket.IO í”„ë¡œí† ì½œì— ë§ê²Œ URL êµ¬ì„±
      // ì°¸ê³ : Socket.IO í´ë¼ì´ì–¸íŠ¸ëŠ” ìë™ìœ¼ë¡œ '/socket.io' ê²½ë¡œë¥¼ ì¶”ê°€í•˜ë¯€ë¡œ
      // ì—¬ê¸°ì„œëŠ” baseUrlë§Œ ë°˜í™˜í•˜ê³  path ì˜µì…˜ì€ socketio.jsì—ì„œ ì„¤ì •
      return normalizedUrl;
    } catch (error) {
      logger.error('WEBSOCKET.CONNECT', 'WebSocket URL ìƒì„± ì¤‘ ì˜¤ë¥˜:', error);
      return null;
    }
  }
};

// ë‹¤ìŒì˜ í•¨ìˆ˜ëŠ” ì œê±°í•˜ê±°ë‚˜ í•„ìš”í•œ ê²½ìš° ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
// export const getWebSocketURL = (path) => {
//     return `${WS_BASE_URL}${path}`;
// }; 


============================================================
File: /home/CVEHub/frontend/src/shared/api/config/axios.ts
------------------------------------------------------------
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, InternalAxiosRequestConfig } from 'axios';
import { getAccessToken, clearAuthStorage } from 'shared/utils/storage/tokenStorage';
import { camelToSnake, snakeToCamel } from 'shared/utils/caseConverter';
import { 
  normalizeDateFieldsForApi, 
  normalizeDateFieldsFromApi
} from '../../utils/dateUtils';
import { API_BASE_URL, CASE_CONVERSION_CONFIG, PUBLIC_ENDPOINTS, TOKEN_REFRESH_CONFIG } from 'config';
import { refreshToken } from 'features/auth/services/authService';

// ë§ˆì§€ë§‰ í† í° ê°±ì‹  ì‹œê°„ ì¶”ì 
let lastTokenRefreshTime = 0;
let tokenRefreshRetryCount = 0;

// ê°œë°œ í™˜ê²½ í™•ì¸ í•¨ìˆ˜
const isDevelopment = (): boolean => {
  return typeof window !== 'undefined' 
    ? window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
    : false;
};

// ì „ì—­ ë³€ìˆ˜ íƒ€ì… ì •ì˜
declare global {
  interface Window {
    _currentApiRequest?: {
      url: string;
      method: string;
      timestamp: string;
    };
  }
}

// ì»¤ìŠ¤í…€ Axios ìš”ì²­ ì„¤ì • íƒ€ì… í™•ì¥
export interface CustomAxiosRequestConfig extends AxiosRequestConfig {
  skipTransform?: boolean;
  useCache?: boolean;
  cacheMaxAge?: number;
  skipAuthRefresh?: boolean;
  metadata?: {
    requestTime: Date;
  };
  transformRequest?: ((data: any, headers?: any) => any)[];
  transformResponse?: ((data: any) => any)[];
}

// ì»¤ìŠ¤í…€ Axios ë‚´ë¶€ ìš”ì²­ ì„¤ì • íƒ€ì… í™•ì¥
export interface CustomInternalAxiosRequestConfig extends InternalAxiosRequestConfig {
  skipTransform?: boolean;
  useCache?: boolean;
  cacheMaxAge?: number;
  skipAuthRefresh?: boolean;
  metadata?: {
    requestTime: Date;
  };
}

// ìºì‹œ í•­ëª© íƒ€ì… ì •ì˜
interface CacheItem {
  data: any;
  timestamp: number;
}

// ê°„ì†Œí™”ëœ ë¡œê¹… í•¨ìˆ˜ - ê°œë°œ í™˜ê²½ì—ì„œë§Œ ë¡œê·¸ ì¶œë ¥
const logDebug = (...args: any[]): void => {
  if (isDevelopment()) {
    console.log(...args);
  }
};

// Axios ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
const api: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000, // 30ì´ˆ íƒ€ì„ì•„ì›ƒ
  headers: {
    'Content-Type': 'application/json'
  }
});

// ìºì‹œ ì €ì¥ì†Œ
const cache = new Map<string, CacheItem>();

// ë³€í™˜ì—ì„œ ì œì™¸í•  í•„ë“œ ëª©ë¡ (configì—ì„œ ê°€ì ¸ì˜´)
const EXCLUDED_FIELDS = CASE_CONVERSION_CONFIG.EXCLUDED_FIELDS;

// ë¡œê·¸ ì¶œë ¥ì—ì„œ ì œì™¸í•  URL íŒ¨í„´
const URL_NO_LOG_PATTERNS: string[] = [
  '/static/',
  '/assets/',
  '/images/',
  '/favicon.ico',
  '/manifest.json'
];

// ë‚ ì§œ ì²˜ë¦¬ì—ì„œ ì œì™¸í•  URL íŒ¨í„´
const URL_NO_DATE_PROCESS_PATTERNS: string[] = [
  '/auth/',
  '/static/',
  '/assets/',
  '/images/'
];

// URL íŒ¨í„´ì— ë”°ë¼ ë¡œê·¸ ì¶œë ¥ ì—¬ë¶€ ê²°ì •
const isExcludedFromLogging = (url?: string): boolean => {
  if (!url) return true;
  return URL_NO_LOG_PATTERNS.some(pattern => url.includes(pattern));
};

// URL íŒ¨í„´ì— ë”°ë¼ ë‚ ì§œ ì²˜ë¦¬ ì—¬ë¶€ ê²°ì •
const shouldProcessDates = (url?: string): boolean => {
  if (!url) return false;
  const shouldProcess = !URL_NO_DATE_PROCESS_PATTERNS.some(pattern => url.includes(pattern));
  
  // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ë‚ ì§œ ì²˜ë¦¬ ì—¬ë¶€ ë¡œê¹…
  if (isDevelopment() && url.includes('/activities')) {
    console.log(`[axios] ë‚ ì§œ ì²˜ë¦¬ ê²°ì •: URL=${url}, ì²˜ë¦¬ì—¬ë¶€=${shouldProcess}`);
  }
  
  return shouldProcess;
};

// Request Interceptor
api.interceptors.request.use(
  async (config: InternalAxiosRequestConfig): Promise<CustomInternalAxiosRequestConfig> => {
    try {
      // ì „ì—­ ë³€ìˆ˜ì— í˜„ì¬ API ìš”ì²­ ì •ë³´ ì €ì¥ (caseConverterì—ì„œ URL ì¶”ì ìš©)
      if (typeof window !== 'undefined') {
        window._currentApiRequest = {
          url: config.url || '',
          method: config.method || 'get',
          timestamp: new Date().toISOString()
        };
      }
      
      // ë¡œê¹… ì œì™¸ ëŒ€ìƒ í™•ì¸
      const shouldLog = !isExcludedFromLogging(config.url) && isDevelopment();
      
      // ìš”ì²­ ì‹œì‘ ì‹œê°„ ê¸°ë¡ (ì„±ëŠ¥ ì¸¡ì •ìš©)
      const customConfig = config as CustomInternalAxiosRequestConfig;
      customConfig.metadata = {
        requestTime: new Date()
      };
      
      // ê°œë°œ í™˜ê²½ì—ì„œ ìš”ì²­ ë¡œê¹…
      if (shouldLog) {
        console.log(`[axios] ${config.method?.toUpperCase()} ${config.url}`);
        
        // ìš”ì²­ ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš° ë¡œê¹… (ë¯¼ê° ì •ë³´ ì œì™¸)
        if (config.data && typeof config.data === 'object') {
          // ë¹„ë°€ë²ˆí˜¸ í•„ë“œëŠ” ë§ˆìŠ¤í‚¹ ì²˜ë¦¬
          const sanitizedData = { ...config.data };
          if (sanitizedData.password) sanitizedData.password = '********';
          if (sanitizedData.currentPassword) sanitizedData.currentPassword = '********';
          if (sanitizedData.newPassword) sanitizedData.newPassword = '********';
          
          console.log('[axios] ìš”ì²­ ë°ì´í„°:', sanitizedData);
        }
      }
      
      // ì¸ì¦ í† í° ì²˜ë¦¬ (ê³µê°œ ì—”ë“œí¬ì¸íŠ¸ê°€ ì•„ë‹Œ ê²½ìš°)
      if (config.url && !PUBLIC_ENDPOINTS.some(endpoint => config.url?.includes(endpoint))) {
        const token = getAccessToken();
        
        if (token) {
          try {
            // í† í° ë§Œë£Œ ì—¬ë¶€ í™•ì¸
            const tokenData = JSON.parse(atob(token.split('.')[1]));
            const currentTime = Math.floor(Date.now() / 1000);
            
            // í† í°ì´ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ë§Œë£Œ ì„ë°•í•œ ê²½ìš° (30ì´ˆ ì´ë‚´) ê°±ì‹  ì‹œë„
            if (tokenData.exp && tokenData.exp - currentTime < 30 && !customConfig.skipAuthRefresh) {
              const now = Date.now();
              const refreshInterval = TOKEN_REFRESH_CONFIG.MIN_REFRESH_INTERVAL || 10000; // ê¸°ë³¸ 10ì´ˆ
              
              // í† í° ê°±ì‹  ìš”ì²­ ê°„ê²© ì œí•œ (ë„ˆë¬´ ìì£¼ ìš”ì²­í•˜ì§€ ì•Šë„ë¡)
              if (now - lastTokenRefreshTime > refreshInterval) {
                lastTokenRefreshTime = now;
                
                try {
                  // í† í° ê°±ì‹  ì‹œë„
                  const newToken = await refreshToken();
                  if (newToken) {
                    config.headers.Authorization = `Bearer ${newToken}`;
                    tokenRefreshRetryCount = 0; // ì„±ê³µ ì‹œ ì¬ì‹œë„ ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
                  }
                } catch (refreshError) {
                  tokenRefreshRetryCount++;
                  
                  // ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ ì‹œ ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬
                  if (tokenRefreshRetryCount > TOKEN_REFRESH_CONFIG.MAX_RETRY || 3) {
                    clearAuthStorage();
                    tokenRefreshRetryCount = 0;
                    
                    // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ì—ëŸ¬ ë¡œê·¸
                    if (isDevelopment()) {
                      console.error('í† í° ê°±ì‹  ì‹¤íŒ¨ (ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼):', refreshError);
                    }
                    
                    // ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸ (ì„ íƒì )
                    if (typeof window !== 'undefined' && !window.location.pathname.includes('/login')) {
                      window.location.href = '/login?session=expired';
                    }
                  }
                }
              }
            } else {
              // í† í°ì´ ìœ íš¨í•˜ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
              config.headers.Authorization = `Bearer ${token}`;
            }
          } catch (e) {
            // í† í° ê²€ì¦ ê³¼ì •ì—ì„œ ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ì¡´ í† í° ì‚¬ìš©
            config.headers.Authorization = `Bearer ${token}`;
            
            // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ì—ëŸ¬ ë¡œê·¸
            if (isDevelopment()) {
              console.error('í† í° ê²€ì¦ ì˜¤ë¥˜:', e);
            }
          }
        }
      }
      
      // ìš”ì²­ ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš° (POST, PUT, PATCH ë“±)
      if (config.data && typeof config.data === 'object' && !customConfig.skipTransform) {
        // URLSearchParams ê°ì²´ëŠ” ë³€í™˜í•˜ì§€ ì•ŠìŒ
        if (!(config.data instanceof URLSearchParams)) {
          // ë‚ ì§œ í•„ë“œ ì²˜ë¦¬ (ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜)
          config.data = normalizeDateFieldsForApi(config.data);
          
          // ì¹´ë©œ ì¼€ì´ìŠ¤ë¥¼ ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤ë¡œ ë³€í™˜
          config.data = camelToSnake(config.data, {
            excludeFields: EXCLUDED_FIELDS
          });
        }
      }
      
      // ìºì‹œëœ ì‘ë‹µ í™•ì¸ (GET ìš”ì²­ë§Œ í•´ë‹¹)
      if (config.method === 'get' && customConfig.useCache) {
        const cachedResponse = cache.get(config.url || '');
        
        if (cachedResponse) {
          const now = Date.now();
          const cacheAge = now - cachedResponse.timestamp;
          
          // ìºì‹œ ìœ íš¨ ì‹œê°„ ë‚´ì¸ ê²½ìš°
          if (cacheAge < (customConfig.cacheMaxAge || 60000)) { // ê¸°ë³¸ 1ë¶„
            if (shouldLog) {
              console.log(`[axios] ìºì‹œëœ ì‘ë‹µ ì‚¬ìš©: ${config.url}`);
            }
            
            // ìºì‹œëœ ì‘ë‹µ ì‚¬ìš©
            return Promise.resolve({
              data: cachedResponse.data,
              status: 200,
              statusText: 'OK (cached)',
              headers: {},
              config,
              cached: true
            }) as any;
          }
        }
      }
      
      return customConfig;
    } catch (error) {
      console.error('Request Interceptor Critical Error:', error);
      return Promise.reject(error);
    }
  },
  (error) => {
    console.error('Request Interceptor Error:', error);
    return Promise.reject(error);
  }
);

// Response Interceptor 
api.interceptors.response.use(
  (response: AxiosResponse): AxiosResponse => {
    // ë¡œê¹… ì œì™¸ ëŒ€ìƒ í™•ì¸
    const shouldLog = !isExcludedFromLogging(response.config.url) && isDevelopment();
    
    // ì‘ë‹µ ì‹œê°„ ê³„ì‚° (ì„±ëŠ¥ ì¸¡ì •ìš©)
    const customConfig = response.config as CustomInternalAxiosRequestConfig;
    const requestTime = customConfig.metadata?.requestTime;
    let responseTime = 0;
    
    if (requestTime) {
      responseTime = new Date().getTime() - requestTime.getTime();
    }
    
    
    // skipTransform ì˜µì…˜ì´ ìˆëŠ” ê²½ìš° ë³€í™˜ ê±´ë„ˆë›°ê¸°
    if (customConfig.skipTransform) {
      return response;
    }
    
    // ë‚ ì§œ í•„ë“œ ì²˜ë¦¬ (ISO ë¬¸ìì—´ì„ Date ê°ì²´ë¡œ ë³€í™˜)
    if (response.data && 
        typeof response.data === 'object') {
      const url = response.config.url || '';
      const shouldProcess = shouldProcessDates(url);
      
      // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ë¡œê·¸ ì¶œë ¥
      if (isDevelopment() && url.includes('/activities')) {
        console.log(`[axios] ì‘ë‹µ ì¸í„°ì…‰í„° ë‚ ì§œ ì²˜ë¦¬: URL=${url}, ì²˜ë¦¬ì—¬ë¶€=${shouldProcess}`);
        
        if (shouldProcess) {
          console.log(`[axios] ë‚ ì§œ ë³€í™˜ ì „ timestamp ìƒ˜í”Œ:`, 
            Array.isArray(response.data.items) && response.data.items.length > 0 ? 
              response.data.items[0].timestamp : 'ìƒ˜í”Œ ì—†ìŒ');
        }
      }
      
      if (shouldProcess) {
        response.data = normalizeDateFieldsFromApi(response.data);
        
        // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ë¡œê·¸ ì¶œë ¥
        if (isDevelopment() && url.includes('/activities')) {
          console.log(`[axios] ë‚ ì§œ ë³€í™˜ í›„ timestamp ìƒ˜í”Œ:`, 
            Array.isArray(response.data.items) && response.data.items.length > 0 ? 
              response.data.items[0].timestamp : 'ìƒ˜í”Œ ì—†ìŒ');
        }
      }
    }
    
    // ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤ë¥¼ ì¹´ë©œ ì¼€ì´ìŠ¤ë¡œ ë³€í™˜
    if (response.data && typeof response.data === 'object') {
      response.data = snakeToCamel(response.data, {
        excludeFields: EXCLUDED_FIELDS,
        processDate: shouldProcessDates(response.config.url)
      });
    }
    
    // GET ìš”ì²­ ê²°ê³¼ ìºì‹± (useCache ì˜µì…˜ì´ ìˆëŠ” ê²½ìš°)
    if (response.config.method === 'get' && 
        (response.config as CustomInternalAxiosRequestConfig).useCache && 
        response.status === 200) {
      cache.set(response.config.url || '', {
        data: response.data,
        timestamp: Date.now()
      });
    }
    
    return response;
  },
  async (error) => {
    // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ì—ëŸ¬ ë¡œê¹…
    const isDev = isDevelopment();
    
    // ì—ëŸ¬ ì‘ë‹µì´ ìˆëŠ” ê²½ìš° ê¸°ë³¸ ì •ë³´ ë¡œê¹…
    if (error.response) {
      const { status, data, config } = error.response;
      
      // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ì—ëŸ¬ ë¡œê¹…
      if (isDev) {
        console.error(`API ì—ëŸ¬ (${status}): ${config.url}`);
        
        // ì—ëŸ¬ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ë¡œê¹…
        if (data) {
          console.error('ì—ëŸ¬ ìƒì„¸:', data);
        }
      }
      
      // skipTransform ì˜µì…˜ì´ ìˆëŠ” ê²½ìš° ë³€í™˜ ê±´ë„ˆë›°ê¸°
      const customConfig = config as CustomInternalAxiosRequestConfig;
      if (customConfig.skipTransform) {
        return Promise.reject(error);
      }
      
      // 401 Unauthorized ì—ëŸ¬ ì²˜ë¦¬ (í† í° ë§Œë£Œ)
      if (status === 401 && config && !customConfig.skipAuthRefresh) {
        try {
          // í† í° ê°±ì‹  ì‹œë„
          const newToken = await refreshToken();
          
          if (newToken) {
            // ê°±ì‹ ëœ í† í°ìœ¼ë¡œ ì›ë˜ ìš”ì²­ ì¬ì‹œë„
            const originalRequest = config;
            originalRequest.headers.Authorization = `Bearer ${newToken}`;
            return axios(originalRequest);
          }
        } catch (refreshError) {
          // í† í° ê°±ì‹  ì‹¤íŒ¨ ì‹œ ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬
          clearAuthStorage();
          
          // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ì—ëŸ¬ ë¡œê·¸
          if (isDev) {
            console.error('í† í° ê°±ì‹  ì‹¤íŒ¨:', refreshError);
          }
          
          // ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸ (ì„ íƒì )
          if (typeof window !== 'undefined' && !window.location.pathname.includes('/login')) {
            window.location.href = '/login?session=expired';
          }
        }
      }
      
      // ì‘ë‹µ ë°ì´í„° í˜•ì‹ í†µì¼ (ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤ -> ì¹´ë©œ ì¼€ì´ìŠ¤)
      if (error.response.data && typeof error.response.data === 'object') {
        error.response.data = snakeToCamel(error.response.data, {
          excludeFields: EXCLUDED_FIELDS,
          processDate: shouldProcessDates(error.response.config.url)
        });
      }
    } else if (error.request) {
      // ìš”ì²­ì€ ì „ì†¡ë˜ì—ˆìœ¼ë‚˜ ì‘ë‹µì´ ì—†ëŠ” ê²½ìš° (ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë“±)
      if (isDev) {
        console.error('API ìš”ì²­ ì˜¤ë¥˜ (ì‘ë‹µ ì—†ìŒ):', error.message);
      }
    } else {
      // ìš”ì²­ ì„¤ì • ê³¼ì •ì—ì„œ ì˜¤ë¥˜ ë°œìƒ
      if (isDev) {
        console.error('API ìš”ì²­ ì„¤ì • ì˜¤ë¥˜:', error.message);
      }
    }
    
    return Promise.reject(error);
  }
);

// ì»¤ìŠ¤í…€ Axios ì¸ìŠ¤í„´ìŠ¤ íƒ€ì… í™•ì¥
export type CustomAxiosInstance = AxiosInstance & {
  (config: CustomAxiosRequestConfig): Promise<AxiosResponse>;
  (url: string, config?: CustomAxiosRequestConfig): Promise<AxiosResponse>;
  defaults: AxiosRequestConfig;
  getUri(config?: CustomAxiosRequestConfig): string;
  request<T = any, R = AxiosResponse<T>>(config: CustomAxiosRequestConfig): Promise<R>;
  get<T = any, R = AxiosResponse<T>>(url: string, config?: CustomAxiosRequestConfig): Promise<R>;
  delete<T = any, R = AxiosResponse<T>>(url: string, config?: CustomAxiosRequestConfig): Promise<R>;
  head<T = any, R = AxiosResponse<T>>(url: string, config?: CustomAxiosRequestConfig): Promise<R>;
  options<T = any, R = AxiosResponse<T>>(url: string, config?: CustomAxiosRequestConfig): Promise<R>;
  post<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: CustomAxiosRequestConfig): Promise<R>;
  put<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: CustomAxiosRequestConfig): Promise<R>;
  patch<T = any, R = AxiosResponse<T>>(url: string, data?: any, config?: CustomAxiosRequestConfig): Promise<R>;
};

export default api as CustomAxiosInstance;



============================================================
File: /home/CVEHub/frontend/src/shared/api/api.js
------------------------------------------------------------
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  baseQuery: fetchBaseQuery({ 
    baseUrl: '/api',
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    } 
  }),
  
  tagTypes: ['CVE', 'CVEList', 'User'],
  
  endpoints: (builder) => ({
    getCVEList: builder.query({
      query: (params) => ({
        url: `/cve/list`,
        params: {
          ...params,
          _t: Date.now() // ìºì‹œ ë²„ìŠ¤íŒ…ìš© íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
        }
      }),
      providesTags: (result) => 
        result
          ? [
              ...result.items.map(({ cveId }) => ({ type: 'CVE', id: cveId })),
              { type: 'CVEList', id: 'LIST' }
            ]
          : [{ type: 'CVEList', id: 'LIST' }],
      // 30ì´ˆ ìºì‹œ - ë°±ì—”ë“œ ìºì‹œì™€ ì ì ˆíˆ ì¡°ìœ¨
      keepUnusedDataFor: 30,
    }),
    
    getCVEDetail: builder.query({
      query: ({ cveId, bypassCache }) => ({
        url: `/cve/${cveId}`,
        params: bypassCache ? { bypass_cache: true, _t: Date.now() } : {}
      }),
      providesTags: (result, error, arg) => 
        result ? [{ type: 'CVE', id: arg.cveId }] : [],
      // 5ë¶„ ìºì‹œ
      keepUnusedDataFor: 300,
    }),
    
    // ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ì— ë”°ë¥¸ ìºì‹œ ë¬´íš¨í™” ë¡œì§ì€ ì†Œì¼“ í•¸ë“¤ëŸ¬ì—ì„œ ì²˜ë¦¬
  })
});

export const { 
  useGetCVEListQuery, 
  useGetCVEDetailQuery,
  useLazyGetCVEDetailQuery 
} = api; 


============================================================
File: /home/CVEHub/frontend/src/shared/api/queryKeys.ts
------------------------------------------------------------
/**
 * React Queryì—ì„œ ì‚¬ìš©í•  query key ìƒìˆ˜
 * ëª¨ë“  query keyë¥¼ í•œ ê³³ì—ì„œ ê´€ë¦¬í•˜ì—¬ ì¼ê´€ì„± ìœ ì§€
 */

// í•„í„° íƒ€ì… ì •ì˜
export interface CVEFilters {
  page?: number;
  limit?: number;
  status?: string;
  severity?: string;
  search?: string;
  assigned_to?: string;
  [key: string]: any;
}

// ì¿¼ë¦¬ í‚¤ íƒ€ì… ì •ì˜
export type QueryKeyType = string | readonly unknown[];

// CVE ê´€ë ¨ ì¿¼ë¦¬ í‚¤ íƒ€ì…
interface CVEQueryKeys {
  all: readonly string[];
  lists: () => readonly unknown[];
  list: (filters?: CVEFilters) => readonly unknown[];
  details: () => readonly unknown[];
  detail: (id: string) => readonly unknown[];
  totalCount: () => readonly unknown[];
  stats: () => readonly unknown[];
}

// ì‚¬ìš©ì ê´€ë ¨ ì¿¼ë¦¬ í‚¤ íƒ€ì…
interface UsersQueryKeys {
  all: readonly string[];
  search: readonly string[];
  searchByQuery: (query: string) => readonly unknown[];
}

// ì „ì²´ ì¿¼ë¦¬ í‚¤ íƒ€ì…
interface QueryKeys {
  CVE_LIST: string;
  CVE_DETAIL: string;
  CVE_SUBSCRIBERS: string;
  CVE: CVEQueryKeys;
  USER: string;
  USER_PROFILE: string;
  USERS: UsersQueryKeys;
  SETTINGS: string;
  NOTIFICATION: string;
}

export const QUERY_KEYS: QueryKeys = {
  // CVE ê´€ë ¨ query keys
  CVE_LIST: 'cve-list',
  CVE_DETAIL: 'cve-detail',
  CVE_SUBSCRIBERS: 'cve-subscribers',
  
  // CVE ê´€ë ¨ í•¨ìˆ˜í˜• ì¿¼ë¦¬ í‚¤ êµ¬ì¡° (useCVEQuery.tsì™€ ì¼ì¹˜)
  CVE: {
    all: ['cves'] as const,
    lists: () => [...QUERY_KEYS.CVE.all, 'list'] as const,
    list: (filters?: CVEFilters) => [...QUERY_KEYS.CVE.lists(), filters] as const,
    details: () => [...QUERY_KEYS.CVE.all, 'detail'] as const,
    detail: (id: string) => [...QUERY_KEYS.CVE.details(), id] as const,
    totalCount: () => [...QUERY_KEYS.CVE.all, 'totalCount'] as const,
    stats: () => [...QUERY_KEYS.CVE.all, 'stats'] as const,
  },
  
  // ì‚¬ìš©ì ê´€ë ¨ query keys
  USER: 'user',
  USER_PROFILE: 'user-profile',
  
  // ì‚¬ìš©ì ê²€ìƒ‰ ê´€ë ¨ query keys
  USERS: {
    all: ['users'] as const,
    search: ['users', 'search'] as const,
    searchByQuery: (query: string) => ['users', 'search', query] as const,
  },
  
  // ì„¤ì • ê´€ë ¨ query keys
  SETTINGS: 'settings',
  
  // ê¸°íƒ€ query keys
  NOTIFICATION: 'notification',
};

export default QUERY_KEYS;


============================================================
File: /home/CVEHub/frontend/src/shared/utils/storage/tokenStorage.ts
------------------------------------------------------------
import { User } from '../../../features/auth/types';

// ìƒìˆ˜
const ACCESS_TOKEN_KEY = 'accessToken';
const REFRESH_TOKEN_KEY = 'refreshToken';
const USER_KEY = 'user';

// ì•¡ì„¸ìŠ¤ í† í°
export const getAccessToken = (): string | null => localStorage.getItem(ACCESS_TOKEN_KEY);
export const setAccessToken = (token: string): void => {
  if (!token) {
    console.error('[TokenStorage] ë¹ˆ ì•¡ì„¸ìŠ¤ í† í° ì €ì¥ ì‹œë„');
    return;
  }
  localStorage.setItem(ACCESS_TOKEN_KEY, token);
};
export const removeAccessToken = (): void => {
  localStorage.removeItem(ACCESS_TOKEN_KEY);
};

// ë¦¬í”„ë ˆì‹œ í† í°
export const getRefreshToken = (): string | null => localStorage.getItem(REFRESH_TOKEN_KEY);
export const setRefreshToken = (token: string): void => {
  if (!token) {
    console.error('[TokenStorage] ë¹ˆ ë¦¬í”„ë ˆì‹œ í† í° ì €ì¥ ì‹œë„');
    return;
  }
  localStorage.setItem(REFRESH_TOKEN_KEY, token);
};
export const removeRefreshToken = (): void => {
  localStorage.removeItem(REFRESH_TOKEN_KEY);
};

// ì‚¬ìš©ì ì •ë³´
export const getUser = (): User | null => {
  const userJson = localStorage.getItem(USER_KEY);
  return userJson ? JSON.parse(userJson) : null;
};
export const setUser = (user: User): void => {
  if (!user) {
    console.error('[TokenStorage] ë¹ˆ ì‚¬ìš©ì ì •ë³´ ì €ì¥ ì‹œë„');
    return;
  }
  localStorage.setItem(USER_KEY, JSON.stringify(user));
};
export const removeUser = (): void => localStorage.removeItem(USER_KEY);

// ëª¨ë“  ì¸ì¦ ë°ì´í„° ì‚­ì œ
export const clearAuthStorage = (): void => {
  removeAccessToken();
  removeRefreshToken();
  removeUser();
};

// í† í°ë§Œ ì‚­ì œ
export const clearAllTokens = (): void => {
  removeAccessToken();
  removeRefreshToken();
};

// í˜„ì¬ ì‚¬ìš©ì ì„¤ì • (setUserì˜ ë³„ì¹­)
export const setCurrentUser = setUser;



============================================================
File: /home/CVEHub/frontend/src/shared/utils/caseConverter.ts
------------------------------------------------------------
/**
 * ì¼€ì´ìŠ¤ ë³€í™˜ ìœ í‹¸ë¦¬í‹°
 * humps ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ camelCaseì™€ snake_case ê°„ ë³€í™˜ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 */
import { camelizeKeys as humpsCamelizeKeys, decamelizeKeys } from 'humps';
import { normalizeDateFieldsFromApi } from './dateUtils';

/**
 * ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤ì—ì„œ ì¹´ë©œ ì¼€ì´ìŠ¤ë¡œ ë³€í™˜ ì˜µì…˜ ì¸í„°í˜ì´ìŠ¤
 */
export interface CaseConverterOptions {
  /** ë³€í™˜ì—ì„œ ì œì™¸í•  í•„ë“œ ì´ë¦„ ëª©ë¡ */
  excludeFields?: string[];
  /** ë‚ ì§œ í•„ë“œ ìë™ ë³€í™˜ ì—¬ë¶€ */
  processDate?: boolean;
/** ìš”ì²­ URL (ë¡œê¹… ë° íŠ¹ìˆ˜ ì²˜ë¦¬ìš©) */
  requestUrl?: string;
}

// camelizeKeysë¥¼ humps ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì§ì ‘ ë‚´ë³´ë‚´ê¸°
export { humpsCamelizeKeys as camelizeKeys };

// decamelizeKeysë¥¼ snakeizeKeysë¡œ ë³„ì¹­í•˜ì—¬ ë‚´ë³´ë‚´ê¸°
export { decamelizeKeys as snakeizeKeys };

/**
 * ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤ì—ì„œ ì¹´ë©œ ì¼€ì´ìŠ¤ë¡œ ë³€í™˜
 * @param data ë³€í™˜í•  ë°ì´í„°
 * @param options ë³€í™˜ ì˜µì…˜
 * @returns ë³€í™˜ëœ ë°ì´í„°
 */
export const snakeToCamel = (data: any, options: CaseConverterOptions = {}): any => {
  const { 
    excludeFields = [],
    processDate = true,
    requestUrl = 'unknown'
  } = options;
  
  // null ë˜ëŠ” undefinedì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (data === null || data === undefined) {
    return data;
  }
  
  // Date ê°ì²´ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (data instanceof Date) {
    return data;
  }
  
  try {
    // 1. humps ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ì¹´ë©œì¼€ì´ìŠ¤ ë³€í™˜
    let camelizedData = humpsCamelizeKeys(data, (key: string, convert: (key: string) => string) => {
      // ì œì™¸ í•„ë“œ ëª©ë¡ì— ìˆëŠ” ê²½ìš° ë³€í™˜í•˜ì§€ ì•ŠìŒ
      return excludeFields.includes(key) ? key : convert(key);
    });
    
    // 2. ë‚ ì§œ í•„ë“œ ìë™ íƒ€ì… ë³€í™˜ ì²˜ë¦¬ (processDate ì˜µì…˜ì´ trueì¸ ê²½ìš°)
    if (processDate) {
      // dateUtils.jsì˜ normalizeDateFieldsFromApi í•¨ìˆ˜ í™œìš©
      camelizedData = normalizeDateFieldsFromApi(camelizedData, requestUrl);
    }
    
    return camelizedData;
  } catch (error) {
    console.error('[snakeToCamel] ë³€í™˜ ì˜¤ë¥˜:', error);
    return data; // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì›ë³¸ ë°˜í™˜
  }
};

/**
 * ì¹´ë©œ ì¼€ì´ìŠ¤ë¥¼ ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤ë¡œ ë³€í™˜
 * @param data ë³€í™˜í•  ë°ì´í„°
 * @param options ë³€í™˜ ì˜µì…˜
 * @returns ë³€í™˜ëœ ë°ì´í„°
 */
export const camelToSnake = (data: any, options: Omit<CaseConverterOptions, 'processDate'> = {}): any => {
  const { excludeFields = [] } = options;
  
  // null ë˜ëŠ” undefinedì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (data === null || data === undefined) {
    return data;
  }
  
  // Date ê°ì²´ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (data instanceof Date) {
    return data;
  }
  
  try {
    // humps ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ ìŠ¤ë„¤ì´í¬ì¼€ì´ìŠ¤ ë³€í™˜
    return decamelizeKeys(data, (key: string, convert: (key: string, options?: any) => string, options?: any) => {
      // ì œì™¸ í•„ë“œ ëª©ë¡ì— ìˆëŠ” ê²½ìš° ë³€í™˜í•˜ì§€ ì•ŠìŒ
      return excludeFields.includes(key) ? key : convert(key, options);
    });
  } catch (error) {
    console.error('[camelToSnake] ë³€í™˜ ì˜¤ë¥˜:', error);
    return data; // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì›ë³¸ ë°˜í™˜
  }
};



============================================================
File: /home/CVEHub/frontend/src/shared/utils/reactQuery.ts
------------------------------------------------------------
import { QueryClient } from '@tanstack/react-query';
import { QUERY_KEYS as API_QUERY_KEYS } from 'shared/api/queryKeys';

// ì¿¼ë¦¬ í‚¤ ì¬ì‚¬ìš©
export const QUERY_KEYS = {
  ...API_QUERY_KEYS,
  // ì¶”ê°€ í‚¤ ì •ì˜
  CVE_SUBSCRIBERS: 'cve-subscribers',
};

// ê¸€ë¡œë²Œ QueryClient ì¸ìŠ¤í„´ìŠ¤ (ì‹±ê¸€í„´)
let queryClientInstance: QueryClient | null = null;

/**
 * ê¸€ë¡œë²Œ QueryClient ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
 * App ì»´í¬ë„ŒíŠ¸ì—ì„œ ì´ˆê¸°í™”ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
 */
export function getQueryClient(): QueryClient | null {
  return queryClientInstance;
}

/**
 * ê¸€ë¡œë²Œ QueryClient ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
 * App ì»´í¬ë„ŒíŠ¸ì—ì„œ í•œ ë²ˆë§Œ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.
 */
export function setQueryClient(client: QueryClient): void {
  queryClientInstance = client;
}



============================================================
File: /home/CVEHub/frontend/src/shared/utils/logging.ts
------------------------------------------------------------
/**
 * ì¤‘ì•™í™”ëœ ë¡œê¹… ì„œë¹„ìŠ¤
 * ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì²´ì—ì„œ ì‚¬ìš©ë˜ëŠ” ë¡œê¹… ì‹œìŠ¤í…œ
 * 
 * ë¡œê·¸ ë ˆë²¨ ê°€ì´ë“œë¼ì¸:
 * - DEBUG: ê°œë°œ ì¤‘ ë””ë²„ê¹…ì— í•„ìš”í•œ ìƒì„¸ ì •ë³´ (ì˜ˆ: í•¨ìˆ˜ í˜¸ì¶œ, ë³€ìˆ˜ ê°’, ì›¹ì†Œì¼“ ë©”ì‹œì§€ ë“±)
 * - INFO: ì •ìƒì ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ íë¦„ì— ëŒ€í•œ ì •ë³´ (ì˜ˆ: í˜ì´ì§€ ë¡œë“œ, ì‚¬ìš©ì ì‘ì—…, ë°ì´í„° ë¡œë“œ ë“±)
 * - WARN: ì ì¬ì ì¸ ë¬¸ì œì´ì§€ë§Œ ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ê³„ì† ì‹¤í–‰ë  ìˆ˜ ìˆëŠ” ìƒí™© (ì˜ˆ: API ì‘ë‹µ ì§€ì—°, ì¬ì‹œë„ ë“±)
 * - ERROR: ì• í”Œë¦¬ì¼€ì´ì…˜ ê¸°ëŠ¥ì´ ì¤‘ë‹¨ë˜ëŠ” ì‹¬ê°í•œ ë¬¸ì œ (ì˜ˆ: API ì˜¤ë¥˜, ë Œë”ë§ ì˜¤ë¥˜, ì˜ˆì™¸ ë°œìƒ ë“±)
 */

// í™˜ê²½ ë³€ìˆ˜ì— ëŒ€í•œ ì•ˆì „í•œ ì ‘ê·¼
const isDevMode = (): boolean => {
  return typeof window !== 'undefined' && 
         window.location && 
         (window.location.hostname === 'localhost' || 
          window.location.hostname === '127.0.0.1');
};

// ë¡œê·¸ ë ˆë²¨ ì •ì˜
export const LOG_LEVEL = {
  DEBUG: 0,   // ë””ë²„ê·¸ ë¡œê·¸ (ë§¤ìš° ìƒì„¸)
  INFO: 1,    // ì •ë³´ì„± ë¡œê·¸ 
  WARN: 2,    // ê²½ê³  ë¡œê·¸
  ERROR: 3,   // ì˜¤ë¥˜ ë¡œê·¸
  NONE: 100   // ë¡œê¹… ë¹„í™œì„±í™”
};

export type LogLevel = typeof LOG_LEVEL[keyof typeof LOG_LEVEL];

// ë¡œê·¸ ë©”ì„œë“œ íƒ€ì… ì •ì˜
export interface LogMethod {
  (module: string, message: string, data?: any): void;
  (message: string): void;
  (message: string, data: any): void;
}

interface ExtraContext {
  [key: string]: any;
}

/**
 * ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì €ì¥ì„ ìœ„í•œ í´ë˜ìŠ¤
 */
class LogContext {
  private userId: string | null = null;
  private sessionId: string | null = null;
  private requestId: string | null = null;
  private extraContext: ExtraContext = {};

  /**
   * ì‚¬ìš©ì ID ì„¤ì •
   * @param userId - ì‚¬ìš©ì ID
   */
  setUserId(userId: string): void {
    this.userId = userId;
  }

  /**
   * ì„¸ì…˜ ID ì„¤ì •
   * @param sessionId - ì„¸ì…˜ ID
   */
  setSessionId(sessionId: string): void {
    this.sessionId = sessionId;
  }

  /**
   * ìš”ì²­ ID ì„¤ì •
   * @param requestId - ìš”ì²­ ID
   */
  setRequestId(requestId: string): void {
    this.requestId = requestId;
  }

  /**
   * ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì„¤ì •
   * @param key - ì»¨í…ìŠ¤íŠ¸ í‚¤
   * @param value - ì»¨í…ìŠ¤íŠ¸ ê°’
   */
  setContext(key: string, value: any): void {
    if (key && value !== undefined) {
      this.extraContext[key] = value;
    }
  }

  /**
   * ëª¨ë“  ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
   * @returns ì»¨í…ìŠ¤íŠ¸ ì •ë³´
   */
  getAll(): ExtraContext {
    const context: ExtraContext = { ...this.extraContext };
    
    if (this.userId) context.userId = this.userId;
    if (this.sessionId) context.sessionId = this.sessionId;
    if (this.requestId) context.requestId = this.requestId;
    
    return context;
  }

  /**
   * ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
   */
  clear(): void {
    this.userId = null;
    this.sessionId = null;
    this.requestId = null;
    this.extraContext = {};
  }
}

interface LogEntry {
  level: string;
  timestamp: string;
  module: string;
  message: string;
  data?: any;
  context: ExtraContext;
}

/**
 * ì¤‘ì•™í™”ëœ ë¡œê¹… ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
 */
class LoggingService {
  private logLevel: LogLevel;
  private enabled: boolean;
  private ignorePatterns: (string | RegExp)[];
  private recentLogs: LogEntry[];
  private maxLogHistory: number;
  private context: LogContext;

  constructor() {
    // ê¸°ë³¸ ë¡œê·¸ ë ˆë²¨ì„ ERRORë¡œ ì„¤ì • (ERROR ë ˆë²¨ë§Œ ì¶œë ¥)
    this.logLevel = LOG_LEVEL.DEBUG;
    this.enabled = true;
    this.ignorePatterns = [
      'ping', 
      'pong', 
      'notifications/unread/count', 
      'health', 
      'user/status',
      'socket',
      'Socket',
      'WebSocket',
      'websocket'
    ]; // ê¸°ë³¸ì ìœ¼ë¡œ ë¬´ì‹œí•  íŒ¨í„´ í™•ì¥
    this.recentLogs = [];
    this.maxLogHistory = 100; // ìµœëŒ€ ë¡œê·¸ ê¸°ë¡ ìˆ˜
    this.context = new LogContext(); // ì»¨í…ìŠ¤íŠ¸ ì •ë³´
    
    // ì´ˆê¸°í™” ë¡œê·¸ ì¶œë ¥ (ERROR ë ˆë²¨ë¡œ ì„¤ì •)
    if (isDevMode()) {
      console.log('%c ë¡œê¹… ì‹œìŠ¤í…œ ì´ˆê¸°í™” (ERROR ë ˆë²¨)', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', {
        logLevel: this._getLogLevelName(this.logLevel),
        enabled: this.enabled,
        environment: isDevMode() ? 'development' : 'production'
      });
    }
  }

  /**
   * ë¡œê·¸ ë ˆë²¨ ì„¤ì •
   * @param level - ë¡œê·¸ ë ˆë²¨ (LOG_LEVEL ìƒìˆ˜ ì‚¬ìš©)
   */
  setLogLevel(level: LogLevel): void {
    try {
      const prevLevel = this.logLevel;
      this.logLevel = level;
      
      // ERROR ë ˆë²¨ë¡œ ë³€ê²½ë˜ê±°ë‚˜ ERROR ë ˆë²¨ì—ì„œ ë‹¤ë¥¸ ë ˆë²¨ë¡œ ë³€ê²½ë  ë•Œë§Œ ë¡œê·¸ ì¶œë ¥
      if (level === LOG_LEVEL.ERROR || prevLevel === LOG_LEVEL.ERROR) {
        if (isDevMode()) {
          console.log('%c ë¡œê·¸ ë ˆë²¨ ë³€ê²½', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', {
            prevLevel: this._getLogLevelName(prevLevel),
            newLevel: this._getLogLevelName(level)
          });
        }
      }
    } catch (error) {
      console.error(`[ì•ˆì „ ë¡œê¹…] ë¡œê·¸ ë ˆë²¨ ë³€ê²½ ì˜¤ë¥˜: ${level}`, error);
    }
  }

  /**
   * ë¡œê·¸ ë ˆë²¨ëª… ê°€ì ¸ì˜¤ê¸°
   * @private
   */
  private _getLogLevelName(level: LogLevel): string {
    try {
      switch(level) {
        case LOG_LEVEL.DEBUG: return 'DEBUG';
        case LOG_LEVEL.INFO: return 'INFO';
        case LOG_LEVEL.WARN: return 'WARN';
        case LOG_LEVEL.ERROR: return 'ERROR';
        case LOG_LEVEL.NONE: return 'NONE';
        default: return 'UNKNOWN';
      }
    } catch (error) {
      return 'UNKNOWN';
    }
  }

  /**
   * ë¡œê¹… í™œì„±í™”/ë¹„í™œì„±í™”
   * @param enabled - í™œì„±í™” ì—¬ë¶€
   */
  setEnabled(enabled: boolean): void {
    try {
      this.enabled = !!enabled;
      if (isDevMode()) {
        console.log('%c ë¡œê¹… ìƒíƒœ ë³€ê²½', 'background: #2196f3; color: white; padding: 2px 4px; border-radius: 2px;', {
          enabled: this.enabled
        });
      }
    } catch (error) {
      console.log(`[ì•ˆì „ ë¡œê¹…] ë¡œê¹… ${enabled ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'} ì„¤ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ`);
    }
  }

  /**
   * ë¡œê·¸ ë¬´ì‹œ íŒ¨í„´ ì¶”ê°€
   * @param pattern - ë¬´ì‹œí•  íŒ¨í„´
   */
  addIgnorePattern(pattern: string | RegExp): void {
    try {
      if (pattern && !this.ignorePatterns.includes(pattern)) {
        this.ignorePatterns.push(pattern);
      }
    } catch (error) {
      console.debug('[ì•ˆì „ ë¡œê¹…] ë¡œê·¸ ë¬´ì‹œ íŒ¨í„´ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', pattern);
    }
  }

  /**
   * ë¡œê·¸ ë¬´ì‹œ íŒ¨í„´ ì œê±°
   * @param pattern - ì œê±°í•  íŒ¨í„´
   */
  removeIgnorePattern(pattern: string | RegExp): void {
    try {
      const index = this.ignorePatterns.indexOf(pattern);
      if (index !== -1) {
        this.ignorePatterns.splice(index, 1);
      }
    } catch (error) {
      console.debug('[ì•ˆì „ ë¡œê¹…] ë¡œê·¸ ë¬´ì‹œ íŒ¨í„´ ì œê±° ì¤‘ ì˜¤ë¥˜ ë°œìƒ', pattern);
    }
  }

  /**
   * ë¡œê·¸ ë¬´ì‹œ ì—¬ë¶€ ê²€ì‚¬
   * @param message - ë¡œê·¸ ë©”ì‹œì§€
   * @returns ë¬´ì‹œ ì—¬ë¶€
   * @private
   */
  private _shouldIgnore(message: string): boolean {
    try {
      if (!message || typeof message !== 'string') return false;
      
      for (const pattern of this.ignorePatterns) {
        if (typeof pattern === 'string') {
          if (message.includes(pattern)) return true;
        } else if (pattern instanceof RegExp) {
          if (pattern.test(message)) return true;
        }
      }
      return false;
    } catch (error) {
      // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ì ìœ¼ë¡œ ë¬´ì‹œí•˜ì§€ ì•ŠìŒ
      return false;
    }
  }

  /**
   * ì‚¬ìš©ì ID ì„¤ì •
   * @param userId - ì‚¬ìš©ì ID
   */
  setUserId(userId: string): void {
    try {
      this.context.setUserId(userId);
    } catch (error) {
      console.debug(`[ì•ˆì „ ë¡œê¹…] ì‚¬ìš©ì ID ì„¤ì •: ${userId}`);
    }
  }

  /**
   * ì„¸ì…˜ ID ì„¤ì •
   * @param sessionId - ì„¸ì…˜ ID
   */
  setSessionId(sessionId: string): void {
    try {
      this.context.setSessionId(sessionId);
    } catch (error) {
      console.debug(`[ì•ˆì „ ë¡œê¹…] ì„¸ì…˜ ID ì„¤ì •: ${sessionId}`);
    }
  }

  /**
   * ìš”ì²­ ID ì„¤ì •
   * @param requestId - ìš”ì²­ ID
   */
  setRequestId(requestId: string): void {
    try {
      this.context.setRequestId(requestId);
    } catch (error) {
      console.debug(`[ì•ˆì „ ë¡œê¹…] ìš”ì²­ ID ì„¤ì •: ${requestId}`);
    }
  }

  /**
   * ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì„¤ì •
   * @param key - ì»¨í…ìŠ¤íŠ¸ í‚¤
   * @param value - ì»¨í…ìŠ¤íŠ¸ ê°’
   */
  setContext(key: string, value: any): void {
    try {
      this.context.setContext(key, value);
    } catch (error) {
      console.debug(`[ì•ˆì „ ë¡œê¹…] ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì„¤ì •: ${key}=${value}`);
    }
  }

  /**
   * ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
   */
  clearContext(): void {
    try {
      this.context.clear();
    } catch (error) {
      console.debug('[ì•ˆì „ ë¡œê¹…] ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ');
    }
  }

  /**
   * ë¡œê·¸ ì¶œë ¥ (ë‚´ë¶€ ì‚¬ìš©)
   * @param level - ë¡œê·¸ ë ˆë²¨
   * @param module - ëª¨ë“ˆëª…
   * @param message - ë¡œê·¸ ë©”ì‹œì§€
   * @param data - ì¶”ê°€ ë°ì´í„°
   * @private
   */
  private _log(level: LogLevel, module: string, message: string, data?: any): void {
    try {
      // ë¡œê·¸ ë ˆë²¨ ì²´í¬ - ì„¤ì •ëœ ë ˆë²¨ë³´ë‹¤ ë‚®ìœ¼ë©´ ì¶œë ¥í•˜ì§€ ì•ŠìŒ
      if (!this.enabled || level < this.logLevel) {
        return;
      }
      
      // ë¬´ì‹œ íŒ¨í„´ ì²´í¬
      if (message && this._shouldIgnore(message)) {
        return;
      }
      
      const timestamp = new Date().toISOString();
      const context = this.context.getAll();
      const logEntry: LogEntry = {
        level: this._getLogLevelName(level),
        timestamp,
        module: module || 'App',
        message,
        data,
        context
      };
      
      // ë¡œê·¸ ì €ì¥
      this.recentLogs.unshift(logEntry);
      if (this.recentLogs.length > this.maxLogHistory) {
        this.recentLogs.pop();
      }
      
      // ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ë¬¸ìì—´ ìƒì„±
      let contextStr = '';
      if (context.userId) contextStr += ` userId=${context.userId}`;
      if (context.sessionId) contextStr += ` sessionId=${context.sessionId}`;
      if (context.requestId) contextStr += ` requestId=${context.requestId}`;
      
      // ì½˜ì†” ì¶œë ¥
      const prefix = `[${timestamp.split('T')[1].substring(0, 8)}] [${this._getLogLevelName(level)}] [${module || 'App'}]${contextStr}`;
      
      // ë¡œê·¸ ë ˆë²¨ì— ë”°ë¼ ë‹¤ë¥¸ ìŠ¤íƒ€ì¼ ì ìš©
      let style = '';
      let icon = '';
      
      switch (level) {
        case LOG_LEVEL.DEBUG:
          style = 'background: #9e9e9e; color: white; padding: 2px 4px; border-radius: 2px;';
          icon = '';
          console.debug(`%c ${icon} ${prefix}`, style, message, data || '');
          break;
        case LOG_LEVEL.INFO:
          style = 'background: #2196f3; color: white; padding: 2px 4px; border-radius: 2px;';
          icon = '';
          console.info(`%c ${icon} ${prefix}`, style, message, data || '');
          break;
        case LOG_LEVEL.WARN:
          style = 'background: #ff9800; color: white; padding: 2px 4px; border-radius: 2px;';
          icon = '';
          console.warn(`%c ${icon} ${prefix}`, style, message, data || '');
          break;
        case LOG_LEVEL.ERROR:
          style = 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;';
          icon = '';
          console.error(`%c ${icon} ${prefix}`, style, message, data || '');
          break;
      }
    } catch (error) {
      // ë¡œê¹… ìì²´ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•œ ê²½ìš° ê¸°ë³¸ ì½˜ì†” ë¡œê¹…ìœ¼ë¡œ í´ë°±
      console.error('[ë¡œê¹… ì‹œìŠ¤í…œ ì˜¤ë¥˜]', error);
      const levelName = level === LOG_LEVEL.DEBUG ? 'DEBUG' : 
                        level === LOG_LEVEL.INFO ? 'INFO' : 
                        level === LOG_LEVEL.WARN ? 'WARN' : 'ERROR';
      
      console[levelName.toLowerCase()](`[ì•ˆì „ ë¡œê¹…] [${levelName}] [${module || 'App'}]`, message, data || '');
    }
  }

  /**
   * ë””ë²„ê·¸ ë¡œê·¸
   */
  debug = (moduleOrMessage: string, messageOrData?: any, data?: any): void => {
    try {
      // ì¸ì ê°œìˆ˜ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬
      if (messageOrData === undefined && data === undefined) {
        // ì¸ìê°€ 1ê°œì¸ ê²½ìš°: moduleOrMessageëŠ” ë©”ì‹œì§€ë¡œ ì²˜ë¦¬
        this._log(LOG_LEVEL.DEBUG, 'App', moduleOrMessage);
      } else if (data === undefined) {
        // ì¸ìê°€ 2ê°œì¸ ê²½ìš°: ì²« ë²ˆì§¸ ì¸ìê°€ ëª¨ë“ˆëª…ì¸ì§€ ë©”ì‹œì§€ì¸ì§€ íŒë‹¨
        if (typeof messageOrData === 'string') {
          // messageOrDataê°€ ë¬¸ìì—´ì´ë©´ moduleOrMessageëŠ” ëª¨ë“ˆëª…, messageOrDataëŠ” ë©”ì‹œì§€ë¡œ ì²˜ë¦¬
          this._log(LOG_LEVEL.DEBUG, moduleOrMessage, messageOrData);
        } else {
          // messageOrDataê°€ ë¬¸ìì—´ì´ ì•„ë‹ˆë©´ moduleOrMessageëŠ” ë©”ì‹œì§€, messageOrDataëŠ” ë°ì´í„°ë¡œ ì²˜ë¦¬
          this._log(LOG_LEVEL.DEBUG, 'App', moduleOrMessage, messageOrData);
        }
      } else {
        // ì¸ìê°€ 3ê°œì¸ ê²½ìš°: ëª¨ë‘ ê·¸ëŒ€ë¡œ ì‚¬ìš©
        this._log(LOG_LEVEL.DEBUG, moduleOrMessage, messageOrData, data);
      }
    } catch (error) {
      // ë””ë²„ê·¸ ë¡œê·¸ëŠ” ì˜¤ë¥˜ ì‹œ ì¶œë ¥í•˜ì§€ ì•ŠìŒ
    }
  };

  /**
   * ì •ë³´ ë¡œê·¸
   */
  info = (moduleOrMessage: string, messageOrData?: any, data?: any): void => {
    try {
      // ì¸ì ê°œìˆ˜ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬
      if (messageOrData === undefined && data === undefined) {
        // ì¸ìê°€ 1ê°œì¸ ê²½ìš°: moduleOrMessageëŠ” ë©”ì‹œì§€ë¡œ ì²˜ë¦¬
        this._log(LOG_LEVEL.INFO, 'App', moduleOrMessage);
      } else if (data === undefined) {
        // ì¸ìê°€ 2ê°œì¸ ê²½ìš°: ì²« ë²ˆì§¸ ì¸ìê°€ ëª¨ë“ˆëª…ì¸ì§€ ë©”ì‹œì§€ì¸ì§€ íŒë‹¨
        if (typeof messageOrData === 'string') {
          // messageOrDataê°€ ë¬¸ìì—´ì´ë©´ moduleOrMessageëŠ” ëª¨ë“ˆëª…, messageOrDataëŠ” ë©”ì‹œì§€ë¡œ ì²˜ë¦¬
          this._log(LOG_LEVEL.INFO, moduleOrMessage, messageOrData);
        } else {
          // messageOrDataê°€ ë¬¸ìì—´ì´ ì•„ë‹ˆë©´ moduleOrMessageëŠ” ë©”ì‹œì§€, messageOrDataëŠ” ë°ì´í„°ë¡œ ì²˜ë¦¬
          this._log(LOG_LEVEL.INFO, 'App', moduleOrMessage, messageOrData);
        }
      } else {
        // ì¸ìê°€ 3ê°œì¸ ê²½ìš°: ëª¨ë‘ ê·¸ëŒ€ë¡œ ì‚¬ìš©
        this._log(LOG_LEVEL.INFO, moduleOrMessage, messageOrData, data);
      }
    } catch (error) {
      // INFO ë¡œê·¸ëŠ” ì˜¤ë¥˜ ì‹œ ì¶œë ¥í•˜ì§€ ì•ŠìŒ
    }
  };

  /**
   * ê²½ê³  ë¡œê·¸
   */
  warn = (moduleOrMessage: string, messageOrData?: any, data?: any): void => {
    try {
      // ì¸ì ê°œìˆ˜ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬
      if (messageOrData === undefined && data === undefined) {
        // ì¸ìê°€ 1ê°œì¸ ê²½ìš°: moduleOrMessageëŠ” ë©”ì‹œì§€ë¡œ ì²˜ë¦¬
        this._log(LOG_LEVEL.WARN, 'App', moduleOrMessage);
      } else if (data === undefined) {
        // ì¸ìê°€ 2ê°œì¸ ê²½ìš°: ì²« ë²ˆì§¸ ì¸ìê°€ ëª¨ë“ˆëª…ì¸ì§€ ë©”ì‹œì§€ì¸ì§€ íŒë‹¨
        if (typeof messageOrData === 'string') {
          // messageOrDataê°€ ë¬¸ìì—´ì´ë©´ moduleOrMessageëŠ” ëª¨ë“ˆëª…, messageOrDataëŠ” ë©”ì‹œì§€ë¡œ ì²˜ë¦¬
          this._log(LOG_LEVEL.WARN, moduleOrMessage, messageOrData);
        } else {
          // messageOrDataê°€ ë¬¸ìì—´ì´ ì•„ë‹ˆë©´ moduleOrMessageëŠ” ë©”ì‹œì§€, messageOrDataëŠ” ë°ì´í„°ë¡œ ì²˜ë¦¬
          this._log(LOG_LEVEL.WARN, 'App', moduleOrMessage, messageOrData);
        }
      } else {
        // ì¸ìê°€ 3ê°œì¸ ê²½ìš°: ëª¨ë‘ ê·¸ëŒ€ë¡œ ì‚¬ìš©
        this._log(LOG_LEVEL.WARN, moduleOrMessage, messageOrData, data);
      }
    } catch (error) {
      console.warn(`[ì•ˆì „ ë¡œê¹…] [WARN] [${moduleOrMessage}]`, messageOrData, data || '');
    }
  };

  /**
   * ì˜¤ë¥˜ ë¡œê·¸
   */
  error = (moduleOrMessage: string, messageOrData?: any, error?: any): void => {
    try {
      // ì¸ì ê°œìˆ˜ì— ë”°ë¼ ë‹¤ë¥´ê²Œ ì²˜ë¦¬
      let actualModule = 'App';
      let actualMessage = '';
      let actualError: any = null;

      if (messageOrData === undefined && error === undefined) {
        // ì¸ìê°€ 1ê°œì¸ ê²½ìš°: moduleOrMessageëŠ” ë©”ì‹œì§€ë¡œ ì²˜ë¦¬
        actualMessage = moduleOrMessage;
      } else if (error === undefined) {
        // ì¸ìê°€ 2ê°œì¸ ê²½ìš°: ì²« ë²ˆì§¸ ì¸ìê°€ ëª¨ë“ˆëª…ì¸ì§€ ë©”ì‹œì§€ì¸ì§€ íŒë‹¨
        if (typeof messageOrData === 'string' || messageOrData === undefined) {
          // messageOrDataê°€ ë¬¸ìì—´ì´ë©´ moduleOrMessageëŠ” ëª¨ë“ˆëª…, messageOrDataëŠ” ë©”ì‹œì§€ë¡œ ì²˜ë¦¬
          actualModule = moduleOrMessage;
          actualMessage = messageOrData || '';
        } else {
          // messageOrDataê°€ ë¬¸ìì—´ì´ ì•„ë‹ˆë©´ moduleOrMessageëŠ” ë©”ì‹œì§€, messageOrDataëŠ” ì˜¤ë¥˜ë¡œ ì²˜ë¦¬
          actualMessage = moduleOrMessage;
          actualError = messageOrData;
        }
      } else {
        // ì¸ìê°€ 3ê°œì¸ ê²½ìš°: ëª¨ë‘ ê·¸ëŒ€ë¡œ ì‚¬ìš©
        actualModule = moduleOrMessage;
        actualMessage = messageOrData;
        actualError = error;
      }

      // ì˜¤ë¥˜ ê°ì²´ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
      interface ErrorLike {
        message: string;
        stack?: string;
        name?: string;
      }

      // ì˜¤ë¥˜ ê°ì²´ íƒ€ì… ê°€ë“œ
      const isErrorLike = (obj: any): obj is ErrorLike => {
        return obj && typeof obj === 'object' && 'message' in obj;
      };

      // ì˜¤ë¥˜ ê°ì²´ê°€ Error ì¸ìŠ¤í„´ìŠ¤ì¸ ê²½ìš° êµ¬ì¡°í™”ëœ ê°ì²´ë¡œ ë³€í™˜
      let formattedError: any = actualError;
      
      if (actualError && isErrorLike(actualError)) {
        formattedError = {
          message: actualError.message,
          stack: actualError.stack || '',
          name: actualError.name || 'Error'
        };
      } else if (actualError !== null) {
        // ì´ë¯¸ ê°ì²´ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ì‚¬ìš©
        formattedError = actualError;
      }
      
      this._log(LOG_LEVEL.ERROR, actualModule, actualMessage, formattedError);
    } catch (logError) {
      // ì˜¤ë¥˜ ê°ì²´ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
      interface ErrorLike {
        message: string;
        stack?: string;
        name?: string;
      }

      // ì˜¤ë¥˜ ê°ì²´ íƒ€ì… ê°€ë“œ
      const isErrorLike = (obj: any): obj is ErrorLike => {
        return obj && typeof obj === 'object' && 'message' in obj;
      };

      let formattedError: any = error;
      
      if (error && isErrorLike(error)) {
        formattedError = { 
          message: error.message, 
          stack: error.stack || '' 
        };
      }
      
      console.error(`[ì•ˆì „ ë¡œê¹…] [ERROR]`, moduleOrMessage, messageOrData || '', formattedError || '');
    }
  };

  /**
   * ìµœê·¼ ë¡œê·¸ ê°€ì ¸ì˜¤ê¸°
   * @param count - ê°€ì ¸ì˜¬ ë¡œê·¸ ìˆ˜
   * @returns ìµœê·¼ ë¡œê·¸ ë°°ì—´
   */
  getRecentLogs(count = 10): LogEntry[] {
    return this.recentLogs.slice(0, Math.min(count, this.recentLogs.length));
  }

  /**
   * ë¡œê·¸ ë‚´ë³´ë‚´ê¸° (ê°ì²´ ë°°ì—´)
   * @returns ë¡œê·¸ ê°ì²´ ë°°ì—´
   */
  exportLogs(): LogEntry[] {
    try {
      return [...this.recentLogs];
    } catch (error) {
      console.error('[ì•ˆì „ ë¡œê¹…] ë¡œê·¸ ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨', error);
      return [];
    }
  }

  /**
   * ë¡œê·¸ ë‚´ë³´ë‚´ê¸° (ë¬¸ìì—´)
   * @returns JSON ë¬¸ìì—´
   */
  exportLogsAsString(): string {
    try {
      return JSON.stringify(this.recentLogs, null, 2);
    } catch (error) {
      console.error('[ì•ˆì „ ë¡œê¹…] ë¡œê·¸ ë¬¸ìì—´ ë‚´ë³´ë‚´ê¸° ì‹¤íŒ¨', error);
      return '[]';
    }
  }

  /**
   * ë¡œê·¸ ë‹¤ìš´ë¡œë“œ
   */
  downloadLogs(): void {
    try {
      const logs = this.exportLogsAsString();
      const blob = new Blob([logs], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cvehub-logs-${new Date().toISOString().replace(/:/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('[ì•ˆì „ ë¡œê¹…] [ERROR] [LoggingService]', 'ë¡œê·¸ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨', error);
    }
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
const logger = new LoggingService();

export default logger;



============================================================
File: /home/CVEHub/frontend/src/shared/utils/mentionUtils.js
------------------------------------------------------------
// ë©˜ì…˜ëœ ì‚¬ìš©ìë¥¼ í•˜ì´ë¼ì´íŠ¸í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
export const highlightMentions = (content) => {
  if (!content) return '';
  
  // @username íŒ¨í„´ì„ ì°¾ì•„ì„œ í•˜ì´ë¼ì´íŠ¸ëœ ìŠ¤íŒ¬ìœ¼ë¡œ ë³€í™˜
  // í•œê¸€, ì˜ë¬¸, ìˆ«ìë¥¼ í¬í•¨í•˜ëŠ” íŒ¨í„´ìœ¼ë¡œ ìˆ˜ì •
  const parts = content.split(/(@[ê°€-í£a-zA-Z0-9]+)/g);
  
  return parts.map((part, index) => {
    if (part.match(/^@[ê°€-í£a-zA-Z0-9]+$/)) {
      // ë©˜ì…˜ì¸ ê²½ìš° í•˜ì´ë¼ì´íŠ¸ ì²˜ë¦¬
      return `<span class="mention" style="color: #1976d2; font-weight: 500; background-color: rgba(25, 118, 210, 0.08); padding: 2px 4px; border-radius: 4px;">${part}</span>`;
    }
    return part;
  }).join('');
};

// í…ìŠ¤íŠ¸ì—ì„œ ë©˜ì…˜ëœ ì‚¬ìš©ì ëª©ë¡ ì¶”ì¶œ
export const extractMentions = (content) => {
  if (!content) return [];
  
  const mentions = content.match(/@[ê°€-í£a-zA-Z0-9]+/g) || [];
  return mentions.map(mention => mention.slice(1)); // @ ì œê±°
};



============================================================
File: /home/CVEHub/frontend/src/shared/utils/dateUtils.ts
------------------------------------------------------------
import { format, parseISO, isValid } from 'date-fns';
import { formatInTimeZone, utcToZonedTime } from 'date-fns-tz';
import { ko } from 'date-fns/locale';

// ë‚ ì§œ í¬ë§· ìƒìˆ˜
export const DATE_FORMATS = {
  API: "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", // API í†µì‹ ìš© ISO í¬ë§· (ëª¨ë“  ë¬¸ìë¥¼ ì‘ì€ë”°ì˜´í‘œë¡œ ì´ìŠ¤ì¼€ì´í”„)
  DISPLAY: {
    DEFAULT: 'yyyy-MM-dd HH:mm',
    DATE_ONLY: 'yyyy-MM-dd',
    TIME_ONLY: 'HH:mm:ss',
    FULL: 'yyyy-MM-dd HH:mm:ss',
    YEAR_MONTH: 'yyyy-MM'
  }
} as const;

// ì‹œê°„ëŒ€ ìƒìˆ˜
export const TIME_ZONES = {
  UTC: 'UTC',
  KST: 'Asia/Seoul',
  DEFAULT: 'Asia/Seoul'
} as const;

// íƒ€ì… ì •ì˜
export type DateFormatType = typeof DATE_FORMATS.DISPLAY[keyof typeof DATE_FORMATS.DISPLAY] | typeof DATE_FORMATS.API;
export type TimeZoneType = typeof TIME_ZONES[keyof typeof TIME_ZONES];
export type DateValueType = string | Date | number | null | undefined;

/**
 * í˜„ì¬ UTC ì‹œê°„ì„ Date ê°ì²´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
 * ë°±ì—”ë“œì˜ get_utc_now()ì™€ ìœ ì‚¬í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 * @returns UTC ì‹œê°„ì˜ Date ê°ì²´
 */
export const getUtcNow = (): Date => {
  return new Date();
};

/**
 * í˜„ì¬ UTC ì‹œê°„ì„ ISO 8601 í˜•ì‹ì˜ ë¬¸ìì—´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
 * @returns ISO 8601 í˜•ì‹ì˜ UTC ì‹œê°„ ë¬¸ìì—´ (ì˜ˆ: "2025-03-28T06:46:44.123Z")
 */
export const getUtcTimestamp = (): string => {
  return new Date().toISOString();
};

/**
 * í˜„ì¬ KST ì‹œê°„ì„ Date ê°ì²´ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.
 * ë°±ì—”ë“œì˜ get_kst_now()ì™€ ìœ ì‚¬í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 * date-fns-tzì˜ utcToZonedTimeì„ ì‚¬ìš©í•˜ì—¬ UTC ì‹œê°„ì„ KSTë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 * @returns KST ì‹œê°„ëŒ€ì˜ Date ê°ì²´
 */
export const getKstNow = (): Date => {
  // date-fns-tzì˜ utcToZonedTime í•¨ìˆ˜ë¡œ UTC -> KST ë³€í™˜
  return utcToZonedTime(new Date(), TIME_ZONES.KST);
};

/**
 * ë‚ ì§œ ê°’ì„ íŒŒì‹±í•˜ì—¬ Date ê°ì²´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 * ë‹¤ì–‘í•œ í˜•ì‹ì˜ ì…ë ¥(ISO ë¬¸ìì—´, Date ê°ì²´, íƒ€ì„ìŠ¤íƒ¬í”„ ë“±)ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * @param dateValue - ë³€í™˜í•  ë‚ ì§œ ê°’
 * @returns ë³€í™˜ëœ Date ê°ì²´ ë˜ëŠ” ë³€í™˜ ì‹¤íŒ¨ ì‹œ null
 */
export const parseDate = (dateValue: DateValueType): Date | null => {
  if (!dateValue) {
    return null;
  }

  try {
    // ì´ë¯¸ Date ê°ì²´ì¸ ê²½ìš°
    if (dateValue instanceof Date) {
      return isValid(dateValue) ? dateValue : null;
    }

    // ìˆ«ì(íƒ€ì„ìŠ¤íƒ¬í”„)ì¸ ê²½ìš°
    if (typeof dateValue === 'number') {
      const date = new Date(dateValue);
      return isValid(date) ? date : null;
    }

    // ë¬¸ìì—´ì¸ ê²½ìš°
    if (typeof dateValue === 'string') {
      // ISO 8601 í˜•ì‹ ë¬¸ìì—´ ì²˜ë¦¬
      if (dateValue.includes('T') || dateValue.includes('Z')) {
        const date = parseISO(dateValue);
        return isValid(date) ? date : null;
      }

      // MongoDB í˜•ì‹ ë¬¸ìì—´ ì²˜ë¦¬ (ISODate("2023-01-01T00:00:00.000Z"))
      if (dateValue.startsWith('ISODate(') && dateValue.endsWith(')')) {
        const isoString = dateValue.substring(9, dateValue.length - 2);
        const date = parseISO(isoString);
        return isValid(date) ? date : null;
      }

      // ì¼ë°˜ ë¬¸ìì—´ ì²˜ë¦¬
      const date = new Date(dateValue);
      return isValid(date) ? date : null;
    }
  } catch (error) {
    console.error('ë‚ ì§œ íŒŒì‹± ì˜¤ë¥˜:', error);
  }

  return null;
};

/**
 * ë‚ ì§œë¥¼ ì§€ì •ëœ í˜•ì‹ìœ¼ë¡œ í¬ë§·íŒ…í•©ë‹ˆë‹¤.
 * UTC ì‹œê°„ì„ ì§€ì •ëœ ì‹œê°„ëŒ€(ê¸°ë³¸ê°’: KST)ë¡œ ë³€í™˜í•˜ì—¬ í¬ë§·íŒ…í•©ë‹ˆë‹¤.
 * @param dateValue - í¬ë§·íŒ…í•  ë‚ ì§œ ê°’ (ISO ë¬¸ìì—´, Date ê°ì²´, íƒ€ì„ìŠ¤íƒ¬í”„ ë“±)
 * @param formatStr - ì¶œë ¥ í¬ë§· (ê¸°ë³¸ê°’: yyyy-MM-dd HH:mm)
 * @param timeZone - ì‹œê°„ëŒ€ (ê¸°ë³¸ê°’: Asia/Seoul)
 * @returns í¬ë§·íŒ…ëœ ë¬¸ìì—´
 */
export const formatDateTime = (
  dateValue: DateValueType,
  formatStr: string = DATE_FORMATS.DISPLAY.DEFAULT,
  timeZone: TimeZoneType = TIME_ZONES.KST
): string => {
  if (!dateValue) {
    return '-';
  }

  try {
    const date = parseDate(dateValue);
    if (!date) {
      return '-';
    }
    
    // date-fns-tzì˜ formatInTimeZone í•¨ìˆ˜ë¡œ í¬ë§·íŒ… ì²˜ë¦¬
    return formatInTimeZone(date, timeZone, formatStr, { locale: ko });
  } catch (error) {
    return '-';
  }
};

/**
 * ë‚ ì§œë¥¼ ISO 8601 í˜•ì‹ì˜ ë¬¸ìì—´ë¡œ ì§ë ¬í™”í•©ë‹ˆë‹¤.
 * ë°±ì—”ë“œì˜ serialize_datetime()ê³¼ ìœ ì‚¬í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 * @param dateValue - ì§ë ¬í™”í•  ë‚ ì§œ ê°’
 * @returns ISO 8601 í˜•ì‹ì˜ ë¬¸ìì—´ ë˜ëŠ” null
 */
export const serializeDateTime = (dateValue: DateValueType): string | null => {
  if (!dateValue) {
    return null;
  }

  try {
    const date = parseDate(dateValue);
    if (!date) {
      return null;
    }

    return date.toISOString();
  } catch (error) {
    console.error('ë‚ ì§œ ì§ë ¬í™” ì˜¤ë¥˜:', error);
    return null;
  }
};

/**
 * API ìš”ì²­ ë°ì´í„°ì—ì„œ ë‚ ì§œ í•„ë“œë¥¼ ìë™ìœ¼ë¡œ UTCë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 * @param data - APIë¡œ ì „ì†¡í•  ë°ì´í„°
 * @param dateFields - ë‚ ì§œ í•„ë“œ ì´ë¦„ ë°°ì—´
 * @returns ë‚ ì§œ í•„ë“œê°€ UTCë¡œ ë³€í™˜ëœ ë°ì´í„°
 */
export const normalizeDateFieldsForApi = <T>(
  data: T | null | undefined,
  dateFields: string[] = ['created_at', 'last_modified_at', 'dateAdded']
): T | null | undefined => {
  if (!data) {
    return data;
  }

  const result = { ...data } as any;

  for (const field of dateFields) {
    if (field in result && result[field]) {
      try {
        const date = parseDate(result[field]);
        if (date) {
          result[field] = date.toISOString();
        }
      } catch (error) {
        console.error(`í•„ë“œ ${field} ì •ê·œí™” ì˜¤ë¥˜:`, error);
      }
    }
  }

  return result as T;
};

/**
 * API ì‘ë‹µ ë°ì´í„°ì˜ ë‚ ì§œ í•„ë“œë¥¼ ìë™ìœ¼ë¡œ Date ê°ì²´ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 * @param data - API ì‘ë‹µ ë°ì´í„° (ê°ì²´ ë˜ëŠ” ë°°ì—´)
 * @param requestUrl - ìš”ì²­ URL (ë””ë²„ê¹… ìš©ë„)
 * @returns ë‚ ì§œ í•„ë“œê°€ Date ê°ì²´ë¡œ ë³€í™˜ëœ ë°ì´í„°
 */
export const normalizeDateFieldsFromApi = <T>(data: T, requestUrl: string = ''): T => {
  if (!data || shouldSkipDateProcessing(requestUrl)) {
    return data;
  }

  // ë‚ ì§œ í•„ë“œ í›„ë³´ (ì¹´ë©œì¼€ì´ìŠ¤ì™€ ìŠ¤ë„¤ì´í¬ì¼€ì´ìŠ¤ ëª¨ë‘ í¬í•¨)
  const DATE_FIELD_CANDIDATES = [
    // ì¹´ë©œì¼€ì´ìŠ¤
    'createdAt', 'lastModifiedAt', 'updatedAt', 'publishedAt', 
    'expiresAt', 'deletedAt', 'dateAdded', 'dateModified', 'date',
    'timestamp', // í™œë™ ì´ë ¥ì˜ timestamp í•„ë“œ ì¶”ê°€
    // ìŠ¤ë„¤ì´í¬ì¼€ì´ìŠ¤ (ë°±ì—”ë“œ ì¼ê´€ì„±)
    'created_at', 'last_modified_at', 'updated_at', 'published_at',
    'expires_at', 'deleted_at', 'date_added', 'date_modified',
    'timestamp' // í™œë™ ì´ë ¥ì˜ timestamp í•„ë“œ ì¶”ê°€ (ìŠ¤ë„¤ì´í¬ì¼€ì´ìŠ¤)
  ];

  const processValue = (value: any): any => {
    if (!value) {
      return value;
    }

    // ë°°ì—´ ì²˜ë¦¬
    if (Array.isArray(value)) {
      return value.map(item => processValue(item));
    }

    // ê°ì²´ ì²˜ë¦¬
    if (typeof value === 'object' && value !== null) {
      // Date ê°ì²´ëŠ” ê·¸ëŒ€ë¡œ ë°˜í™˜
      if (value instanceof Date) {
        return value;
      }

      // ì¼ë°˜ ê°ì²´ ì²˜ë¦¬
      const result: any = {};
      for (const [key, val] of Object.entries(value)) {
        // ë‚ ì§œ í•„ë“œ í›„ë³´ì¸ ê²½ìš° Date ê°ì²´ë¡œ ë³€í™˜ ì‹œë„ (UTC->KST ë³€í™˜ ê³ ë ¤)
        if (DATE_FIELD_CANDIDATES.includes(key) && typeof val === 'string') {
          try {
                                    // ë°±ì—”ë“œì—ì„œ ì „ì†¡ëœ ë‚ ì§œë¥¼ ê°„ë‹¨í•˜ê²Œ ì²˜ë¦¬
            let date;
            
            // MongoDB ë¬¸ìì—´ì„ ISO í˜•ì‹ìœ¼ë¡œ ì˜ˆìƒí•˜ê³  ì²˜ë¦¬
            // MongoDB ISODate ë¬¸ìì—´ì€ Zê°€ ì—†ì–´ë„ UTC ì‹œê°„ì„
            try {
              // 1. ë¬¸ìì—´ì— Zê°€ ì—†ìœ¼ë©´ ì¶”ê°€
              if (typeof val === 'string' && val.includes('T') && !val.includes('Z') && !val.includes('+')) {
                const isoString = val.replace(/(\.\d+)?$/, 'Z');
                date = parseISO(isoString);
              } else {
                // 2. ê¸°ë³¸ íŒŒì‹± ì‹œë„
                date = parseDate(val);
              }
              
              if (date && isValid(date)) {
                // ìœ íš¨í•œ ë‚ ì§œë¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
                result[key] = date;
            
              } else {
                result[key] = val;
              }
            } catch (e) {
              // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì›ë³¸ ê°’ ê·¸ëŒ€ë¡œ ì‚¬ìš©
              result[key] = val;
            }
          } catch (error) {
            console.error(`[ERROR] ë‚ ì§œ ë³€í™˜ ì˜¤ë¥˜ (${key}):`, error);
            result[key] = val;
          }
        } else {
          // ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬
          result[key] = processValue(val);
        }
      }
      return result;
    }

    return value;
  };

  return processValue(data);
};

/**
 * íŠ¹ì • URL íŒ¨í„´ì— ëŒ€í•´ ë‚ ì§œ ì²˜ë¦¬ë¥¼ ê±´ë„ˆë›¸ì§€ ê²°ì •í•˜ëŠ” í•¨ìˆ˜
 * @param url - ìš”ì²­ URL
 * @returns ë‚ ì§œ ì²˜ë¦¬ë¥¼ ê±´ë„ˆë›¸ì§€ ì—¬ë¶€
 */
export const shouldSkipDateProcessing = (url: string = ''): boolean => {
  const SKIP_PATTERNS = [
    '/auth/', 
    '/config/',
    '/health',
    '/metrics'
  ];
  
  return SKIP_PATTERNS.some(pattern => url.includes(pattern));
};

/**
 * ì£¼ì–´ì§„ íƒ€ì„ìŠ¤íƒ¬í”„ë¡œë¶€í„° ê²½ê³¼ëœ ì‹œê°„ì„ í•œêµ­ì–´ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * @param timestamp - ë¹„êµí•  íƒ€ì„ìŠ¤íƒ¬í”„
 * @returns ê²½ê³¼ ì‹œê°„ ë¬¸ìì—´ (ì˜ˆ: '5ì´ˆ', '10ë¶„', '2ì‹œê°„', '3ì¼')
 */
export const timeAgo = (timestamp: DateValueType): string => {
  if (!timestamp) {
    return '-';
  }

  try {
    const date = parseDate(timestamp);
    if (!date) {
      return '-';
    }

    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHour = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHour / 24);
    const diffMonth = Math.floor(diffDay / 30);
    const diffYear = Math.floor(diffMonth / 12);

    if (diffSec < 60) return `${diffSec}ì´ˆ ì „`;
    if (diffMin < 60) return `${diffMin}ë¶„ ì „`;
    if (diffHour < 24) return `${diffHour}ì‹œê°„ ì „`;
    if (diffDay < 30) return `${diffDay}ì¼ ì „`;
    if (diffMonth < 12) return `${diffMonth}ê°œì›” ì „`;
    return `${diffYear}ë…„ ì „`;
  } catch (error) {
    console.error('timeAgo ì˜¤ë¥˜:', error);
    return '-';
  }
};

// date-fnsì˜ isValid í•¨ìˆ˜ ì¬ë‚´ë³´ë‚´ê¸°
export { isValid };



============================================================
File: /home/CVEHub/frontend/src/shared/utils/avatarUtils.js
------------------------------------------------------------
const ANIMAL_EMOJIS = [
  'ğŸ¶', 'ğŸ±', 'ğŸ­', 'ğŸ¹', 'ğŸ°', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼',
  'ğŸ¨', 'ğŸ¯', 'ğŸ¦', 'ğŸ®', 'ğŸ·', 'ğŸ¸', 'ğŸ™', 'ğŸµ'
];

export const getAnimalEmoji = (username) => {
  // ì‚¬ìš©ì ì´ë¦„ì„ ê¸°ë°˜ìœ¼ë¡œ ì¼ê´€ëœ ì´ëª¨ì§€ë¥¼ ë°˜í™˜
  const charSum = username.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
  return ANIMAL_EMOJIS[charSum % ANIMAL_EMOJIS.length];
};

export const getInitials = (name) => {
  return name
    .split(' ')
    .map(part => part[0])
    .join('')
    .toUpperCase();
};



============================================================
File: /home/CVEHub/frontend/src/shared/contexts/ErrorContext.tsx
------------------------------------------------------------
import React, { createContext, useContext, useState, useCallback, ReactNode, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { clearAuthStorage } from '../utils/storage/tokenStorage';
import { AxiosError } from 'axios';
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
import { useAuthQuery } from 'features/auth/hooks/useAuthQuery';

// ì‘ë‹µ ë°ì´í„° íƒ€ì… ì •ì˜
interface ErrorResponseData {
  message?: string;
  [key: string]: any;
}

interface ErrorState {
  type: 'error';
  message: string;
}

interface ErrorContextValue {
  error: ErrorState | null;
  handleError: (error: AxiosError | Error | any) => void;
  clearError: () => void;
}

const ErrorContext = createContext<ErrorContextValue | null>(null);

interface ErrorProviderProps {
  children: ReactNode;
}

export const ErrorProvider: React.FC<ErrorProviderProps> = ({ children }) => {
  const [error, setError] = useState<ErrorState | null>(null);
  const navigate = useNavigate();
  const { logout } = useAuthQuery();

  // ë””ë°”ìš´ìŠ¤ëœ ì—ëŸ¬ ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
  const debouncedSetError = useCallback(
    debounce((newError: ErrorState | null) => {
      setError(newError);
    }, 300),
    []
  );

  // ìŠ¤ë¡œí‹€ëœ ì—ëŸ¬ ì²˜ë¦¬ í•¨ìˆ˜
  const handleError = useCallback(
    throttle((err: AxiosError | Error | any) => {
      const error = err as AxiosError<ErrorResponseData>; // íƒ€ì… assertion ìˆ˜ì •
      const status = error?.response?.status;
      const message = error?.response?.data?.message || error?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';

      // 401 Unauthorized ì—ëŸ¬ ì²˜ë¦¬
      if (status === 401) {
        // í† í° ë§Œë£Œ ë˜ëŠ” ì¸ì¦ ì‹¤íŒ¨
        clearAuthStorage();
        logout();
        navigate('/login', {
          state: {
            from: window.location.pathname,
            message: 'ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.',
          },
        });
        return;
      }

      // 403 Forbidden ì—ëŸ¬ ì²˜ë¦¬
      if (status === 403) {
        debouncedSetError({
          type: 'error',
          message: 'ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.',
        });
        return;
      }

      // 404 Not Found ì—ëŸ¬ ì²˜ë¦¬
      if (status === 404) {
        debouncedSetError({
          type: 'error',
          message: 'ìš”ì²­í•˜ì‹  ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
        });
        return;
      }

      // 500 Internal Server Error ì²˜ë¦¬
      if (status >= 500) {
        debouncedSetError({
          type: 'error',
          message: 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
        });
        return;
      }

      // ê¸°íƒ€ ì˜¤ë¥˜ ì²˜ë¦¬
      debouncedSetError({
        type: 'error',
        message,
      });
    }, 500, { leading: true, trailing: false }),
    [navigate, logout, debouncedSetError]
  );

  const clearError = useCallback(() => {
    debouncedSetError(null);
  }, [debouncedSetError]);

  // ë©”ëª¨ì´ì œì´ì…˜ëœ ì»¨í…ìŠ¤íŠ¸ ê°’
  const contextValue = useMemo<ErrorContextValue>(
    () => ({
      error,
      handleError,
      clearError,
    }),
    [error, handleError, clearError]
  );

  return (
    <ErrorContext.Provider value={contextValue}>
      {children}
    </ErrorContext.Provider>
  );
};

export const useError = () => {
  const context = useContext(ErrorContext);
  if (!context) {
    throw new Error('useError must be used within an ErrorProvider');
  }
  return context;
};

export default ErrorContext;


============================================================
File: /home/CVEHub/frontend/src/theme.js
------------------------------------------------------------
import { createTheme } from '@mui/material/styles';

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
    },
    secondary: {
      main: '#9c27b0',
      light: '#ba68c8',
      dark: '#7b1fa2',
    },
    error: {
      main: '#d32f2f',
      light: '#ef5350',
      dark: '#c62828',
    },
    warning: {
      main: '#ed6c02',
      light: '#ff9800',
      dark: '#e65100',
    },
    info: {
      main: '#0288d1',
      light: '#03a9f4',
      dark: '#01579b',
    },
    success: {
      main: '#2e7d32',
      light: '#4caf50',
      dark: '#1b5e20',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
  },
  typography: {
    fontFamily: [
      '-apple-system',
      'BlinkMacSystemFont',
      '"Segoe UI"',
      'Roboto',
      '"Helvetica Neue"',
      'Arial',
      'sans-serif',
    ].join(','),
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
        },
      },
    },
  },
});

export default theme; 


============================================================
File: /home/CVEHub/frontend/src/config.js
------------------------------------------------------------
/**
 * ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì—­ ì„¤ì •
 * 
 * ì´ íŒŒì¼ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì²´ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì„¤ì •ê°’ì„ ì •ì˜í•©ë‹ˆë‹¤.
 * í™˜ê²½ ë³€ìˆ˜ëŠ” .env íŒŒì¼ ë˜ëŠ” docker-compose.ymlì—ì„œ ê´€ë¦¬ë©ë‹ˆë‹¤.
 */

// ë¸Œë¼ìš°ì € í™˜ê²½ì—ì„œ í˜„ì¬ í˜¸ìŠ¤íŠ¸ ê¸°ë°˜ URL ê°€ì ¸ì˜¤ê¸°
const getCurrentOrigin = () => {
  if (typeof window !== 'undefined') {
    return window.location.origin;
  }
  return null;
};

// API ê¸°ë³¸ URL - ìš°ì„ ìˆœìœ„: í™˜ê²½ë³€ìˆ˜ > í˜„ì¬ í˜¸ìŠ¤íŠ¸ > ê¸°ë³¸ê°’
export const API_BASE_URL = process.env.REACT_APP_API_URL || getCurrentOrigin() || 'http://localhost:8000';

// WebSocket ê¸°ë³¸ URL - ìš°ì„ ìˆœìœ„: í™˜ê²½ë³€ìˆ˜ > í˜„ì¬ í˜¸ìŠ¤íŠ¸ > ê¸°ë³¸ê°’
// Socket.IO ì—°ê²°ì— ì‚¬ìš©ë¨
export const WS_BASE_URL = process.env.REACT_APP_WS_URL || getCurrentOrigin() || 'http://localhost:8000';

// Socket.IO ê²½ë¡œ ì„¤ì • - ë°±ì—”ë“œì˜ ë§ˆìš´íŠ¸ ê²½ë¡œì™€ ì¼ì¹˜í•´ì•¼ í•¨
export const SOCKET_IO_PATH = '/socket.io';

// WebSocket ì—°ê²° ì„¤ì •
export const SOCKET_CONFIG = {
  RECONNECTION: true,
  RECONNECTION_ATTEMPTS: parseInt(process.env.REACT_APP_WS_RECONNECTION_ATTEMPTS) || 10,
  RECONNECTION_DELAY: parseInt(process.env.REACT_APP_WS_RECONNECTION_DELAY) || 1000,
  RECONNECTION_DELAY_MAX: parseInt(process.env.REACT_APP_WS_RECONNECTION_DELAY_MAX) || 30000,
  TIMEOUT: parseInt(process.env.REACT_APP_WS_TIMEOUT) || 20000,
  LOG_PING_PONG: process.env.REACT_APP_WS_LOG_PING_PONG === 'true' || false,
  AUTO_CONNECT: false, // ìˆ˜ë™ìœ¼ë¡œ ì—°ê²° ê´€ë¦¬
  CONNECTION_CHECK_INTERVAL: 5000, // ì—°ê²° ìƒíƒœ ì²´í¬ ê°„ê²© (ms)
  CONNECTION_CHECK_TIMEOUT: 10000, // ì—°ê²° ì²´í¬ íƒ€ì„ì•„ì›ƒ (ms)
};

// ì¸ì¦ì´ í•„ìš”í•˜ì§€ ì•Šì€ ê³µê°œ ì—”ë“œí¬ì¸íŠ¸ ëª©ë¡
export const PUBLIC_ENDPOINTS = [
    '/auth/token',
    '/auth/login',
    '/auth/signup',
    '/auth/refresh',
    '/auth/verify',
    '/auth/password/reset',
    '/auth/password/reset/verify',
    '/health'
];

// API ì—”ë“œí¬ì¸íŠ¸ ì„¤ì •
export const API_ENDPOINTS = {
    /**
     * ì¸ì¦ ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸
     */
    AUTH: {
        LOGIN: '/auth/token',
        SIGNUP: '/auth/signup',
        REFRESH: '/auth/refresh',
        LOGOUT: '/auth/logout',
        ME: '/auth/me'
    },
    /**
     * ì•Œë¦¼ ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸
     */
    NOTIFICATION: {
        BASE: '/notifications',
        READ: (id) => `/notifications/${id}/read`,
        READ_ALL: '/notifications/read-all',
        UNREAD_COUNT: '/notifications/unread/count'
    },
    /**
     * ì·¨ì•½ì  ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸
     */
    CVE: {
        BASE: '/cves',
        DETAIL: (id) => `/cves/${id}`,
        SEARCH: '/cves/search',
        COMMENTS: (id) => `/cves/${id}/comments`,
        COMMENT: (cveId, commentId) => `/cves/${cveId}/comments/${commentId}`,
        POC: (id) => `/cves/${id}/poc`,
        SNORT_RULE: (id) => `/cves/${id}/snort-rules`,
        LOCK: (id) => `/cves/${id}/lock`
    },
    /**
     * ì‚¬ìš©ì ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸
     */
    USER: {
        SEARCH: '/auth/search'
    },
    /**
     * WebSocket ê´€ë ¨ ì—”ë“œí¬ì¸íŠ¸
     */
    WEBSOCKET: {
        CONNECT: (token) => `/socket.io?token=${encodeURIComponent(token)}`
    }
};

// ì¼€ì´ìŠ¤ ë³€í™˜ ê´€ë ¨ ì„¤ì •
export const CASE_CONVERSION_CONFIG = {
    // ë³€í™˜ í™œì„±í™” ì—¬ë¶€
    ENABLED: true,
    
    // ë””ë²„ê·¸ ëª¨ë“œ (ë³€í™˜ ì „í›„ ë¡œê¹…)
    DEBUG: true, // í•­ìƒ ë””ë²„ê·¸ ëª¨ë“œ í™œì„±í™”
    
    // ë³€í™˜ì—ì„œ ì œì™¸í•  í•„ë“œ ëª©ë¡ (í•„ìš”í•œ ê²½ìš° ì¶”ê°€)
    EXCLUDED_FIELDS: []//['access_token', 'refresh_token', 'token_type', 'expires_in']
};

// ê¸°íƒ€ ì„¤ì •
export const DEFAULT_ERROR_MESSAGE = 'ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
export const TOKEN_REFRESH_THRESHOLD = 5 * 60 * 1000; // 5ë¶„ (ë°€ë¦¬ì´ˆ) 

// í† í° ê°±ì‹  ê´€ë ¨ ì„¤ì •
export const TOKEN_REFRESH_CONFIG = {
    // í† í° ë§Œë£Œ ì „ ê°±ì‹  ì‹œì‘ ì‹œê°„ (ì´ˆ)
    REFRESH_BEFORE_EXPIRY: 300, // 5ë¶„
    
    // í† í° ê°±ì‹  ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜
    MAX_RETRY_COUNT: 3,
    
    // í† í° ê°±ì‹  ìš”ì²­ ê°„ ìµœì†Œ ê°„ê²© (ë°€ë¦¬ì´ˆ)
    MIN_REFRESH_INTERVAL: 10 * 1000, // 10ì´ˆ
    
    // ë””ë²„ê·¸ ëª¨ë“œ
    DEBUG: false
};


============================================================
File: /home/CVEHub/frontend/src/features/auth/types/index.ts
------------------------------------------------------------
import { AxiosRequestConfig } from 'axios';

/**
 * ì¸ì¦ ê´€ë ¨ íƒ€ì… ì •ì˜ íŒŒì¼
 */

/**
 * ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤
 */
export interface User {
  id: string;
  username: string;
  email: string;
  displayName?: string;
  profileImage?: string;
  role?: string;
  createdAt?: string | Date;
  lastLogin?: string | Date;
}

/**
 * ë¡œê·¸ì¸ ìš”ì²­ ì¸í„°í˜ì´ìŠ¤
 */
export interface LoginRequest {
  username: string;
  password: string;
  rememberMe?: boolean;
}

/**
 * ë¡œê·¸ì¸ ì‘ë‹µ ì¸í„°í˜ì´ìŠ¤
 */
export interface LoginResponse {
  user: User;
  tokens: {
    accessToken: string;
    refreshToken: string;
  };
  expiresIn?: number;
}

/**
 * ë¡œê·¸ì¸ ì‘ë‹µ ë°ì´í„° ì¸í„°í˜ì´ìŠ¤
 */
export interface LoginResponseData {
  access_token?: string;
  accessToken?: string;
  refresh_token?: string;
  refreshToken?: string;
  user?: User;
}

/**
 * íšŒì›ê°€ì… ìš”ì²­ ì¸í„°í˜ì´ìŠ¤
 */
export interface SignUpRequest {
  username: string;
  email: string;
  password: string;
  confirmPassword: string;
  displayName?: string;
}

/**
 * í† í° ê°±ì‹  ìš”ì²­ ì¸í„°í˜ì´ìŠ¤
 */
export interface RefreshTokenRequest {
  refreshToken: string;
}

/**
 * í† í° ê°±ì‹  ì‘ë‹µ ì¸í„°í˜ì´ìŠ¤
 */
export interface RefreshTokenResponse {
  accessToken: string;
  refreshToken?: string;
  expiresIn?: number;
}

/**
 * ì¸ì¦ ì»¨í…ìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤
 */
export interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: Error | null;
  login: (credentials: LoginRequest) => Promise<LoginResponse>;
  loginAsync: (credentials: LoginRequest) => Promise<LoginResponse>;
  logout: () => Promise<void>;
  logoutAsync: () => Promise<void>;
  refreshToken: (refreshToken?: string) => Promise<void>;
  refreshTokenAsync: (refreshToken?: string) => Promise<void>;
  accessToken: string | null;
}

/**
 * í† í° í˜ì´ë¡œë“œ ì¸í„°í˜ì´ìŠ¤
 */
export interface TokenPayload {
  sub: string; // ì‚¬ìš©ì ID
  username: string;
  exp: number; // ë§Œë£Œ ì‹œê°„ (timestamp)
  iat: number; // ë°œê¸‰ ì‹œê°„ (timestamp)
  role?: string;
}

/**
 * ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸ ì¸í„°í˜ì´ìŠ¤
 */
export interface UserUpdate {
  email?: string;
  displayName?: string;
  profileImage?: string;
  password?: string;
  currentPassword?: string;
}

/**
 * ì»¤ìŠ¤í…€ Axios ìš”ì²­ ì„¤ì • ì¸í„°í˜ì´ìŠ¤
 */
export interface CustomAxiosRequestConfig extends AxiosRequestConfig {
  skipTransform?: boolean;
  useCache?: boolean;
  cacheMaxAge?: number;
  skipAuthRefresh?: boolean;
  metadata?: {
    requestTime: Date;
  };
}


============================================================
File: /home/CVEHub/frontend/src/features/auth/AuthRoute.jsx
------------------------------------------------------------
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { CircularProgress, Box } from '@mui/material';

const AuthRoute = ({ children }) => {
  const location = useLocation();
  const { isAuthenticated, loading } = useAuth();
  const from = location.state?.from?.pathname || '/cves';
  
  if (loading) {
    return (
      <Box
        sx={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh'
        }}
      >
        <CircularProgress />
      </Box>
    );
  }

  if (isAuthenticated) {
    return <Navigate to={from} replace />;
  }

  return children;
};

export default AuthRoute;



============================================================
File: /home/CVEHub/frontend/src/features/auth/Login.tsx
------------------------------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useNavigate, Link as RouterLink } from 'react-router-dom';
import { useSnackbar } from 'notistack';
import { 
  Container,
  Box,
  Typography,
  TextField,
  Button,
  FormControlLabel,
  Checkbox,
  IconButton,
  InputAdornment,
  Paper,
  CircularProgress,
  Alert,
  Divider,
  Link
} from '@mui/material';
import { Email, Lock, Visibility, VisibilityOff } from '@mui/icons-material';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { LoginRequest, AuthContextType, LoginResponse } from 'features/auth/types';

interface FormData {
  email: string;
  password: string;
}

const Login: React.FC = () => {
  const navigate = useNavigate();
  const { enqueueSnackbar } = useSnackbar();
  const auth = useAuth();
  const { loginAsync, loading: authLoading, error: authError } = auth as AuthContextType;
  
  const [formData, setFormData] = useState<FormData>({
    email: '',
    password: ''
  });
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>('');
  const [saveId, setSaveId] = useState<boolean>(false);
  const [showPassword, setShowPassword] = useState<boolean>(false);
  
  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ìƒíƒœë¥¼ ì¶”ì í•˜ëŠ” ref
  const isMounted = useRef<boolean>(true);
  // íƒ€ì´ë¨¸ ì°¸ì¡°ë¥¼ ì €ì¥í•˜ëŠ” ref
  const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ì´ˆê¸°í™”
  useEffect(() => {
    // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
    window.addEventListener('beforeunload', cleanupBeforeUnload);
    
    const savedEmail = localStorage.getItem('savedEmail');
    if (savedEmail) {
      setFormData(prev => ({ ...prev, email: savedEmail }));
      setSaveId(true);
    }
    
    return () => {
      isMounted.current = false;
      window.removeEventListener('beforeunload', cleanupBeforeUnload);
      
      // íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ì •ë¦¬
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, []);

  // í˜ì´ì§€ ì–¸ë¡œë“œ ì „ ì •ë¦¬ í•¨ìˆ˜
  const cleanupBeforeUnload = (): void => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
  };

  // ì…ë ¥ í•„ë“œ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    
    // ì…ë ¥ ì‹œ ì—ëŸ¬ ë©”ì‹œì§€ ì´ˆê¸°í™”
    if (error) setError('');
  };

  // ì•„ì´ë”” ì €ì¥ ì²´í¬ë°•ìŠ¤ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleSaveIdChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    setSaveId(e.target.checked);
  };

  // ë¹„ë°€ë²ˆí˜¸ í‘œì‹œ í† ê¸€ í•¸ë“¤ëŸ¬
  const handleTogglePasswordVisibility = (): void => {
    setShowPassword(prev => !prev);
  };

  // ë¡œê·¸ì¸ í¼ ì œì¶œ í•¸ë“¤ëŸ¬
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>): Promise<void> => {
    e.preventDefault();
    
    // í•„ìˆ˜ ì…ë ¥ í•„ë“œ ê²€ì¦
    if (!formData.email || !formData.password) {
      setError('ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }
    
    // ì´ë©”ì¼ í˜•ì‹ ê²€ì¦
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(formData.email)) {
      setError('ìœ íš¨í•œ ì´ë©”ì¼ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }
    
    setLoading(true);
    setError('');
    
    try {
      // ë¡œê·¸ì¸ ìš”ì²­
      const loginRequest: LoginRequest = {
        username: formData.email, // APIëŠ” ì´ë©”ì¼ì„ usernameìœ¼ë¡œ ë°›ìŒ
        password: formData.password
      };

      const response: LoginResponse = await loginAsync(loginRequest);
      
      // ì•„ì´ë”” ì €ì¥ ì„¤ì •ì— ë”°ë¼ ì €ì¥ ë˜ëŠ” ì‚­ì œ
      if (saveId) {
        localStorage.setItem('savedEmail', formData.email);
      } else {
        localStorage.removeItem('savedEmail');
      }
      
      // ë¡œê·¸ì¸ ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
      enqueueSnackbar('ë¡œê·¸ì¸ì— ì„±ê³µí–ˆìŠµë‹ˆë‹¤.', { 
        variant: 'success',
        autoHideDuration: 3000
      });
      
      // ë©”ì¸ í˜ì´ì§€ë¡œ ì´ë™ (ì§€ì—° ì ìš©)
      timerRef.current = setTimeout(() => {
        if (isMounted.current) {
          navigate('/');
        }
      }, 1000);
      
    } catch (err) {
      console.error('ë¡œê·¸ì¸ ì˜¤ë¥˜:', err);
      
      // ì˜¤ë¥˜ ë©”ì‹œì§€ ì„¤ì •
      const error = err as any; // íƒ€ì… ë‹¨ì–¸
      
      if (error.response) {
        // ì„œë²„ ì‘ë‹µì´ ìˆëŠ” ê²½ìš°
        const status = error.response.status;
        
        if (status === 401) {
          setError('ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        } else if (status === 429) {
          setError('ë„ˆë¬´ ë§ì€ ë¡œê·¸ì¸ ì‹œë„ê°€ ìˆì—ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        } else {
          setError(error.response.data?.message || 'ë¡œê·¸ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
      } else if (error.request) {
        // ìš”ì²­ì€ ë³´ëƒˆì§€ë§Œ ì‘ë‹µì´ ì—†ëŠ” ê²½ìš°
        setError('ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
      } else {
        // ìš”ì²­ ì„¤ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ
        setError('ë¡œê·¸ì¸ ìš”ì²­ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      // ì˜¤ë¥˜ ì•Œë¦¼ í‘œì‹œ
      enqueueSnackbar('ë¡œê·¸ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', { 
        variant: 'error',
        autoHideDuration: 5000
      });
    } finally {
      if (isMounted.current) {
        setLoading(false);
      }
    }
  };

  return (
    <Container maxWidth="sm" sx={{ 
      display: 'flex', 
      flexDirection: 'column',
      justifyContent: 'center',
      minHeight: '100vh',
      py: 4
    }}>
      <Paper 
        elevation={3} 
        sx={{ 
          p: 4, 
          display: 'flex', 
          flexDirection: 'column',
          borderRadius: 2
        }}
      >
        <Box sx={{ mb: 3, textAlign: 'center' }}>
          <Typography variant="h4" component="h1" gutterBottom>
            ë¡œê·¸ì¸
          </Typography>
          <Typography variant="body2" color="text.secondary">
            CVE Hubì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤
          </Typography>
        </Box>
        
        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            {error}
          </Alert>
        )}
        
        <Box component="form" onSubmit={handleSubmit} noValidate>
          <TextField
            margin="normal"
            required
            fullWidth
            id="email"
            label="ì´ë©”ì¼"
            name="email"
            autoComplete="email"
            autoFocus
            value={formData.email}
            onChange={handleChange}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <Email />
                </InputAdornment>
              ),
            }}
          />
          
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="ë¹„ë°€ë²ˆí˜¸"
            type={showPassword ? 'text' : 'password'}
            id="password"
            autoComplete="current-password"
            value={formData.password}
            onChange={handleChange}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <Lock />
                </InputAdornment>
              ),
              endAdornment: (
                <InputAdornment position="end">
                  <IconButton
                    aria-label="toggle password visibility"
                    onClick={handleTogglePasswordVisibility}
                    edge="end"
                  >
                    {showPassword ? <VisibilityOff /> : <Visibility />}
                  </IconButton>
                </InputAdornment>
              )
            }}
          />
          
          <FormControlLabel
            control={
              <Checkbox 
                value="remember" 
                color="primary" 
                checked={saveId}
                onChange={handleSaveIdChange}
              />
            }
            label="ì•„ì´ë”” ì €ì¥"
          />
          
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2, py: 1.5 }}
            disabled={loading || authLoading}
          >
            {(loading || authLoading) ? (
              <CircularProgress size={24} color="inherit" />
            ) : (
              'ë¡œê·¸ì¸'
            )}
          </Button>
          
          <Divider sx={{ my: 3 }}>
            <Typography variant="body2" color="text.secondary">
              ë˜ëŠ”
            </Typography>
          </Divider>
          
          <Box sx={{ mt: 1, textAlign: 'center' }}>
            <RouterLink to="/signup" style={{ textDecoration: 'none' }}>
              <Button
                fullWidth
                variant="outlined"
                color="primary"
              >
                íšŒì›ê°€ì…
              </Button>
            </RouterLink>
            
            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
              <RouterLink to="/forgot-password" style={{ color: 'inherit' }}>
                ë¹„ë°€ë²ˆí˜¸ë¥¼ ìŠìœ¼ì…¨ë‚˜ìš”?
              </RouterLink>
            </Typography>
          </Box>
        </Box>
      </Paper>
    </Container>
  );
};

export default Login;


============================================================
File: /home/CVEHub/frontend/src/features/auth/SignUp.jsx
------------------------------------------------------------
import React, { useState } from 'react';
import {
  Box,
  Container,
  Typography,
  TextField,
  Button,
  Paper,
  Alert,
  IconButton,
  InputAdornment,
  Snackbar,
  Checkbox,
  FormControlLabel
} from '@mui/material';
import {
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon
} from '@mui/icons-material';
import { useNavigate } from 'react-router-dom';
import { register } from 'features/auth/services/authService';

const SignUp = () => {
  const navigate = useNavigate();
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
    is_admin: false
  });
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [errors, setErrors] = useState({});
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'success'
  });
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (event) => {
    event.preventDefault();
    
    // í¼ ê²€ì¦ ì‹¤í–‰
    if (!validateForm()) {
      return;
    }
    
    setLoading(true);

    try {
      const userData = {
        email: formData.email,
        username: formData.username,
        password: formData.password,
        confirmPassword: formData.confirmPassword,
        is_admin: formData.is_admin
      };

      await register(userData);
      
      setSnackbar({
        open: true,
        message: 'íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™í•©ë‹ˆë‹¤.',
        severity: 'success'
      });

      // íšŒì›ê°€ì… ì„±ê³µ í›„ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
      setTimeout(() => {
        navigate('/login');
      }, 1000);
    } catch (error) {
      console.error('íšŒì›ê°€ì… ì—ëŸ¬:', error);
      
      // ì„œë²„ì—ì„œ ë°˜í™˜í•œ ì—ëŸ¬ ë©”ì‹œì§€ê°€ ìˆëŠ” ê²½ìš° í•´ë‹¹ ë©”ì‹œì§€ í‘œì‹œ
      const errorMessage = error.response?.data?.detail || error.message || 'íšŒì›ê°€ì… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
      
      // í•„ë“œë³„ ì—ëŸ¬ ë©”ì‹œì§€ ì²˜ë¦¬
      if (error.response?.data?.errors) {
        const fieldErrors = {};
        Object.entries(error.response.data.errors).forEach(([field, message]) => {
          fieldErrors[field] = Array.isArray(message) ? message[0] : message;
        });
        setErrors(fieldErrors);
      }
      
      setSnackbar({
        open: true,
        message: errorMessage,
        severity: 'error'
      });
    } finally {
      setLoading(false);
    }
  };

  const validateForm = () => {
    const newErrors = {};
    
    // ì‚¬ìš©ì ì´ë¦„ ê²€ì¦
    if (!formData.username.trim()) {
      newErrors.username = 'ì‚¬ìš©ì ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”';
    } else if (formData.username.length < 3) {
      newErrors.username = 'ì‚¬ìš©ì ì´ë¦„ì€ ìµœì†Œ 3ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤';
    } else if (formData.username.length > 30) {
      newErrors.username = 'ì‚¬ìš©ì ì´ë¦„ì€ ìµœëŒ€ 30ìê¹Œì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤';
    }

    // ì´ë©”ì¼ ê²€ì¦
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!formData.email) {
      newErrors.email = 'ì´ë©”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”';
    } else if (!emailRegex.test(formData.email)) {
      newErrors.email = 'ì˜¬ë°”ë¥¸ ì´ë©”ì¼ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤';
    }

    // ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
    if (!formData.password) {
      newErrors.password = 'ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”';
    }

    // ë¹„ë°€ë²ˆí˜¸ í™•ì¸ ê²€ì¦
    if (!formData.confirmPassword) {
      newErrors.confirmPassword = 'ë¹„ë°€ë²ˆí˜¸ í™•ì¸ì„ ì…ë ¥í•´ì£¼ì„¸ìš”';
    } else if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
    
    // ì…ë ¥ ì‹œ í•´ë‹¹ í•„ë“œì˜ ì—ëŸ¬ ë©”ì‹œì§€ ì œê±°
    if (errors[name]) {
      setErrors(prev => ({
        ...prev,
        [name]: ''
      }));
    }
  };

  const handleCheckboxChange = (e) => {
    setFormData(prev => ({
      ...prev,
      is_admin: e.target.checked
    }));
  };

  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({
      ...prev,
      open: false
    }));
  };

  return (
    <Container maxWidth="sm">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Paper 
          elevation={3}
          sx={{
            padding: 4,
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
          }}
        >
          <Typography
            component="h1"
            variant="h4"
            sx={{
              mb: 4,
              fontWeight: 'bold',
              background: 'linear-gradient(45deg, #2196F3 30%, #21CBF3 90%)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent'
            }}
          >
            íšŒì›ê°€ì…
          </Typography>

          <Box component="form" onSubmit={handleSubmit} sx={{ width: '100%' }}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="username"
              label="ì‚¬ìš©ì ì´ë¦„"
              name="username"
              autoComplete="username"
              autoFocus
              value={formData.username}
              onChange={handleChange}
              error={!!errors.username}
              helperText={errors.username}
              sx={{ mb: 2 }}
            />

            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="ì´ë©”ì¼"
              name="email"
              autoComplete="email"
              value={formData.email}
              onChange={handleChange}
              error={!!errors.email}
              helperText={errors.email}
              sx={{ mb: 2 }}
            />

            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="ë¹„ë°€ë²ˆí˜¸"
              type={showPassword ? 'text' : 'password'}
              id="password"
              autoComplete="new-password"
              value={formData.password}
              onChange={handleChange}
              error={!!errors.password}
              helperText={errors.password}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={() => setShowPassword(!showPassword)}
                      edge="end"
                    >
                      {showPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
              sx={{ mb: 2 }}
            />

            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="ë¹„ë°€ë²ˆí˜¸ í™•ì¸"
              type={showConfirmPassword ? 'text' : 'password'}
              id="confirmPassword"
              autoComplete="new-password"
              value={formData.confirmPassword}
              onChange={handleChange}
              error={!!errors.confirmPassword}
              helperText={errors.confirmPassword}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      aria-label="toggle password visibility"
                      onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                      edge="end"
                    >
                      {showConfirmPassword ? <VisibilityOffIcon /> : <VisibilityIcon />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
              sx={{ mb: 2 }}
            />

            <FormControlLabel
              control={
                <Checkbox
                  checked={formData.is_admin}
                  onChange={handleCheckboxChange}
                  name="is_admin"
                />
              }
              label="ê´€ë¦¬ì ê³„ì •ìœ¼ë¡œ ê°€ì…"
            />

            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{
                mt: 2,
                mb: 2,
                py: 1.5,
                fontSize: '1.1rem',
                background: 'linear-gradient(45deg, #2196F3 30%, #21CBF3 90%)',
                '&:hover': {
                  background: 'linear-gradient(45deg, #1976D2 30%, #21CBF3 90%)',
                }
              }}
            >
              íšŒì›ê°€ì…
            </Button>

            <Button
              fullWidth
              onClick={() => navigate('/login')}
              sx={{
                color: 'text.secondary',
                textDecoration: 'underline',
                '&:hover': {
                  backgroundColor: 'transparent',
                  color: 'primary.main',
                }
              }}
            >
              ì´ë¯¸ ê³„ì •ì´ ìˆìœ¼ì‹ ê°€ìš”? ë¡œê·¸ì¸í•˜ê¸°
            </Button>
          </Box>
        </Paper>
      </Box>

      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={handleCloseSnackbar}
          severity={snackbar.severity}
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Container>
  );
};

export default SignUp;



============================================================
File: /home/CVEHub/frontend/src/features/auth/LoginForm.tsx
------------------------------------------------------------
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { Container, Grid, Paper, TextField, Button, Typography, Box, CircularProgress } from '@mui/material';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { AuthContextType, LoginRequest } from 'features/auth/types';
import { useSocket } from 'core/socket/hooks/useSocket';
import logger from 'shared/utils/logging';


interface LoginFormProps {
  username: string;
  password: string;
  setUsername: (username: string) => void;
  setPassword: (password: string) => void;
}

const LoginForm: React.FC<LoginFormProps> = ({ 
  username, 
  password, 
  setUsername, 
  setPassword 
}) => {
  const navigate = useNavigate();
  const auth: AuthContextType = useAuth();
  const socket = useSocket();
  const { connected } = socket;
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>): Promise<void> => {
    event.preventDefault();
    if (isSubmitting) return;
    
    setIsSubmitting(true);
    try {
      const loginRequest: LoginRequest = {
        username,
        password
      };
      
      await auth.loginAsync(loginRequest);
      logger.info('Auth', 'ë¡œê·¸ì¸ ì„±ê³µ', { username });
      
      // ì†Œì¼“ ì—°ê²° ìƒíƒœ í™•ì¸ - RxJS ê¸°ë°˜ ì†Œì¼“ì€ ìë™ìœ¼ë¡œ ì—°ê²°ë¨
      if (!connected) {
        logger.info('Auth', 'ì†Œì¼“ ì—°ê²° ëŒ€ê¸° ì¤‘', {});
        // ì†Œì¼“ ì—°ê²°ì€ ìë™ìœ¼ë¡œ ì´ë£¨ì–´ì§€ë¯€ë¡œ ë³„ë„ ì—°ê²° ìš”ì²­ ë¶ˆí•„ìš”
      }
      
      // ë¡œê·¸ì¸ ì„±ê³µ í›„ ëŒ€ì‹œë³´ë“œë¡œ ì´ë™
      navigate('/dashboard');
    } catch (error) {
      logger.error('Auth', 'ë¡œê·¸ì¸ ì‹¤íŒ¨', error);
      // ì˜¤ë¥˜ ì²˜ë¦¬ëŠ” ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì—ì„œ ìˆ˜í–‰
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div className="form-group">
        <button 
          type="submit" 
          className="btn btn-primary btn-block" 
          disabled={isSubmitting}
        >
          {isSubmitting ? 'ë¡œê·¸ì¸ ì¤‘...' : 'ë¡œê·¸ì¸'}
        </button>
      </div>
    </form>
  );
};

export default LoginForm;


============================================================
File: /home/CVEHub/frontend/src/features/auth/services/userService.js
------------------------------------------------------------
import api from 'shared/api/config/axios';
import { AUTH } from 'shared/api/config/endpoints';

export const userService = {
  // ì‚¬ìš©ì ë“±ë¡
  register: async (data) => {
    const response = await api.post(AUTH.REGISTER, data);
    return response.data;
  },

  // ì‚¬ìš©ì ë¡œê·¸ì¸
  login: async (data) => {
    const response = await api.post(AUTH.LOGIN, data);
    return response.data;
  },

  // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
  getCurrentUser: async () => {
    const response = await api.get(AUTH.ME);
    return response.data;
  },

  // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ìˆ˜ì •
  updateCurrentUser: async (data) => {
    const response = await api.patch(AUTH.ME, data);
    return response.data;
  },

  // í˜„ì¬ ì‚¬ìš©ì ê³„ì • ì‚­ì œ
  deleteCurrentUser: async () => {
    const response = await api.delete(AUTH.ME);
    return response.data;
  },
}; 


============================================================
File: /home/CVEHub/frontend/src/features/auth/services/authService.ts
------------------------------------------------------------
import axios from 'axios';
import {
  User,
  LoginRequest,
  LoginResponse,
  RefreshTokenRequest,
  RefreshTokenResponse,
  SignUpRequest,
  TokenPayload,
  CustomAxiosRequestConfig,
  LoginResponseData
} from '../types';
import { QueryClient } from '@tanstack/react-query';
import api from 'shared/api/config/axios';
import { getRefreshToken, getUser, setUser } from 'shared/utils/storage/tokenStorage';
import { API_BASE_URL, API_ENDPOINTS } from 'config'
import {setAccessToken, setRefreshToken, clearAuthStorage, getAccessToken } from 'shared/utils/storage/tokenStorage'

// ì „ì—­ ì˜¤ë¥˜ í•¸ë“¤ëŸ¬ì™€ QueryClient ì°¸ì¡° ì €ì¥
let globalErrorHandler: ((error: Error, context?: string) => void) | null = null;
let globalQueryClient: QueryClient | null = null;

/**
 * ì˜¤ë¥˜ í•¸ë“¤ëŸ¬ ì£¼ì… - API ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì „ì—­ í•¸ë“¤ëŸ¬ ì„¤ì •
 * @param handler - ì˜¤ë¥˜ ì²˜ë¦¬ í•¨ìˆ˜ (error) => void
 */
export const injectErrorHandler = (handler: (error: Error, context?: string) => void): void => {
  if (typeof handler !== 'function') {
    console.warn('ìœ íš¨í•˜ì§€ ì•Šì€ ì˜¤ë¥˜ í•¸ë“¤ëŸ¬ì…ë‹ˆë‹¤. í•¨ìˆ˜ë¥¼ ì „ë‹¬í•´ì£¼ì„¸ìš”.');
    return;
  }
  
  globalErrorHandler = handler;
  console.log('ì˜¤ë¥˜ í•¸ë“¤ëŸ¬ê°€ ì„±ê³µì ìœ¼ë¡œ ì£¼ì…ë˜ì—ˆìŠµë‹ˆë‹¤.');
};

/**
 * React Query Client ì£¼ì… - ì¸ì¦ ê´€ë ¨ ì¿¼ë¦¬ ìºì‹œ ê´€ë¦¬
 * @param queryClient - React Queryì˜ QueryClient ì¸ìŠ¤í„´ìŠ¤
 */
export const injectQueryClient = (queryClient: QueryClient): void => {
  if (!queryClient || typeof queryClient.invalidateQueries !== 'function') {
    console.warn('ìœ íš¨í•˜ì§€ ì•Šì€ QueryClientì…ë‹ˆë‹¤. React Queryì˜ QueryClient ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•´ì£¼ì„¸ìš”.');
    return;
  }
  
  globalQueryClient = queryClient;
  console.log('QueryClientê°€ ì„±ê³µì ìœ¼ë¡œ ì£¼ì…ë˜ì—ˆìŠµë‹ˆë‹¤.');
};

/**
 * ë‚´ë¶€ìš© ì˜¤ë¥˜ ì²˜ë¦¬ í•¨ìˆ˜
 * @param error - ì²˜ë¦¬í•  ì˜¤ë¥˜ ê°ì²´
 * @param context - ì˜¤ë¥˜ ë°œìƒ ì»¨í…ìŠ¤íŠ¸
 */
const handleError = (error: Error, context = ''): void => {
  // ê°œë°œ í™˜ê²½ì—ì„œëŠ” ì½˜ì†” ë¡œê·¸ ì¶œë ¥
  if (process.env.NODE_ENV === 'development') {
    console.error(`Auth ì˜¤ë¥˜ [${context}]:`, error);
  }
  
  // ê¸€ë¡œë²Œ ì˜¤ë¥˜ í•¸ë“¤ëŸ¬ê°€ ìˆìœ¼ë©´ í˜¸ì¶œ
  if (globalErrorHandler) {
    try {
      globalErrorHandler(error, context);
    } catch (handlerError) {
      console.error('ì˜¤ë¥˜ í•¸ë“¤ëŸ¬ ì‹¤í–‰ ì¤‘ ì˜ˆì™¸ ë°œìƒ:', handlerError);
    }
  }
  
  // 401 ì˜¤ë¥˜ëŠ” ìë™ìœ¼ë¡œ ì¸ì¦ ê´€ë ¨ ìºì‹œ ë¬´íš¨í™”
  const apiError = error as any;
  if (apiError?.response?.status === 401 && globalQueryClient) {
    globalQueryClient.invalidateQueries({queryKey: ['auth']});
  }
};

/**
 * í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
 * @returns ì‚¬ìš©ì ì •ë³´
 */
export const getCurrentUser = async (): Promise<User | null> => {
  try {
    // ì•¡ì„¸ìŠ¤ í† í°ì´ ì—†ìœ¼ë©´ API í˜¸ì¶œí•˜ì§€ ì•Šê³  null ë°˜í™˜
    const accessToken = getAccessToken();
    if (!accessToken) {
      return null;
    }
    
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì‚¬ìš©ì ì •ë³´ í™•ì¸
    const cachedUser = getUser();
    
    // ìºì‹œëœ ì‚¬ìš©ì ì •ë³´ê°€ ìˆìœ¼ë©´ ë°˜í™˜
    if (cachedUser) {
      return cachedUser as User;
    }
    
    // ì„œë²„ì—ì„œ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
    const response = await api.get<User>('/auth/me');
    
    // ì‚¬ìš©ì ì •ë³´ ìºì‹œ ì—…ë°ì´íŠ¸
    if (response.data) {
      setUser(response.data);
    }
    
    return response.data;
  } catch (error) {
    handleError(error as Error, 'getCurrentUser');
    throw error;
  }
};

/**
 * í† í° ê°±ì‹  (ìë™ ê°±ì‹  ë¡œì§ ì ìš©)
 * @returns ìƒˆë¡œ ë°œê¸‰ëœ ì•¡ì„¸ìŠ¤ í† í°
 */
export const refreshToken = async (): Promise<RefreshTokenResponse> => {
  const currentRefreshToken = getRefreshToken();
  
  if (!currentRefreshToken) {
    const error = new Error('ì‚¬ìš© ê°€ëŠ¥í•œ ë¦¬í”„ë ˆì‹œ í† í°ì´ ì—†ìŠµë‹ˆë‹¤');
    handleError(error, 'refreshToken');
    throw error;
  }

  try {
    // api ì¸ìŠ¤í„´ìŠ¤ ëŒ€ì‹  ê¸°ë³¸ axios ì‚¬ìš©í•˜ì—¬ ìˆœí™˜ ì°¸ì¡° ë°©ì§€
    const response = await axios.post<RefreshTokenResponse>(
      `${API_BASE_URL}${API_ENDPOINTS.AUTH.REFRESH}`, 
      {
        refresh_token: currentRefreshToken
      },
      {
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );

    // ì¹´ë©œì¼€ì´ìŠ¤/ìŠ¤ë„¤ì´í¬ì¼€ì´ìŠ¤ í•„ë“œëª… ëª¨ë‘ ì§€ì›
    const accessToken = response.data.accessToken || (response.data as any).access_token;
    const refreshTokenValue = response.data.refreshToken || (response.data as any).refresh_token;
    const user = (response.data as any).user as User | undefined;
    
    if (!accessToken) {
      const error = new Error('ì‘ë‹µì— ìƒˆ ì•¡ì„¸ìŠ¤ í† í°ì´ ì—†ìŠµë‹ˆë‹¤');
      handleError(error, 'refreshToken');
      throw error;
    }

    setAccessToken(accessToken);
    if (refreshTokenValue) {
      setRefreshToken(refreshTokenValue);
    }
    if (user) {
      setUser(user);
    }

    // QueryClientê°€ ìˆìœ¼ë©´ ê´€ë ¨ ì¿¼ë¦¬ ê°±ì‹ 
    if (globalQueryClient) {
      globalQueryClient.invalidateQueries({queryKey: ['auth', 'user']});
    }

    return {
      accessToken,
      refreshToken: refreshTokenValue,
      expiresIn: (response.data as any).expiresIn
    };
  } catch (error) {
    handleError(error as Error, 'refreshToken');

    const apiError = error as any;
    if (apiError.response?.status === 401 || apiError.response?.status === 403) {
      clearAuthStorage();
      
      if (typeof window !== 'undefined') {
        const currentPath = window.location.pathname + window.location.search;
        sessionStorage.setItem('redirectAfterLogin', currentPath);
      }
    }

    throw error;
  }
};

/**
 * ë¡œê·¸ì¸ í•¨ìˆ˜ íƒ€ì… ì •ì˜
 */
export type LoginFunction = (credentials: LoginRequest) => Promise<LoginResponse>;

/**
 * ì‚¬ìš©ì ë¡œê·¸ì¸
 * @param credentials - ë¡œê·¸ì¸ ì •ë³´ (username, password)
 * @returns ë¡œê·¸ì¸ ê²°ê³¼ ë° ì‚¬ìš©ì ì •ë³´
 */
export const login = async (credentials: LoginRequest): Promise<LoginResponse> => {
  try {
    // ë””ë²„ê¹…ìš© ë¡œê·¸ ì¶”ê°€
    console.log('ë¡œê·¸ì¸ ìš”ì²­ ë°ì´í„°:', {
      username: credentials.username,
      password: '********' // ë³´ì•ˆìƒ ì‹¤ì œ ë¹„ë°€ë²ˆí˜¸ëŠ” ë¡œê¹…í•˜ì§€ ì•ŠìŒ
    });

    // ë¡œê·¸ì¸ ìš”ì²­ ì‹œ x-www-form-urlencoded í˜•ì‹ ì‚¬ìš©
    // URLSearchParams ì‚¬ìš© (ë°±ì—”ë“œ API ìš”êµ¬ì‚¬í•­)
    const formData = new URLSearchParams();
    formData.append('username', credentials.username);
    formData.append('password', credentials.password);
    // grant_type í•„ë“œ ì¶”ê°€ (OAuth2 í‘œì¤€)
    formData.append('grant_type', 'password');
    
    // ìš”ì²­ í˜•ì‹ ë¡œê¹…
    console.log('ìš”ì²­ í˜•ì‹:', formData.toString());
    console.log('ìš”ì²­ í—¤ë”:', {
      'Content-Type': 'application/x-www-form-urlencoded',
    });

    // ë¡œê·¸ì¸ ìš”ì²­ ì „ì†¡ (axios ì¸í„°ì…‰í„° ìš°íšŒ)
    const axiosConfig = {
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Accept': 'application/json'
      },
      skipTransform: true,
      transformRequest: [(data: any) => data], // ë°ì´í„° ë³€í™˜ ë°©ì§€
      transformResponse: [(data: any) => {
        // ì‘ë‹µ ë°ì´í„°ê°€ ë¬¸ìì—´ì¸ ê²½ìš° JSONìœ¼ë¡œ íŒŒì‹±
        if (typeof data === 'string') {
          try {
            return JSON.parse(data);
          } catch (e) {
            return data;
          }
        }
        return data;
      }]
    } as CustomAxiosRequestConfig;

    const response = await axios.post<LoginResponseData>(
      `${API_BASE_URL}/auth/token`, 
      formData, 
      axiosConfig
    );

    // ì‘ë‹µ ë°ì´í„° ë¡œê¹… (í† í° ë§ˆìŠ¤í‚¹ ì²˜ë¦¬)
    const responseData = response.data as LoginResponseData;
    console.log('ë¡œê·¸ì¸ ì‘ë‹µ ë°ì´í„°:', {
      ...responseData,
      access_token: responseData.access_token ? '********' : undefined,
      accessToken: responseData.accessToken ? '********' : undefined,
      refresh_token: responseData.refresh_token ? '********' : undefined,
      refreshToken: responseData.refreshToken ? '********' : undefined,
      user: responseData.user || null
    });

    // í† í° ì €ì¥ (ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤ ë˜ëŠ” ì¹´ë©œ ì¼€ì´ìŠ¤ ì²˜ë¦¬)
    const accessToken = responseData.access_token || responseData.accessToken;
    const refreshToken = responseData.refresh_token || responseData.refreshToken;

    if (!accessToken) {
      throw new Error('ì•¡ì„¸ìŠ¤ í† í°ì´ ì‘ë‹µì— ì—†ìŠµë‹ˆë‹¤.');
    }

    // í† í° ì €ì¥
    setAccessToken(accessToken);
    if (refreshToken) {
      setRefreshToken(refreshToken);
    }

    // ì‚¬ìš©ì ì •ë³´ ì €ì¥
    const user = responseData.user;
    if (user) {
      setUser(user);
    }

    // ë¡œê·¸ì¸ ì‘ë‹µ ë°˜í™˜
    return {
      user: user || {} as User,
      tokens: {
        accessToken,
        refreshToken: refreshToken || ''
      }
    };
  } catch (error) {
    // ì—ëŸ¬ ì²˜ë¦¬
    console.error('ë¡œê·¸ì¸ ì˜¤ë¥˜:', error);
    
    // HTTP ì—ëŸ¬ ì²˜ë¦¬
    if (axios.isAxiosError(error) && error.response) {
      const status = error.response.status;
      
      // 401 Unauthorized: ì¸ì¦ ì‹¤íŒ¨ (ì˜ëª»ëœ ìê²© ì¦ëª…)
      if (status === 401) {
        throw new Error('ì•„ì´ë”” ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
      }
      
      // 422 Unprocessable Entity: í•„ìˆ˜ í•„ë“œ ëˆ„ë½ ë˜ëŠ” ì˜ëª»ëœ í˜•ì‹
      if (status === 422) {
        throw new Error('ë¡œê·¸ì¸ ìš”ì²­ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. í•„ìˆ˜ í•„ë“œê°€ ëˆ„ë½ë˜ì—ˆê±°ë‚˜ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.');
      }
      
      // ê¸°íƒ€ HTTP ì—ëŸ¬
      throw new Error(`ë¡œê·¸ì¸ ìš”ì²­ ì‹¤íŒ¨ (${status}): ${error.response.data?.message || error.message}`);
    }
    
    // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ë“± ê¸°íƒ€ ì˜ˆì™¸
    throw new Error(`ë¡œê·¸ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${(error as Error).message}`);
  }
};

/**
 * ì‚¬ìš©ì ë¡œê·¸ì•„ì›ƒ
 */
export const logout = async (): Promise<void> => {
  try {
    const refreshToken = getRefreshToken();
    // ì„œë²„ì— ë¡œê·¸ì•„ì›ƒ ìš”ì²­ (í† í° ë¬´íš¨í™”)
    await api.post('/auth/logout', { refresh_token: refreshToken });
    
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì´ˆê¸°í™”
    clearAuthStorage();
    
    // QueryClientê°€ ìˆìœ¼ë©´ ê´€ë ¨ ì¿¼ë¦¬ ì´ˆê¸°í™”
    if (globalQueryClient) {
      globalQueryClient.clear();
    }
  } catch (error) {
    handleError(error as Error, 'logout');
    // ì˜¤ë¥˜ê°€ ë°œìƒí•´ë„ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ëŠ” ì´ˆê¸°í™”
    clearAuthStorage();
    throw error;
  }
};

/**
 * ì¸ì¦ ìƒíƒœ í™•ì¸
 * @returns ì¸ì¦ ì—¬ë¶€
 */
export const isAuthenticated = (): boolean => {
  return !!getAccessToken();
};

/**
 * ì‚¬ìš©ì í† í° í™•ì¸ ë° ìœ íš¨ì„± ê²€ì¦
 * @returns ë””ì½”ë”©ëœ í† í° ì •ë³´ ë˜ëŠ” null
 */
export const checkTokenValidity = (): TokenPayload | null => {
  try {
    const token = getAccessToken();
    
    if (!token) {
      return null;
    }
    
    // JWT í† í° íŒŒì‹± (í—¤ë”.í˜ì´ë¡œë“œ.ì„œëª…)
    const parts = token.split('.');
    if (parts.length !== 3) {
      console.warn('ìœ íš¨í•˜ì§€ ì•Šì€ í† í° í˜•ì‹');
      return null;
    }
    
    // Base64 ë””ì½”ë”© ë° JSON íŒŒì‹±
    const payload = JSON.parse(atob(parts[1])) as TokenPayload;
    const now = Math.floor(Date.now() / 1000);
    
    // ë§Œë£Œ ì‹œê°„ í™•ì¸
    if (payload.exp && payload.exp < now) {
      console.warn('í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤');
      return null;
    }
    
    return payload;
  } catch (error) {
    handleError(error as Error, 'checkTokenValidity');
    return null;
  }
};

/**
 * ì‚¬ìš©ì íšŒì›ê°€ì…
 * @param userData - íšŒì›ê°€ì… ì •ë³´
 * @returns íšŒì›ê°€ì… ê²°ê³¼
 */
export const register = async (userData: SignUpRequest): Promise<User> => {
  try {
    const response = await api.post<User>('/auth/signup', userData);
    return response.data;
  } catch (error) {
    handleError(error as Error, 'register');
    const apiError = error as any;
    throw apiError.response?.data?.detail || apiError.message || 'íšŒì›ê°€ì… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
  }
};

/**
 * ì‚¬ìš©ì ê¶Œí•œ í™•ì¸
 * @param requiredRoles - í•„ìš”í•œ ê¶Œí•œ ëª©ë¡
 * @returns ê¶Œí•œ ë³´ìœ  ì—¬ë¶€
 */
export const hasPermission = (requiredRoles: string[] = []): boolean => {
  try {
    const user = getUser() as User | null;
    
    // ì‚¬ìš©ì ì •ë³´ê°€ ì—†ìœ¼ë©´ ê¶Œí•œ ì—†ìŒ
    if (!user || !user.role) {
      return false;
    }
    
    // í•„ìš”í•œ ê¶Œí•œì´ ì§€ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì¸ì¦ë§Œ í™•ì¸
    if (!requiredRoles.length) {
      return isAuthenticated();
    }
    
    // ì‚¬ìš©ìê°€ í•„ìš”í•œ ê¶Œí•œì„ í•˜ë‚˜ë¼ë„ ê°€ì§€ê³  ìˆëŠ”ì§€ í™•ì¸
    return requiredRoles.includes(user.role);
  } catch (error) {
    handleError(error as Error, 'hasPermission');
    return false;
  }
};

/**
 * ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ìš”ì²­
 * @param email - ì‚¬ìš©ì ì´ë©”ì¼
 * @returns ìš”ì²­ ê²°ê³¼
 */
export const requestPasswordReset = async (email: string): Promise<{ success: boolean; message: string }> => {
  try {
    const response = await api.post<{ success: boolean; message: string }>('/auth/reset-password', { email });
    return response.data;
  } catch (error) {
    handleError(error as Error, 'requestPasswordReset');
    const apiError = error as any;
    throw apiError.response?.data?.detail || apiError.message || 'ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ìš”ì²­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
  }
};

/**
 * ë¹„ë°€ë²ˆí˜¸ ë³€ê²½
 * @param data - ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ë°ì´í„° (token, password)
 * @returns ìš”ì²­ ê²°ê³¼
 */
export const resetPassword = async (data: { token: string; password: string }): Promise<{ success: boolean; message: string }> => {
  try {
    const response = await api.post<{ success: boolean; message: string }>('/auth/confirm-reset-password', data);
    return response.data;
  } catch (error) {
    handleError(error as Error, 'resetPassword');
    const apiError = error as any;
    throw apiError.response?.data?.detail || apiError.message || 'ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
  }
};

// í†µí•©ëœ ì¸ì¦ ì„œë¹„ìŠ¤ ë‚´ë³´ë‚´ê¸°
export default {
  injectErrorHandler,
  injectQueryClient,
  getCurrentUser,
  refreshToken,
  login,
  logout,
  isAuthenticated,
  register,
  checkTokenValidity,
  hasPermission,
  requestPasswordReset,
  resetPassword
};


============================================================
File: /home/CVEHub/frontend/src/features/auth/PrivateRoute.jsx
------------------------------------------------------------
import React, { useEffect } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { CircularProgress, Box, Typography } from '@mui/material';
import logger from 'shared/utils/logging';
import { getAccessToken } from 'shared/utils/storage/tokenStorage';

const PrivateRoute = ({ children }) => {
  const location = useLocation();
  const { isAuthenticated, loading } = useAuth();
  const hasToken = !!getAccessToken();
  
  useEffect(() => {
    logger.info('PrivateRoute', 'ì¸ì¦ ìƒíƒœ í™•ì¸', { 
      isAuthenticated, 
      loading, 
      hasToken,
      path: location.pathname
    });
  }, [isAuthenticated, loading, hasToken, location.pathname]);
  
  // í† í°ì´ ì—†ìœ¼ë©´ ì¦‰ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
  if (!hasToken) {
    logger.info('PrivateRoute', 'í† í° ì—†ìŒ, ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸');
    return <Navigate to="/login" state={{ from: location }} />;
  }
  
  // ë¡œë”© ì¤‘ì¸ ê²½ìš° ë¡œë”© í‘œì‹œ
  if (loading) {
    return (
      <Box
        sx={{
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center',
          alignItems: 'center',
          height: '100vh'
        }}
      >
        <CircularProgress size={40} />
        <Typography variant="body2" sx={{ mt: 2 }}>
          ì¸ì¦ ì •ë³´ë¥¼ í™•ì¸í•˜ëŠ” ì¤‘ì…ë‹ˆë‹¤...
        </Typography>
      </Box>
    );
  }

  // ì¸ì¦ë˜ì§€ ì•Šì€ ê²½ìš° ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
  if (!isAuthenticated) {
    logger.info('PrivateRoute', 'ì¸ì¦ë˜ì§€ ì•ŠìŒ, ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸');
    return <Navigate to="/login" state={{ from: location }} />;
  }

  return children;
};

export default PrivateRoute;



============================================================
File: /home/CVEHub/frontend/src/features/auth/contexts/AuthContext.tsx
------------------------------------------------------------
import React, { createContext, useContext, useEffect, useState, useRef, ReactNode, useCallback, useMemo } from 'react';
import { getAccessToken, getRefreshToken } from 'shared/utils/storage/tokenStorage';
import logger from 'shared/utils/logging';
import socketService from 'core/socket/services/socketService';
import { useAuthQuery } from 'features/auth/hooks/useAuthQuery';
import { TOKEN_REFRESH_THRESHOLD } from 'config';
import { User, LoginRequest, LoginResponse, RefreshTokenResponse, AuthContextType } from 'features/auth/types';
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
import isEqual from 'lodash/isEqual';
import memoize from 'lodash/memoize';

// Provider Props ì¸í„°í˜ì´ìŠ¤
interface AuthProviderProps {
  children: ReactNode;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const { 
    user, 
    isAuthenticated, 
    isLoading, 
    error, 
    login, 
    loginAsync, 
    logout, 
    logoutAsync, 
    refreshToken: refreshTokenMutation, 
    refreshTokenAsync: refreshTokenAsyncMutation 
  } = useAuthQuery();
  
  // ë¡œì»¬ ìƒíƒœ ì¶”ê°€
  const [loading, setLoading] = useState<boolean>(true);
  const [accessToken, setAccessToken] = useState<string | null>(getAccessToken());
  const initRef = useRef<boolean>(false);
  const prevUserRef = useRef<User | null>(null);

  // JWT í† í° ë””ì½”ë”© í•¨ìˆ˜ ë©”ëª¨ì´ì œì´ì…˜
  const decodeToken = useMemo(() => memoize((token: string) => {
    try {
      return JSON.parse(atob(token.split('.')[1]));
    } catch (e) {
      logger.error('AuthContext', 'í† í° ë””ì½”ë”© ì‹¤íŒ¨', e);
      return null;
    }
  }), []);

  // ì´ˆê¸° ì¸ì¦ ìƒíƒœ í™•ì¸
  useEffect(() => {
    const checkInitialAuth = async (): Promise<void> => {
      try {
        const hasAccessToken = !!getAccessToken()?.trim();
        const hasRefreshToken = !!getRefreshToken()?.trim();
        
        logger.info('AuthContext', 'ì´ˆê¸° ì¸ì¦ ìƒíƒœ í™•ì¸', { 
          hasAccessToken, 
          hasRefreshToken,
          isLoading,
          isAuthenticated
        });
        
        // í† í°ì´ ì—†ìœ¼ë©´ ë¡œë”© ìƒíƒœ ì¦‰ì‹œ í•´ì œ
        if (!hasAccessToken) {
          setLoading(false);
          return;
        }
        
        // í† í°ì´ ìˆìœ¼ë©´ ì‚¬ìš©ì ì •ë³´ ë¡œë”© ìƒíƒœ ìœ ì§€
        // useAuthQueryì˜ ì¿¼ë¦¬ê°€ ì™„ë£Œë˜ë©´ isLoadingì´ falseê°€ ë¨
        if (!isLoading) {
          setLoading(false);
        }
      } catch (error) {
        logger.error('AuthContext', 'ì´ˆê¸° ì¸ì¦ ìƒíƒœ í™•ì¸ ì¤‘ ì˜¤ë¥˜', error);
        setLoading(false);
      }
    };
    
    checkInitialAuth();
  }, [isLoading, isAuthenticated]);

  // ë””ë°”ìš´ìŠ¤ëœ í† í° ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
  const debouncedSetAccessToken = useCallback(
    debounce((newToken: string | null) => {
      setAccessToken(newToken);
    }, 300),
    []
  );

  // í† í° ìƒíƒœ ì •ê¸° í™•ì¸ (1ì´ˆë§ˆë‹¤)
  useEffect(() => {
    if (initRef.current) return;
    
    logger.info('AuthContext', 'ì´ˆê¸°í™”ë¨', {});
    initRef.current = true;
    
    // ì •ê¸°ì ìœ¼ë¡œ í† í° ìƒíƒœ í™•ì¸
    const tokenCheckInterval = setInterval(() => {
      const currentAccessToken = getAccessToken();
      if (currentAccessToken !== accessToken) {
        logger.info('AuthContext', 'í† í° ìƒíƒœ ë³€ê²½ ê°ì§€', {});
        debouncedSetAccessToken(currentAccessToken);
      }
    }, 1000);
    
    return () => {
      clearInterval(tokenCheckInterval);
    };
  }, [accessToken, debouncedSetAccessToken]);

  // ìŠ¤ë¡œí‹€ëœ í† í° ê°±ì‹  í•¨ìˆ˜
  const throttledRefreshToken = useCallback(
    throttle(async () => {
      try {
        logger.info('AuthContext', 'í† í° ê°±ì‹  ì‹œë„ (ìŠ¤ë¡œí‹€)', {});
        await refreshTokenAsyncMutation();
      } catch (error) {
        logger.error('AuthContext', 'í† í° ê°±ì‹  ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
      }
    }, 10000, { leading: true, trailing: false }),
    [refreshTokenAsyncMutation]
  );

  // í† í° ìë™ ê°±ì‹  ì„¤ì •
  useEffect(() => {
    if (!isAuthenticated) return;
    
    logger.info('AuthContext', 'í† í° ìë™ ê°±ì‹  ì„¤ì •', {});
    
    // í† í° ë§Œë£Œ ì‹œê°„ í™•ì¸ ë° ê°±ì‹  í•¨ìˆ˜
    const checkTokenExpiration = async (): Promise<void> => {
      try {
        const token = getAccessToken();
        if (!token) return;
        
        // JWT í† í°ì—ì„œ ë§Œë£Œ ì‹œê°„ ì¶”ì¶œ (ë©”ëª¨ì´ì œì´ì…˜ í™œìš©)
        const tokenData = decodeToken(token);
        if (!tokenData) return;
        
        const expirationTime = tokenData.exp * 1000; // ì´ˆ -> ë°€ë¦¬ì´ˆ
        const currentTime = Date.now();
        const timeUntilExpiration = expirationTime - currentTime;
        
        // ë§Œë£Œ ì„ê³„ê°’(5ë¶„) ì´ë‚´ë©´ í† í° ê°±ì‹ 
        if (timeUntilExpiration < TOKEN_REFRESH_THRESHOLD) {
          logger.info('AuthContext', 'í† í° ë§Œë£Œ ì„ë°•, ê°±ì‹  ì‹œë„', {
            expiresIn: Math.floor(timeUntilExpiration / 1000)
          });
          throttledRefreshToken();
        }
      } catch (error) {
        logger.error('AuthContext', 'í† í° ê°±ì‹  ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
      }
    };
    
    // ì´ˆê¸° ì‹¤í–‰ ë° ì£¼ê¸°ì  ì‹¤í–‰ ì„¤ì • (1ë¶„ë§ˆë‹¤)
    checkTokenExpiration();
    const refreshInterval = setInterval(checkTokenExpiration, 60 * 1000);
    
    return () => {
      clearInterval(refreshInterval);
    };
  }, [isAuthenticated, throttledRefreshToken, decodeToken]);

  // Socket.IO ì—°ê²° ê´€ë¦¬ (ì‚¬ìš©ì ë³€ê²½ ì‹œì—ë§Œ ì¬ì—°ê²°)
  useEffect(() => {
    // isEqualì„ ì‚¬ìš©í•˜ì—¬ ê¹Šì€ ë¹„êµ ìˆ˜í–‰
    if (!isEqual(prevUserRef.current, user)) {
      prevUserRef.current = user;
      
      if (isAuthenticated && user) {
        logger.info('AuthContext', 'Socket.IO ì—°ê²° ìš”ì²­', {});
        // ì§ì ‘ ì—°ê²°í•˜ì§€ ì•Šê³  SocketIOContextì— ì¸ì¦ ìƒíƒœ ë³€ê²½ì„ ì•Œë¦¼
        if (socketService && socketService.handleAuthStateChange) {
          socketService.handleAuthStateChange(true);
        }
      } else {
        logger.info('AuthContext', 'Socket.IO ì—°ê²° í•´ì œ ìš”ì²­', {});
        // ì§ì ‘ ì—°ê²° í•´ì œí•˜ì§€ ì•Šê³  SocketIOContextì— ì¸ì¦ ìƒíƒœ ë³€ê²½ì„ ì•Œë¦¼
        if (socketService && socketService.handleAuthStateChange) {
          socketService.handleAuthStateChange(false);
        }
      }
    }
    
    return () => {
      // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì—°ê²° í•´ì œ ìš”ì²­
      if (socketService && socketService.handleAuthStateChange) {
        socketService.handleAuthStateChange(false);
      }
    };
  }, [isAuthenticated, user]);

  // ë¡œê·¸ì¸ í•¸ë“¤ëŸ¬ (useCallbackìœ¼ë¡œ ë©”ëª¨ì´ì œì´ì…˜)
  const handleLogin = useCallback(async (credentials: LoginRequest): Promise<LoginResponse> => {
    setLoading(true);
    try {
      const result = await loginAsync(credentials);
      logger.info('AuthContext', 'ë¡œê·¸ì¸ ì„±ê³µ', {});
      return result;
    } catch (error) {
      logger.error('AuthContext', 'ë¡œê·¸ì¸ ì‹¤íŒ¨', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [loginAsync]);

  // ë¡œê·¸ì•„ì›ƒ í•¸ë“¤ëŸ¬ (useCallbackìœ¼ë¡œ ë©”ëª¨ì´ì œì´ì…˜)
  const handleLogout = useCallback(async (): Promise<void> => {
    setLoading(true);
    try {
      await logoutAsync();
      logger.info('AuthContext', 'ë¡œê·¸ì•„ì›ƒ ì„±ê³µ', {});
    } catch (error) {
      logger.error('AuthContext', 'ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨', error);
    } finally {
      setLoading(false);
    }
  }, [logoutAsync]);

  // refreshToken ë˜í¼ í•¨ìˆ˜ (useCallbackìœ¼ë¡œ ë©”ëª¨ì´ì œì´ì…˜)
  const handleRefreshToken = useCallback(async (refreshToken?: string): Promise<void> => {
    try {
      // refreshTokenMutationì€ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì§€ë§Œ, ì¸í„°í˜ì´ìŠ¤ ì¼ê´€ì„±ì„ ìœ„í•´ ë˜í¼ í•¨ìˆ˜ ì œê³µ
      await refreshTokenMutation();
    } catch (error) {
      logger.error('AuthContext', 'í† í° ê°±ì‹  ì‹¤íŒ¨', error);
      throw error;
    }
  }, [refreshTokenMutation]);

  // refreshTokenAsync ë˜í¼ í•¨ìˆ˜ (useCallbackìœ¼ë¡œ ë©”ëª¨ì´ì œì´ì…˜)
  const handleRefreshTokenAsync = useCallback(async (refreshToken?: string): Promise<void> => {
    try {
      // refreshTokenAsyncMutationì€ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì§€ë§Œ, ì¸í„°í˜ì´ìŠ¤ ì¼ê´€ì„±ì„ ìœ„í•´ ë˜í¼ í•¨ìˆ˜ ì œê³µ
      await refreshTokenAsyncMutation();
    } catch (error) {
      logger.error('AuthContext', 'í† í° ê°±ì‹  ì‹¤íŒ¨', error);
      throw error;
    }
  }, [refreshTokenAsyncMutation]);

  // Context ê°’ (useMemoë¡œ ë©”ëª¨ì´ì œì´ì…˜)
  const value = useMemo<AuthContextType>(() => ({
    user: user || null,
    isAuthenticated,
    loading: loading || isLoading,
    error,
    login: handleLogin,
    logout: handleLogout,
    accessToken: getAccessToken(),
    loginAsync,
    logoutAsync,
    refreshToken: handleRefreshToken,
    refreshTokenAsync: handleRefreshTokenAsync
  }), [
    user, 
    isAuthenticated, 
    loading, 
    isLoading, 
    error, 
    handleLogin, 
    handleLogout, 
    loginAsync, 
    logoutAsync, 
    handleRefreshToken, 
    handleRefreshTokenAsync
  ]);

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export default AuthContext;



============================================================
File: /home/CVEHub/frontend/src/features/auth/hooks/useAuthQuery.ts
------------------------------------------------------------
import { useMutation, useQueryClient } from '@tanstack/react-query';

import debounce from 'lodash/debounce';
import { useCallback, useEffect, useRef } from 'react';
import { LoginRequest, LoginResponse, RefreshTokenResponse } from '../types';
import { refreshToken, login, logout } from 'features/auth/services/authService';
import { getAccessToken, setAccessToken, setRefreshToken, clearAuthStorage } from 'shared/utils/storage/tokenStorage';
import logger from 'shared/utils/logging';
import { useCurrentUser } from './useUsersQuery';

/**
 * ì¸ì¦ ê´€ë ¨ React Query í›…
 */
export const useAuthQuery = () => {
  const queryClient = useQueryClient();
  
  // í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ ì¿¼ë¦¬ (useUsersQueryì—ì„œ ê°€ì ¸ì˜´)
  const userQuery = useCurrentUser();

  // ë¡œê·¸ì¸ ë®¤í…Œì´ì…˜
  const loginMutation = useMutation({
    mutationFn: (credentials: LoginRequest) => login(credentials),
    onSuccess: (data: LoginResponse) => {
      logger.info('AuthQuery', 'ë¡œê·¸ì¸ ì„±ê³µ', data);
      
      // í† í° ì €ì¥
      if (data.tokens?.accessToken) setAccessToken(data.tokens.accessToken);
      if (data.tokens?.refreshToken) setRefreshToken(data.tokens.refreshToken);
    }
  });

  // ë¡œê·¸ì•„ì›ƒ ë®¤í…Œì´ì…˜
  const logoutMutation = useMutation({
    mutationFn: logout,
    onSuccess: () => {
      logger.info('AuthQuery', 'ë¡œê·¸ì•„ì›ƒ ì„±ê³µ', null);
      
      // ì¸ì¦ ì •ë³´ ì´ˆê¸°í™”
      clearAuthStorage();
      
      // ì¿¼ë¦¬ ìºì‹œ ì´ˆê¸°í™”
      queryClient.setQueryData(['auth', 'user'], null);
      queryClient.invalidateQueries();
    }
  });

  // í† í° ê°±ì‹  ë®¤í…Œì´ì…˜
  const refreshTokenMutation = useMutation({
    mutationFn: refreshToken,
    onSuccess: (data: RefreshTokenResponse) => {
      logger.info('AuthQuery', 'í† í° ê°±ì‹  ì„±ê³µ', data);
      
      // í† í° ì €ì¥
      if (data.accessToken) setAccessToken(data.accessToken);
      if (data.refreshToken) setRefreshToken(data.refreshToken);
    }
  });

  // í† í° ê°±ì‹  ìš”ì²­ ì¤‘ì¸ì§€ ì¶”ì í•˜ëŠ” í”Œë˜ê·¸
  const isRefreshingRef = useRef(false);

  // ë””ë°”ìš´ìŠ¤ëœ í† í° ê°±ì‹  í•¨ìˆ˜ (300ms)
  const debouncedRefreshToken = useCallback(
    debounce((callback?: () => void) => {
      // ì´ë¯¸ ê°±ì‹  ì¤‘ì´ë©´ ì¤‘ë³µ ìš”ì²­ ë°©ì§€
      if (isRefreshingRef.current) {
        logger.info('AuthQuery', 'í† í° ê°±ì‹  ì´ë¯¸ ì§„í–‰ ì¤‘, ìš”ì²­ ë¬´ì‹œ');
        return;
      }

      isRefreshingRef.current = true;
      logger.info('AuthQuery', 'ë””ë°”ìš´ìŠ¤ëœ í† í° ê°±ì‹  ìš”ì²­ ì‹¤í–‰');
      
      refreshTokenMutation.mutate(undefined, {
        onSuccess: () => {
          isRefreshingRef.current = false;
          if (callback) callback();
        },
        onError: () => {
          isRefreshingRef.current = false;
        }
      });
    }, 300),
    [refreshTokenMutation]
  );
  
  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ë””ë°”ìš´ìŠ¤ í•¨ìˆ˜ ì·¨ì†Œ
  useEffect(() => {
    return () => {
      // @ts-ignore - TypeScriptì—ì„œ cancel ë©”ì„œë“œë¥¼ ì¸ì‹í•˜ì§€ ëª»í•  ìˆ˜ ìˆìŒ
      debouncedRefreshToken.cancel && debouncedRefreshToken.cancel();
    };
  }, [debouncedRefreshToken]);

  // ì¸ì¦ ìƒíƒœ í™•ì¸
  const isAuthenticated = !!getAccessToken() && !!userQuery.data;
  
  // ë¡œë”© ìƒíƒœ í™•ì¸
  const isLoading = 
    userQuery.isLoading || 
    loginMutation.isPending || 
    logoutMutation.isPending || 
    refreshTokenMutation.isPending;

  return {
    user: userQuery.data,
    isAuthenticated,
    isLoading,
    error: userQuery.error || loginMutation.error || logoutMutation.error,
    login: loginMutation.mutate,
    loginAsync: loginMutation.mutateAsync,
    logout: logoutMutation.mutate,
    logoutAsync: logoutMutation.mutateAsync,
    refreshToken: debouncedRefreshToken,
    refreshTokenAsync: refreshTokenMutation.mutateAsync, // ë¹„ë™ê¸° ë²„ì „ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
    isRefreshingToken: isRefreshingRef.current
  } as const;
};


============================================================
File: /home/CVEHub/frontend/src/features/auth/hooks/useUsersQuery.ts
------------------------------------------------------------
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import axios from 'shared/api/config/axios';
import { userService } from '../services/userService';
import { getCurrentUser } from '../services/authService';
import { getAccessToken } from 'shared/utils/storage/tokenStorage';
import { User, UserUpdate } from '../types/index';

/**
 * ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ ì‘ë‹µ íƒ€ì…
 */
export interface UserListResponse {
  items: User[];
  total: number;
}

/**
 * í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ í›…
 * 
 * @returns í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì¿¼ë¦¬ ê²°ê³¼
 */
export const useCurrentUser = () => {
  // ì•¡ì„¸ìŠ¤ í† í°ì´ ìˆëŠ”ì§€ í™•ì¸
  const hasToken = Boolean(getAccessToken());
  
  return useQuery({
    queryKey: ['auth', 'user'],
    queryFn: getCurrentUser,
    staleTime: 5 * 60 * 1000, // 5ë¶„
    retry: 1,
    // í† í°ì´ ìˆì„ ë•Œë§Œ ì¿¼ë¦¬ ì‹¤í–‰
    enabled: hasToken
  });
};

/**
 * ì „ì²´ ì‚¬ìš©ì ëª©ë¡ì„ ì¡°íšŒí•˜ëŠ” í›…
 * 
 * @returns ì‚¬ìš©ì ëª©ë¡ ì¿¼ë¦¬ ê²°ê³¼
 */
export const useUsers = () => {
  return useQuery({
    queryKey: ['users'],
    queryFn: async () => {
      try {
        const { data } = await axios.get('/auth/');
        return data;
      } catch (error) {
        console.error('ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        throw error;
      }
    },
    staleTime: 5 * 60 * 1000, // 5ë¶„
    retry: 1
  });
};

/**
 * ì‚¬ìš©ì ê²€ìƒ‰ì„ ìœ„í•œ í›…
 * 
 * @param query ê²€ìƒ‰ì–´
 * @returns ê²€ìƒ‰ ê²°ê³¼ ì¿¼ë¦¬
 */
export const useSearchUsers = (query: string) => {
  return useQuery({
    queryKey: ['users', 'search', query],
    queryFn: async () => {
      try {
        if (!query || query.length < 2) {
          return { items: [] };
        }
        
        const { data } = await axios.get(`/auth/search`, {
          params: { query }
        });
        return data;
      } catch (error) {
        console.error('ì‚¬ìš©ì ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        throw error;
      }
    },
    enabled: !!query && query.length >= 2,
    staleTime: 60 * 1000, // 1ë¶„
    retry: 1
  });
};

/**
 * ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸ í›…
 * 
 * @returns ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸ ë®¤í…Œì´ì…˜
 */
export const useUpdateUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (userData: UserUpdate) => userService.updateCurrentUser(userData),
    onSuccess: (updatedUser) => {
      // ì‚¬ìš©ì ì •ë³´ ìºì‹œ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(['auth', 'user'], updatedUser);
      // ì‚¬ìš©ì ëª©ë¡ ìºì‹œ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: ['users'] });
    }
  });
};

/**
 * ì‚¬ìš©ì ê³„ì • ì‚­ì œ í›…
 * 
 * @returns ì‚¬ìš©ì ê³„ì • ì‚­ì œ ë®¤í…Œì´ì…˜
 */
export const useDeleteUser = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: () => userService.deleteCurrentUser(),
    onSuccess: () => {
      // ì‚¬ìš©ì ì •ë³´ ìºì‹œ ì´ˆê¸°í™”
      queryClient.setQueryData(['auth', 'user'], null);
      // ì‚¬ìš©ì ëª©ë¡ ìºì‹œ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: ['users'] });
    }
  });
};

export default useUsers;



============================================================
File: /home/CVEHub/frontend/src/features/auth/Register.jsx
------------------------------------------------------------
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import {
  Container,
  Paper,
  TextField,
  Button,
  Typography,
  Box,
  Alert,
  CircularProgress,
  FormControlLabel,
  Checkbox,
  InputAdornment,
  IconButton
} from '@mui/material';
import { Visibility, VisibilityOff } from '@mui/icons-material';
import { api } from '../../utils/auth';

const Register = () => {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
  });
  const [isAdmin, setIsAdmin] = useState(false);
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      await api.post('/auth/register', {
        username: formData.username,
        password: formData.password,
        is_admin: isAdmin
      });

      // íšŒì›ê°€ì… ì„±ê³µ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ ì´ë™
      navigate('/login', {
        state: { message: 'Registration successful! Please login.' }
      });
    } catch (err) {
      setError(err.response?.data?.detail || 'Registration failed');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Paper elevation={3} sx={{ p: 4, width: '100%' }}>
          <Typography component="h1" variant="h4" align="center" gutterBottom>
            CVE Hub
          </Typography>
          <Typography component="h2" variant="h6" align="center" gutterBottom>
            Create Account
          </Typography>

          {error && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}

          <form onSubmit={handleSubmit}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="username"
              label="Username"
              name="username"
              autoComplete="username"
              autoFocus
              value={formData.username}
              onChange={handleChange}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email Address"
              name="email"
              autoComplete="email"
              type="email"
              value={formData.email}
              onChange={handleChange}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type={showPassword ? 'text' : 'password'}
              id="password"
              autoComplete="new-password"
              value={formData.password}
              onChange={handleChange}
              InputProps={{
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      onClick={() => setShowPassword(!showPassword)}
                      edge="end"
                    >
                      {showPassword ? <VisibilityOff /> : <Visibility />}
                    </IconButton>
                  </InputAdornment>
                ),
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirm Password"
              type={showPassword ? 'text' : 'password'}
              id="confirmPassword"
              autoComplete="new-password"
              value={formData.confirmPassword}
              onChange={handleChange}
            />

            <FormControlLabel
              control={
                <Checkbox
                  checked={isAdmin}
                  onChange={(e) => setIsAdmin(e.target.checked)}
                  color="primary"
                />
              }
              label="Register as Admin"
              sx={{ mt: 1 }}
            />

            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ mt: 3, mb: 2 }}
              disabled={loading}
            >
              {loading ? <CircularProgress size={24} /> : 'Register'}
            </Button>

            <Box sx={{ textAlign: 'center' }}>
              <Link to="/login" style={{ textDecoration: 'none' }}>
                <Typography variant="body2" color="primary">
                  Already have an account? Login
                </Typography>
              </Link>
            </Box>
          </form>
        </Paper>
      </Box>
    </Container>
  );
};

export default Register;



============================================================
File: /home/CVEHub/frontend/src/features/notification/types/index.ts
------------------------------------------------------------
/**
 * ì•Œë¦¼ ê´€ë ¨ íƒ€ì… ì •ì˜ íŒŒì¼
 */

/**
 * ì•Œë¦¼ íƒ€ì… ì—´ê±°í˜•
 */
export enum NotificationType {
  CVE_CREATED = 'CVE_CREATED',
  CVE_UPDATED = 'CVE_UPDATED',
  COMMENT_ADDED = 'COMMENT_ADDED',
  MENTION = 'MENTION',
  SYSTEM = 'SYSTEM',
}

/**
 * ì•Œë¦¼ ìš°ì„ ìˆœìœ„ ì—´ê±°í˜•
 */
export enum NotificationPriority {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
}

/**
 * ê¸°ë³¸ ì•Œë¦¼ ì¸í„°í˜ì´ìŠ¤
 */
export interface Notification {
  id: string;
  type: NotificationType;
  title: string;
  message: string;
  createdAt: string | Date;
  isRead: boolean;
  priority?: NotificationPriority;
  targetUrl?: string;
  data?: Record<string, any>;
}

/**
 * CVE ê´€ë ¨ ì•Œë¦¼ ì¸í„°í˜ì´ìŠ¤
 */
export interface CVENotification extends Notification {
  type: NotificationType.CVE_CREATED | NotificationType.CVE_UPDATED;
  data: {
    cveId: string;
    title?: string;
    fieldUpdated?: string;
    updatedBy?: string;
  };
}

/**
 * ëŒ“ê¸€ ê´€ë ¨ ì•Œë¦¼ ì¸í„°í˜ì´ìŠ¤
 */
export interface CommentNotification extends Notification {
  type: NotificationType.COMMENT_ADDED;
  data: {
    cveId: string;
    commentId: string;
    commentAuthor: string;
  };
}

/**
 * ì–¸ê¸‰ ì•Œë¦¼ ì¸í„°í˜ì´ìŠ¤
 */
export interface MentionNotification extends Notification {
  type: NotificationType.MENTION;
  data: {
    cveId: string;
    commentId: string;
    mentionedBy: string;
    commentText?: string;
  };
}

/**
 * ì‹œìŠ¤í…œ ì•Œë¦¼ ì¸í„°í˜ì´ìŠ¤
 */
export interface SystemNotification extends Notification {
  type: NotificationType.SYSTEM;
  data?: {
    severity?: 'info' | 'warning' | 'error';
    action?: string;
  };
}

/**
 * ì•Œë¦¼ í•„í„° ì˜µì…˜ ì¸í„°í˜ì´ìŠ¤
 */
export interface NotificationFilterOptions {
  isRead?: boolean;
  type?: NotificationType;
  priority?: NotificationPriority;
  fromDate?: string | Date;
  toDate?: string | Date;
}

/**
 * ì•Œë¦¼ ì—…ë°ì´íŠ¸ ìš”ì²­ ì¸í„°í˜ì´ìŠ¤
 */
export interface NotificationUpdateRequest {
  isRead?: boolean;
}

/**
 * ì•Œë¦¼ ì„¤ì • ì¸í„°í˜ì´ìŠ¤
 */
export interface NotificationSettings {
  emailNotifications: boolean;
  browserNotifications: boolean;
  notifyOnCveCreated: boolean;
  notifyOnCveUpdated: boolean;
  notifyOnCommentAdded: boolean;
  notifyOnMention: boolean;
  notifyOnSystem: boolean;
}


============================================================
File: /home/CVEHub/frontend/src/features/notification/NotificationBell.tsx
------------------------------------------------------------
import React, { useEffect, useState, useCallback, memo } from 'react';
import {
  Badge,
  IconButton,
  Menu,
  MenuItem,
  Typography,
  Box,
  Divider,
  Button,
  Snackbar,
  Alert,
  CircularProgress
} from '@mui/material';
import NotificationsIcon from '@mui/icons-material/Notifications';
import { useNotifications, useUnreadCount, useMarkAsRead, useMarkAllAsRead } from '../../features/notification/hooks/useNotifications';
import CVEDetail from '../cve/CVEDetail';
import { NotificationBellProps } from '../../shared/api/types/components';
/**
 * ì•Œë¦¼ ì¢… ì»´í¬ë„ŒíŠ¸ - RxJS ë§ˆì´ê·¸ë ˆì´ì…˜ ë²„ì „
 * 
 * ì›¹ ì•Œë¦¼ì„ í‘œì‹œí•˜ê³  ê´€ë¦¬í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ì…ë‹ˆë‹¤.
 * CVE ê´€ë ¨ ì•Œë¦¼ì„ ë°›ìœ¼ë©´ ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•˜ê³ , í´ë¦­ ì‹œ ìƒì„¸ ì •ë³´ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.
 */
const NotificationBell: React.FC<NotificationBellProps> = memo(({ onOpenCVEDetail }) => {
  const [anchorEl, setAnchorEl] = useState<HTMLElement | null>(null);
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: '',
    severity: 'info' as 'info' | 'error' | 'success' | 'warning'
  });
  const [dialogOpen, setDialogOpen] = useState(false);
  const [selectedCVE, setSelectedCVE] = useState<string | null>(null);
  const [selectedCommentId, setSelectedCommentId] = useState<string | null>(null);

  const ITEMS_PER_PAGE = 5;
  const skip = page * ITEMS_PER_PAGE;
  
  // React Query í›… ì‚¬ìš©
  const { data: unreadCountData } = useUnreadCount({
    refetchOnWindowFocus: true,
    refetchInterval: 60000, // 1ë¶„ë§ˆë‹¤ ê°±ì‹ 
  });
  
  const { 
    data: notificationsData, 
    isLoading: notificationsLoading,
    refetch: refetchNotifications
  } = useNotifications(
    { skip, limit: ITEMS_PER_PAGE },
    { 
      enabled: Boolean(anchorEl),
      keepPreviousData: true
    }
  );
  
  const markAsReadMutation = useMarkAsRead();
  const markAllAsReadMutation = useMarkAllAsRead();
  
  const notifications = notificationsData?.notifications || [];
  const totalCount = notificationsData?.total || 0;
  const unreadCount = unreadCountData?.count || 0;
  
  const loadNotifications = useCallback((newPage: number) => {
    setPage(newPage);
    setHasMore((newPage + 1) * ITEMS_PER_PAGE < totalCount);
  }, [totalCount]);
  
  const loadMoreNotifications = useCallback(() => {
    if (hasMore && !notificationsLoading) {
      loadNotifications(page + 1);
    }
  }, [hasMore, notificationsLoading, loadNotifications, page]);
  
  // ì•Œë¦¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
  useEffect(() => {
    if (Boolean(anchorEl)) {
      loadNotifications(0);
    }
  }, [anchorEl, loadNotifications]);
  
  // ì•Œë¦¼ ID ì¶”ì¶œ í—¬í¼ í•¨ìˆ˜
  const getNotificationId = useCallback((notification: any): string | null => {
    if (!notification) return null;
    
    // MongoDB ObjectId ë˜ëŠ” ì¼ë°˜ ID ì²˜ë¦¬
    if (notification._id) return notification._id;
    if (notification.id) return notification.id;
    
    return null;
  }, []);
  
  const handleClick = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };
  
  const handleClose = () => {
    setAnchorEl(null);
  };
  
  const handleMarkAllAsRead = async () => {
    try {
      await markAllAsReadMutation.mutateAsync();
      
      setSnackbar({
        open: true,
        message: 'ëª¨ë“  ì•Œë¦¼ì„ ì½ìŒ ì²˜ë¦¬í–ˆìŠµë‹ˆë‹¤.',
        severity: 'success'
      });
      
      // ì•Œë¦¼ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
      refetchNotifications();
    } catch (error: any) {
      console.error('ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
      
      setSnackbar({
        open: true,
        message: 'ëª¨ë“  ì•Œë¦¼ì„ ì½ìŒ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
        severity: 'error'
      });
    }
  };
  
  const formatNotificationContent = useCallback((notification: any) => {
    const { type, content, metadata } = notification;
    
    switch (type) {
      case 'cve_update':
        return (
          <Typography variant="body1">
            <strong>CVE ì—…ë°ì´íŠ¸:</strong> {content}
          </Typography>
        );
      
      case 'comment':
        return (
          <Typography variant="body1">
            <strong>ëŒ“ê¸€:</strong> {content}
          </Typography>
        );
      
      case 'system':
        return (
          <Typography variant="body1">
            {content}
          </Typography>
        );
      
      default:
        return (
          <Typography variant="body1">
            {content}
          </Typography>
        );
    }
  }, []);
  
  const handleNotificationClick = async (notification: any) => {
    try {
      const id = getNotificationId(notification);
      
      if (!id) {
        console.error('%c âŒ ì•Œë¦¼ ID ì˜¤ë¥˜', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', 'ìœ íš¨í•˜ì§€ ì•Šì€ ì•Œë¦¼ ID');
        return;
      }
      
      // ì½ìŒ ì²˜ë¦¬
      await markAsReadMutation.mutateAsync(id);
      
      // CVE ê´€ë ¨ ì•Œë¦¼ì¸ ê²½ìš° ìƒì„¸ ì •ë³´ í‘œì‹œ
      if (notification.metadata && notification.metadata.cve_id) {
        const cveId = notification.metadata.cve_id;
        const commentId = notification.metadata.comment_id || null;
        
        // ì™¸ë¶€ì—ì„œ ì „ë‹¬ëœ onOpenCVEDetail í•¨ìˆ˜ê°€ ìˆìœ¼ë©´ ì‚¬ìš©
        if (onOpenCVEDetail) {
          handleClose(); // ë©”ë‰´ ë‹«ê¸°
          onOpenCVEDetail(cveId, commentId);
        } else {
          // ë‚´ë¶€ ë‹¤ì´ì–¼ë¡œê·¸ ì‚¬ìš©
          setSelectedCVE(cveId);
          setSelectedCommentId(commentId);
          setDialogOpen(true);
        }
      }
    } catch (error: any) {
      console.error('%c âŒ ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬ ì˜¤ë¥˜', 'background: #f44336; color: white; padding: 2px 4px; border-radius: 2px;', {
        message: error.message,
        code: error.code
      });
      setSnackbar({
        open: true,
        message: 'ì•Œë¦¼ì„ ì½ìŒ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
        severity: 'error'
      });
    }
  };
  
  const handleDialogClose = () => {
    setDialogOpen(false);
    setSelectedCVE(null);
    setSelectedCommentId(null);
  };
  
  const handleSnackbarClose = useCallback(() => {
    setSnackbar(prev => ({ ...prev, open: false }));
  }, []);
  
  const formatDate = (dateString: string) => {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffSec = Math.floor(diffMs / 1000);
    const diffMin = Math.floor(diffSec / 60);
    const diffHour = Math.floor(diffMin / 60);
    const diffDay = Math.floor(diffHour / 24);
    
    if (diffDay > 7) {
      return date.toLocaleDateString('ko-KR', { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
      });
    } else if (diffDay > 0) {
      return `${diffDay}ì¼ ì „`;
    } else if (diffHour > 0) {
      return `${diffHour}ì‹œê°„ ì „`;
    } else if (diffMin > 0) {
      return `${diffMin}ë¶„ ì „`;
    } else {
      return 'ë°©ê¸ˆ ì „';
    }
  };
  
  return (
    <>
      <IconButton
        color="inherit"
        onClick={handleClick}
        aria-label="ì•Œë¦¼"
      >
        <Badge badgeContent={unreadCount} color="error">
          <NotificationsIcon />
        </Badge>
      </IconButton>
      
      <Menu
        id="notification-menu"
        anchorEl={anchorEl}
        keepMounted
        open={Boolean(anchorEl)}
        onClose={handleClose}
        PaperProps={{
          style: {
            width: '320px',
            maxHeight: '70vh',
          },
        }}
      >
        <Box sx={{ p: 1, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
            ì•Œë¦¼
            {unreadCount > 0 && (
              <Typography component="span" color="error" sx={{ ml: 1 }}>
                ({unreadCount}ê°œ ì•ˆ ì½ìŒ)
              </Typography>
            )}
          </Typography>
          
          {unreadCount > 0 && (
            <Button 
              size="small" 
              color="primary" 
              onClick={handleMarkAllAsRead}
              disabled={markAllAsReadMutation.isLoading}
            >
              {markAllAsReadMutation.isLoading ? (
                <CircularProgress size={16} />
              ) : (
                'ëª¨ë‘ ì½ìŒ'
              )}
            </Button>
          )}
        </Box>
        
        <Divider />
        
        {notificationsLoading && (
          <Box sx={{ p: 2, textAlign: 'center' }}>
            <CircularProgress size={24} />
          </Box>
        )}
        
        {!notificationsLoading && notifications.length === 0 && (
          <Box sx={{ p: 2, textAlign: 'center' }}>
            <Typography variant="body2" color="text.secondary">
              ì•Œë¦¼ì´ ì—†ìŠµë‹ˆë‹¤.
            </Typography>
          </Box>
        )}
        
        {notifications.map((notification: any, index: number) => (
          <React.Fragment key={getNotificationId(notification) || index}>
            <MenuItem 
              onClick={() => handleNotificationClick(notification)}
              sx={{ 
                py: 1.5,
                px: 2,
                borderLeft: notification.read ? 'none' : '4px solid',
                borderColor: 'primary.main',
                backgroundColor: notification.read ? 'transparent' : 'rgba(0, 0, 0, 0.04)',
                '&:hover': {
                  backgroundColor: notification.read ? 'rgba(0, 0, 0, 0.08)' : 'rgba(0, 0, 0, 0.1)',
                }
              }}
            >
              <Box sx={{ width: '100%' }}>
                {formatNotificationContent(notification)}
                
                <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mt: 0.5 }}>
                  {formatDate(notification.createdAt)}
                </Typography>
              </Box>
            </MenuItem>
            {index < notifications.length - 1 && <Divider />}
          </React.Fragment>
        ))}
        
        {hasMore && (
          <Box sx={{ p: 1, textAlign: 'center' }}>
            <Button 
              size="small" 
              onClick={loadMoreNotifications}
              disabled={notificationsLoading}
            >
              ë” ë³´ê¸°
            </Button>
          </Box>
        )}
      </Menu>
      
      {/* CVE ìƒì„¸ ë‹¤ì´ì–¼ë¡œê·¸ */}
      {dialogOpen && selectedCVE && (
        <CVEDetail
          cveId={selectedCVE}
          open={dialogOpen}
          onClose={handleDialogClose}
          highlightCommentId={selectedCommentId}
        />
      )}
      
      {/* ì•Œë¦¼ ìŠ¤ë‚µë°” */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={5000}
        onClose={handleSnackbarClose}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbar.severity}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </>
  );
});

export default NotificationBell;



============================================================
File: /home/CVEHub/frontend/src/features/notification/services/notificationService.js
------------------------------------------------------------
import api from 'shared/api/config/axios';
import { NOTIFICATION, WEBSOCKET } from 'shared/api/config/endpoints';

export const notificationService = {
  // ì•Œë¦¼ ëª©ë¡ ì¡°íšŒ
  getNotifications: async (params) => {
    const response = await api.get(NOTIFICATION.BASE, { params });
    return response.data;
  },

  // ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜ ì¡°íšŒ
  getUnreadCount: async () => {
    const response = await api.get(NOTIFICATION.UNREAD_COUNT);
    return response.data;
  },

  // ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  markAsRead: async (id) => {
    const response = await api.patch(NOTIFICATION.READ(id));
    return response.data;
  },

  // ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  markAllAsRead: async () => {
    const response = await api.patch(NOTIFICATION.READ_ALL);
    return response.data;
  },

  // WebSocket ì—°ê²° URL ìƒì„±
  getWebSocketUrl: (userId, token) => {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsHost = process.env.REACT_APP_API_URL || `${window.location.protocol}//${window.location.hostname}:8000`;
    const cleanHost = wsHost.replace(/^https?:\/\//, '');
    return `${wsProtocol}//${cleanHost}${WEBSOCKET.CONNECT(userId, token)}`;
  },
}; 


============================================================
File: /home/CVEHub/frontend/src/features/notification/hooks/useNotifications.js
------------------------------------------------------------
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { notificationService } from '../services/notificationService';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { useSocket } from 'core/socket/hooks/useSocket';
import { useEffect, useCallback } from 'react';
import logger from 'shared/utils/logging';

/**
 * ì•Œë¦¼ ëª©ë¡ì„ ì¡°íšŒí•˜ëŠ” í›…
 * @param {Object} params - í˜ì´ì§€ë„¤ì´ì…˜ íŒŒë¼ë¯¸í„° (skip, limit)
 * @param {Object} options - React Query ì˜µì…˜
 * @returns {Object} ì¿¼ë¦¬ ê²°ê³¼
 */
export const useNotifications = (params = {}, options = {}) => {
  return useQuery({
    queryKey: [QUERY_KEYS.NOTIFICATION, 'list', params],
    queryFn: () => notificationService.getNotifications(params),
    ...options,
  });
};

/**
 * ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜ë¥¼ ì¡°íšŒí•˜ëŠ” í›…
 * @param {Object} options - React Query ì˜µì…˜
 * @returns {Object} ì¿¼ë¦¬ ê²°ê³¼
 */
export const useUnreadCount = (options = {}) => {
  const queryClient = useQueryClient();
  // useSocket í›… ì‚¬ìš© - í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ì— ë§ê²Œ ìˆ˜ì •
  const { on } = useSocket(
    undefined, // ì´ë²¤íŠ¸ ì´ë¦„ì€ ì§€ì •í•˜ì§€ ì•ŠìŒ
    undefined, // ì½œë°± í•¨ìˆ˜ëŠ” ì§€ì •í•˜ì§€ ì•ŠìŒ
    [], // ì˜ì¡´ì„± ë°°ì—´
    {
      componentId: 'notifications-unread-count',
      useRxJS: true
    }
  );
  
  // ì‹¤ì‹œê°„ ì•Œë¦¼ ìˆ˜ì‹  ì‹œ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
  useEffect(() => {
    // ìƒˆ ì•Œë¦¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    const unsubNewNotification = on('NEW_NOTIFICATION', () => {
      logger.info('ìƒˆ ì•Œë¦¼ ì´ë²¤íŠ¸ ìˆ˜ì‹ ');
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'] });
    });
    
    // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
    return () => {
      unsubNewNotification();
    };
  }, [on, queryClient]);
  
  return useQuery({
    queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'],
    queryFn: () => notificationService.getUnreadCount(),
    ...options,
  });
};

/**
 * ì•Œë¦¼ì„ ì½ìŒ ì²˜ë¦¬í•˜ëŠ” í›…
 * @returns {Object} ë®¤í…Œì´ì…˜ ê²°ê³¼
 */
export const useMarkAsRead = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (id) => notificationService.markAsRead(id),
    onSuccess: () => {
      // ì•Œë¦¼ ëª©ë¡ê³¼ ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜ ê°±ì‹ 
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'list'] });
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'] });
    },
  });
};

/**
 * ëª¨ë“  ì•Œë¦¼ì„ ì½ìŒ ì²˜ë¦¬í•˜ëŠ” í›…
 * @returns {Object} ë®¤í…Œì´ì…˜ ê²°ê³¼
 */
export const useMarkAllAsRead = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: () => notificationService.markAllAsRead(),
    onSuccess: () => {
      // ì•Œë¦¼ ëª©ë¡ê³¼ ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜ ê°±ì‹ 
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'list'] });
      queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'] });
    },
  });
};

/**
 * ì‹¤ì‹œê°„ ì•Œë¦¼ ì—…ë°ì´íŠ¸ë¥¼ êµ¬ë…í•˜ëŠ” í›…
 * @returns {Object} êµ¬ë… ìƒíƒœ
 */
export const useNotificationUpdates = () => {
  const queryClient = useQueryClient();
  // useSocket í›… ì‚¬ìš© - í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ì— ë§ê²Œ ìˆ˜ì •
  const { connected, on } = useSocket(
    undefined, // ì´ë²¤íŠ¸ ì´ë¦„ì€ ì§€ì •í•˜ì§€ ì•ŠìŒ
    undefined, // ì½œë°± í•¨ìˆ˜ëŠ” ì§€ì •í•˜ì§€ ì•ŠìŒ
    [], // ì˜ì¡´ì„± ë°°ì—´
    {
      componentId: 'notification-updates',
      useRxJS: true
    }
  );
  
  // ìƒˆ ì•Œë¦¼ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  const handleNewNotification = useCallback((notification) => {
    logger.info('ìƒˆ ì•Œë¦¼ ìˆ˜ì‹ :', notification);
    
    // ì•Œë¦¼ ëª©ë¡ê³¼ ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜ ê°±ì‹ 
    queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'list'] });
    queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'] });
  }, [queryClient]);
  
  // ì½ìŒ ì²˜ë¦¬ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  const handleNotificationRead = useCallback((data) => {
    logger.info('ì•Œë¦¼ ì½ìŒ ì´ë²¤íŠ¸ ìˆ˜ì‹ :', data);
    
    // ì•Œë¦¼ ëª©ë¡ê³¼ ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜ ê°±ì‹ 
    queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'list'] });
    queryClient.invalidateQueries({ queryKey: [QUERY_KEYS.NOTIFICATION, 'unread-count'] });
  }, [queryClient]);
  
  // ì†Œì¼“ ì´ë²¤íŠ¸ êµ¬ë… ì„¤ì •
  useEffect(() => {
    if (connected) {
      // ì´ë²¤íŠ¸ êµ¬ë… ì„¤ì •
      const unsubNew = on('NEW_NOTIFICATION', handleNewNotification);
      const unsubRead = on('NOTIFICATION_READ', handleNotificationRead);
      const unsubAllRead = on('ALL_NOTIFICATIONS_READ', handleNotificationRead);
      
      // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì •ë¦¬ ì‘ì—…
      return () => {
        unsubNew();
        unsubRead();
        unsubAllRead();
      };
    }
  }, [connected, on, handleNewNotification, handleNotificationRead, queryClient]);
  
  return { isConnected: connected };
};

export default {
  useNotifications,
  useUnreadCount,
  useMarkAsRead,
  useMarkAllAsRead,
  useNotificationUpdates
};


============================================================
File: /home/CVEHub/frontend/src/features/cache/services/cacheService.js
------------------------------------------------------------
/**
 * ìºì‹œ ê´€ë ¨ API ì„œë¹„ìŠ¤
 */
import axios from 'axios';
import { API_BASE_URL } from 'config';

/**
 * Redis ìºì‹œ ì„œë²„ ì •ë³´ ì¡°íšŒ
 * @returns {Promise<Object>} ìºì‹œ ì„œë²„ ì •ë³´
 */
export const getCacheInfo = async () => {
  try {
    const response = await axios.get(`${API_BASE_URL}/cache/info`);
    return response.data;
  } catch (error) {
    console.error('ìºì‹œ ì„œë²„ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:', error);
    throw error;
  }
};

/**
 * Redis ìºì‹œ í†µê³„ ì •ë³´ ì¡°íšŒ
 * @returns {Promise<Object>} ìºì‹œ í†µê³„ ì •ë³´
 */
export const getCacheStats = async () => {
  try {
    const response = await axios.get(`${API_BASE_URL}/cache/stats`);
    return response.data;
  } catch (error) {
    console.error('ìºì‹œ í†µê³„ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:', error);
    throw error;
  }
};

/**
 * Redis ìºì‹œ í‚¤ ëª©ë¡ ì¡°íšŒ
 * @param {Object} params ì¡°íšŒ íŒŒë¼ë¯¸í„°
 * @param {string} [params.prefix] ìºì‹œ í‚¤ í”„ë¦¬í”½ìŠ¤
 * @param {string} [params.pattern] ê²€ìƒ‰ íŒ¨í„´
 * @param {number} [params.limit] ìµœëŒ€ ì¡°íšŒ ê°œìˆ˜
 * @returns {Promise<Object>} ìºì‹œ í‚¤ ëª©ë¡
 */
export const getCacheKeys = async (params = {}) => {
  try {
    const response = await axios.get(`${API_BASE_URL}/cache/keys`, { params });
    return response.data;
  } catch (error) {
    console.error('ìºì‹œ í‚¤ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:', error);
    throw error;
  }
};

/**
 * Redis ìºì‹œ ê°’ ì¡°íšŒ
 * @param {Object} params ì¡°íšŒ íŒŒë¼ë¯¸í„°
 * @param {string} [params.prefix] ìºì‹œ í‚¤ í”„ë¦¬í”½ìŠ¤
 * @param {string} [params.pattern] ê²€ìƒ‰ íŒ¨í„´
 * @param {number} [params.limit] ìµœëŒ€ ì¡°íšŒ ê°œìˆ˜
 * @returns {Promise<Object>} ìºì‹œ ê°’ ëª©ë¡
 */
export const getCacheValues = async (params = {}) => {
  try {
    const response = await axios.get(`${API_BASE_URL}/cache/values`, { params });
    return response.data;
  } catch (error) {
    console.error('ìºì‹œ ê°’ ì¡°íšŒ ì‹¤íŒ¨:', error);
    throw error;
  }
};

/**
 * Redis ìºì‹œ ì‚­ì œ
 * @param {Object} params ì‚­ì œ íŒŒë¼ë¯¸í„°
 * @param {string} [params.prefix] ìºì‹œ í‚¤ í”„ë¦¬í”½ìŠ¤
 * @param {string} [params.pattern] ì‚­ì œí•  í‚¤ íŒ¨í„´
 * @returns {Promise<Object>} ì‚­ì œ ê²°ê³¼
 */
export const clearCache = async (params = {}) => {
  try {
    const response = await axios.delete(`${API_BASE_URL}/cache/clear`, { params });
    return response.data;
  } catch (error) {
    console.error('ìºì‹œ ì‚­ì œ ì‹¤íŒ¨:', error);
    throw error;
  }
};



============================================================
File: /home/CVEHub/frontend/src/features/cache/CacheVisualization.jsx
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Container, 
  Typography, 
  Paper, 
  Grid, 
  Tabs, 
  Tab, 
  CircularProgress,
  Divider,
  useTheme
} from '@mui/material';
import { 
  useCacheInfoQuery, 
  useCacheStatsQuery, 
  useReactQueryCache 
} from './hooks/useCacheQuery';
import RedisOverview from './components/RedisOverview';
import RedisKeysList from './components/RedisKeysList';
import RedisValuesViewer from './components/RedisValuesViewer';
import ReactQueryViewer from './components/ReactQueryViewer';
import CacheDashboard from './components/CacheDashboard';

/**
 * ìºì‹œ ì‹œê°í™” í˜ì´ì§€ ì»´í¬ë„ŒíŠ¸
 */
const CacheVisualization = () => {
  const theme = useTheme();
  const [tabValue, setTabValue] = useState(0);
  const { data: cacheInfo, isLoading: isInfoLoading } = useCacheInfoQuery();
  const { data: cacheStats, isLoading: isStatsLoading } = useCacheStatsQuery();
  const { getQueryCache } = useReactQueryCache();
  const [queryCache, setQueryCache] = useState([]);

  // React Query ìºì‹œ ì •ë³´ ì£¼ê¸°ì  ì—…ë°ì´íŠ¸
  useEffect(() => {
    const updateQueryCache = () => {
      setQueryCache(getQueryCache());
    };

    // ì´ˆê¸° ë¡œë“œ
    updateQueryCache();

    // 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
    const interval = setInterval(updateQueryCache, 1000);
    return () => clearInterval(interval);
  }, []); // getQueryCache ì˜ì¡´ì„± ì œê±°

  // íƒ­ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  // ë¡œë”© ì¤‘ í‘œì‹œ
  if (isInfoLoading || isStatsLoading) {
    return (
      <Box 
        sx={{ 
          display: 'flex', 
          justifyContent: 'center', 
          alignItems: 'center', 
          minHeight: '80vh' 
        }}
      >
        <CircularProgress size={60} thickness={4} />
      </Box>
    );
  }

  return (
    <Container maxWidth="xl" sx={{ mt: 4, mb: 8 }}>
      <Paper 
        elevation={3} 
        sx={{ 
          p: 3, 
          borderRadius: 2, 
          background: `linear-gradient(135deg, ${theme.palette.background.paper} 0%, ${theme.palette.background.default} 100%)`,
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)'
        }}
      >
        <Typography 
          variant="h4" 
          component="h1" 
          gutterBottom 
          sx={{ 
            fontWeight: 700, 
            color: theme.palette.primary.main,
            textShadow: '0px 2px 4px rgba(0, 0, 0, 0.05)',
            mb: 3
          }}
        >
          ìºì‹œ ì‹œê°í™” ëŒ€ì‹œë³´ë“œ
        </Typography>
        
        <Divider sx={{ mb: 4 }} />
        
        {/* ëŒ€ì‹œë³´ë“œ ìš”ì•½ ì •ë³´ */}
        <CacheDashboard 
          cacheInfo={cacheInfo} 
          cacheStats={cacheStats} 
          queryCache={queryCache} 
        />
        
        {/* íƒ­ ë„¤ë¹„ê²Œì´ì…˜ */}
        <Box sx={{ mt: 6, mb: 3, borderBottom: 1, borderColor: 'divider' }}>
          <Tabs 
            value={tabValue} 
            onChange={handleTabChange} 
            variant="scrollable"
            scrollButtons="auto"
            sx={{
              '& .MuiTab-root': {
                fontWeight: 600,
                fontSize: '1rem',
                transition: 'all 0.2s',
                '&:hover': {
                  color: theme.palette.primary.main,
                  opacity: 0.8,
                },
              },
              '& .Mui-selected': {
                color: theme.palette.primary.main,
              },
              '& .MuiTabs-indicator': {
                backgroundColor: theme.palette.primary.main,
                height: 3,
                borderRadius: '3px 3px 0 0',
              },
            }}
          >
            <Tab label="Redis ê°œìš”" />
            <Tab label="Redis í‚¤ ëª©ë¡" />
            <Tab label="Redis ê°’ ë·°ì–´" />
            <Tab label="React Query ìºì‹œ" />
          </Tabs>
        </Box>
        
        {/* íƒ­ ì»¨í…ì¸  */}
        <Box sx={{ py: 2 }}>
          {tabValue === 0 && <RedisOverview cacheInfo={cacheInfo} cacheStats={cacheStats} />}
          {tabValue === 1 && <RedisKeysList />}
          {tabValue === 2 && <RedisValuesViewer />}
          {tabValue === 3 && <ReactQueryViewer queryCache={queryCache} />}
        </Box>
      </Paper>
    </Container>
  );
};

export default CacheVisualization;



============================================================
File: /home/CVEHub/frontend/src/features/cache/components/CacheDashboard.jsx
------------------------------------------------------------
import React from 'react';
import { 
  Box, 
  Grid, 
  Paper, 
  Typography, 
  useTheme,
  Tooltip,
  Chip
} from '@mui/material';
import { 
  Storage as StorageIcon, 
  Memory as MemoryIcon, 
  Speed as SpeedIcon, 
  QueryStats as QueryStatsIcon 
} from '@mui/icons-material';
import { 
  BarChart, 
  Bar, 
  PieChart, 
  Pie, 
  Cell, 
  ResponsiveContainer,
  Tooltip as RechartsTooltip,
  Legend
} from 'recharts';

/**
 * ìºì‹œ ëŒ€ì‹œë³´ë“œ ì»´í¬ë„ŒíŠ¸
 * @param {Object} props ì»´í¬ë„ŒíŠ¸ ì†ì„±
 * @param {Object} props.cacheInfo Redis ì„œë²„ ì •ë³´
 * @param {Object} props.cacheStats Redis ìºì‹œ í†µê³„
 * @param {Array} props.queryCache React Query ìºì‹œ ì •ë³´
 */
const CacheDashboard = ({ cacheInfo, cacheStats, queryCache }) => {
  const theme = useTheme();
  
  // ìƒ‰ìƒ íŒ”ë ˆíŠ¸
  const colors = [
    theme.palette.primary.main,
    theme.palette.secondary.main,
    theme.palette.success.main,
    theme.palette.warning.main,
    theme.palette.error.main,
    theme.palette.info.main,
  ];
  
  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë°ì´í„° (MB ë‹¨ìœ„)
  const memoryData = [
    { name: 'ì‚¬ìš© ë©”ëª¨ë¦¬', value: parseFloat((cacheInfo.used_memory / (1024 * 1024)).toFixed(2)) },
    { name: 'í”¼í¬ ë©”ëª¨ë¦¬', value: parseFloat((cacheInfo.used_memory_peak / (1024 * 1024)).toFixed(2)) },
  ];
  
  // í‚¤ íƒ€ì… ë°ì´í„°
  const keyTypesData = Object.entries(cacheStats.key_types || {}).map(([type, count], index) => ({
    name: type,
    value: count,
    color: colors[index % colors.length]
  }));
  
  // íˆíŠ¸/ë¯¸ìŠ¤ ë°ì´í„°
  const hitMissData = [
    { name: 'íˆíŠ¸', value: cacheStats.keyspace_hits || 0 },
    { name: 'ë¯¸ìŠ¤', value: cacheStats.keyspace_misses || 0 },
  ];
  
  // íˆíŠ¸ìœ¨ ê³„ì‚°
  const hitRate = hitMissData[0].value + hitMissData[1].value > 0
    ? ((hitMissData[0].value / (hitMissData[0].value + hitMissData[1].value)) * 100).toFixed(2)
    : 0;
  
  // React Query ìºì‹œ ìƒíƒœ ë°ì´í„°
  const queryStatusData = [
    { name: 'í™œì„±', value: queryCache.filter(q => q.isActive).length },
    { name: 'ì˜¤ë˜ë¨', value: queryCache.filter(q => q.isStale).length },
    { name: 'ë¹„í™œì„±', value: queryCache.filter(q => !q.isActive).length },
  ];

  // í†µê³„ ì¹´ë“œ ìŠ¤íƒ€ì¼
  const statCardStyle = {
    p: 3,
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    borderRadius: 2,
    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
    transition: 'transform 0.3s, box-shadow 0.3s',
    '&:hover': {
      transform: 'translateY(-5px)',
      boxShadow: '0 8px 30px rgba(0, 0, 0, 0.12)',
    }
  };

  // ì•„ì´ì½˜ ìŠ¤íƒ€ì¼
  const iconStyle = {
    fontSize: 40,
    mb: 2,
    p: 1,
    borderRadius: '50%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    width: 64,
    height: 64,
  };

  return (
    <Box sx={{ mb: 6 }}>
      <Grid container spacing={3}>
        {/* Redis ì„œë²„ ì •ë³´ */}
        <Grid item xs={12} md={6} lg={3}>
          <Paper sx={statCardStyle}>
            <Box sx={{ 
              ...iconStyle, 
              bgcolor: 'rgba(25, 118, 210, 0.1)', 
              color: 'primary.main' 
            }}>
              <StorageIcon fontSize="large" />
            </Box>
            <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
              Redis ì„œë²„
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              ë²„ì „: {cacheInfo.redis_version}
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              ì—…íƒ€ì„: {Math.floor(cacheInfo.uptime_in_seconds / 86400)}ì¼ {Math.floor((cacheInfo.uptime_in_seconds % 86400) / 3600)}ì‹œê°„
            </Typography>
            <Typography variant="body2" color="text.secondary">
              ì—°ê²° í´ë¼ì´ì–¸íŠ¸: {cacheInfo.connected_clients}
            </Typography>
            <Box sx={{ mt: 'auto', pt: 2 }}>
              <Chip 
                label={cacheInfo.redis_mode === 'standalone' ? 'ë‹¨ë… ëª¨ë“œ' : cacheInfo.redis_mode} 
                size="small" 
                color="primary" 
                variant="outlined" 
              />
            </Box>
          </Paper>
        </Grid>

        {/* ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ */}
        <Grid item xs={12} md={6} lg={3}>
          <Paper sx={statCardStyle}>
            <Box sx={{ 
              ...iconStyle, 
              bgcolor: 'rgba(156, 39, 176, 0.1)', 
              color: 'secondary.main' 
            }}>
              <MemoryIcon fontSize="large" />
            </Box>
            <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
              ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              ì‚¬ìš© ë©”ëª¨ë¦¬: {(cacheInfo.used_memory / (1024 * 1024)).toFixed(2)} MB
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              í”¼í¬ ë©”ëª¨ë¦¬: {(cacheInfo.used_memory_peak / (1024 * 1024)).toFixed(2)} MB
            </Typography>
            <Typography variant="body2" color="text.secondary">
              ë©”ëª¨ë¦¬ ë‹¨í¸í™”: {cacheInfo.mem_fragmentation_ratio?.toFixed(2) || 'N/A'}
            </Typography>
            
            <Box sx={{ mt: 2, height: 100 }}>
              <ResponsiveContainer width="100%" height="100%">
                <BarChart data={memoryData} layout="vertical">
                  <RechartsTooltip 
                    formatter={(value) => [`${value} MB`, 'ë©”ëª¨ë¦¬']}
                    labelFormatter={() => ''}
                  />
                  <Bar 
                    dataKey="value" 
                    fill={theme.palette.secondary.main}
                    radius={[0, 4, 4, 0]}
                  >
                    {memoryData.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={colors[index % colors.length]} />
                    ))}
                  </Bar>
                </BarChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>

        {/* ìºì‹œ ì„±ëŠ¥ */}
        <Grid item xs={12} md={6} lg={3}>
          <Paper sx={statCardStyle}>
            <Box sx={{ 
              ...iconStyle, 
              bgcolor: 'rgba(76, 175, 80, 0.1)', 
              color: 'success.main' 
            }}>
              <SpeedIcon fontSize="large" />
            </Box>
            <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
              ìºì‹œ ì„±ëŠ¥
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              í‚¤ìŠ¤í˜ì´ìŠ¤ íˆíŠ¸: {cacheStats.keyspace_hits?.toLocaleString() || 0}
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              í‚¤ìŠ¤í˜ì´ìŠ¤ ë¯¸ìŠ¤: {cacheStats.keyspace_misses?.toLocaleString() || 0}
            </Typography>
            <Typography variant="h5" color="success.main" sx={{ mt: 1, fontWeight: 700 }}>
              íˆíŠ¸ìœ¨: {hitRate}%
            </Typography>
            
            <Box sx={{ mt: 2, height: 100 }}>
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={hitMissData}
                    cx="50%"
                    cy="50%"
                    innerRadius={25}
                    outerRadius={40}
                    paddingAngle={5}
                    dataKey="value"
                  >
                    <Cell fill={theme.palette.success.main} />
                    <Cell fill={theme.palette.error.main} />
                  </Pie>
                  <RechartsTooltip 
                    formatter={(value, name) => [value.toLocaleString(), name]}
                  />
                </PieChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>

        {/* React Query ìºì‹œ */}
        <Grid item xs={12} md={6} lg={3}>
          <Paper sx={statCardStyle}>
            <Box sx={{ 
              ...iconStyle, 
              bgcolor: 'rgba(0, 150, 136, 0.1)', 
              color: 'info.main' 
            }}>
              <QueryStatsIcon fontSize="large" />
            </Box>
            <Typography variant="h6" sx={{ fontWeight: 600, mb: 1 }}>
              React Query ìºì‹œ
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              ì´ ì¿¼ë¦¬ ìˆ˜: {queryCache.length}
            </Typography>
            <Typography variant="body2" color="text.secondary" gutterBottom>
              í™œì„± ì¿¼ë¦¬: {queryCache.filter(q => q.isActive).length}
            </Typography>
            <Typography variant="body2" color="text.secondary">
              ì˜¤ë˜ëœ ì¿¼ë¦¬: {queryCache.filter(q => q.isStale).length}
            </Typography>
            
            <Box sx={{ mt: 2, height: 100 }}>
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={queryStatusData}
                    cx="50%"
                    cy="50%"
                    innerRadius={25}
                    outerRadius={40}
                    paddingAngle={5}
                    dataKey="value"
                  >
                    {queryStatusData.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={colors[index % colors.length]} />
                    ))}
                  </Pie>
                  <RechartsTooltip 
                    formatter={(value, name) => [value, name]}
                  />
                </PieChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
};

export default CacheDashboard;



============================================================
File: /home/CVEHub/frontend/src/features/cache/components/RedisOverview.jsx
------------------------------------------------------------
import React from 'react';
import { 
  Box, 
  Grid, 
  Paper, 
  Typography, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Divider,
  useTheme,
  Chip,
  LinearProgress,
  Tooltip
} from '@mui/material';
import { 
  AreaChart, 
  Area, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip as RechartsTooltip, 
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
  Legend
} from 'recharts';

/**
 * Redis ì„œë²„ ê°œìš” ì»´í¬ë„ŒíŠ¸
 * @param {Object} props ì»´í¬ë„ŒíŠ¸ ì†ì„±
 * @param {Object} props.cacheInfo Redis ì„œë²„ ì •ë³´
 * @param {Object} props.cacheStats Redis ìºì‹œ í†µê³„
 */
const RedisOverview = ({ cacheInfo, cacheStats }) => {
  const theme = useTheme();
  
  // ìƒ‰ìƒ íŒ”ë ˆíŠ¸
  const colors = [
    theme.palette.primary.main,
    theme.palette.secondary.main,
    theme.palette.success.main,
    theme.palette.warning.main,
    theme.palette.error.main,
    theme.palette.info.main,
  ];
  
  // ëª…ë ¹ì–´ í†µê³„ ë°ì´í„°
  const commandStatsData = Object.entries(cacheStats.commandstats || {})
    .map(([cmd, stats]) => ({
      name: cmd.replace('cmdstat_', ''),
      calls: stats.calls,
      usec: stats.usec,
      usec_per_call: stats.usec_per_call,
    }))
    .sort((a, b) => b.calls - a.calls)
    .slice(0, 10);
  
  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë°ì´í„°
  const memoryData = [
    { name: 'ì‚¬ìš© ë©”ëª¨ë¦¬', value: cacheInfo.used_memory },
    { name: 'í”¼í¬ ë©”ëª¨ë¦¬', value: cacheInfo.used_memory_peak },
    { name: 'RSS ë©”ëª¨ë¦¬', value: cacheInfo.used_memory_rss },
    { name: 'Lua ë©”ëª¨ë¦¬', value: cacheInfo.used_memory_lua },
  ];
  
  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì°¨íŠ¸ ë°ì´í„°
  const memoryChartData = [
    { name: 'í˜„ì¬', ì‚¬ìš©: parseFloat((cacheInfo.used_memory / (1024 * 1024)).toFixed(2)) },
    { name: 'í”¼í¬', ì‚¬ìš©: parseFloat((cacheInfo.used_memory_peak / (1024 * 1024)).toFixed(2)) },
    { name: 'RSS', ì‚¬ìš©: parseFloat((cacheInfo.used_memory_rss / (1024 * 1024)).toFixed(2)) },
    { name: 'Lua', ì‚¬ìš©: parseFloat((cacheInfo.used_memory_lua / (1024 * 1024)).toFixed(2)) },
  ];
  
  // í‚¤ íƒ€ì… ë°ì´í„°
  const keyTypesData = Object.entries(cacheStats.key_types || {})
    .map(([type, count], index) => ({
      name: type,
      value: count,
      color: colors[index % colors.length]
    }));
  
  // í‚¤ ë§Œë£Œ ë°ì´í„°
  const keyExpiryData = [
    { name: 'ë§Œë£Œ ì„¤ì •ë¨', value: cacheStats.expires || 0 },
    { name: 'ë§Œë£Œ ì—†ìŒ', value: (cacheStats.keys || 0) - (cacheStats.expires || 0) },
  ];
  
  // ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
  const memoryUsagePercent = cacheInfo.used_memory_peak > 0 
    ? (cacheInfo.used_memory / cacheInfo.used_memory_peak) * 100 
    : 0;
  
  // ì„œë²„ ì •ë³´ í•­ëª©
  const serverInfoItems = [
    { label: 'Redis ë²„ì „', value: cacheInfo.redis_version },
    { label: 'ìš´ì˜ ëª¨ë“œ', value: cacheInfo.redis_mode },
    { label: 'í”„ë¡œì„¸ìŠ¤ ID', value: cacheInfo.process_id },
    { label: 'TCP í¬íŠ¸', value: cacheInfo.tcp_port },
    { label: 'ì—…íƒ€ì„', value: `${Math.floor(cacheInfo.uptime_in_seconds / 86400)}ì¼ ${Math.floor((cacheInfo.uptime_in_seconds % 86400) / 3600)}ì‹œê°„` },
    { label: 'ì—°ê²° í´ë¼ì´ì–¸íŠ¸', value: cacheInfo.connected_clients },
    { label: 'ê±°ë¶€ëœ ì—°ê²°', value: cacheInfo.rejected_connections },
    { label: 'ì‹¤í–‰ ëª…ë ¹ì–´', value: cacheInfo.total_commands_processed?.toLocaleString() },
    { label: 'í‚¤ìŠ¤í˜ì´ìŠ¤ íˆíŠ¸', value: cacheStats.keyspace_hits?.toLocaleString() },
    { label: 'í‚¤ìŠ¤í˜ì´ìŠ¤ ë¯¸ìŠ¤', value: cacheStats.keyspace_misses?.toLocaleString() },
  ];
  
  // ë©”ëª¨ë¦¬ ì •ë³´ í•­ëª©
  const memoryInfoItems = [
    { label: 'ì‚¬ìš© ë©”ëª¨ë¦¬', value: `${(cacheInfo.used_memory / (1024 * 1024)).toFixed(2)} MB` },
    { label: 'í”¼í¬ ë©”ëª¨ë¦¬', value: `${(cacheInfo.used_memory_peak / (1024 * 1024)).toFixed(2)} MB` },
    { label: 'RSS ë©”ëª¨ë¦¬', value: `${(cacheInfo.used_memory_rss / (1024 * 1024)).toFixed(2)} MB` },
    { label: 'Lua ë©”ëª¨ë¦¬', value: `${(cacheInfo.used_memory_lua / (1024 * 1024)).toFixed(2)} MB` },
    { label: 'ë©”ëª¨ë¦¬ ë‹¨í¸í™” ë¹„ìœ¨', value: cacheInfo.mem_fragmentation_ratio?.toFixed(2) || 'N/A' },
    { label: 'ë©”ëª¨ë¦¬ í• ë‹¹ì', value: cacheInfo.mem_allocator || 'N/A' },
  ];
  
  // í†µê³„ ì •ë³´ í•­ëª©
  const statsInfoItems = [
    { label: 'ì´ í‚¤ ê°œìˆ˜', value: cacheStats.keys?.toLocaleString() || 0 },
    { label: 'ë§Œë£Œ ì„¤ì •ëœ í‚¤', value: cacheStats.expires?.toLocaleString() || 0 },
    { label: 'ë§Œë£Œëœ í‚¤', value: cacheStats.expired_keys?.toLocaleString() || 0 },
    { label: 'ì œê±°ëœ í‚¤', value: cacheStats.evicted_keys?.toLocaleString() || 0 },
    { label: 'íˆíŠ¸ìœ¨', value: `${((cacheStats.keyspace_hits / (cacheStats.keyspace_hits + cacheStats.keyspace_misses || 1)) * 100).toFixed(2)}%` },
    { label: 'ì´ˆë‹¹ ëª…ë ¹ì–´ ì²˜ë¦¬', value: (cacheInfo.instantaneous_ops_per_sec || 0).toLocaleString() },
  ];

  return (
    <Box>
      <Grid container spacing={4}>
        {/* ì„œë²„ ì •ë³´ ë° í‚¤ íƒ€ì… ë¶„í¬ */}
        <Grid item xs={12} lg={6}>
          <Paper 
            elevation={0} 
            sx={{ 
              p: 3, 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%'
            }}
          >
            <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
              ì„œë²„ ì •ë³´
            </Typography>
            
            <Grid container spacing={2}>
              {serverInfoItems.map((item, index) => (
                <Grid item xs={6} key={index}>
                  <Box sx={{ mb: 2 }}>
                    <Typography variant="body2" color="text.secondary">
                      {item.label}
                    </Typography>
                    <Typography variant="body1" sx={{ fontWeight: 500 }}>
                      {item.value}
                    </Typography>
                  </Box>
                </Grid>
              ))}
            </Grid>
            
            <Divider sx={{ my: 3 }} />
            
            <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
              í‚¤ íƒ€ì… ë¶„í¬
            </Typography>
            
            <Box sx={{ height: 300 }}>
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={keyTypesData}
                    cx="50%"
                    cy="50%"
                    labelLine={true}
                    outerRadius={100}
                    fill="#8884d8"
                    dataKey="value"
                    label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                  >
                    {keyTypesData.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={entry.color} />
                    ))}
                  </Pie>
                  <RechartsTooltip 
                    formatter={(value, name) => [value, name]}
                  />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>
        
        {/* ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë° í‚¤ ë§Œë£Œ */}
        <Grid item xs={12} lg={6}>
          <Paper 
            elevation={0} 
            sx={{ 
              p: 3, 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%'
            }}
          >
            <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
              ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰
            </Typography>
            
            <Box sx={{ mb: 4 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                <Typography variant="body2">
                  ì‚¬ìš© ë©”ëª¨ë¦¬ / í”¼í¬ ë©”ëª¨ë¦¬
                </Typography>
                <Typography variant="body2" fontWeight={600}>
                  {memoryUsagePercent.toFixed(2)}%
                </Typography>
              </Box>
              <LinearProgress 
                variant="determinate" 
                value={memoryUsagePercent} 
                sx={{ 
                  height: 10, 
                  borderRadius: 5,
                  bgcolor: 'rgba(0, 0, 0, 0.05)',
                  '& .MuiLinearProgress-bar': {
                    borderRadius: 5,
                    background: `linear-gradient(90deg, ${theme.palette.primary.main} 0%, ${theme.palette.secondary.main} 100%)`,
                  }
                }}
              />
            </Box>
            
            <Box sx={{ height: 200, mb: 4 }}>
              <ResponsiveContainer width="100%" height="100%">
                <AreaChart
                  data={memoryChartData}
                  margin={{ top: 10, right: 30, left: 0, bottom: 0 }}
                >
                  <CartesianGrid strokeDasharray="3 3" stroke="rgba(0,0,0,0.1)" />
                  <XAxis dataKey="name" />
                  <YAxis unit=" MB" />
                  <RechartsTooltip formatter={(value) => [`${value} MB`, 'ë©”ëª¨ë¦¬']} />
                  <Area 
                    type="monotone" 
                    dataKey="ì‚¬ìš©" 
                    stroke={theme.palette.primary.main} 
                    fill={`${theme.palette.primary.main}40`} 
                  />
                </AreaChart>
              </ResponsiveContainer>
            </Box>
            
            <Divider sx={{ my: 3 }} />
            
            <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
              í‚¤ ë§Œë£Œ ìƒíƒœ
            </Typography>
            
            <Box sx={{ height: 200 }}>
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={keyExpiryData}
                    cx="50%"
                    cy="50%"
                    innerRadius={60}
                    outerRadius={80}
                    fill="#8884d8"
                    paddingAngle={5}
                    dataKey="value"
                  >
                    <Cell fill={theme.palette.warning.main} />
                    <Cell fill={theme.palette.info.main} />
                  </Pie>
                  <RechartsTooltip 
                    formatter={(value, name) => [value, name]}
                  />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            </Box>
          </Paper>
        </Grid>
        
        {/* ëª…ë ¹ì–´ í†µê³„ */}
        <Grid item xs={12}>
          <Paper 
            elevation={0} 
            sx={{ 
              p: 3, 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)'
            }}
          >
            <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
              ìƒìœ„ ëª…ë ¹ì–´ í†µê³„
            </Typography>
            
            <TableContainer>
              <Table sx={{ minWidth: 650 }} size="medium">
                <TableHead>
                  <TableRow>
                    <TableCell>ëª…ë ¹ì–´</TableCell>
                    <TableCell align="right">í˜¸ì¶œ íšŸìˆ˜</TableCell>
                    <TableCell align="right">ì´ ì†Œìš” ì‹œê°„ (Î¼s)</TableCell>
                    <TableCell align="right">í˜¸ì¶œë‹¹ í‰ê·  ì‹œê°„ (Î¼s)</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {commandStatsData.map((row, index) => (
                    <TableRow
                      key={row.name}
                      sx={{ '&:last-child td, &:last-child th': { border: 0 } }}
                    >
                      <TableCell component="th" scope="row">
                        <Chip 
                          label={row.name} 
                          size="small" 
                          sx={{ 
                            bgcolor: `${colors[index % colors.length]}20`,
                            color: colors[index % colors.length],
                            fontWeight: 500
                          }} 
                        />
                      </TableCell>
                      <TableCell align="right">{row.calls.toLocaleString()}</TableCell>
                      <TableCell align="right">{row.usec.toLocaleString()}</TableCell>
                      <TableCell align="right">{row.usec_per_call.toFixed(2)}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          </Paper>
        </Grid>
      </Grid>
    </Box>
  );
};

export default RedisOverview;



============================================================
File: /home/CVEHub/frontend/src/features/cache/components/ReactQueryViewer.jsx
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Paper, 
  Typography, 
  TextField, 
  InputAdornment,
  Divider,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Chip,
  useTheme,
  Tooltip,
  IconButton,
  Button,
  CircularProgress,
  Grid,
  Card,
  CardContent,
  Tabs,
  Tab,
  Alert
} from '@mui/material';
import { 
  Search as SearchIcon, 
  ExpandMore as ExpandMoreIcon,
  ContentCopy as CopyIcon,
  Refresh as RefreshIcon,
  DeleteOutline as DeleteIcon,
  DataUsage as DataUsageIcon,
  QueryStats as QueryStatsIcon,
  Cached as CachedIcon,
  AccessTime as AccessTimeIcon
} from '@mui/icons-material';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';
import { useReactQueryCache } from 'features/cache/hooks/useCacheQuery';

/**
 * React Query ìºì‹œ ë·°ì–´ ì»´í¬ë„ŒíŠ¸
 * @param {Object} props ì»´í¬ë„ŒíŠ¸ ì†ì„±
 * @param {Array} props.queryCache React Query ìºì‹œ ì •ë³´
 */
const ReactQueryViewer = ({ queryCache }) => {
  const theme = useTheme();
  const [searchTerm, setSearchTerm] = useState('');
  const [activeTab, setActiveTab] = useState('all');
  const { queryClient } = useReactQueryCache();
  
  // í•„í„°ë§ëœ ì¿¼ë¦¬ ìºì‹œ
  const filteredQueries = queryCache.filter(query => {
    const matchesSearch = searchTerm === '' || 
      query.queryKey.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesTab = activeTab === 'all' || 
      (activeTab === 'active' && query.isActive) ||
      (activeTab === 'stale' && query.isStale) ||
      (activeTab === 'inactive' && !query.isActive);
    
    return matchesSearch && matchesTab;
  });
  
  // ê²€ìƒ‰ì–´ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleSearchChange = (e) => {
    setSearchTerm(e.target.value);
  };
  
  // íƒ­ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  
  // ì¿¼ë¦¬ ë¬´íš¨í™” í•¸ë“¤ëŸ¬
  const handleInvalidateQuery = (queryKey) => {
    try {
      const parsedKey = JSON.parse(queryKey);
      queryClient.invalidateQueries({ queryKey: parsedKey });
    } catch (error) {
      console.error('ì¿¼ë¦¬ ë¬´íš¨í™” ì‹¤íŒ¨:', error);
    }
  };
  
  // ì¿¼ë¦¬ ì‚­ì œ í•¸ë“¤ëŸ¬
  const handleRemoveQuery = (queryKey) => {
    try {
      const parsedKey = JSON.parse(queryKey);
      queryClient.removeQueries({ queryKey: parsedKey });
    } catch (error) {
      console.error('ì¿¼ë¦¬ ì‚­ì œ ì‹¤íŒ¨:', error);
    }
  };
  
  // ëª¨ë“  ì¿¼ë¦¬ ë¬´íš¨í™” í•¸ë“¤ëŸ¬
  const handleInvalidateAll = () => {
    queryClient.invalidateQueries();
  };
  
  // ëª¨ë“  ì¿¼ë¦¬ ì‚­ì œ í•¸ë“¤ëŸ¬
  const handleClearAll = () => {
    queryClient.clear();
  };
  
  // ì¿¼ë¦¬ ìƒíƒœì— ë”°ë¥¸ ìƒ‰ìƒ
  const getStatusColor = (query) => {
    if (!query.isActive) return theme.palette.grey[500];
    if (query.isStale) return theme.palette.warning.main;
    return theme.palette.success.main;
  };
  
  // ì¿¼ë¦¬ ìƒíƒœ ë ˆì´ë¸”
  const getStatusLabel = (query) => {
    if (!query.isActive) return 'ë¹„í™œì„±';
    if (query.isStale) return 'ì˜¤ë˜ë¨';
    return 'í™œì„±';
  };
  
  // ì¿¼ë¦¬ í‚¤ í¬ë§·íŒ…
  const formatQueryKey = (queryKey) => {
    try {
      const parsedKey = JSON.parse(queryKey);
      if (Array.isArray(parsedKey)) {
        return parsedKey.map(item => 
          typeof item === 'object' ? JSON.stringify(item) : String(item)
        ).join(' / ');
      } 
      return typeof parsedKey === 'object' ? JSON.stringify(parsedKey) : String(parsedKey);
    } catch (error) {
      return queryKey;
    }
  };
  
  // í†µê³„ ë°ì´í„°
  const stats = {
    total: queryCache.length,
    active: queryCache.filter(q => q.isActive).length,
    stale: queryCache.filter(q => q.isStale).length,
    inactive: queryCache.filter(q => !q.isActive).length,
  };

  return (
    <Box>
      {/* í†µê³„ ì¹´ë“œ */}
      <Grid container spacing={3} sx={{ mb: 4 }}>
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            elevation={0}
            sx={{ 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%',
              transition: 'transform 0.3s',
              '&:hover': {
                transform: 'translateY(-5px)',
              }
            }}
          >
            <CardContent sx={{ p: 3 }}>
              <Box 
                sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2 
                }}
              >
                <Box 
                  sx={{ 
                    bgcolor: `${theme.palette.primary.main}20`, 
                    color: theme.palette.primary.main,
                    borderRadius: '50%',
                    p: 1,
                    mr: 2,
                    display: 'flex'
                  }}
                >
                  <QueryStatsIcon />
                </Box>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  ì´ ì¿¼ë¦¬
                </Typography>
              </Box>
              <Typography variant="h4" sx={{ fontWeight: 700, mb: 1 }}>
                {stats.total}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                React Query ìºì‹œì— ì €ì¥ëœ ì´ ì¿¼ë¦¬ ìˆ˜
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            elevation={0}
            sx={{ 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%',
              transition: 'transform 0.3s',
              '&:hover': {
                transform: 'translateY(-5px)',
              }
            }}
          >
            <CardContent sx={{ p: 3 }}>
              <Box 
                sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2 
                }}
              >
                <Box 
                  sx={{ 
                    bgcolor: `${theme.palette.success.main}20`, 
                    color: theme.palette.success.main,
                    borderRadius: '50%',
                    p: 1,
                    mr: 2,
                    display: 'flex'
                  }}
                >
                  <CachedIcon />
                </Box>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  í™œì„± ì¿¼ë¦¬
                </Typography>
              </Box>
              <Typography variant="h4" sx={{ fontWeight: 700, mb: 1 }}>
                {stats.active}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                í˜„ì¬ í™œì„± ìƒíƒœì¸ ì¿¼ë¦¬ ìˆ˜
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            elevation={0}
            sx={{ 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%',
              transition: 'transform 0.3s',
              '&:hover': {
                transform: 'translateY(-5px)',
              }
            }}
          >
            <CardContent sx={{ p: 3 }}>
              <Box 
                sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2 
                }}
              >
                <Box 
                  sx={{ 
                    bgcolor: `${theme.palette.warning.main}20`, 
                    color: theme.palette.warning.main,
                    borderRadius: '50%',
                    p: 1,
                    mr: 2,
                    display: 'flex'
                  }}
                >
                  <DataUsageIcon />
                </Box>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  ì˜¤ë˜ëœ ì¿¼ë¦¬
                </Typography>
              </Box>
              <Typography variant="h4" sx={{ fontWeight: 700, mb: 1 }}>
                {stats.stale}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                ì˜¤ë˜ëœ(stale) ìƒíƒœì¸ ì¿¼ë¦¬ ìˆ˜
              </Typography>
            </CardContent>
          </Card>
        </Grid>
        
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            elevation={0}
            sx={{ 
              borderRadius: 2, 
              boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
              height: '100%',
              transition: 'transform 0.3s',
              '&:hover': {
                transform: 'translateY(-5px)',
              }
            }}
          >
            <CardContent sx={{ p: 3 }}>
              <Box 
                sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2 
                }}
              >
                <Box 
                  sx={{ 
                    bgcolor: `${theme.palette.grey[500]}20`, 
                    color: theme.palette.grey[500],
                    borderRadius: '50%',
                    p: 1,
                    mr: 2,
                    display: 'flex'
                  }}
                >
                  <AccessTimeIcon />
                </Box>
                <Typography variant="h6" sx={{ fontWeight: 600 }}>
                  ë¹„í™œì„± ì¿¼ë¦¬
                </Typography>
              </Box>
              <Typography variant="h4" sx={{ fontWeight: 700, mb: 1 }}>
                {stats.inactive}
              </Typography>
              <Typography variant="body2" color="text.secondary">
                ë¹„í™œì„± ìƒíƒœì¸ ì¿¼ë¦¬ ìˆ˜
              </Typography>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
      
      {/* ê²€ìƒ‰ ë° í•„í„° */}
      <Paper 
        elevation={0} 
        sx={{ 
          p: 3, 
          borderRadius: 2, 
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
          mb: 4
        }}
      >
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
          <Typography variant="h6" sx={{ fontWeight: 600 }}>
            React Query ìºì‹œ ê´€ë¦¬
          </Typography>
          
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button 
              variant="outlined" 
              color="warning" 
              startIcon={<RefreshIcon />}
              onClick={handleInvalidateAll}
              size="small"
            >
              ëª¨ë‘ ë¬´íš¨í™”
            </Button>
            <Button 
              variant="outlined" 
              color="error" 
              startIcon={<DeleteIcon />}
              onClick={handleClearAll}
              size="small"
            >
              ëª¨ë‘ ì‚­ì œ
            </Button>
          </Box>
        </Box>
        
        <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
          <TextField
            fullWidth
            placeholder="ì¿¼ë¦¬ í‚¤ ê²€ìƒ‰..."
            value={searchTerm}
            onChange={handleSearchChange}
            variant="outlined"
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
          />
        </Box>
        
        <Tabs 
          value={activeTab} 
          onChange={handleTabChange}
          sx={{
            borderBottom: 1,
            borderColor: 'divider',
            mb: 2,
            '& .MuiTab-root': {
              minWidth: 100,
              fontWeight: 600,
            },
          }}
        >
          <Tab 
            value="all" 
            label={`ì „ì²´ (${stats.total})`} 
          />
          <Tab 
            value="active" 
            label={`í™œì„± (${stats.active})`} 
            sx={{ color: theme.palette.success.main }}
          />
          <Tab 
            value="stale" 
            label={`ì˜¤ë˜ë¨ (${stats.stale})`} 
            sx={{ color: theme.palette.warning.main }}
          />
          <Tab 
            value="inactive" 
            label={`ë¹„í™œì„± (${stats.inactive})`} 
            sx={{ color: theme.palette.grey[500] }}
          />
        </Tabs>
      </Paper>
      
      {/* ì¿¼ë¦¬ ëª©ë¡ */}
      {filteredQueries.length === 0 ? (
        <Alert severity="info">
          ê²€ìƒ‰ ì¡°ê±´ì— ë§ëŠ” ì¿¼ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.
        </Alert>
      ) : (
        filteredQueries.map((query) => (
          <Accordion 
            key={query.queryHash} 
            sx={{ 
              mb: 2, 
              boxShadow: '0 2px 8px rgba(0, 0, 0, 0.05)',
              borderRadius: '8px !important',
              '&:before': {
                display: 'none',
              },
              overflow: 'hidden'
            }}
          >
            <AccordionSummary
              expandIcon={<ExpandMoreIcon />}
              aria-controls={`panel-${query.queryHash}-content`}
              id={`panel-${query.queryHash}-header`}
              sx={{ 
                bgcolor: 'background.default',
                borderBottom: '1px solid',
                borderColor: 'divider'
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                <Box 
                  sx={{ 
                    width: 12, 
                    height: 12, 
                    borderRadius: '50%', 
                    bgcolor: getStatusColor(query),
                    mr: 2
                  }} 
                />
                
                <Box sx={{ flexGrow: 1 }}>
                  <Typography variant="body1" sx={{ fontWeight: 500 }}>
                    {formatQueryKey(query.queryKey)}
                  </Typography>
                  
                  <Box sx={{ display: 'flex', alignItems: 'center', mt: 0.5 }}>
                    <Chip 
                      label={getStatusLabel(query)} 
                      size="small" 
                      sx={{ 
                        mr: 1,
                        bgcolor: `${getStatusColor(query)}20`,
                        color: getStatusColor(query),
                        fontWeight: 500,
                        fontSize: '0.7rem'
                      }} 
                    />
                    
                    <Typography variant="caption" color="text.secondary">
                      ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {query.lastUpdated}
                    </Typography>
                  </Box>
                </Box>
                
                <Box sx={{ display: 'flex' }}>
                  <Tooltip title="ì¿¼ë¦¬ ë¬´íš¨í™”">
                    <IconButton 
                      size="small" 
                      onClick={(e) => {
                        e.stopPropagation();
                        handleInvalidateQuery(query.queryKey);
                      }}
                      sx={{ color: theme.palette.warning.main }}
                    >
                      <RefreshIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                  
                  <Tooltip title="ì¿¼ë¦¬ ì‚­ì œ">
                    <IconButton 
                      size="small" 
                      onClick={(e) => {
                        e.stopPropagation();
                        handleRemoveQuery(query.queryKey);
                      }}
                      sx={{ color: theme.palette.error.main }}
                    >
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </Box>
              </Box>
            </AccordionSummary>
            <AccordionDetails sx={{ p: 0 }}>
              <Box sx={{ p: 2 }}>
                <Grid container spacing={2}>
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle2" sx={{ mb: 1, fontWeight: 600 }}>
                      ì¿¼ë¦¬ í‚¤
                    </Typography>
                    <Paper 
                      variant="outlined" 
                      sx={{ 
                        p: 2, 
                        borderRadius: 1, 
                        bgcolor: 'background.default',
                        maxHeight: 200,
                        overflow: 'auto'
                      }}
                    >
                      <SyntaxHighlighter
                        language="json"
                        style={vscDarkPlus}
                        customStyle={{ 
                          borderRadius: 8,
                          fontSize: '0.85rem',
                          background: 'transparent',
                          margin: 0
                        }}
                      >
                        {query.queryKey}
                      </SyntaxHighlighter>
                    </Paper>
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <Typography variant="subtitle2" sx={{ mb: 1, fontWeight: 600 }}>
                      ìƒíƒœ ì •ë³´
                    </Typography>
                    <Paper 
                      variant="outlined" 
                      sx={{ 
                        p: 2, 
                        borderRadius: 1, 
                        bgcolor: 'background.default',
                        height: '100%'
                      }}
                    >
                      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                          <Typography variant="body2" color="text.secondary">
                            ìƒíƒœ:
                          </Typography>
                          <Chip 
                            label={getStatusLabel(query)} 
                            size="small" 
                            sx={{ 
                              bgcolor: `${getStatusColor(query)}20`,
                              color: getStatusColor(query),
                              fontWeight: 500,
                              fontSize: '0.7rem'
                            }} 
                          />
                        </Box>
                        
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                          <Typography variant="body2" color="text.secondary">
                            í™œì„± ì—¬ë¶€:
                          </Typography>
                          <Typography variant="body2">
                            {query.isActive ? 'í™œì„±' : 'ë¹„í™œì„±'}
                          </Typography>
                        </Box>
                        
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                          <Typography variant="body2" color="text.secondary">
                            ì˜¤ë˜ë¨ ì—¬ë¶€:
                          </Typography>
                          <Typography variant="body2">
                            {query.isStale ? 'ì˜¤ë˜ë¨' : 'ìµœì‹ '}
                          </Typography>
                        </Box>
                        
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                          <Typography variant="body2" color="text.secondary">
                            ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸:
                          </Typography>
                          <Typography variant="body2">
                            {query.lastUpdated}
                          </Typography>
                        </Box>
                        
                        <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                          <Typography variant="body2" color="text.secondary">
                            ì¿¼ë¦¬ í•´ì‹œ:
                          </Typography>
                          <Typography variant="body2" sx={{ maxWidth: 200, overflow: 'hidden', textOverflow: 'ellipsis' }}>
                            {query.queryHash}
                          </Typography>
                        </Box>
                      </Box>
                    </Paper>
                  </Grid>
                  
                  <Grid item xs={12}>
                    <Typography variant="subtitle2" sx={{ mb: 1, fontWeight: 600 }}>
                      ë°ì´í„°
                    </Typography>
                    <Paper 
                      variant="outlined" 
                      sx={{ 
                        p: 2, 
                        borderRadius: 1, 
                        bgcolor: 'background.default',
                        maxHeight: 300,
                        overflow: 'auto'
                      }}
                    >
                      <SyntaxHighlighter
                        language="json"
                        style={vscDarkPlus}
                        customStyle={{ 
                          borderRadius: 8,
                          fontSize: '0.85rem',
                          background: 'transparent',
                          margin: 0
                        }}
                      >
                        {JSON.stringify(query.state.data || {}, null, 2)}
                      </SyntaxHighlighter>
                    </Paper>
                  </Grid>
                </Grid>
              </Box>
            </AccordionDetails>
          </Accordion>
        ))
      )}
    </Box>
  );
};

export default ReactQueryViewer;



============================================================
File: /home/CVEHub/frontend/src/features/cache/components/RedisValuesViewer.jsx
------------------------------------------------------------
import React, { useState } from 'react';
import { 
  Box, 
  Paper, 
  Typography, 
  TextField, 
  Button, 
  IconButton,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  InputAdornment,
  Divider,
  CircularProgress,
  Alert,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Chip,
  useTheme,
  Tooltip,
  Tabs,
  Tab
} from '@mui/material';
import { 
  Search as SearchIcon, 
  Refresh as RefreshIcon,
  ExpandMore as ExpandMoreIcon,
  ContentCopy as CopyIcon,
  Code as CodeIcon,
  DataObject as DataObjectIcon,
  FormatListBulleted as ListIcon,
  TextFields as TextIcon
} from '@mui/icons-material';
import { useCacheValuesQuery } from '../hooks/useCacheQuery';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism';

/**
 * Redis ê°’ ë·°ì–´ ì»´í¬ë„ŒíŠ¸
 */
const RedisValuesViewer = () => {
  const theme = useTheme();
  const [searchParams, setSearchParams] = useState({
    prefix: '',
    pattern: '*',
    limit: 20
  });
  const [viewMode, setViewMode] = useState('formatted');
  
  // ìºì‹œ ê°’ ì¡°íšŒ
  const { 
    data: valuesData, 
    isLoading, 
    isError, 
    error, 
    refetch 
  } = useCacheValuesQuery(searchParams);
  
  // ê²€ìƒ‰ íŒŒë¼ë¯¸í„° ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleSearchParamChange = (e) => {
    const { name, value } = e.target;
    setSearchParams(prev => ({ ...prev, [name]: value }));
  };
  
  // ê²€ìƒ‰ í•¸ë“¤ëŸ¬
  const handleSearch = () => {
    refetch();
  };
  
  // ê°’ ë³µì‚¬ í•¸ë“¤ëŸ¬
  const handleCopyValue = (value) => {
    navigator.clipboard.writeText(typeof value === 'object' ? JSON.stringify(value, null, 2) : value.toString());
  };
  
  // ë¬¸ìì—´ ë˜ëŠ” ê°ì²´ë¥¼ ì•ˆì „í•˜ê²Œ í‘œì‹œí•˜ëŠ” í•¨ìˆ˜
  const safeStringify = (value) => {
    if (value === null || value === undefined) {
      return String(value);
    }
    
    if (typeof value === 'object') {
      try {
        return JSON.stringify(value, null, 2);
      } catch (e) {
        return String(value);
      }
    }
    
    return String(value);
  };
  
  // ë·° ëª¨ë“œ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleViewModeChange = (event, newValue) => {
    setViewMode(newValue);
  };
  
  // ê°’ ë Œë”ë§ í•¨ìˆ˜
  const renderValue = (key, value, type) => {
    // ë¬¸ìì—´ì¸ ê²½ìš° JSON íŒŒì‹± ì‹œë„
    let parsedValue = value;
    let valueType = type;
    
    if (type === 'string' && typeof value === 'string') {
      try {
        const parsed = JSON.parse(value);
        if (typeof parsed === 'object') {
          parsedValue = parsed;
          valueType = 'json';
        }
      } catch (e) {
        // JSON íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì›ë˜ ê°’ ì‚¬ìš©
      }
    }
    
    // ë·° ëª¨ë“œì— ë”°ë¼ ë Œë”ë§
    if (viewMode === 'raw') {
      return (
        <SyntaxHighlighter
          language="json"
          style={vscDarkPlus}
          customStyle={{ 
            borderRadius: 8,
            fontSize: '0.85rem',
            maxHeight: 300
          }}
        >
          {typeof parsedValue === 'object' ? JSON.stringify(parsedValue, null, 2) : String(parsedValue)}
        </SyntaxHighlighter>
      );
    }
    
    // í¬ë§·íŒ…ëœ ë·°
    switch (valueType) {
      case 'json':
        return (
          <Box sx={{ 
            maxHeight: 300, 
            overflow: 'auto', 
            bgcolor: 'background.default', 
            borderRadius: 2,
            p: 2
          }}>
            <SyntaxHighlighter
              language="json"
              style={vscDarkPlus}
              customStyle={{ 
                borderRadius: 8,
                fontSize: '0.85rem',
                background: 'transparent'
              }}
            >
              {JSON.stringify(parsedValue, null, 2)}
            </SyntaxHighlighter>
          </Box>
        );
        
      case 'list':
        return (
          <Box sx={{ maxHeight: 300, overflow: 'auto' }}>
            {Array.isArray(parsedValue) && parsedValue.map((item, idx) => (
              <Box 
                key={idx} 
                sx={{ 
                  p: 1, 
                  borderBottom: '1px solid', 
                  borderColor: 'divider',
                  '&:last-child': { borderBottom: 'none' }
                }}
              >
                <Typography variant="body2">
                  {safeStringify(item)}
                </Typography>
              </Box>
            ))}
          </Box>
        );
        
      case 'hash':
        return (
          <Box sx={{ maxHeight: 300, overflow: 'auto' }}>
            {Object.entries(parsedValue).map(([field, val], idx) => (
              <Box 
                key={idx} 
                sx={{ 
                  p: 1, 
                  borderBottom: '1px solid', 
                  borderColor: 'divider',
                  '&:last-child': { borderBottom: 'none' },
                  display: 'flex'
                }}
              >
                <Typography variant="body2" sx={{ fontWeight: 600, minWidth: 120 }}>
                  {field}:
                </Typography>
                <Typography variant="body2">
                  {safeStringify(val)}
                </Typography>
              </Box>
            ))}
          </Box>
        );
        
      default:
        return (
          <Typography 
            variant="body2" 
            sx={{ 
              p: 2, 
              bgcolor: 'background.default', 
              borderRadius: 2,
              fontFamily: 'monospace',
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-all',
              maxHeight: 300,
              overflow: 'auto'
            }}
          >
            {safeStringify(parsedValue)}
          </Typography>
        );
    }
  };
  
  // ê°’ íƒ€ì…ì— ë”°ë¥¸ ì•„ì´ì½˜ ë° ìƒ‰ìƒ
  const getTypeIconAndColor = (type) => {
    switch (type) {
      case 'string':
        return { icon: <TextIcon />, color: theme.palette.primary.main };
      case 'list':
        return { icon: <ListIcon />, color: theme.palette.success.main };
      case 'hash':
        return { icon: <DataObjectIcon />, color: theme.palette.warning.main };
      case 'json':
        return { icon: <CodeIcon />, color: theme.palette.info.main };
      default:
        return { icon: <TextIcon />, color: theme.palette.grey[500] };
    }
  };

  return (
    <Box>
      <Paper 
        elevation={0} 
        sx={{ 
          p: 3, 
          borderRadius: 2, 
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
          mb: 4
        }}
      >
        <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
          Redis ê°’ ì¡°íšŒ
        </Typography>
        
        <Box sx={{ display: 'flex', flexDirection: { xs: 'column', md: 'row' }, gap: 2, mb: 3 }}>
          <TextField
            name="prefix"
            label="ì ‘ë‘ì‚¬"
            variant="outlined"
            value={searchParams.prefix}
            onChange={handleSearchParamChange}
            placeholder="ì˜ˆ: user"
            sx={{ width: { xs: '100%', md: 200 } }}
          />
          
          <TextField
            name="pattern"
            label="ê²€ìƒ‰ íŒ¨í„´"
            variant="outlined"
            value={searchParams.pattern}
            onChange={handleSearchParamChange}
            placeholder="ì˜ˆ: *"
            fullWidth
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
          />
          
          <TextField
            name="limit"
            label="ìµœëŒ€ ê²°ê³¼ ìˆ˜"
            variant="outlined"
            type="number"
            value={searchParams.limit}
            onChange={handleSearchParamChange}
            sx={{ width: { xs: '100%', md: 150 } }}
          />
          
          <Button 
            variant="contained" 
            onClick={handleSearch}
            startIcon={<SearchIcon />}
            sx={{ 
              height: 56,
              px: 4,
              background: `linear-gradient(90deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.dark} 100%)`,
              boxShadow: '0 4px 10px rgba(0, 0, 0, 0.1)',
              '&:hover': {
                boxShadow: '0 6px 15px rgba(0, 0, 0, 0.2)',
              }
            }}
          >
            ì¡°íšŒ
          </Button>
          
          <IconButton 
            color="primary" 
            onClick={refetch}
            sx={{ height: 56, width: 56 }}
          >
            <RefreshIcon />
          </IconButton>
        </Box>
        
        <Divider sx={{ my: 3 }} />
        
        <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
          <Tabs 
            value={viewMode} 
            onChange={handleViewModeChange}
            sx={{
              '& .MuiTab-root': {
                minWidth: 100,
                fontWeight: 600,
              },
            }}
          >
            <Tab 
              value="formatted" 
              label="í¬ë§·íŒ…" 
              icon={<DataObjectIcon />} 
              iconPosition="start"
            />
            <Tab 
              value="raw" 
              label="ì›ì‹œ ë°ì´í„°" 
              icon={<CodeIcon />} 
              iconPosition="start"
            />
          </Tabs>
        </Box>
      </Paper>
      
      {isLoading ? (
        <Box 
          sx={{ 
            display: 'flex', 
            justifyContent: 'center', 
            alignItems: 'center', 
            height: 200 
          }}
        >
          <CircularProgress size={40} thickness={4} />
          <Typography variant="body2" sx={{ ml: 2, color: 'text.secondary' }}>
            ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
          </Typography>
        </Box>
      ) : isError ? (
        <Alert severity="error" sx={{ mb: 3 }}>
          ê°’ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}
        </Alert>
      ) : valuesData?.keys?.length === 0 ? (
        <Alert severity="info" sx={{ mb: 3 }}>
          ê²€ìƒ‰ ì¡°ê±´ì— ë§ëŠ” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.
        </Alert>
      ) : (
        <Box>
          {valuesData?.keys.map((key, index) => {
            const value = valuesData.values[index];
            const type = valuesData.types[index];
            const { icon, color } = getTypeIconAndColor(type);
            
            // í‚¤ ì ‘ë‘ì‚¬ ë¶„ë¦¬
            const keyParts = key.split(':');
            const keyPrefix = keyParts.length > 1 ? keyParts[0] : '';
            const keyDisplay = keyPrefix ? key.substring(keyPrefix.length + 1) : key;
            
            return (
              <Accordion 
                key={key} 
                sx={{ 
                  mb: 2, 
                  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.05)',
                  borderRadius: '8px !important',
                  '&:before': {
                    display: 'none',
                  },
                  overflow: 'hidden'
                }}
              >
                <AccordionSummary
                  expandIcon={<ExpandMoreIcon />}
                  aria-controls={`panel-${key}-content`}
                  id={`panel-${key}-header`}
                  sx={{ 
                    bgcolor: 'background.default',
                    borderBottom: '1px solid',
                    borderColor: 'divider'
                  }}
                >
                  <Box sx={{ display: 'flex', alignItems: 'center', width: '100%' }}>
                    <Box 
                      sx={{ 
                        mr: 2, 
                        color, 
                        display: 'flex', 
                        alignItems: 'center', 
                        justifyContent: 'center' 
                      }}
                    >
                      {icon}
                    </Box>
                    
                    <Box sx={{ flexGrow: 1 }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        {keyPrefix && (
                          <Chip 
                            label={keyPrefix} 
                            size="small" 
                            color="primary" 
                            variant="outlined"
                            sx={{ mr: 1, fontSize: '0.7rem' }}
                          />
                        )}
                        <Typography variant="body1" sx={{ fontWeight: 500 }}>
                          {keyDisplay}
                        </Typography>
                      </Box>
                      
                      <Typography variant="caption" color="text.secondary">
                        {type === 'string' && typeof value === 'string' && value.startsWith('{') ? 'json' : type}
                        {valuesData.ttls[index] !== -1 && ` â€¢ TTL: ${valuesData.ttls[index]}ì´ˆ`}
                      </Typography>
                    </Box>
                    
                    <Tooltip title="ê°’ ë³µì‚¬">
                      <IconButton 
                        size="small" 
                        onClick={(e) => {
                          e.stopPropagation();
                          handleCopyValue(value);
                        }}
                        sx={{ color: theme.palette.info.main }}
                      >
                        <CopyIcon fontSize="small" />
                      </IconButton>
                    </Tooltip>
                  </Box>
                </AccordionSummary>
                <AccordionDetails sx={{ p: 0 }}>
                  <Box sx={{ p: 2 }}>
                    {renderValue(key, value, type)}
                  </Box>
                </AccordionDetails>
              </Accordion>
            );
          })}
        </Box>
      )}
    </Box>
  );
};

export default RedisValuesViewer;



============================================================
File: /home/CVEHub/frontend/src/features/cache/components/RedisKeysList.jsx
------------------------------------------------------------
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Paper, 
  Typography, 
  TextField, 
  Button, 
  IconButton,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  TablePagination,
  InputAdornment,
  Chip,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogContentText,
  DialogActions,
  CircularProgress,
  Divider,
  useTheme,
  Alert,
  Snackbar,
  FormControl,
  InputLabel,
  Select,
  MenuItem
} from '@mui/material';
import { 
  Search as SearchIcon, 
  Delete as DeleteIcon, 
  Refresh as RefreshIcon,
  ContentCopy as CopyIcon,
  Visibility as ViewIcon,
  FilterList as FilterIcon
} from '@mui/icons-material';
import { useCacheKeysQuery, useClearCacheMutation } from '../hooks/useCacheQuery';

/**
 * Redis í‚¤ ëª©ë¡ ì»´í¬ë„ŒíŠ¸
 */
const RedisKeysList = () => {
  const theme = useTheme();
  const [searchParams, setSearchParams] = useState({
    prefix: '',
    pattern: '*',
    limit: 100
  });
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [openDialog, setOpenDialog] = useState(false);
  const [selectedKey, setSelectedKey] = useState(null);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' });
  const [prefixOptions, setPrefixOptions] = useState([]);
  
  // ìºì‹œ í‚¤ ëª©ë¡ ì¡°íšŒ
  const { 
    data: keysData, 
    isLoading, 
    isError, 
    error, 
    refetch 
  } = useCacheKeysQuery(searchParams);
  
  // ìºì‹œ ì‚­ì œ ë®¤í…Œì´ì…˜
  const clearCacheMutation = useClearCacheMutation();
  
  // í‚¤ ëª©ë¡ ë°ì´í„° ì¶”ì¶œ ë° ê°€ê³µ
  const keys = keysData?.keys || [];
  const processedKeys = keys.map(keyObj => {
    // í‚¤ ê°ì²´ì—ì„œ í•„ìš”í•œ ì •ë³´ ì¶”ì¶œ
    const keyValue = typeof keyObj === 'object' && keyObj.key ? keyObj.key : String(keyObj);
    return {
      key: keyValue,
      type: typeof keyObj === 'object' && keyObj.type ? keyObj.type : 'unknown',
      ttl: typeof keyObj === 'object' && keyObj.ttl !== undefined ? keyObj.ttl : -1,
      size: typeof keyObj === 'object' && keyObj.size !== undefined ? keyObj.size : 0
    };
  });
  
  // ì ‘ë‘ì‚¬ ì˜µì…˜ ì¶”ì¶œ
  useEffect(() => {
    if (processedKeys.length > 0) {
      const prefixes = new Set();
      processedKeys.forEach(keyObj => {
        const keyParts = keyObj.key.split(':');
        if (keyParts.length > 1) {
          prefixes.add(keyParts[0]);
        }
      });
      setPrefixOptions(Array.from(prefixes));
    }
  }, [processedKeys]);
  
  // í˜ì´ì§€ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };
  
  // í˜ì´ì§€ë‹¹ í–‰ ìˆ˜ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };
  
  // ê²€ìƒ‰ í•¸ë“¤ëŸ¬
  const handleSearch = () => {
    refetch();
  };
  
  // ê²€ìƒ‰ íŒŒë¼ë¯¸í„° ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleSearchParamChange = (e) => {
    const { name, value } = e.target;
    setSearchParams(prev => ({ ...prev, [name]: value }));
  };
  
  // í‚¤ ì‚­ì œ ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
  const handleOpenDeleteDialog = (key) => {
    setSelectedKey(key);
    setOpenDialog(true);
  };
  
  // í‚¤ ì‚­ì œ ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°
  const handleCloseDialog = () => {
    setOpenDialog(false);
  };
  
  // í‚¤ ì‚­ì œ ì‹¤í–‰
  const handleDeleteKey = async () => {
    try {
      await clearCacheMutation.mutateAsync({ pattern: selectedKey });
      setSnackbar({
        open: true,
        message: `í‚¤ '${selectedKey}'ê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`,
        severity: 'success'
      });
      handleCloseDialog();
    } catch (err) {
      setSnackbar({
        open: true,
        message: `í‚¤ ì‚­ì œ ì‹¤íŒ¨: ${err.message}`,
        severity: 'error'
      });
    }
  };
  
  // í‚¤ ë³µì‚¬ í•¸ë“¤ëŸ¬
  const handleCopyKey = (key) => {
    navigator.clipboard.writeText(key);
    setSnackbar({
      open: true,
      message: 'í‚¤ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.',
      severity: 'success'
    });
  };
  
  // ìŠ¤ë‚µë°” ë‹«ê¸° í•¸ë“¤ëŸ¬
  const handleCloseSnackbar = () => {
    setSnackbar(prev => ({ ...prev, open: false }));
  };
  
  // ì ‘ë‘ì‚¬ ì„ íƒ í•¸ë“¤ëŸ¬
  const handlePrefixSelect = (prefix) => {
    setSearchParams(prev => ({ ...prev, prefix }));
  };

  return (
    <Box>
      <Paper 
        elevation={0} 
        sx={{ 
          p: 3, 
          borderRadius: 2, 
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
          mb: 4
        }}
      >
        <Typography variant="h6" sx={{ mb: 3, fontWeight: 600 }}>
          Redis í‚¤ ê²€ìƒ‰
        </Typography>
        
        <Box sx={{ display: 'flex', flexDirection: { xs: 'column', md: 'row' }, gap: 2, mb: 3 }}>
          <FormControl variant="outlined" sx={{ minWidth: 200 }}>
            <InputLabel id="prefix-select-label">ì ‘ë‘ì‚¬</InputLabel>
            <Select
              labelId="prefix-select-label"
              id="prefix-select"
              name="prefix"
              value={searchParams.prefix}
              onChange={handleSearchParamChange}
              label="ì ‘ë‘ì‚¬"
            >
              <MenuItem value="">
                <em>ì—†ìŒ</em>
              </MenuItem>
              {prefixOptions.map((prefix) => (
                <MenuItem key={prefix} value={prefix}>
                  {prefix}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
          
          <TextField
            name="pattern"
            label="ê²€ìƒ‰ íŒ¨í„´"
            variant="outlined"
            value={searchParams.pattern}
            onChange={handleSearchParamChange}
            placeholder="ì˜ˆ: user:*"
            fullWidth
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon />
                </InputAdornment>
              ),
            }}
          />
          
          <TextField
            name="limit"
            label="ìµœëŒ€ ê²°ê³¼ ìˆ˜"
            variant="outlined"
            type="number"
            value={searchParams.limit}
            onChange={handleSearchParamChange}
            sx={{ width: { xs: '100%', md: 150 } }}
          />
          
          <Button 
            variant="contained" 
            onClick={handleSearch}
            startIcon={<SearchIcon />}
            sx={{ 
              height: 56,
              px: 4,
              background: `linear-gradient(90deg, ${theme.palette.primary.main} 0%, ${theme.palette.primary.dark} 100%)`,
              boxShadow: '0 4px 10px rgba(0, 0, 0, 0.1)',
              '&:hover': {
                boxShadow: '0 6px 15px rgba(0, 0, 0, 0.2)',
              }
            }}
          >
            ê²€ìƒ‰
          </Button>
          
          <IconButton 
            color="primary" 
            onClick={refetch}
            sx={{ height: 56, width: 56 }}
          >
            <RefreshIcon />
          </IconButton>
        </Box>
        
        {prefixOptions.length > 0 && (
          <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mb: 3 }}>
            <Chip 
              icon={<FilterIcon />} 
              label="ì ‘ë‘ì‚¬ í•„í„°:" 
              variant="outlined" 
              sx={{ bgcolor: 'background.default' }}
            />
            {prefixOptions.map((prefix) => (
              <Chip 
                key={prefix}
                label={prefix}
                onClick={() => handlePrefixSelect(prefix)}
                color={searchParams.prefix === prefix ? 'primary' : 'default'}
                variant={searchParams.prefix === prefix ? 'filled' : 'outlined'}
                sx={{ 
                  '&:hover': { 
                    bgcolor: searchParams.prefix === prefix ? '' : `${theme.palette.primary.main}20` 
                  } 
                }}
              />
            ))}
          </Box>
        )}
        
        {isError && (
          <Alert severity="error" sx={{ mb: 3 }}>
            í‚¤ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {error?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}
          </Alert>
        )}
      </Paper>
      
      <Paper 
        elevation={0} 
        sx={{ 
          borderRadius: 2, 
          boxShadow: '0 4px 20px rgba(0, 0, 0, 0.08)',
          overflow: 'hidden'
        }}
      >
        <TableContainer sx={{ maxHeight: 600 }}>
          <Table stickyHeader>
            <TableHead>
              <TableRow>
                <TableCell 
                  sx={{ 
                    bgcolor: theme.palette.background.default,
                    fontWeight: 600
                  }}
                >
                  í‚¤
                </TableCell>
                <TableCell 
                  align="right"
                  sx={{ 
                    bgcolor: theme.palette.background.default,
                    fontWeight: 600
                  }}
                >
                  íƒ€ì…
                </TableCell>
                <TableCell 
                  align="right"
                  sx={{ 
                    bgcolor: theme.palette.background.default,
                    fontWeight: 600,
                    width: 180
                  }}
                >
                  TTL (ì´ˆ)
                </TableCell>
                <TableCell 
                  align="right"
                  sx={{ 
                    bgcolor: theme.palette.background.default,
                    fontWeight: 600,
                    width: 150
                  }}
                >
                  ì‘ì—…
                </TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {isLoading ? (
                <TableRow>
                  <TableCell colSpan={4} align="center" sx={{ py: 5 }}>
                    <CircularProgress size={40} thickness={4} />
                    <Typography variant="body2" sx={{ mt: 2, color: 'text.secondary' }}>
                      í‚¤ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : processedKeys.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={4} align="center" sx={{ py: 5 }}>
                    <Typography variant="body1" sx={{ color: 'text.secondary' }}>
                      ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.
                    </Typography>
                    <Typography variant="body2" sx={{ mt: 1, color: 'text.secondary' }}>
                      ë‹¤ë¥¸ ê²€ìƒ‰ì–´ë‚˜ íŒ¨í„´ìœ¼ë¡œ ì‹œë„í•´ë³´ì„¸ìš”.
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : (
                processedKeys
                  .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)
                  .map((key, index) => {
                    return (
                      <TableRow
                        key={key.key}
                        hover
                        sx={{ 
                          '&:nth-of-type(odd)': { 
                            bgcolor: 'rgba(0, 0, 0, 0.02)' 
                          } 
                        }}
                      >
                        <TableCell component="th" scope="row">
                          <Box sx={{ display: 'flex', alignItems: 'center' }}>
                            {key.key.includes(':') && (
                              <Chip 
                                label={key.key.split(':')[0]} 
                                size="small" 
                                color="primary" 
                                variant="outlined"
                                sx={{ mr: 1, fontSize: '0.7rem' }}
                              />
                            )}
                            <Tooltip title={key.key} arrow>
                              <Typography 
                                variant="body2" 
                                sx={{ 
                                  maxWidth: 400, 
                                  overflow: 'hidden', 
                                  textOverflow: 'ellipsis', 
                                  whiteSpace: 'nowrap' 
                                }}
                              >
                                {key.key.includes(':') ? key.key.substring(key.key.split(':')[0].length + 1) : key.key}
                              </Typography>
                            </Tooltip>
                          </Box>
                        </TableCell>
                        <TableCell align="right">
                          <Chip 
                            label={key.type} 
                            size="small" 
                            sx={{ 
                              bgcolor: `${theme.palette.info.main}20`,
                              color: theme.palette.info.main,
                              fontWeight: 500,
                              fontSize: '0.7rem'
                            }} 
                          />
                        </TableCell>
                        <TableCell align="right">
                          {key.ttl === -1 ? (
                            <Chip 
                              label="ë¬´ê¸°í•œ" 
                              size="small" 
                              sx={{ 
                                bgcolor: `${theme.palette.success.main}20`,
                                color: theme.palette.success.main,
                                fontWeight: 500,
                                fontSize: '0.7rem'
                              }} 
                            />
                          ) : key.ttl === -2 ? (
                            <Chip 
                              label="ë§Œë£Œë¨" 
                              size="small" 
                              sx={{ 
                                bgcolor: `${theme.palette.error.main}20`,
                                color: theme.palette.error.main,
                                fontWeight: 500,
                                fontSize: '0.7rem'
                              }} 
                            />
                          ) : (
                            key.ttl
                          )}
                        </TableCell>
                        <TableCell align="right">
                          <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
                            <Tooltip title="í‚¤ ë³µì‚¬">
                              <IconButton 
                                size="small" 
                                onClick={() => handleCopyKey(key.key)}
                                sx={{ color: theme.palette.info.main }}
                              >
                                <CopyIcon fontSize="small" />
                              </IconButton>
                            </Tooltip>
                            <Tooltip title="í‚¤ ì‚­ì œ">
                              <IconButton 
                                size="small" 
                                onClick={() => handleOpenDeleteDialog(key.key)}
                                sx={{ color: theme.palette.error.main }}
                              >
                                <DeleteIcon fontSize="small" />
                              </IconButton>
                            </Tooltip>
                          </Box>
                        </TableCell>
                      </TableRow>
                    );
                  })
              )}
            </TableBody>
          </Table>
        </TableContainer>
        
        <TablePagination
          rowsPerPageOptions={[10, 25, 50, 100]}
          component="div"
          count={processedKeys.length}
          rowsPerPage={rowsPerPage}
          page={page}
          onPageChange={handleChangePage}
          onRowsPerPageChange={handleChangeRowsPerPage}
          labelRowsPerPage="í–‰ ìˆ˜:"
          labelDisplayedRows={({ from, to, count }) => `${from}-${to} / ${count}`}
        />
      </Paper>
      
      {/* í‚¤ ì‚­ì œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸ */}
      <Dialog
        open={openDialog}
        onClose={handleCloseDialog}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">
          í‚¤ ì‚­ì œ í™•ì¸
        </DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">
            ì •ë§ë¡œ <strong>{selectedKey}</strong> í‚¤ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?
            <br />
            ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog} color="primary">
            ì·¨ì†Œ
          </Button>
          <Button 
            onClick={handleDeleteKey} 
            color="error" 
            variant="contained"
            startIcon={<DeleteIcon />}
            autoFocus
          >
            ì‚­ì œ
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* ì•Œë¦¼ ìŠ¤ë‚µë°” */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert 
          onClose={handleCloseSnackbar} 
          severity={snackbar.severity} 
          variant="filled"
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default RedisKeysList;



============================================================
File: /home/CVEHub/frontend/src/features/cache/hooks/useCacheQuery.ts
------------------------------------------------------------
/**
 * ìºì‹œ ì •ë³´ ì¡°íšŒë¥¼ ìœ„í•œ React Query í›…
 * ì›¹ì†Œì¼“ í†µí•© ë° ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ê¸°ëŠ¥ì´ í¬í•¨ëœ ë²„ì „
 */
import { useQuery, useMutation, useQueryClient, UseQueryOptions, UseMutationOptions, QueryClient } from '@tanstack/react-query';
import { useEffect, useCallback, useRef } from 'react';
import {
  getCacheInfo,
  getCacheStats,
  getCacheKeys,
  getCacheValues,
  clearCache
} from '../services/cacheService';
import { formatDateTime, TIME_ZONES } from 'shared/utils/dateUtils';
import { ApiResponse } from 'shared/api/types/api';
import { useSocket } from 'core/socket/hooks/useSocket';
import _ from 'lodash';
import logger from 'shared/utils/logging';

// ë¡œê±° íŒ©í† ë¦¬ í•¨ìˆ˜
const createLogger = (prefix: string) => ({
  info: (message: string, data?: any) => {
    if (data !== undefined) {
      logger.info(prefix, message, data);
    } else {
      logger.info(prefix, message);
    }
  },
  warn: (message: string, data?: any) => {
    if (data !== undefined) {
      logger.warn(prefix, message, data);
    } else {
      logger.warn(prefix, message);
    }
  },
  error: (message: string, error?: any) => {
    if (error !== undefined) {
      logger.error(prefix, message, error);
    } else {
      logger.error(prefix, message);
    }
  },
  debug: (message: string, data?: any) => {
    if (data !== undefined) {
      logger.debug(prefix, message, data);
    } else {
      logger.debug(prefix, message);
    }
  }
});

/**
 * ìºì‹œ ì •ë³´ ì¸í„°í˜ì´ìŠ¤
 */
export interface CacheInfo {
  version: string;
  mode: string;
  os: string;
  arch: string;
  process_id: number;
  uptime_in_seconds: number;
  uptime_in_days: number;
  connected_clients: number;
  used_memory_human: string;
  used_memory_peak_human: string;
  total_connections_received: number;
  total_commands_processed: number;
  [key: string]: string | number | boolean;
}

/**
 * ìºì‹œ í†µê³„ ì •ë³´ ì¸í„°í˜ì´ìŠ¤
 */
export interface CacheStats {
  total_keys: number;
  expires_keys: number;
  avg_ttl: number;
  memory_usage: string;
  hit_rate: number;
  miss_rate: number;
  [key: string]: string | number | boolean;
}

/**
 * ìºì‹œ í‚¤ ì¡°íšŒ íŒŒë¼ë¯¸í„° ì¸í„°í˜ì´ìŠ¤
 */
export interface CacheQueryParams {
  prefix?: string;
  pattern?: string;
  limit?: number;
}

/**
 * ìºì‹œ í‚¤ ì •ë³´ ì¸í„°í˜ì´ìŠ¤
 */
export interface CacheKey {
  key: string;
  type: string;
  ttl: number;
  size?: number;
}

/**
 * ìºì‹œ ê°’ ì •ë³´ ì¸í„°í˜ì´ìŠ¤
 */
export interface CacheValue {
  key: string;
  value: any;
  type: string;
  ttl: number;
  size?: number;
}

/**
 * React Query ìºì‹œ í•­ëª© ì¸í„°í˜ì´ìŠ¤
 */
export interface ReactQueryCacheItem {
  queryKey: string;
  state: any;
  queryHash: string;
  isStale: boolean;
  isActive: boolean;
  dataUpdatedAt: number;
  lastUpdated: string;
}

/**
 * ë‚™ê´€ì  ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ ì¸í„°í˜ì´ìŠ¤
 */
interface CacheMutationContext {
  previousKeys?: ApiResponse<CacheKey[]>;
  previousStats?: ApiResponse<CacheStats>;
  previousInfo?: ApiResponse<CacheInfo>;
}

/**
 * Redis ìºì‹œ ì„œë²„ ì •ë³´ ì¡°íšŒ í›…
 * @returns ìºì‹œ ì„œë²„ ì •ë³´ ì¿¼ë¦¬ ê²°ê³¼
 */
export const useCacheInfoQuery = (
  options?: UseQueryOptions<ApiResponse<CacheInfo>, Error>
) => {
  const queryLog = createLogger('useCacheInfoQuery');
  
  return useQuery<ApiResponse<CacheInfo>, Error>({
    queryKey: ['cacheInfo'],
    queryFn: async () => {
      queryLog.info('ìºì‹œ ì„œë²„ ì •ë³´ ì¡°íšŒ ìš”ì²­');
      try {
        const result = await getCacheInfo();
        queryLog.debug('ìºì‹œ ì„œë²„ ì •ë³´ ì¡°íšŒ ì™„ë£Œ', result);
        return result;
      } catch (error) {
        queryLog.error('ìºì‹œ ì„œë²„ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜', error);
        throw error;
      }
    },
    staleTime: 1000 * 60, // 1ë¶„
    ...options,
  });
};

/**
 * Redis ìºì‹œ í†µê³„ ì •ë³´ ì¡°íšŒ í›…
 * @returns ìºì‹œ í†µê³„ ì •ë³´ ì¿¼ë¦¬ ê²°ê³¼
 */
export const useCacheStatsQuery = (
  options?: UseQueryOptions<ApiResponse<CacheStats>, Error>
) => {
  const queryLog = createLogger('useCacheStatsQuery');
  
  return useQuery<ApiResponse<CacheStats>, Error>({
    queryKey: ['cacheStats'],
    queryFn: async () => {
      queryLog.info('ìºì‹œ í†µê³„ ì •ë³´ ì¡°íšŒ ìš”ì²­');
      try {
        const result = await getCacheStats();
        queryLog.debug('ìºì‹œ í†µê³„ ì •ë³´ ì¡°íšŒ ì™„ë£Œ', result);
        return result;
      } catch (error) {
        queryLog.error('ìºì‹œ í†µê³„ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜', error);
        throw error;
      }
    },
    staleTime: 1000 * 30, // 30ì´ˆ
    ...options,
  });
};

/**
 * Redis ìºì‹œ í‚¤ ëª©ë¡ ì¡°íšŒ í›…
 * @param params ì¡°íšŒ íŒŒë¼ë¯¸í„°
 * @param options ì¿¼ë¦¬ ì˜µì…˜
 * @returns ìºì‹œ í‚¤ ëª©ë¡ ì¿¼ë¦¬ ê²°ê³¼
 */
export const useCacheKeysQuery = (
  params: CacheQueryParams = {}, 
  options?: UseQueryOptions<ApiResponse<CacheKey[]>, Error>
) => {
  const queryLog = createLogger('useCacheKeysQuery');
  
  return useQuery<ApiResponse<CacheKey[]>, Error>({
    queryKey: ['cacheKeys', params],
    queryFn: async () => {
      queryLog.info('ìºì‹œ í‚¤ ëª©ë¡ ì¡°íšŒ ìš”ì²­', params);
      try {
        const result = await getCacheKeys(params);
        queryLog.debug('ìºì‹œ í‚¤ ëª©ë¡ ì¡°íšŒ ì™„ë£Œ', {
          params,
          keyCount: result.data?.length || 0
        });
        return result;
      } catch (error) {
        queryLog.error('ìºì‹œ í‚¤ ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜', error);
        throw error;
      }
    },
    staleTime: 1000 * 30, // 30ì´ˆ
    ...options,
  });
};

/**
 * Redis ìºì‹œ ê°’ ì¡°íšŒ í›…
 * @param params ì¡°íšŒ íŒŒë¼ë¯¸í„°
 * @param options ì¿¼ë¦¬ ì˜µì…˜
 * @returns ìºì‹œ ê°’ ëª©ë¡ ì¿¼ë¦¬ ê²°ê³¼
 */
export const useCacheValuesQuery = (
  params: CacheQueryParams = {}, 
  options?: UseQueryOptions<ApiResponse<CacheValue[]>, Error>
) => {
  const queryLog = createLogger('useCacheValuesQuery');
  
  return useQuery<ApiResponse<CacheValue[]>, Error>({
    queryKey: ['cacheValues', params],
    queryFn: async () => {
      queryLog.info('ìºì‹œ ê°’ ëª©ë¡ ì¡°íšŒ ìš”ì²­', params);
      try {
        const result = await getCacheValues(params);
        queryLog.debug('ìºì‹œ ê°’ ëª©ë¡ ì¡°íšŒ ì™„ë£Œ', {
          params,
          valueCount: result.data?.length || 0
        });
        return result;
      } catch (error) {
        queryLog.error('ìºì‹œ ê°’ ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜', error);
        throw error;
      }
    },
    staleTime: 1000 * 30, // 30ì´ˆ
    ...options,
  });
};

/**
 * Redis ìºì‹œ ì‚­ì œ ë®¤í…Œì´ì…˜ í›… (ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì ìš©)
 * @returns ìºì‹œ ì‚­ì œ ë®¤í…Œì´ì…˜ ê²°ê³¼
 */
export const useClearCacheMutation = (
  options?: UseMutationOptions<ApiResponse<any>, Error, CacheQueryParams, CacheMutationContext>
) => {
  const queryClient = useQueryClient();
  const mutationLog = createLogger('useClearCacheMutation');
  
  return useMutation<ApiResponse<any>, Error, CacheQueryParams, CacheMutationContext>({
    mutationFn: async (params) => {
      mutationLog.info('ìºì‹œ ì‚­ì œ ìš”ì²­', params);
      try {
        const result = await clearCache(params);
        mutationLog.info('ìºì‹œ ì‚­ì œ ì„±ê³µ', params);
        return result;
      } catch (error) {
        mutationLog.error('ìºì‹œ ì‚­ì œ ì˜¤ë¥˜', error);
        throw error;
      }
    },
    
    // ë‚™ê´€ì  ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ onMutate
    onMutate: async (params) => {
      mutationLog.debug('ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì‹œì‘', params);
      
      // ì§„í–‰ ì¤‘ì¸ ê´€ë ¨ ì¿¼ë¦¬ ì·¨ì†Œ
      await queryClient.cancelQueries({ queryKey: ['cacheKeys', params] });
      await queryClient.cancelQueries({ queryKey: ['cacheStats'] });
      await queryClient.cancelQueries({ queryKey: ['cacheInfo'] });
      
      // ì´ì „ ìƒíƒœ ìŠ¤ëƒ…ìƒ· ì €ì¥
      const previousKeys = queryClient.getQueryData<ApiResponse<CacheKey[]>>(['cacheKeys', params]);
      const previousStats = queryClient.getQueryData<ApiResponse<CacheStats>>(['cacheStats']);
      const previousInfo = queryClient.getQueryData<ApiResponse<CacheInfo>>(['cacheInfo']);
      
      // ë‚™ê´€ì ìœ¼ë¡œ ìºì‹œ í‚¤ ëª©ë¡ ì—…ë°ì´íŠ¸
      if (previousKeys) {
        queryClient.setQueryData<ApiResponse<CacheKey[]>>(['cacheKeys', params], {
          ...previousKeys,
          data: [], // ì‚­ì œí–ˆìœ¼ë¯€ë¡œ ë¹ˆ ë°°ì—´ë¡œ ì„¤ì •
          message: 'ìºì‹œê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.',
          success: true
        });
      }
      
      // ë‚™ê´€ì ìœ¼ë¡œ ìºì‹œ í†µê³„ ì—…ë°ì´íŠ¸
      if (previousStats && previousStats.data) {
        queryClient.setQueryData<ApiResponse<CacheStats>>(['cacheStats'], {
          ...previousStats,
          data: {
            ...previousStats.data,
            total_keys: 0,
            expires_keys: 0,
            memory_usage: '0 bytes'
          }
        });
      }
      
      mutationLog.debug('ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì™„ë£Œ');
      
      return { previousKeys, previousStats, previousInfo };
    },
    
    // ì˜¤ë¥˜ ë°œìƒ ì‹œ ë¡¤ë°±
    onError: (err, params, context) => {
      mutationLog.error('ìºì‹œ ì‚­ì œ ì‹¤íŒ¨, ë¡¤ë°± ìˆ˜í–‰', err);
      
      if (context?.previousKeys) {
        queryClient.setQueryData(['cacheKeys', params], context.previousKeys);
      }
      
      if (context?.previousStats) {
        queryClient.setQueryData(['cacheStats'], context.previousStats);
      }
      
      if (context?.previousInfo) {
        queryClient.setQueryData(['cacheInfo'], context.previousInfo);
      }
    },
    
    // ì„±ê³µ ì‹œ ì¿¼ë¦¬ ë¬´íš¨í™”
    onSuccess: () => {
      mutationLog.info('ìºì‹œ ì‚­ì œ í›„ ì¿¼ë¦¬ ë¬´íš¨í™”');
      
      // ëª¨ë“  ê´€ë ¨ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ 
        queryKey: ['cacheInfo'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheStats'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheKeys'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheValues'],
        refetchType: 'active'
      });
    },
    ...options,
  });
};

/**
 * React Query ìºì‹œ ì •ë³´ ì¡°íšŒ í›…
 * @returns React Query ìºì‹œ ì •ë³´
 */
export const useReactQueryCache = () => {
  const queryClient = useQueryClient();
  
  const getQueryCache = useCallback((): ReactQueryCacheItem[] => {
    const queryCache = queryClient.getQueryCache();
    const queries = queryCache.getAll();
    
    return queries.map(query => ({
      queryKey: JSON.stringify(query.queryKey),
      state: query.state,
      queryHash: query.queryHash,
      isStale: query.isStale(),
      isActive: query.isActive(),
      dataUpdatedAt: query.state.dataUpdatedAt,
      lastUpdated: query.state.dataUpdatedAt ? formatDateTime(new Date(query.state.dataUpdatedAt), undefined, TIME_ZONES.KST) : 'N/A',
    }));
  }, [queryClient]);
  
  return {
    getQueryCache,
    queryClient,
  };
};

/**
 * ë””ë°”ìš´ìŠ¤ëœ ìºì‹œ ì¿¼ë¦¬ ê°±ì‹  í›…
 * @returns ìºì‹œ ì¿¼ë¦¬ ê°±ì‹  í•¨ìˆ˜
 */
export const useRefreshCacheQueries = () => {
  const queryClient = useQueryClient();
  const logRefresh = createLogger('useRefreshCacheQueries');
  
  // ë””ë°”ìš´ìŠ¤ëœ ìºì‹œ ìƒˆë¡œê³ ì¹¨ í•¨ìˆ˜
  const refreshCache = useCallback(
    _.debounce(() => {
      logRefresh.info('ë””ë°”ìš´ìŠ¤ëœ ìºì‹œ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰');
      
      queryClient.invalidateQueries({ 
        queryKey: ['cacheInfo'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheStats'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheKeys'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cacheValues'],
        refetchType: 'active'
      });
    }, 300),
    [queryClient]
  );
  
  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ë””ë°”ìš´ìŠ¤ í•¨ìˆ˜ ì·¨ì†Œ
  useEffect(() => {
    return () => {
      refreshCache.cancel();
    };
  }, [refreshCache]);
  
  return { refreshCache };
};

/**
 * ì‹¤ì‹œê°„ ìºì‹œ ì—…ë°ì´íŠ¸ êµ¬ë… í›…
 * ì›¹ì†Œì¼“ì„ í†µí•´ ìºì‹œ ë³€ê²½ ì´ë²¤íŠ¸ë¥¼ êµ¬ë…í•˜ê³  ê´€ë ¨ ì¿¼ë¦¬ë¥¼ ìë™ìœ¼ë¡œ ê°±ì‹ í•©ë‹ˆë‹¤.
 * @returns ì—°ê²° ìƒíƒœ ê°ì²´
 */
export const useCacheUpdates = () => {
  const queryClient = useQueryClient();
  const logCache = createLogger('useCacheUpdates');
  
  // ë””ë°”ìš´ìŠ¤ëœ ìºì‹œ ìƒˆë¡œê³ ì¹¨ í›… ì‚¬ìš©
  const { refreshCache } = useRefreshCacheQueries();
  
  // êµ¬ë… ìƒíƒœ ì¶”ì ìš© Ref
  const isSubscribedRef = useRef(false);
  
  // useSocket í›… ì‚¬ìš©
  const { connected, on, emit, cleanup } = useSocket(
    undefined, undefined, [], { 
      componentId: 'cache-updates',
      useRxJS: true
    }
  );
  
  // ìºì‹œ ë³€ê²½ ì´ë²¤íŠ¸ ì²˜ë¦¬
  useEffect(() => {
    if (connected && !isSubscribedRef.current) {
      logCache.info('ìºì‹œ ì—…ë°ì´íŠ¸ êµ¬ë… ì‹œì‘');
      
      // ì„œë²„ì— ìºì‹œ ëª¨ë‹ˆí„°ë§ ìš”ì²­
      emit('MONITOR_CACHE', { enabled: true });
      
      // ìºì‹œ í‚¤ ë³€ê²½ ì´ë²¤íŠ¸
      const unsubCacheKeysChanged = on('CACHE_KEYS_CHANGED', (data) => {
        logCache.info('ìºì‹œ í‚¤ ë³€ê²½ ê°ì§€', data);
        queryClient.invalidateQueries({ 
          queryKey: ['cacheKeys'],
          refetchType: 'active'
        });
        queryClient.invalidateQueries({ 
          queryKey: ['cacheStats'],
          refetchType: 'active'
        });
      });
      
      // ìºì‹œ ê°’ ë³€ê²½ ì´ë²¤íŠ¸
      const unsubCacheValuesChanged = on('CACHE_VALUES_CHANGED', (data) => {
        logCache.info('ìºì‹œ ê°’ ë³€ê²½ ê°ì§€', data);
        queryClient.invalidateQueries({ 
          queryKey: ['cacheValues'],
          refetchType: 'active'
        });
      });
      
      // ìºì‹œ ì •ë³´ ë³€ê²½ ì´ë²¤íŠ¸
      const unsubCacheInfoChanged = on('CACHE_INFO_CHANGED', (data) => {
        logCache.info('ìºì‹œ ì •ë³´ ë³€ê²½ ê°ì§€', data);
        queryClient.invalidateQueries({ 
          queryKey: ['cacheInfo'],
          refetchType: 'active'
        });
      });
      
      // ìºì‹œ í”ŒëŸ¬ì‹œ ì´ë²¤íŠ¸ (ëª¨ë“  ìºì‹œê°€ ì‚­ì œëœ ê²½ìš°)
      const unsubCacheFlushed = on('CACHE_FLUSHED', () => {
        logCache.info('ìºì‹œ í”ŒëŸ¬ì‹œ ê°ì§€');
        refreshCache();
      });
      
      isSubscribedRef.current = true;
      
      return () => {
        logCache.info('ìºì‹œ ì—…ë°ì´íŠ¸ êµ¬ë… í•´ì œ');
        
        // ì„œë²„ì— ëª¨ë‹ˆí„°ë§ ì¤‘ì§€ ìš”ì²­
        if (connected) {
          emit('MONITOR_CACHE', { enabled: false });
        }
        
        // ì´ë²¤íŠ¸ êµ¬ë… í•´ì œ
        unsubCacheKeysChanged();
        unsubCacheValuesChanged();
        unsubCacheInfoChanged();
        unsubCacheFlushed();
        
        // ë””ë°”ìš´ìŠ¤ëœ í•¨ìˆ˜ ì·¨ì†Œ
        refreshCache.cancel();
        
        // ì†Œì¼“ ì •ë¦¬
        cleanup();
        
        isSubscribedRef.current = false;
      };
    }
    
    return () => {
      // ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš°ì—ë„ ì •ë¦¬
      refreshCache.cancel();
    };
  }, [connected, on, emit, cleanup, queryClient, refreshCache]);
  
  return { isConnected: connected };
};

// ëª¨ë“  ìºì‹œ ê´€ë ¨ í›…ì„ ë‹¨ì¼ ê°ì²´ë¡œ ë‚´ë³´ë‚´ê¸°
export default {
  useCacheInfoQuery,
  useCacheStatsQuery,
  useCacheKeysQuery,
  useCacheValuesQuery,
  useClearCacheMutation,
  useReactQueryCache,
  useRefreshCacheQueries,
  useCacheUpdates
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/index.ts
------------------------------------------------------------
// index.ts - ëª…ì‹œì  ë‚´ë³´ë‚´ê¸°ë¡œ ì¶©ëŒ í•´ê²°
// ê³µí†µ íƒ€ì…ë“¤
export type { User } from './CommentTypes';

// ëŒ“ê¸€ ê´€ë ¨ íƒ€ì…ë“¤
export type { 
  CommentData,
  CommentProps,
  CommentsTabProps
} from './CommentTypes';

// ë©˜ì…˜ ê´€ë ¨ íƒ€ì…ë“¤
export type {
  MentionUser,
  MentionState,
  MentionInputProps
} from './MentionTypes';

// UI ê´€ë ¨ íƒ€ì…ë“¤
export type {
  InlineEditTextProps,
  StyledComponentProps,
  SeverityChipProps,
  TabPanelProps
} from './UITypes';

// íƒ­ ê´€ë ¨ íƒ€ì…ë“¤
export type {
  TabConfig,
  PoCSourceInfo,
  RuleTypeInfo,
  BaseItem,
  PoCItem,
  SnortRuleItem,
  ReferenceItem,
  DataItem,
  ExtendedTabConfig
} from './TabTypes';

// CVE ê´€ë ¨ í•µì‹¬ íƒ€ì…ë“¤ (ì¤‘ë³µë˜ì§€ ì•ŠëŠ” íƒ€ì…ë“¤ë§Œ)
export type {
  CVEBase,
  CVEListResponse,
  CVEDetail,
  CVEDetailData,
  Reference,
  PoC,
  SnortRule,
  ModificationHistory,
  Comment,
  CommentExtended,
  CommentState,
  Subscriber,
  RefreshTriggers,
  TabCounts,
  CVEDetailHeaderProps,
  CVEDetailInfoPanelProps,
  CVEDetailTabsProps,
  CVEDetailProps,
  SubscriberCountProps,
  CVEFilterOptions,
  CVEUpdateRequest,
  OperationResponse,
  ApiResponse,
  FormData,
  PoCFile,
  SnortRuleFile,
  ReferenceFile,
  CVEData,
  SelectOption,
  GenericDataTabBaseProps,
  SnortRuleTabProps,
  PoCTabProps,
  ReferenceTabProps,
  GenericDataTabProps,
  WebSocketUpdateData,
  HistoryChange,
  HistoryItem,
  HistoryTabProps
} from './cve';

// ìƒì„±ëœ íƒ€ì… export ì¶”ê°€
export * from './generated/cve';

// í•¨ìˆ˜ ë‚´ë³´ë‚´ê¸°
export { countActiveComments } from './cve';


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/UITypes.ts
------------------------------------------------------------
import React from 'react';
import { Theme } from '@mui/material';

/**
 * ì¸ë¼ì¸ í…ìŠ¤íŠ¸ í¸ì§‘ ì»´í¬ë„ŒíŠ¸ Props ì¸í„°í˜ì´ìŠ¤
 */
export interface InlineEditTextProps {
  /** í‘œì‹œ/í¸ì§‘ ê°’ */
  value: string;
  
  /** ê°’ ì €ì¥ ì½œë°± */
  onSave: (value: string) => void;
  
  /** í”Œë ˆì´ìŠ¤í™€ë” */
  placeholder?: string;
  
  /** ì—¬ëŸ¬ ì¤„ ì…ë ¥ ê°€ëŠ¥ ì—¬ë¶€ */
  multiline?: boolean;
  
  /** ë¹„í™œì„±í™” ì—¬ë¶€ */
  disabled?: boolean;
  
  /** ìµœëŒ€ ë†’ì´ */
  maxHeight?: string | number;
  
  /** ê¸€ê¼´ í¬ê¸° */
  fontSize?: string | number;
  
  /** ì™¸ë¶€ì—ì„œ í¸ì§‘ ëª¨ë“œ ì œì–´ */
  externalEdit?: boolean;
  
  /** í¸ì§‘ ì‹œì‘ ì½œë°± */
  onEditingStart?: () => void;
  
  /** í¸ì§‘ ì¢…ë£Œ ì½œë°± */
  onEditingEnd?: () => void;
}

/**
 * styled ì»´í¬ë„ŒíŠ¸ì— ì‚¬ìš©ë˜ëŠ” Props íƒ€ì…ë“¤
 */
export interface StyledComponentProps {
  theme: Theme;
}

/**
 * ì‹¬ê°ë„ ì¹© ì»´í¬ë„ŒíŠ¸ Props
 */
export interface SeverityChipProps {
  /** CVSS ì ìˆ˜ (0-10) */
  score?: number;
  
  /** ì§ì ‘ ì§€ì •í•˜ëŠ” ì‹¬ê°ë„ ë ˆë²¨ */
  severity?: 'critical' | 'high' | 'medium' | 'low' | 'none';
  
  /** ì¹© í¬ê¸° */
  size?: 'small' | 'medium';
  
  /** ì ìˆ˜ í‘œì‹œ ì—¬ë¶€ */
  showScore?: boolean;
  
  /** ì¶”ê°€ ìŠ¤íƒ€ì¼ */
  sx?: React.CSSProperties;
}

/**
 * íƒ­ íŒ¨ë„ ì»´í¬ë„ŒíŠ¸ Props
 */
export interface TabPanelProps {
  /** í˜„ì¬ í™œì„±í™”ëœ íƒ­ ì¸ë±ìŠ¤ */
  currentTab: number;
  
  /** ì´ íŒ¨ë„ì˜ ì¸ë±ìŠ¤ */
  index: number;
  
  /** íŒ¨ë„ ë‚´ìš© */
  children?: React.ReactNode;
  
  /** ì¶”ê°€ Props */
  [key: string]: any;
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/generated/comment.ts
------------------------------------------------------------
/**
 * ìë™ ìƒì„±ëœ Comment ì¸í„°í˜ì´ìŠ¤ íŒŒì¼ - ì§ì ‘ ìˆ˜ì •í•˜ì§€ ë§ˆì„¸ìš”
 * ìƒì„± ì‹œê°„: 2025-04-11 18:30:00
 */

// ë² ì´ìŠ¤ ëª¨ë¸ ì •ì˜
export interface BaseGeneratedModel {
  [key: string]: unknown;
}

/**
 * Comment ì¸í„°í˜ì´ìŠ¤
 * @description ëŒ“ê¸€ ì •ë³´
 */
export interface GeneratedComment extends BaseGeneratedModel {
  /** ëŒ“ê¸€ ID */
  id: string;
  /** ëŒ“ê¸€ ë‚´ìš© */
  content: string;
  /** ì‘ì„±ì ì´ë¦„ */
  createdBy: string;
  /** ë¶€ëª¨ ëŒ“ê¸€ ID */
  parentId?: string;
  /** ëŒ“ê¸€ ê¹Šì´ */
  depth: number;
  /** ì‚­ì œ ì—¬ë¶€ */
  isDeleted: boolean;
  /** ìƒì„± ì‹œê°„ */
  createdAt: string | Date;
  /** ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„ */
  lastModifiedAt?: string | Date;
  /** ë§ˆì§€ë§‰ ìˆ˜ì •ì */
  lastModifiedBy?: string;
  /** ë©˜ì…˜ëœ ì‚¬ìš©ì ëª©ë¡ */
  mentions: string[];
}



============================================================
File: /home/CVEHub/frontend/src/features/cve/types/generated/cve.ts
------------------------------------------------------------
/**
 * ìë™ ìƒì„±ëœ TypeScript ì¸í„°í˜ì´ìŠ¤ íŒŒì¼ - ì§ì ‘ ìˆ˜ì •í•˜ì§€ ë§ˆì„¸ìš”
 * ìƒì„± ì‹œê°„: 2025-04-11 18:22:52
 */

// ëŒ“ê¸€ íƒ€ì… import
import { GeneratedComment } from './comment';

// ë² ì´ìŠ¤ ëª¨ë¸ ì •ì˜
export interface BaseGeneratedModel {
  [key: string]: unknown;
}

/**
 * Reference ì¸í„°í˜ì´ìŠ¤
 * @description ì°¸ì¡° ì •ë³´
 */
export interface GeneratedReference extends BaseGeneratedModel {
  /** ì°¸ì¡° URL */
  url: string;
  /** ì°¸ì¡° íƒ€ì… */
  type?: string;
  /** ì°¸ì¡° ì„¤ëª… */
  description?: string;
  /** ìƒì„± ì‹œê°„ */
  createdAt: string | Date;
  /** ì¶”ê°€í•œ ì‚¬ìš©ì */
  createdBy: string;
  /** ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„ */
  lastModifiedAt: string | Date;
  /** ë§ˆì§€ë§‰ ìˆ˜ì •ì */
  lastModifiedBy: string;
}

/**
 * PoC ì¸í„°í˜ì´ìŠ¤
 * @description Proof of Concept ì½”ë“œ
 */
export interface GeneratedPoC extends BaseGeneratedModel {
  /** PoC ì†ŒìŠ¤ */
  source: string;
  /** PoC URL */
  url: string;
  /** PoC ì„¤ëª… */
  description?: string;
  /** ìƒì„± ì‹œê°„ */
  createdAt: string | Date;
  /** ì¶”ê°€í•œ ì‚¬ìš©ì */
  createdBy: string;
  /** ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„ */
  lastModifiedAt: string | Date;
  /** ë§ˆì§€ë§‰ ìˆ˜ì •ì */
  lastModifiedBy: string;
}

/**
 * SnortRule ì¸í„°í˜ì´ìŠ¤
 * @description Snort ì¹¨ì… íƒì§€ ê·œì¹™
 */
export interface GeneratedSnortRule extends BaseGeneratedModel {
  /** Snort Rule ë‚´ìš© */
  rule: string;
  /** Rule íƒ€ì… */
  type: string;
  /** Rule ì„¤ëª… */
  description?: string;
  /** ìƒì„± ì‹œê°„ */
  createdAt: string | Date;
  /** ì¶”ê°€í•œ ì‚¬ìš©ì */
  createdBy: string;
  /** ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„ */
  lastModifiedAt: string | Date;
  /** ë§ˆì§€ë§‰ ìˆ˜ì •ì */
  lastModifiedBy: string;
}

/**
 * ChangeItem ì¸í„°í˜ì´ìŠ¤
 * @description ë³€ê²½ í•­ëª©
 */
export interface GeneratedChangeItem extends BaseGeneratedModel {
  /** ë³€ê²½ëœ í•„ë“œëª… */
  field: string;
  /** í•„ë“œì˜ í•œê¸€ëª… */
  fieldName: string;
  /** ë³€ê²½ ìœ í˜• */
  action: "add" | "edit" | "delete";
  /** ë³€ê²½ ë‚´ì—­ í‘œì‹œ ë°©ì‹ */
  detailType?: "simple" | "detailed";
  /** ë³€ê²½ ì „ ê°’ */
  before?: any;
  /** ë³€ê²½ í›„ ê°’ */
  after?: any;
  /** ì»¬ë ‰ì…˜ íƒ€ì… í•„ë“œì˜ ë³€ê²½ í•­ëª©ë“¤ */
  items?: Array<Record<string, any>>;
  /** ë³€ê²½ ìš”ì•½ */
  summary: string;
}

/**
 * ModificationHistory ì¸í„°í˜ì´ìŠ¤ (ìˆ˜ë™ ì •ì˜)
 * @description ë³€ê²½ ì´ë ¥
 * @note ë°±ì—”ë“œì—ì„œ ë¦¬íŒ©í† ë§ ì˜ˆì •ì´ë¯€ë¡œ ì„ì‹œ êµ¬í˜„
 */
export interface GeneratedModificationHistory extends BaseGeneratedModel {
  /** ìˆ˜ì • ID */
  id?: string;
  /** ìˆ˜ì •í•œ ì‚¬ìš©ì */
  username: string;
  /** ìˆ˜ì • ì‹œê°„ */
  timestamp: string | Date;
  /** ë³€ê²½ ë‚´ì—­ ëª©ë¡ */
  changes: GeneratedChangeItem[];
}

/**
 * ìƒì„±ëœ CVE ìƒì„¸ ì •ë³´ ì¸í„°í˜ì´ìŠ¤
 */
export interface GeneratedCVEDetail extends BaseGeneratedModel {
  /** CVE ID */
  cveId: string;
  /** CVE ì œëª© */
  title?: string;
  /** CVE ì„¤ëª… */
  description?: string;
  /** CVE ìƒíƒœ */
  status: string;
  /** ë‹´ë‹¹ì */
  assignedTo?: string;
  /** ì‹¬ê°ë„ */
  severity?: string;
  /** ì¶”ê°€í•œ ì‚¬ìš©ì */
  createdBy: string;
  /** ë§ˆì§€ë§‰ ìˆ˜ì •ì */
  lastModifiedBy: string;
  /** í¸ì§‘ ì ê¸ˆ ì—¬ë¶€ */
  isLocked?: boolean;
  /** ì ê¸ˆ ì„¤ì •í•œ ì‚¬ìš©ì */
  lockedBy?: string;
  /** ì ê¸ˆ ì„¤ì • ì‹œê°„ */
  lockTimestamp?: string | Date;
  /** ì ê¸ˆ ë§Œë£Œ ì‹œê°„ */
  lockExpiresAt?: string | Date;
  /** ë‚´ë¶€ ì°¸ê³ ì‚¬í•­ */
  notes?: string;
  /** Nuclei í…œí”Œë¦¿ í•´ì‹œ */
  nucleiHash?: string;
  
  /** ëŒ“ê¸€ ëª©ë¡ */
  comments?: GeneratedComment[];
  
  /** PoC ëª©ë¡ */
  poc?: GeneratedPoC[];
  
  /** Snort ê·œì¹™ ëª©ë¡ */
  snort_rule?: GeneratedSnortRule[];
  
  /** ì°¸ì¡° ì •ë³´ ëª©ë¡ */
  reference?: GeneratedReference[];
  
  /** ë³€ê²½ ì´ë ¥ ëª©ë¡ (ë°±ì—”ë“œ ë¦¬íŒ©í† ë§ ì˜ˆì •) */
  modificationHistory?: GeneratedModificationHistory[];
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/CommentTypes.ts
------------------------------------------------------------
import React from 'react';
import { MentionUser } from './MentionTypes';

/**
 * í™•ì¥ëœ ëŒ“ê¸€ ë°ì´í„° íƒ€ì…
 */
export interface CommentData {
  /** ëŒ“ê¸€ ê³ ìœ  ID */
  id: string;
  
  /** ëŒ“ê¸€ ë‚´ìš© */
  content: string;
  
  /** ì‘ì„±ì (username) */
  author?: string;
  
  /** ì‘ì„±ì ì´ë¦„ */
  authorName?: string;
  
  /** í”„ë¡œí•„ ì´ë¯¸ì§€ URL */
  profileImage?: string;
  
  /** ì‘ì„± ì‹œê°„ */
  createdAt: string | Date;
  
  /** ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„ */
  lastModifiedAt?: string | Date;
  
  /** ë¶€ëª¨ ëŒ“ê¸€ ID (ëŒ€ëŒ“ê¸€ì¸ ê²½ìš°) */
  parentId?: string;
  
  /** ì‚­ì œ ì—¬ë¶€ */
  isDeleted?: boolean;
  
  /** ë‚™ê´€ì  ì—…ë°ì´íŠ¸ìš© í”Œë˜ê·¸ */
  isOptimistic?: boolean;
  
  /** ìì‹ ëŒ“ê¸€ ëª©ë¡ */
  children?: CommentData[];
  
  /** ëŒ“ê¸€ ê¹Šì´ (ì¤‘ì²© ë ˆë²¨) */
  depth?: number;
  
  /** ì‘ì„±ì ID (username) */
  createdBy?: string;
  
  /** ê¸°íƒ€ ì†ì„± */
  [key: string]: unknown;
}

/**
 * Comment ì»´í¬ë„ŒíŠ¸ Props ì¸í„°í˜ì´ìŠ¤
 */
export interface CommentProps {
  /** ëŒ“ê¸€ ë°ì´í„° */
  comment: CommentData;
  
  /** ëŒ“ê¸€ ê¹Šì´ (ëŒ€ëŒ“ê¸€ì´ë©´ 1,2...) */
  depth?: number;
  
  /** í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ìëª… */
  currentUsername?: string;
  
  /** ê´€ë¦¬ì ì—¬ë¶€ */
  isAdmin?: boolean;
  
  /** í˜„ì¬ ì´ ëŒ“ê¸€ì´ "ìˆ˜ì • ì¤‘"ì¸ì§€ ì—¬ë¶€ */
  isEditing?: boolean;
  
  /** í˜„ì¬ ì´ ëŒ“ê¸€ì´ "ë‹µê¸€ ëª¨ë“œ"ì¸ì§€ ì—¬ë¶€ */
  replyMode?: boolean;
  
  /** CVE ID */
  cveId?: string;
  
  /** ë©˜ì…˜ ê°€ëŠ¥í•œ ì‚¬ìš©ì ëª©ë¡ */
  usersForMention?: MentionUser[];
  
  /** ì œì¶œ ì¤‘ ì—¬ë¶€ (ë¡œë”© ìƒíƒœ) */
  isSubmitting?: boolean;
  
  /** ë¶€ëª¨ ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜ */
  parentSendMessage?: (type: string, data: Record<string, unknown>) => Promise<boolean | null> | boolean | null;
  
  /** ìˆ˜ì • ì‹œì‘ ì½œë°± */
  onStartEdit: (commentId: string) => void;
  
  /** ìˆ˜ì • ì¢…ë£Œ ì½œë°± */
  onFinishEdit: () => void;
  
  /** ìˆ˜ì • ì½œë°± */
  onEdit: (commentId: string, content: string) => Promise<any>;
  
  /** ë‹µê¸€ ëª¨ë“œ ì‹œì‘ ì½œë°± */
  onReply: (comment: CommentData) => void;
  
  /** ë‹µê¸€ ëª¨ë“œ ì·¨ì†Œ ì½œë°± */
  onReplyCancel: () => void;
  
  /** ë‹µê¸€ ì œì¶œ ì½œë°± */
  onReplySubmit: (parentCommentId: string, content: string) => Promise<any>;
  
  /** ì‚­ì œ ì½œë°± */
  onDelete: (commentId: string, permanent: boolean) => Promise<any>;
  
  /** ìì‹ (ì¤‘ì²© ëŒ“ê¸€) ë Œë”ë§ ì»¨í…ì¸  */
  children?: React.ReactNode;
}

/**
 * ì‚¬ìš©ì ê¸°ë³¸ ì •ë³´ ì¸í„°í˜ì´ìŠ¤
 */
export interface User {
  id?: string;
  username: string;
  displayName?: string;
  profileImage?: string;
  isAdmin?: boolean;
}

/**
 * CommentsTab ì»´í¬ë„ŒíŠ¸ Props ì¸í„°í˜ì´ìŠ¤
 */
export interface CommentsTabProps {
  /** CVE ìƒì„¸ ë°ì´í„° */
  cve: {
    cveId: string;
    comments?: CommentData[];
    [key: string]: any;
  };
  
  /** ëŒ“ê¸€ ìˆ˜ ë³€ê²½ ì½œë°± */
  onCommentCountChange?: (count: number) => void;
  
  /** í˜„ì¬ ì‚¬ìš©ì ì •ë³´ */
  currentUser?: User | null;
  
  /** ìƒˆë¡œê³ ì¹¨ íŠ¸ë¦¬ê±° */
  refreshTrigger?: number;
  
  /** ë¶€ëª¨ ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜ */
  parentSendMessage?: (type: string, data: Record<string, unknown>) => Promise<boolean | null> | boolean | null;
  
  /** ê°•ì¡°í•  ëŒ“ê¸€ ID */
  highlightCommentId?: string | null;
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/TabTypes.ts
------------------------------------------------------------
import React from 'react';
import { SvgIconComponent } from '@mui/icons-material';
import { User } from './CommentTypes';

/**
 * ê¸°ë³¸ íƒ­ ì„¤ì • ì¸í„°í˜ì´ìŠ¤
 */
export interface TabConfig {
  /** íƒ­ ì•„ì´ì½˜ */
  icon: SvgIconComponent | React.ElementType;
  
  /** íƒ­ ì œëª© */
  title: string;
  
  /** í•­ëª© ì´ë¦„ */
  itemName: string;
  
  /** ë°ì´í„° í•„ë“œ ì´ë¦„ */
  dataField: string;
  
  /** ì¶”ê°€ ë²„íŠ¼ í…ìŠ¤íŠ¸ */
  addButtonText: string;
  
  /** í¸ì§‘ ë²„íŠ¼ í…ìŠ¤íŠ¸ */
  editButtonText: string;
  
  /** ì‚­ì œ ë²„íŠ¼ í…ìŠ¤íŠ¸ */
  deleteButtonText: string;
}

/**
 * PoC ì†ŒìŠ¤ ì •ë³´ ì¸í„°í˜ì´ìŠ¤
 */
export interface PoCSourceInfo {
  /** í‘œì‹œ ë¼ë²¨ */
  label: string;
  
  /** ìƒ‰ìƒ ìŠ¤í‚¤ë§ˆ */
  color: 'default' | 'primary' | 'secondary' | 'error' | 'info' | 'success' | 'warning';
}

/**
 * ê·œì¹™ íƒ€ì… ì •ë³´ ì¸í„°í˜ì´ìŠ¤
 */
export interface RuleTypeInfo {
  /** í‘œì‹œ ë¼ë²¨ */
  label: string;
  
  /** ìƒ‰ìƒ ìŠ¤í‚¤ë§ˆ */
  color: 'default' | 'primary' | 'secondary' | 'error' | 'info' | 'success' | 'warning';
}

/**
 * ê¸°ë³¸ ì•„ì´í…œ ì¸í„°í˜ì´ìŠ¤
 */
export interface BaseItem {
  /** ì•„ì´í…œ ID */
  id?: string | number;
  
  /** ì„¤ëª… */
  description?: string;
  
  /** ìƒì„± ì¼ì‹œ */
  created_at?: string | Date;
  
  /** ìƒì„±ì (username) */
  created_by?: string;
  
  /** ë§ˆì§€ë§‰ ìˆ˜ì • ì¼ì‹œ */
  last_modified_at?: string | Date;
  
  /** ë§ˆì§€ë§‰ ìˆ˜ì •ì (username) */
  last_modified_by?: string;
  
  /** í˜„ì¬ ì‚¬ìš©ì ì •ë³´ */
  currentUser?: User;
}

/**
 * PoC ì•„ì´í…œ ì¸í„°í˜ì´ìŠ¤
 */
export interface PoCItem extends BaseItem {
  /** ì†ŒìŠ¤ íƒ€ì… */
  source: string;
  
  /** URL */
  url: string;
}

/**
 * Snort ê·œì¹™ ì•„ì´í…œ ì¸í„°í˜ì´ìŠ¤
 */
export interface SnortRuleItem extends BaseItem {
  /** ê·œì¹™ íƒ€ì… */
  type: string;
  
  /** ê·œì¹™ ë‚´ìš© */
  rule: string;
}

/**
 * ì°¸ì¡° ì•„ì´í…œ ì¸í„°í˜ì´ìŠ¤
 */
export interface ReferenceItem extends BaseItem {
  /** ì°¸ì¡° íƒ€ì… */
  type: string;
  
  /** URL */
  url: string;
}

/**
 * ëª¨ë“  ë°ì´í„° ì•„ì´í…œ íƒ€ì…
 */
export type DataItem = PoCItem | SnortRuleItem | ReferenceItem;

/**
 * í™•ì¥ëœ íƒ­ ì„¤ì • ì¸í„°í˜ì´ìŠ¤
 */
export interface ExtendedTabConfig<T extends DataItem> extends TabConfig {
  /** ì›¹ì†Œì¼“ í•„ë“œ ì´ë¦„ */
  wsFieldName: string;
  
  /** ê¸°ë³¸ ì•„ì´í…œ í…œí”Œë¦¿ */
  defaultItem: T;
  
  /** ë¹ˆ ìƒíƒœ ì œëª© */
  emptyTitle: string;
  
  /** ë¹ˆ ìƒíƒœ ì„¤ëª… */
  emptyDescription: string;
  
  /** ì•„ì´í…œ ìœ íš¨ì„± ê²€ì‚¬ í•¨ìˆ˜ */
  validateItem: (item: T) => boolean | string;
  
  /** ì¤‘ë³µ í™•ì¸ í•¨ìˆ˜ */
  checkDuplicate?: (item: T, items: T[], excludeIndex?: number) => boolean;
  
  /** ì•„ì´í…œ ë¼ë²¨ ë Œë”ë§ í•¨ìˆ˜ */
  renderItemLabel?: (item: T) => React.ReactNode;
  
  /** ì•„ì´í…œ ì½˜í…ì¸  ë Œë”ë§ í•¨ìˆ˜ */
  renderItemContent?: (item: T) => React.ReactNode;
  
  /** ë‹¤ì´ì–¼ë¡œê·¸ ì½˜í…ì¸  ë Œë”ë§ í•¨ìˆ˜ */
  renderDialogContent?: (
    item: T,
    updateItemState: <K extends keyof T>(item: T, field: K, value: T[K]) => void,
    isEdit: boolean
  ) => React.ReactNode;
  
  /** ì €ì¥ ì „ ì•„ì´í…œ ì²˜ë¦¬ í•¨ìˆ˜ */
  prepareItemForSave?: (item: T, isUpdate: boolean, kstTime?: Date) => Partial<T> | Record<string, any>;
  
  /** ìƒì„¸ ì •ë³´ í•„ë“œ */
  detailsField?: string;
  
  /** ì¹´ìš´íŠ¸ í•„ë“œ */
  countField?: string;
  
  /** ë¹ˆ ì•„ì´í…œ ìƒì„± í•¨ìˆ˜ */
  getEmptyItem?: () => T;
  
  /** ì•„ì´í…œ ì œëª© ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜ */
  getItemTitle?: (item: T) => string;
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/bridge.ts
------------------------------------------------------------
// src/features/cve/types/bridge.ts
import {
    GeneratedCVEDetail,
    GeneratedReference,
    GeneratedPoC,
    GeneratedSnortRule,
    GeneratedModificationHistory,
    GeneratedChangeItem
  } from './generated/cve';
  
import { GeneratedComment } from './generated/comment';

// íƒ€ì… ë§¤í•‘ - ê¸°ì¡´ í•„ë“œëª…(snake_case)ì—ì„œ ìë™ ìƒì„± íƒ€ì…(camelCase)ìœ¼ë¡œì˜ ë¸Œë¦¿ì§€
// CVE ìƒì„±/ì—…ë°ì´íŠ¸ ìš”ì²­ ì‹œ humps ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì˜í•´ ìë™ìœ¼ë¡œ snake_caseë¡œ ë³€í™˜ë¨

/**
 * ê¸°ë³¸ í™•ì¥ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
 * ê¸°ì¡´ ì½”ë“œì™€ì˜ í˜¸í™˜ì„±ì„ ìœ„í•´ í•„ë“œ ë§¤í•‘
 */
export interface CVEDetail extends Omit<GeneratedCVEDetail, 'reference' | 'poc' | 'snortRule' | 'modificationHistory' | 'comments'> {
  id?: string;
  reference: Reference[];
  poc: PoC[];
  snortRule: SnortRule[];
  modificationHistory: ModificationHistory[];
  comments?: Comment[];
  createdAt?: string | Date;
  lastModifiedAt?: string | Date;
  [key: string]: unknown;
}

export interface Reference extends GeneratedReference {
  id?: string;
  [key: string]: unknown;
}

export interface PoC extends Omit<GeneratedPoC, 'source'> {
  id?: string;
  code: string; // 'source' ëŒ€ì‹  'code' í•„ë“œ ì‚¬ìš©
  language?: string;
  [key: string]: unknown;
}

export interface SnortRule extends GeneratedSnortRule {
  id?: string;
  [key: string]: unknown;
}

export interface Comment extends Omit<GeneratedComment, 'id'> {
  id?: string;
  children?: Comment[];
  [key: string]: unknown;
}

export interface ChangeItem extends GeneratedChangeItem {
  [key: string]: unknown;
}

export interface ModificationHistory extends GeneratedModificationHistory {
  id?: string;
  [key: string]: unknown;
}

// ì£¼ì˜: API ìš”ì²­ ì‹œ í”„ë¡ íŠ¸ì—”ë“œì˜ ì¹´ë©œì¼€ì´ìŠ¤ í•„ë“œëª…ì€
// axios interceptorì— ì˜í•´ ìë™ìœ¼ë¡œ ìŠ¤ë„¤ì´í¬ì¼€ì´ìŠ¤ë¡œ ë³€í™˜ë¨
// config.jsì— ì„¤ì •ëœ CASE_CONVERSION_CONFIGì— ë”°ë¼ ì¼ë¶€ í•„ë“œëŠ” ë³€í™˜ì—ì„œ ì œì™¸ë  ìˆ˜ ìˆìŒ


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/MentionTypes.ts
------------------------------------------------------------
import React from 'react';

/**
 * ë©˜ì…˜ ê°€ëŠ¥í•œ ì‚¬ìš©ì íƒ€ì…
 */
export interface MentionUser {
  /** ì‚¬ìš©ì ID (ì¼ë°˜ì ìœ¼ë¡œ username) */
  id: string;
  
  /** í‘œì‹œ ì´ë¦„ */
  display: string;
  
  /** ì‚¬ìš©ìëª… (idì™€ ë™ì¼í•  ìˆ˜ ìˆìŒ) */
  username?: string;
  
  /** í”„ë¡œí•„ ì´ë¯¸ì§€ URL */
  profileImage?: string;
}

/**
 * ë©˜ì…˜ ìƒíƒœ íƒ€ì… ì •ì˜
 */
export interface MentionState {
  /** í™œì„±í™” ì—¬ë¶€ */
  active: boolean;
  
  /** ê²€ìƒ‰ ì¿¼ë¦¬ */
  query: string;
  
  /** ì‹œì‘ ìœ„ì¹˜ */
  startPos: number;
}

/**
 * MentionInput ì»´í¬ë„ŒíŠ¸ Props ì¸í„°í˜ì´ìŠ¤
 */
export interface MentionInputProps {
  /** ì…ë ¥ ê°’ */
  value: string;
  
  /** ì…ë ¥ ê°’ ë³€ê²½ í•¸ë“¤ëŸ¬ */
  onChange: (value: string | React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void;
  
  /** ì œì¶œ í•¸ë“¤ëŸ¬ (Enter í‚¤ ë“± ì‚¬ìš© ì‹œ) */
  onSubmit?: (value: string) => void;
  
  /** í”Œë ˆì´ìŠ¤í™€ë” í…ìŠ¤íŠ¸ */
  placeholder?: string;
  
  /** ë¡œë”© ìƒíƒœ ì—¬ë¶€ */
  loading?: boolean;
  
  /** ì „ì²´ ë„ˆë¹„ ì°¨ì§€ ì—¬ë¶€ */
  fullWidth?: boolean;
  
  /** ì—¬ëŸ¬ ì¤„ ì…ë ¥ ê°€ëŠ¥ ì—¬ë¶€ */
  multiline?: boolean;
  
  /** ë©€í‹°ë¼ì¸ì¼ ê²½ìš° ê¸°ë³¸ í–‰ ìˆ˜ */
  rows?: number;
  
  /** ì…ë ¥ ì»´í¬ë„ŒíŠ¸ variant */
  variant?: 'outlined' | 'filled' | 'standard';
  
  /** ì…ë ¥ ì»´í¬ë„ŒíŠ¸ í¬ê¸° */
  size?: 'small' | 'medium';
  
  /** ë©˜ì…˜ ê°€ëŠ¥í•œ ì‚¬ìš©ì ëª©ë¡ */
  users?: MentionUser[];
  
  /** ì…ë ¥ ìš”ì†Œ ref */
  inputRef?: React.RefObject<HTMLDivElement>;
  
  /** ì»´í¬ë„ŒíŠ¸ í‚¤ (ë¦¬ë Œë”ë§ ì œì–´ìš©) */
  key?: number | string;
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/types/cve.ts
------------------------------------------------------------
/**
 * CVE ê´€ë ¨ íƒ€ì… ì •ì˜ íŒŒì¼
 */

// ìƒì„±ëœ íƒ€ì… ì„í¬íŠ¸
import {
  GeneratedCVEDetail,
  GeneratedPoC,
  GeneratedReference,
  GeneratedSnortRule,
  GeneratedModificationHistory,
  GeneratedChangeItem,
  // í•„ìš”í•œ ë‹¤ë¥¸ ìƒì„±ëœ íƒ€ì…ë“¤...
} from './generated/cve';

// GeneratedComment íƒ€ì… import
import { GeneratedComment } from './generated/comment';

// ë‹¤ë¥¸ íƒ€ì… íŒŒì¼ì—ì„œ ì¤‘ë³µëœ íƒ€ì… ì„í¬íŠ¸
import { CommentProps as ImportedCommentProps } from './CommentTypes';
import { CommentsTabProps as ImportedCommentsTabProps } from './CommentTypes';
import { MentionUser as ImportedMentionUser } from './MentionTypes';
import { TabConfig as ImportedTabConfig } from './TabTypes';
import { SeverityChipProps as ImportedSeverityChipProps } from './UITypes';
import { TabPanelProps as ImportedTabPanelProps } from './UITypes';

// ì¤‘ë³µ íƒ€ì…ì„ ì¬ë‚´ë³´ë‚´ê¸° (íƒ€ì… í˜¸í™˜ì„± ìœ ì§€)
export type CommentProps = ImportedCommentProps;
export type CommentsTabProps = ImportedCommentsTabProps;
export type MentionUser = ImportedMentionUser;
export type TabConfig = ImportedTabConfig;
export type SeverityChipProps = ImportedSeverityChipProps;
export type TabPanelProps = ImportedTabPanelProps;

/**
 * CVE ê¸°ë³¸ ì •ë³´ ì¸í„°í˜ì´ìŠ¤
*/
export interface CVEBase {
  id?: string;
  cveId: string;
  title?: string;
  status: string;
  createdAt: string | Date;
  lastModifiedAt?: string | Date;
  severity?: string;
}

/**
 * CVE ëª©ë¡ ì‘ë‹µ ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEListResponse {
  items: CVEBase[];
  total: number;
  page: number;
  limit: number;
}

/**
 * CVE ìƒì„¸ ì •ë³´ ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEDetail extends CVEBase {
  description?: string;
  reference: Reference[];
  poc: PoC[];
  snortRule: SnortRule[];
  modificationHistory: ModificationHistory[];
  createdBy?: string;
  lastModifiedBy?: string;
  comments?: Comment[];
  // CVEDetailData íƒ€ì…ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ ì¶”ê°€
  [key: string]: unknown;
}

/**
 * CVE ìƒì„¸ ë°ì´í„° ì¸í„°í˜ì´ìŠ¤ - API ì‘ë‹µ ë˜ëŠ” ìºì‹œëœ ë°ì´í„°ë¥¼ ìœ„í•œ í™•ì¥ ì¸í„°í˜ì´ìŠ¤
 * ë°±ì—”ë“œì™€ í”„ë¡ íŠ¸ì—”ë“œ ê°„ì˜ í•„ë“œëª… ì°¨ì´ë¥¼ í—ˆìš©í•˜ê¸° ìœ„í•œ ìœ ì—°í•œ ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEDetailData {
  cveId: string;
  createdAt?: string | Date;
  created_at?: string | Date;
  lastModifiedAt?: string | Date;
  last_modified_at?: string | Date;
  fromCache?: boolean;
  _cachedAt?: number | string;
  cachedAt?: number | string;
  poc?: unknown[];
  PoC?: unknown[];
  pocList?: unknown[];
  snortRule?: unknown[];
  snort_rule?: unknown[];
  reference?: unknown[];
  ref?: unknown[];
  comments?: Comment[];
  [key: string]: unknown;
}

/**
 * ì°¸ê³ ìë£Œ ì¸í„°í˜ì´ìŠ¤
 * ì¤‘ì•™í™”ëœ íƒ€ì… ì •ì˜ë¥¼ í™•ì¥
 */
export interface Reference extends GeneratedReference {
  id?: string;
  // CVEData íƒ€ì…ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ ì¶”ê°€
  [key: string]: unknown;
}

/**
 * PoC (Proof of Concept) ì¸í„°í˜ì´ìŠ¤
 * ì¤‘ì•™í™”ëœ íƒ€ì… ì •ì˜ë¥¼ í™•ì¥
 */
export interface PoC extends Omit<GeneratedPoC, 'source'> {
  id?: string;
  code: string;
  language?: string;
  // CVEData íƒ€ì…ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ ì¶”ê°€
  [key: string]: unknown;
}

/**
 * Snort Rule ì¸í„°í˜ì´ìŠ¤
 * ì¤‘ì•™í™”ëœ íƒ€ì… ì •ì˜ë¥¼ í™•ì¥
 */
export interface SnortRule extends GeneratedSnortRule {
  id?: string;
  // CVEData íƒ€ì…ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ ì¶”ê°€
  [key: string]: unknown;
}

/**
 * ìˆ˜ì • ê¸°ë¡ í•­ëª© ì¸í„°í˜ì´ìŠ¤
 * ì¤‘ì•™í™”ëœ íƒ€ì… ì •ì˜ë¥¼ í™•ì¥
 */
export interface ChangeItem extends GeneratedChangeItem {
  // í˜¸í™˜ì„±ì„ ìœ„í•œ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜
  [key: string]: unknown;
}

/**
 * ìˆ˜ì • ê¸°ë¡ ì¸í„°í˜ì´ìŠ¤
 * ì¤‘ì•™í™”ëœ íƒ€ì… ì •ì˜ë¥¼ í™•ì¥
 */
export interface ModificationHistory extends GeneratedModificationHistory {
  id?: string;
  // í˜¸í™˜ì„±ì„ ìœ„í•œ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜
  [key: string]: unknown;
}

/**
 * ëŒ“ê¸€ ì¸í„°í˜ì´ìŠ¤
 * ì¤‘ì•™í™”ëœ íƒ€ì… ì •ì˜ë¥¼ í™•ì¥
 */
export interface Comment extends Omit<GeneratedComment, 'id'> {
  id?: string;
  // í˜¸í™˜ì„±ì„ ìœ„í•œ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜
  [key: string]: unknown;
}

/**
 * í™•ì¥ëœ ëŒ“ê¸€ ì¸í„°í˜ì´ìŠ¤ (Comment ì»´í¬ë„ŒíŠ¸ìš©)
 */
export interface CommentExtended extends Comment {
  parentId?: string;
  depth?: number;
  lastModifiedAt?: string | Date;
}

/**
 * ëŒ“ê¸€ ìƒíƒœ ê´€ë¦¬ ì¸í„°í˜ì´ìŠ¤
 */
export interface CommentState {
  editingId: string | null;
  replyingToId: string | null;
  comments: Comment[];
  loading: boolean;
  error: string | null;
}

/**
 * êµ¬ë…ì ì¸í„°í˜ì´ìŠ¤
 */
export interface Subscriber {
  id?: string;
  userId?: string;
  displayName?: string;
  username?: string;
  profile_image?: string;
  profileImage?: string;
}

/**
 * ìƒˆë¡œê³ ì¹¨ íŠ¸ë¦¬ê±° ì¸í„°í˜ì´ìŠ¤
 */
export interface RefreshTriggers {
  general: number;
  poc: number;
  snortRule: number;
  reference: number;
  comments: number;
  history: number;
}

/**
 * íƒ­ ì¹´ìš´íŠ¸ ì¸í„°í˜ì´ìŠ¤
 */
export interface TabCounts {
  poc: number;
  snortRule: number;
  reference: number;
  comments: number;
}

/**
 * CVE ìƒì„¸ í—¤ë” Props ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEDetailHeaderProps {
  cveId: string;
  subscribers: Subscriber[];
  createdAt: string | Date;
  lastModifiedAt: string | Date;
  isCached: boolean;
  isLoading: boolean;
  onRefresh: () => void;
  onClose: () => void;
}

/**
 * CVE ìƒì„¸ ì •ë³´ íŒ¨ë„ Props ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEDetailInfoPanelProps {
  cveData: CVEDetailData;
  onUpdateField: (field: string, value: unknown) => Promise<void>;
  canEdit: boolean;
}

/**
 * CVE ìƒì„¸ íƒ­ Props ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEDetailTabsProps {
  cveData: CVEDetailData;
  currentUser: unknown;
  refreshTriggers: RefreshTriggers;
  tabCounts: TabCounts;
  onCountChange: (tabKey: keyof TabCounts, count: number) => void;
  parentSendMessage: (type: string, data: Record<string, unknown>) => Promise<boolean | null>;
  highlightCommentId?: string | null;
}

/**
 * CVE ìƒì„¸ ì»´í¬ë„ŒíŠ¸ Props ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEDetailProps {
  cveId?: string;
  open?: boolean;
  onClose: () => void;
  highlightCommentId?: string | null;
}

/**
 * êµ¬ë…ì ìˆ˜ í‘œì‹œ ì»´í¬ë„ŒíŠ¸ Props ì¸í„°í˜ì´ìŠ¤
 */
export interface SubscriberCountProps {
  subscribers: Subscriber[];
  cveId?: string;
}

/**
 * CVE í•„í„°ë§ ì˜µì…˜ ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEFilterOptions {
  page?: number;
  rowsPerPage?: number;
  search?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  filters?: Record<string, any>;
}

/**
 * CVE ì—…ë°ì´íŠ¸ ìš”ì²­ ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEUpdateRequest {
  title?: string;
  description?: string;
  status?: string;
  severity?: string;
  reference?: Reference[];
  poc?: PoC[];
  snortRule?: SnortRule[];
}

/**
 * ì‘ì—… ê²°ê³¼ ì‘ë‹µ ì¸í„°í˜ì´ìŠ¤
 */
export interface OperationResponse {
  success: boolean;
  message: string;
  data?: any;
}

/**
 * API ì‘ë‹µ ì¸í„°í˜ì´ìŠ¤ (ì œë„¤ë¦­)
 */
export interface ApiResponse<T> {
  data?: T;
  success?: boolean;
  message?: string;
  status?: number;
  [key: string]: unknown;
}

/**
 * CreateCVE í¼ ë°ì´í„° ì¸í„°í˜ì´ìŠ¤
 */
export interface FormData {
  cveId: string;
  title: string;
  description: string;
  status: string;
  severity: string;
  tags: string[];
  exploitStatus: string;
}

/**
 * PoC (Proof of Concept) íŒŒì¼ ì¸í„°í˜ì´ìŠ¤
 */
export interface PoCFile {
  id?: string;
  source: string;
  url: string;
  created_by?: string;
  last_modified_by?: string;
}

/**
 * Snort ê·œì¹™ íŒŒì¼ ì¸í„°í˜ì´ìŠ¤
 */
export interface SnortRuleFile {
  id?: string;
  rule: string;
  type: string;
  created_by?: string;
  last_modified_by?: string;
}

/**
 * ì°¸ì¡° URL ì¸í„°í˜ì´ìŠ¤
 */
export interface ReferenceFile {
  id?: string;
  url: string;
  createdAt?: string;
  createdBy?: string;
  lastModifiedAt?: string | null;
  lastModifiedBy?: string;
}

/**
 * CVE ë°ì´í„° ì¸í„°í˜ì´ìŠ¤ (CreateCVE ì»´í¬ë„ŒíŠ¸ìš©)
 */
export interface CVEData extends FormData {
  poc: Omit<PoCFile, 'id'>[];
  snortRule: Omit<SnortRuleFile, 'id'>[];
  reference: Omit<ReferenceFile, 'id'>[];
}

/**
 * ì„ íƒ ì˜µì…˜ ì¸í„°í˜ì´ìŠ¤
 */
export interface SelectOption {
  value: string;
  label: string;
}

/**
 * GenericDataTabì˜ ê¸°ë³¸ í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface GenericDataTabBaseProps {
  cveData: CVEDetail;
  refreshTrigger?: number;
  currentUser?: { username: string; [key: string]: any };
  canEdit?: boolean;
  onTabCountChange?: (key: string, count: number) => void;
  parentSendMessage?: (type: string, data: Record<string, any>) => Promise<boolean | null>;
}

/**
 * SnortRuleTab ì»´í¬ë„ŒíŠ¸ì˜ í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface SnortRuleTabProps extends GenericDataTabBaseProps {}

/**
 * PoCTab ì»´í¬ë„ŒíŠ¸ì˜ í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface PoCTabProps extends GenericDataTabBaseProps {}

/**
 * ReferenceTab ì»´í¬ë„ŒíŠ¸ì˜ í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface ReferenceTabProps extends GenericDataTabBaseProps {}

/**
 * GenericDataTab í”„ë¡­ìŠ¤ ì¸í„°í˜ì´ìŠ¤
 */
export interface GenericDataTabProps extends GenericDataTabBaseProps {
  tabConfig: ImportedTabConfig; // ë³€ê²½ëœ ë¶€ë¶„
}

/**
 * ì›¹ì†Œì¼“ ì—…ë°ì´íŠ¸ ë°ì´í„° ì¸í„°í˜ì´ìŠ¤
 */
export interface WebSocketUpdateData {
  id?: string;
  cveId?: string;
  field?: string;
  field_key?: string;
  value?: unknown;
  data?: Record<string, unknown>;
  timestamp?: string | number;
  senderId?: string;
  event?: string;
  updateId?: number | string;
  updatedData?: Record<string, any>;
  [key: string]: unknown;
}

/**
 * ìš´ì˜ ì¤‘ì¸ ëŒ“ê¸€ ìˆ˜ ê³„ì‚° í•¨ìˆ˜
 * @param comments ëŒ“ê¸€ ë°°ì—´ (ì¤‘ì²© ëŒ“ê¸€ í¬í•¨)
 * @returns ì‚­ì œë˜ì§€ ì•Šì€ ëŒ“ê¸€ì˜ ì´ ê°œìˆ˜
 */
export const countActiveComments = (comments?: Comment[]): number => {
  if (!comments || !Array.isArray(comments)) return 0;
  
  let count = 0;
  comments.forEach(comment => {
    // ì‚­ì œë˜ì§€ ì•Šì€ ëŒ“ê¸€ë§Œ ìª½ìˆ˜
    if (!(comment.isDeleted || comment.is_deleted)) {
      count++;
    }
    // ì¤‘ì²© ëŒ“ê¸€ ì²˜ë¦¬
    if (comment.children && Array.isArray(comment.children)) {
      count += countActiveComments(comment.children);
    }
  });
  
  return count;
};

/**
 * HistoryTab ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ëŠ” ìˆ˜ì • ì´ë ¥ ì¸í„°í˜ì´ìŠ¤
 */
export interface HistoryChange {
  /**
   * ë³€ê²½ëœ í•„ë“œëª…
   */
  field: string;
  
  /**
   * í‘œì‹œìš© í•„ë“œëª…
   */
  fieldName?: string;
  
  /**
   * ë³€ê²½ ì•¡ì…˜ (add, edit, delete)
   */
  action: 'add' | 'edit' | 'delete';
  
  /**
   * ë³€ê²½ ë‚´ìš© ìš”ì•½
   */
  summary: string;
  
  /**
   * ìƒì„¸ í‘œì‹œ íƒ€ì…
   */
  detailType?: 'simple' | 'detailed';
  
  /**
   * ë³€ê²½ ì „ ê°’
   */
  before?: string;
  
  /**
   * ë³€ê²½ í›„ ê°’
   */
  after?: string;
  
  /**
   * ë³€ê²½ëœ ì•„ì´í…œ ëª©ë¡ (ë°°ì—´ íƒ€ì… í•„ë“œì˜ ê²½ìš°)
   */
  items?: Array<{
    type?: string;
    rule?: string;
    url?: string;
    [key: string]: unknown;
  }>;
}

/**
 * HistoryTab ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ëŠ” ìˆ˜ì • ì´ë ¥ í•­ëª© ì¸í„°í˜ì´ìŠ¤
 */
export interface HistoryItem {
  /**
   * ìˆ˜ì •í•œ ì‚¬ìš©ìëª…
   */
  username: string;
  
  /**
   * ìˆ˜ì • ì¼ì‹œ
   */
  modifiedAt?: string | Date;
  
  /**
   * ìˆ˜ì • ì¼ì‹œ (ë°±ì—”ë“œ í•„ë“œëª… í˜¸í™˜ìš©)
   */
  lastModifiedAt?: string | Date;
  
  /**
   * ë³€ê²½ ë‚´ì—­ ëª©ë¡
   */
  changes?: HistoryChange[];
}

/**
 * HistoryTab ì»´í¬ë„ŒíŠ¸ Props ì¸í„°í˜ì´ìŠ¤
 */
export interface HistoryTabProps {
  /**
   * ìˆ˜ì • ì´ë ¥ ëª©ë¡
   */
  modificationHistory?: HistoryItem[];
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/CVEDetail.tsx
------------------------------------------------------------
import React, {
  useState,
  useEffect,
  useRef,
  useCallback,
  useMemo,
} from 'react';
import { useSocket } from 'core/socket/hooks/useSocket';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { useQueryClient } from '@tanstack/react-query';
import { useSnackbar } from 'notistack';
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogActions,
  DialogContentText,
  Card,
  CardContent,
  Box,
  Fade,
  CircularProgress,
  Button,
  Typography,
  Chip,
} from '@mui/material';
import logger from 'shared/utils/logging';
import { useUpdateCVEField } from 'features/cve/hooks/useCVEMutation';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { timeAgo } from 'shared/utils/dateUtils';
import { useCVEDetail, useCVERefresh, useCVESubscription } from './hooks';
import {
  ApiResponse,
  Comment,
  CVEDetail as CVEDetailType,
  CVEDetailData,
  CVEDetailHeaderProps,
  CVEDetailInfoPanelProps,
  CVEDetailProps,
  CVEDetailTabsProps,
  RefreshTriggers,
  Subscriber,
  TabCounts,
  WebSocketUpdateData,
  countActiveComments
} from './types/cve';

import CVEDetailHeader from './CVEDetailHeader';
import CVEDetailInfoPanel from './CVEDetailInfoPanel';
import CVEDetailTabs from './CVEDetailTabs';

// --- ë©”ì¸ ì»´í¬ë„ŒíŠ¸ ---
const CVEDetail: React.FC<CVEDetailProps> = ({ cveId: propsCveId, open = false, onClose, highlightCommentId = null }) => {
  const { enqueueSnackbar, closeSnackbar } = useSnackbar();
  const { socket, connected } = useSocket();
  const { user: currentUser } = useAuth();
  const queryClient = useQueryClient();

  // í”„ë¡ íŠ¸ì—”ë“œì™€ ë°±ì—”ë“œ í•„ë“œëª… ë§¤í•‘ (ì›¹ì†Œì¼“ ì—…ë°ì´íŠ¸ ì²˜ë¦¬ìš©)
  const fieldMapping = useRef<Record<string, string>>({
    status: 'status',
    title: 'title',
    description: 'description',
    severity: 'severity',
    cveId: 'cve_id',
    poc: 'poc',
    snortRule: 'snort_rule',
    reference: 'reference',
    comments: 'comments',
    createdAt: 'created_at',
    lastModifiedAt: 'last_modified_at',
    lastModifiedBy: 'last_modified_by',
    modificationHistory: 'modification_history',
    tags: 'tags',
  }).current;

  // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ë¡œê·¸ ë ˆë²¨ì„ DEBUGë¡œ ì„¤ì • (ë””ë²„ê¹… ëª©ì )
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      // @ts-ignore - logger.setLogLevel íƒ€ì… ì—ëŸ¬ ë¬´ì‹œ
      logger.setLogLevel(0); // DEBUG ë ˆë²¨ ì„¤ì •
      logger.debug('CVEDetail: ë¡œê·¸ ë ˆë²¨ì„ DEBUGë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤.');
    }
  }, []);

  // --- ìƒíƒœ ê´€ë¦¬ ---
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [isCached, setIsCached] = useState<boolean>(false);
  const [errorDialogOpen, setErrorDialogOpen] = useState<boolean>(false);
  const [refreshTriggers, setRefreshTriggers] = useState<RefreshTriggers>({
    general: 0,
    poc: 0,
    snortRule: 0,
    reference: 0,
    comments: 0,
    history: 0,
  });
  const [tabCounts, setTabCounts] = useState<TabCounts>({
    poc: 0,
    snortRule: 0,
    reference: 0,
    comments: 0,
  });

  // --- Refs ---
  const socketRef = useRef(socket);
  const connectedRef = useRef(connected);
  const snackbarShown = useRef<boolean>(false);
  const refreshTriggersRef = useRef<RefreshTriggers>(refreshTriggers);
  const lastProcessedUpdateIdRef = useRef<Record<string, number | string>>({});
  const currentUserRef = useRef<typeof currentUser | null>(null);
  const isFirstLoadRef = useRef<boolean>(true);
  const isSubscribedRef = useRef<boolean>(false);
  // êµ¬ë… ê´€ë ¨ ì¶”ê°€ Refs
  const hasAttemptedSubscriptionRef = useRef<boolean>(false);
  const isModalOpenRef = useRef<boolean>(false);

  // Socket.IO ì„œë¹„ìŠ¤ ì°¸ì¡°
  const socketServiceRef = useRef(socket?.socketService).current;

  // êµ¬ë… ê´€ë ¨ ìƒíƒœì™€ ê¸°ëŠ¥
  const { isSubscribed, isLoading: isSubscriptionLoading, subscribe, unsubscribe, getSubscribers } = useCVESubscription(propsCveId);
  
  // ê¸°ì¡´ êµ¬ë… ìƒíƒœ ì°¸ì¡° ìœ ì§€ (ìµœì‹  ìƒíƒœ ì ‘ê·¼ìš©)
  isSubscribedRef.current = isSubscribed;
  
  // êµ¬ë… ìƒíƒœê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ì°¸ì¡° ì—…ë°ì´íŠ¸
  useEffect(() => {
    isSubscribedRef.current = isSubscribed;
  }, [isSubscribed]);

  // --- Hooks ---
  // í˜„ì¬ ì‚¬ìš©ì ì°¸ì¡° ìœ ì§€
  useEffect(() => {
    currentUserRef.current = currentUser;
  }, [currentUser]);

  // ì†Œì¼“ ì°¸ì¡° ìœ ì§€
  useEffect(() => {
    socketRef.current = socket;
    connectedRef.current = connected;
    
    if (process.env.NODE_ENV === 'development') {
      logger.info('CVEDetail', 'ì†Œì¼“ ì°¸ì¡° ì—…ë°ì´íŠ¸ë¨ (ë©”ì¸ ì»´í¬ë„ŒíŠ¸)', {
        socketId: socket?.id,
        connected,
        hasSocket: !!socket,
      });
    }
  }, [socket, connected]);

  // ëª¨ë‹¬ ìƒíƒœ ì°¸ì¡° ìœ ì§€
  useEffect(() => {
    isModalOpenRef.current = open;
  }, [open]);

  // êµ¬ë…ì ì •ë³´ (ì¤‘ì•™ ê´€ë¦¬ ì‹œìŠ¤í…œì—ì„œ ê°€ì ¸ì˜´)
  const subscribers = useMemo(() => {
    return getSubscribers();
  }, [getSubscribers, propsCveId, isSubscribed]);

  // êµ¬ë… ìƒíƒœ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleSubscription = useCallback(() => {
    if (isSubscribed) {
      unsubscribe();
    } else {
      subscribe();
    }
  }, [isSubscribed, subscribe, unsubscribe]);

  // React Query: CVE ìƒì„¸ ì •ë³´ ì¡°íšŒ
  const {
    data: cveData,
    isLoading: isQueryLoading,
    isFetching,
    dataUpdatedAt,
    error: queryError,
    refetch: refetchCveDetail,
  } = useCVEDetail(propsCveId || '', {
    enabled: !!propsCveId && open,
    refetchOnReconnect: false,
    // @ts-ignore - íƒ€ì… ì •ì˜ì™€ ì‹¤ì œ ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬í˜„ ê°„ì˜ ë¶ˆì¼ì¹˜ ë¬´ì‹œ
    onSuccess: (data: CVEDetailData) => {
      logger.info('CVEDetail', 'ë°ì´í„° ë¡œë”© ì„±ê³µ', { dataReceived: !!data });
      if (snackbarShown.current) {
        closeSnackbar();
      }
      updateTabCounts(data);
      setIsCached(false);
      setLoading(false);
      setError(null);
      setErrorDialogOpen(false);
    },
    onError: (err: Error) => {
      logger.error('CVEDetail', 'ë°ì´í„° ë¡œë”© ì‹¤íŒ¨', { error: err.message });
      if (snackbarShown.current) {
        closeSnackbar();
      }
      enqueueSnackbar(`ë°ì´í„° ë¡œë”© ì‹¤íŒ¨: ${err.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`, {
        variant: 'error',
      });
      setError(err.message || 'ë°ì´í„° ë¡œë”© ì‹¤íŒ¨');
      setLoading(false);
      setErrorDialogOpen(true);
    },
  });

  // ìºì‹œ ìƒíƒœ í™•ì¸
  const isDataFromCache = useMemo(() => {
    if (cveData && dataUpdatedAt) {
      const cacheThreshold = 30 * 1000;
      return Date.now() - dataUpdatedAt > cacheThreshold;
    }
    return false;
  }, [cveData, dataUpdatedAt]);

  // ìºì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸
  useEffect(() => {
    setIsCached(isDataFromCache);
  }, [isDataFromCache]);

  // íƒ­ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
  const updateTabCounts = useCallback((data: CVEDetailData) => {
    if (!data) {
      logger.warn('updateTabCounts: ë°ì´í„°ê°€ ì—†ì–´ ì¹´ìš´íŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      setTabCounts({ poc: 0, snortRule: 0, reference: 0, comments: 0 });
      return;
    }
    
    const newCounts: TabCounts = {
      poc:
        data.poc?.length ??
        data.PoC?.length ??
        data.pocList?.length ??
        0,
      snortRule: data.snortRule?.length ?? data.snort_rule?.length ?? 0,
      reference: data.reference?.length ?? data.ref?.length ?? 0,
      comments: countActiveComments(data.comments),
    };
    setTabCounts(newCounts);
  }, []);

  // CVE ìƒˆë¡œê³ ì¹¨ í›…
  const { mutate: refreshCVE, isLoading: isRefreshing } = useCVERefresh(
    propsCveId || ''
  );
  
  // CVE í•„ë“œ ì—…ë°ì´íŠ¸ í›…
  const { mutate: updateCVEField } = useUpdateCVEField();

  // í•„ë“œ ì—…ë°ì´íŠ¸ í•¸ë“¤ëŸ¬
  const handleFieldUpdate = useCallback((field: string, value: unknown) => {
    if (!propsCveId || !field) {
      logger.warn('handleFieldUpdate: cveId ë˜ëŠ” fieldê°€ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }
    
    if (!cveData || cveData[field] === value) {
      logger.info('handleFieldUpdate: ë³€ê²½ ì‚¬í•­ ì—†ìŒ', { field, value });
      return;
    }
    
    logger.info('handleFieldUpdate ì‹œì‘', { field, value });
    const fieldMappingLocal: Record<string, string> = {
      title: 'title',
      description: 'description',
      status: 'status',
      severity: 'severity',
    };
    
    const backendField = fieldMappingLocal[field] || field;
    const cachedData = queryClient.getQueryData<CVEDetailData>(
      QUERY_KEYS.CVE.detail(propsCveId)
    );
    
    if (cachedData) {
      // ë‚™ê´€ì  ì—…ë°ì´íŠ¸
      const optimisticData = { ...cachedData, [field]: value };
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(propsCveId), optimisticData);
      logger.info('handleFieldUpdate: ìºì‹œ ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì™„ë£Œ', { field, value });
    }
    
    setLoading(true);
    updateCVEField(
      { cveId: propsCveId, fieldName: backendField, fieldValue: value },
      {
        // @ts-ignore - ApiResponseì™€ CVEDetailData íƒ€ì… ë¶ˆì¼ì¹˜ ë¬´ì‹œ
        onSuccess: (updatedData: any) => {
          logger.info('CVEDetail', `í•„ë“œ ì—…ë°ì´íŠ¸ ì„±ê³µ: ${field}`, {
            response: updatedData,
          });
          enqueueSnackbar(`${field} ì—…ë°ì´íŠ¸ ì„±ê³µ`, {
            variant: 'success',
            autoHideDuration: 1500,
          });
          
          // ì£¼ìš” í•„ë“œ ë³€ê²½ ì‹œ ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”
          if (['title', 'status', 'severity'].includes(field)) {
            logger.info('CVEDetail: ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™” ì¤‘...');
            queryClient.invalidateQueries({
              predicate: (query) =>
                Array.isArray(query.queryKey) &&
                query.queryKey[0] === QUERY_KEYS.CVE.list()[0],
            });
          }
        },
        onError: (err: Error) => {
          logger.error('CVEDetail', `í•„ë“œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${field}`, {
            error: err.message,
          });
          enqueueSnackbar(
            `ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (${field}): ${err.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`,
            { variant: 'error' }
          );
          
          // ì˜¤ë¥˜ ì‹œ ìºì‹œ ë¡¤ë°±
          if (cachedData) {
            queryClient.setQueryData(
              QUERY_KEYS.CVE.detail(propsCveId),
              cachedData
            );
            logger.info('handleFieldUpdate: ìºì‹œ ë¡¤ë°± ì™„ë£Œ', { field });
          }
        },
        onSettled: () => {
          setLoading(false);
          logger.info('handleFieldUpdate: ì™„ë£Œ (ì„±ê³µ/ì‹¤íŒ¨ ë¬´ê´€)', { field });
        },
      }
    );
  }, [propsCveId, cveData, updateCVEField, queryClient, enqueueSnackbar]);

  // ì œëª© ì—…ë°ì´íŠ¸ í•¸ë“¤ëŸ¬
  const handleTitleUpdate = useCallback((newTitle: string) => {
    if (!cveData || !propsCveId || newTitle === cveData.title) return;
    handleFieldUpdate('title', newTitle);
  }, [cveData, propsCveId, handleFieldUpdate]);

  // ì„¤ëª… ì—…ë°ì´íŠ¸ í•¸ë“¤ëŸ¬
  const handleDescriptionUpdate = useCallback((newDescription: string) => {
    if (!cveData || !propsCveId || newDescription === cveData.description) return;
    handleFieldUpdate('description', newDescription);
  }, [cveData, propsCveId, handleFieldUpdate]);

  // ì›¹ì†Œì¼“ ì—…ë°ì´íŠ¸ ì²˜ë¦¬ í•¸ë“¤ëŸ¬
  const handleWebSocketUpdate = useCallback((data: WebSocketUpdateData) => {
    logger.info('CVEDetail', 'ì›¹ì†Œì¼“ ì—…ë°ì´íŠ¸ ìˆ˜ì‹ ', data);
    if (!data) return;
    
    const fieldKey = data.field_key || data.field || 'general';
    const updateId = data.updateId || Date.now();
    
    // ì¤‘ë³µ ì—…ë°ì´íŠ¸ í•„í„°ë§
    if (lastProcessedUpdateIdRef.current[fieldKey] === updateId) {
      logger.info('CVEDetail', `ì¤‘ë³µ ì›¹ì†Œì¼“ ì—…ë°ì´íŠ¸ ë¬´ì‹œ: ${fieldKey}, ID: ${updateId}`);
      return;
    }
    
    // ì—…ë°ì´íŠ¸ ID ê¸°ë¡
    lastProcessedUpdateIdRef.current[fieldKey] = updateId;
    
    // ë¦¬í”„ë ˆì‹œ íŠ¸ë¦¬ê±° ì—…ë°ì´íŠ¸
    const newTriggers = {
      ...refreshTriggersRef.current,
      [fieldKey]: (refreshTriggersRef.current[fieldKey as keyof RefreshTriggers] || 0) + 1
    };
    
    refreshTriggersRef.current = newTriggers;
    setRefreshTriggers(newTriggers);
    
    logger.info('CVEDetail: Refresh trigger ì—…ë°ì´íŠ¸', {
      fieldKey,
      newTrigger: newTriggers[fieldKey as keyof RefreshTriggers],
    });
    
    // ëŒ“ê¸€ ì—…ë°ì´íŠ¸ëŠ” CommentsTabì—ì„œ ë³„ë„ ì²˜ë¦¬
    if (fieldKey === 'comments') {
      logger.info('CVEDetail: ëŒ“ê¸€ ì—…ë°ì´íŠ¸ëŠ” CommentsTabì—ì„œ ì²˜ë¦¬');
      return;
    }
    
    // ë¡œë”© ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ìºì‹œ ì—…ë°ì´íŠ¸
    if (!loading) {
      try {
        const cachedData = queryClient.getQueryData<CVEDetailData>(
          QUERY_KEYS.CVE.detail(propsCveId)
        );
        
        if (cachedData && data.updatedData) {
          logger.info('CVEDetail', `${fieldKey} í•„ë“œ ì›¹ì†Œì¼“ ì—…ë°ì´íŠ¸ - ìºì‹œ ì§ì ‘ ì—…ë°ì´íŠ¸`);
          let updatedCacheData = { ...cachedData };
          
          // ì „ì²´ ë°ì´í„° ì—…ë°ì´íŠ¸
          if (fieldKey === 'all') {
            updatedCacheData = { ...updatedCacheData, ...(data.updatedData as Record<string, any>) };
          } 
          // íŠ¹ì • í•„ë“œ ì—…ë°ì´íŠ¸
          else if (data.updatedData.hasOwnProperty(fieldKey)) {
            (updatedCacheData as any)[fieldKey] = data.updatedData[fieldKey];
            
            // í”„ë¡ íŠ¸ì—”ë“œ í•„ë“œëª… ë§¤í•‘ ì²˜ë¦¬
            const frontendField = Object.keys(fieldMapping).find(
              (key) => fieldMapping[key] === fieldKey
            );
            if (frontendField) {
              (updatedCacheData as any)[frontendField] = data.updatedData[fieldKey];
            }
          } 
          // íŠ¹ìˆ˜ í•„ë“œ ì²˜ë¦¬
          else {
            if (fieldKey === 'poc' && data.updatedData.poc)
              updatedCacheData.poc = data.updatedData.poc;
            else if (fieldKey === 'snort_rule' && data.updatedData.snort_rule)
              updatedCacheData.snortRule = data.updatedData.snort_rule;
            else if (fieldKey === 'reference' && data.updatedData.reference)
              updatedCacheData.reference = data.updatedData.reference;
            else {
              logger.warn('CVEDetail: ì²˜ë¦¬ë˜ì§€ ì•Šì€ ì›¹ì†Œì¼“ í•„ë“œ ì—…ë°ì´íŠ¸', {
                fieldKey,
                updatedData: data.updatedData,
              });
              updatedCacheData = { ...updatedCacheData, ...(data.updatedData as Record<string, any>) };
            }
          }
          
          // ìºì‹œ ì—…ë°ì´íŠ¸
          queryClient.setQueryData(
            QUERY_KEYS.CVE.detail(propsCveId),
            updatedCacheData
          );
          updateTabCounts(updatedCacheData);
        } 
        // ìºì‹œê°€ ì—†ëŠ” ê²½ìš° ì¿¼ë¦¬ ë¬´íš¨í™”
        else if (!cachedData) {
          logger.info('CVEDetail', `ì›¹ì†Œì¼“ ì—…ë°ì´íŠ¸ - ìºì‹œ ì—†ìŒ, ì¿¼ë¦¬ ë¬´íš¨í™”: ${fieldKey}`);
          queryClient.invalidateQueries({
            queryKey: QUERY_KEYS.CVE.detail(propsCveId),
          });
        }
      } catch (error: unknown) {
        const err = error instanceof Error ? error : new Error('Unknown error');
        logger.error('CVEDetail', 'ì›¹ì†Œì¼“ ì—…ë°ì´íŠ¸ ì²˜ë¦¬ ì¤‘ ìºì‹œ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜', {
          error: err.message,
        });
        queryClient.invalidateQueries({
          queryKey: QUERY_KEYS.CVE.detail(propsCveId),
        });
      }
    } else {
      logger.info('CVEDetail: ë¡œë”© ì¤‘ì´ë¯€ë¡œ ì›¹ì†Œì¼“ ì—…ë°ì´íŠ¸ ê±´ë„ˆëœ€', { fieldKey });
    }
    
    // ìŠ¤ë‚µë°” í‘œì‹œ
    if (!snackbarShown.current) {
      snackbarShown.current = true;
      let fieldName = fieldKey;
      enqueueSnackbar(`${fieldName} ì •ë³´ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.`, {
        variant: 'info',
        autoHideDuration: 2500,
        anchorOrigin: { vertical: 'bottom', horizontal: 'right' },
        onClose: () => {
          snackbarShown.current = false;
        },
      });
    }
  }, [enqueueSnackbar, propsCveId, queryClient, loading, updateTabCounts]);

  // CVE ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  const handleCVEUpdated = useCallback((data: WebSocketUpdateData) => {
    if (!data || !(data.cveId === propsCveId || data.id === propsCveId)) return;
    
    logger.info('CVEDetail', '`cve_updated` ì´ë²¤íŠ¸ ìˆ˜ì‹ ', {
      dataId: data.id || data.cveId,
      propsCveId,
      type: data.field_key || data.field || 'general',
    });
    
    handleWebSocketUpdate(data);
  }, [propsCveId, handleWebSocketUpdate]);

  // ìƒˆë¡œê³ ì¹¨ í•¸ë“¤ëŸ¬
  const handleRefresh = useCallback(() => {
    if (!propsCveId || loading) {
      logger.warn('handleRefresh: ì´ë¯¸ ë¡œë”© ì¤‘ì´ê±°ë‚˜ IDê°€ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }
    
    logger.info('handleRefresh: ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì‹œì‘', { cveId: propsCveId });
    
    if (snackbarShown.current) closeSnackbar();
    enqueueSnackbar('ë°ì´í„°ë¥¼ ìƒˆë¡œê³ ì¹¨ ì¤‘ì…ë‹ˆë‹¤...', { variant: 'info' });
    snackbarShown.current = true;
    
    setLoading(true);
    setIsCached(false);
    
    queryClient.invalidateQueries({
      queryKey: QUERY_KEYS.CVE.detail(propsCveId),
    });
    
    refetchCveDetail()
      .then(() => {
        logger.info('handleRefresh: ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì„±ê³µ', { cveId: propsCveId });
        closeSnackbar();
        enqueueSnackbar('ìµœì‹  ë°ì´í„°ë¥¼ ì„±ê³µì ìœ¼ë¡œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤', {
          variant: 'success',
          autoHideDuration: 2000,
        });
        snackbarShown.current = false;
      })
      .catch((error: Error) => {
        logger.error('handleRefresh: ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨', {
          cveId: propsCveId,
          error: error.message,
        });
        closeSnackbar();
        enqueueSnackbar(`ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨: ${error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`, {
          variant: 'error',
        });
        snackbarShown.current = false;
        setError(error.message || 'ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨');
        setErrorDialogOpen(true);
      })
      .finally(() => {
        setLoading(false);
      });
  }, [propsCveId, loading, refetchCveDetail, queryClient, enqueueSnackbar, closeSnackbar]);

  // ë©”ì‹œì§€ ì „ì†¡ í•¸ë“¤ëŸ¬
  const sendMessage = useCallback(async (type: string, data: Record<string, unknown>): Promise<boolean | null> => {
    if (!socketRef.current || !connectedRef.current) {
      logger.warn('sendMessage: ì†Œì¼“ ì—°ê²° ì—†ìŒ', { type });
      enqueueSnackbar('ì„œë²„ ì—°ê²°ì´ ì—†ì–´ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', {
        variant: 'warning',
      });
      return null;
    }
    
    if (!type) {
      logger.error('sendMessage: ì´ë²¤íŠ¸ íƒ€ì… ëˆ„ë½', { data });
      enqueueSnackbar('ë©”ì‹œì§€ ì „ì†¡ ì˜¤ë¥˜: íƒ€ì… ëˆ„ë½', { variant: 'error' });
      return null;
    }
    
    logger.info('sendMessage: ë©”ì‹œì§€ ì „ì†¡ ì‹œë„', {
      type,
      cveId: propsCveId,
      data,
    });
    
    try {
      socketRef.current.emit(type, {
        cve_id: propsCveId,
        ...data,
      });
      
      logger.info('sendMessage: ë©”ì‹œì§€ ì „ì†¡ ì„±ê³µ', { type });
      
      // ì ì‹œ í›„ ì¿¼ë¦¬ ë¬´íš¨í™”
      if (!loading && !isQueryLoading) {
        setTimeout(() => {
          queryClient.invalidateQueries({
            queryKey: QUERY_KEYS.CVE.detail(propsCveId),
          });
        }, 1000);
      }
      
      return true;
    } catch (socketError: unknown) {
      const err = socketError instanceof Error ? socketError : new Error('Unknown error');
      logger.error('sendMessage: ì†Œì¼“ emit ì˜¤ë¥˜', { type, error: err.message });
      enqueueSnackbar('ë©”ì‹œì§€ ì „ì†¡ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', { variant: 'error' });
      return null;
    }
  }, [propsCveId, enqueueSnackbar, queryClient, loading, isQueryLoading]);

  // ì˜¤ë¥˜ ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸° í•¸ë“¤ëŸ¬
  const handleErrorDialogClose = useCallback(() => {
    setErrorDialogOpen(false);
    setError(null);
  }, []);

  // íƒ­ ì¹´ìš´íŠ¸ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleTabCountChange = useCallback((tabKey: keyof TabCounts, count: number) => {
    setTabCounts(prev => {
      if (prev[tabKey] === count) return prev;
      return { ...prev, [tabKey]: count };
    });
  }, []);

  // í¸ì§‘ ê¶Œí•œ í™•ì¸
  const canEdit = useCallback((): boolean => {
    // ì‹¤ì œ ê¶Œí•œ í™•ì¸ ë¡œì§ êµ¬í˜„ ê°€ëŠ¥
    return true;
  }, []);

  // ì˜¤ë¥˜ ë‹¤ì´ì–¼ë¡œê·¸ ë Œë”ë§
  const renderErrorDialog = useCallback((): React.ReactElement => (
    <Dialog
      open={errorDialogOpen}
      onClose={handleErrorDialogClose}
      aria-labelledby="error-dialog-title"
      aria-describedby="error-dialog-description"
    >
      <DialogTitle id="error-dialog-title">ì˜¤ë¥˜ ë°œìƒ</DialogTitle>
      <DialogContent>
        <DialogContentText id="error-dialog-description">
          {error || 'ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'}
        </DialogContentText>
        <Typography variant="body2" color="text.secondary" mt={2}>
          ë¬¸ì œê°€ ì§€ì†ë˜ë©´ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.
        </Typography>
      </DialogContent>
      <DialogActions>
        {queryError && (
          <Button
            onClick={() => {
              handleErrorDialogClose();
              handleRefresh();
            }}
            color="primary"
          >
            ë‹¤ì‹œ ì‹œë„
          </Button>
        )}
        <Button onClick={handleErrorDialogClose} color="secondary">
          ë‹«ê¸°
        </Button>
      </DialogActions>
    </Dialog>
  ), [errorDialogOpen, handleErrorDialogClose, error, queryError, handleRefresh]);

  // ëŒ€í™”ìƒì ë‹«ê¸° í•¸ë“¤ëŸ¬
  const handleClose = useCallback(() => {
    snackbarShown.current = false;
    
    // ì»´í¬ë„ŒíŠ¸ ë‹«í ë•Œ êµ¬ë… ì •ë³´ ì¦‰ì‹œ ì €ì¥
    try {
      if (socketServiceRef && typeof socketServiceRef.updateSubscription === 'function') {
        // í˜„ì¬ êµ¬ë… ìƒíƒœë¥¼ ì¤‘ì•™ ì €ì¥ì†Œì— ë°˜ì˜
        socketServiceRef.updateSubscription(propsCveId, isSubscribedRef.current);
        logger.info('CVEDetail', 'ì»´í¬ë„ŒíŠ¸ ë‹«í˜ - êµ¬ë… ì •ë³´ ì €ì¥ ì™„ë£Œ', { 
          cveId: propsCveId, 
          isSubscribed: isSubscribedRef.current 
        });
      } else {
        // ì†Œì¼“ ì„œë¹„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²½ìš° ë¡œì»¬ì— ì§ì ‘ ì €ì¥
        const key = 'cvehub_subscribed_cves';
        const savedCVEs = localStorage.getItem(key);
        let cveList: string[] = [];
        
        if (savedCVEs) {
          try {
            cveList = JSON.parse(savedCVEs);
          } catch (e) {
            logger.error('CVEDetail', 'ì €ì¥ëœ êµ¬ë… ì •ë³´ íŒŒì‹± ì‹¤íŒ¨', e);
            cveList = [];
          }
        }
        
        // êµ¬ë… ì—¬ë¶€ì— ë”°ë¼ ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        if (isSubscribedRef.current) {
          // ì´ë¯¸ ë¦¬ìŠ¤íŠ¸ì— ì—†ëŠ” ê²½ìš°ì—ë§Œ ì¶”ê°€
          if (!cveList.includes(propsCveId)) {
            cveList.push(propsCveId);
          }
        } else {
          // ë¦¬ìŠ¤íŠ¸ì—ì„œ ì œê±°
          cveList = cveList.filter(id => id !== propsCveId);
        }
        
        // ì—…ë°ì´íŠ¸ëœ ë¦¬ìŠ¤íŠ¸ ì €ì¥
        localStorage.setItem(key, JSON.stringify(cveList));
        logger.info('CVEDetail', 'ë¡œì»¬ êµ¬ë… ì •ë³´ ì§ì ‘ ì—…ë°ì´íŠ¸', { 
          cveId: propsCveId, 
          isSubscribed: isSubscribedRef.current 
        });
      }
    } catch (error) {
      logger.error('CVEDetail', 'êµ¬ë… ì •ë³´ ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
    }
    
    // ì›ë˜ onClose ì½œë°± í˜¸ì¶œ
    if (typeof onClose === 'function') {
      onClose();
    }
  }, [propsCveId, onClose, socketServiceRef, isSubscribedRef]);

  // --- useEffects ---
  // CVE ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ êµ¬ë…
  useEffect(() => {
    if (!propsCveId || !open || !socketRef.current) return;
    
    const eventName = `cve_updated_${propsCveId}`;
    
    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    socketRef.current.on(eventName, handleCVEUpdated);
    
    logger.debug('CVEDetail: ì†Œì¼“ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡', { event: eventName });
    
    return () => {
      if (socketRef.current) {
        socketRef.current.off(eventName, handleCVEUpdated);
        logger.debug('CVEDetail: ì†Œì¼“ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°', { event: eventName });
      }
    };
  }, [propsCveId, open, handleCVEUpdated]);

  // CVEDetail.tsxì—ì„œ êµ¬ë… ê´€ë¦¬ ë¡œì§ ìˆ˜ì •
  useEffect(() => {
    // ëª¨ë‹¬ì´ ì—´ë ¤ ìˆê³ , CVE IDê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰
    if (!propsCveId || !open) {
      return;
    }
    
    // ì´ë¯¸ êµ¬ë… ìƒíƒœë©´ ì¤‘ë³µ ìš”ì²­ ë°©ì§€
    if (isSubscribedRef.current) {
      logger.debug('CVEDetail: ì´ë¯¸ êµ¬ë… ì¤‘, ì¤‘ë³µ ìš”ì²­ ë°©ì§€', { cveId: propsCveId });
      return;
    }
    
    // ì•„ì§ êµ¬ë… ì‹œë„ë¥¼ í•˜ì§€ ì•Šì•˜ê³  ì—°ê²°ëœ ìƒíƒœì—ì„œë§Œ êµ¬ë…
    if (!hasAttemptedSubscriptionRef.current && connected && socketRef.current) {
      logger.info('CVEDetail: êµ¬ë… ì‹œì‘', { cveId: propsCveId });
      hasAttemptedSubscriptionRef.current = true;
      
      // í™•ì‹¤í•œ íƒ€ì´ë°ì„ ìœ„í•´ ì•½ê°„ ì§€ì—° (ì„ íƒì )
      setTimeout(() => {
        subscribe();
      }, 100);
    }
    
    // ëª¨ë‹¬ ë˜ëŠ” ì»´í¬ë„ŒíŠ¸ê°€ ë‹«í ë•Œë§Œ êµ¬ë… í•´ì œ (ì¤‘ìš”)
    return () => {
      // ëª¨ë‹¬ì´ ë‹«íˆê±°ë‚˜ ì»´í¬ë„ŒíŠ¸ê°€ ì–¸ë§ˆìš´íŠ¸ë  ë•Œë§Œ êµ¬ë… í•´ì œ
      if (isSubscribedRef.current) {
        logger.info('CVEDetail: ëª¨ë‹¬ ë‹«í˜ ë˜ëŠ” ì–¸ë§ˆìš´íŠ¸, êµ¬ë… í•´ì œ', { cveId: propsCveId });
        unsubscribe();
      }
    };
  }, [propsCveId, open, connected, subscribe, unsubscribe]);

  // ì—°ê²° ìƒíƒœ ë³€ê²½ ì²˜ë¦¬ (ë¶„ë¦¬ëœ useEffect)
  useEffect(() => {
    // ì—°ê²° ìƒíƒœê°€ ë³€ê²½ë˜ê³  ëª¨ë‹¬ì´ ì—´ë ¤ìˆëŠ” ìƒíƒœì—ì„œë§Œ ì²˜ë¦¬
    if (!propsCveId || !open) return;
    
    if (connected) {
      // ì—°ê²°ëì§€ë§Œ ì•„ì§ êµ¬ë…ë˜ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ êµ¬ë… ì‹œë„
      if (hasAttemptedSubscriptionRef.current && !isSubscribedRef.current) {
        logger.info('CVEDetail: ì—°ê²° ë³µêµ¬, êµ¬ë… ì¬ì‹œë„', { cveId: propsCveId });
        subscribe();
      }
    }
  }, [connected, propsCveId, open, subscribe]);

  // ë Œë”ë§ ë¡œì§
  if (!open) return null;
  
  if (isQueryLoading && !cveData) {
    return (
      <Dialog open={open} fullWidth maxWidth="md" onClose={handleClose}>
        <DialogContent
          sx={{
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            p: 5,
            height: '200px',
          }}
        >
          <CircularProgress />
        </DialogContent>
      </Dialog>
    );
  }
  
  if (queryError && !cveData) {
    return (
      <Dialog open={open} onClose={handleClose} fullWidth maxWidth="sm">
        <DialogTitle>ì˜¤ë¥˜</DialogTitle>
        <DialogContent>
          <Typography color="error" gutterBottom>
            ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.
          </Typography>
          <Typography variant="body2" sx={{ mt: 1 }}>
            {queryError.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}
          </Typography>
        </DialogContent>
        <DialogActions>
          {queryError && (
            <Button
              onClick={() => {
                handleErrorDialogClose();
                handleRefresh();
              }}
              color="primary"
            >
              ë‹¤ì‹œ ì‹œë„
            </Button>
          )}
          <Button onClick={handleClose}>ë‹«ê¸°</Button>
        </DialogActions>
      </Dialog>
    );
  }
  
  if (!cveData) {
    logger.warn('CVEDetail: cveDataê°€ ì—†ìŠµë‹ˆë‹¤ (ë¡œë”©/ì—ëŸ¬ ì•„ë‹˜). ë Œë”ë§ ì¤‘ë‹¨.');
    return (
      <Dialog open={open} onClose={handleClose} fullWidth maxWidth="sm">
        <DialogTitle>ì •ë³´ ì—†ìŒ</DialogTitle>
        <DialogContent>
          <Typography>í•´ë‹¹ CVE ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>ë‹«ê¸°</Button>
        </DialogActions>
      </Dialog>
    );
  }

  return (
    <Dialog
      open={open}
      onClose={handleClose}
      maxWidth="lg"
      fullWidth
      TransitionComponent={Fade}
      PaperProps={{
        sx: {
          borderRadius: 3,
          height: '90vh',
          maxHeight: '90vh',
          overflow: 'hidden',
          zIndex: 1500,
        },
      }}
      aria-labelledby="cve-detail-dialog-title"
    >
      <DialogTitle sx={{ p: 2, flexShrink: 0 }} id="cve-detail-dialog-title">
        <CVEDetailHeader
          cveId={cveData.cveId}
          subscribers={subscribers}
          createdAt={(cveData.createdAt || cveData.created_at) as string | Date}
          lastModifiedAt={(cveData.lastModifiedAt || cveData.last_modified_at) as string | Date}
          isCached={isCached}
          isLoading={loading}
          onRefresh={handleRefresh}
          onClose={handleClose}
        />
      </DialogTitle>
      <DialogContent
        sx={{
          p: 0,
          flexGrow: 1,
          overflow: 'hidden',
          display: 'flex',
        }}
      >
        <Card
          elevation={0}
          sx={{
            height: '100%',
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
          }}
        >
          <CardContent
            sx={{
              p: 0,
              flexGrow: 1,
              display: 'flex',
              flexDirection: 'column',
              overflow: 'hidden',
            }}
          >
            <Box
              sx={{
                p: 2,
                flexShrink: 0,
                borderBottom: 1,
                borderColor: 'divider',
              }}
            >
              <CVEDetailInfoPanel
                cveData={cveData}
                onUpdateField={handleFieldUpdate}
                canEdit={canEdit()}
              />
            </Box>
            <CVEDetailTabs
              cveData={cveData}
              currentUser={currentUser}
              refreshTriggers={refreshTriggers}
              tabCounts={tabCounts}
              onCountChange={handleTabCountChange}
              parentSendMessage={sendMessage}
              highlightCommentId={highlightCommentId}
            />
            {(isCached || cveData.fromCache) && (
              <Box
                sx={{
                  display: 'flex',
                  alignItems: 'center',
                  gap: 1,
                  p: 1,
                  borderTop: 1,
                  borderColor: 'divider',
                  flexShrink: 0,
                  bgcolor: 'action.hover',
                }}
              >
                <Chip
                  size="small"
                  label="ìºì‹œëœ ë°ì´í„°"
                  color="info"
                  variant="outlined"
                  sx={{ fontWeight: 500 }}
                />
                {(cveData._cachedAt || cveData.cachedAt) && (
                  <Typography variant="caption" color="text.secondary">
                    ì„œë²„ì™€ {timeAgo((cveData._cachedAt || cveData.cachedAt) as string | number)} ì „ì— ë™ê¸°í™”ë¨
                  </Typography>
                )}
              </Box>
            )}
          </CardContent>
        </Card>
      </DialogContent>
      {renderErrorDialog()}
    </Dialog>
  );
};

export default CVEDetail;


============================================================
File: /home/CVEHub/frontend/src/features/cve/CVEList.jsx
------------------------------------------------------------
// frontend/src/features/cve/CVEList.jsx

import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  Chip,
  Tooltip,
  IconButton,
  Button,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  TextField,
  CircularProgress,
  Skeleton,
  Grid,
  Card,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  InputAdornment,
  useTheme,
  alpha
} from '@mui/material';
import { TIME_ZONES, DATE_FORMATS, formatDateTime } from 'shared/utils/dateUtils';
import SearchIcon from '@mui/icons-material/Search';
import DeleteIcon from '@mui/icons-material/Delete';
import RefreshIcon from '@mui/icons-material/Refresh';
import AddIcon from '@mui/icons-material/Add';
import SearchOffIcon from '@mui/icons-material/SearchOff';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { useQueryClient } from '@tanstack/react-query'; 
import { useSocket } from 'core/socket/hooks/useSocket';
import { QUERY_KEYS } from 'shared/api/queryKeys';

// ê¸°ì¡´ import ëŒ€ì‹  ìƒˆë¡œìš´ í†µí•© ì„œë¹„ìŠ¤ ì‚¬ìš©
import {
  useDeleteCVE,
  useCreateCVE
} from 'features/cve/hooks/useCVEMutation';

import CVEDetail from './CVEDetail';
import CrawlerUpdateButton from './components/CrawlerUpdateButton';
import CreateCVE from './CreateCVE';
import { useSnackbar } from 'notistack';
import { useCVEDetail, useCVEList, useCVEListUpdates, useCVEStats } from './hooks';

// ê¸°ë³¸ í°íŠ¸ ìŠ¤íƒ€ì¼
const fontStyles = {
  fontFamily: "'Noto Sans KR', sans-serif",
  letterSpacing: '0.5px'
};

// ê³µí†µ ìŠ¤íƒ€ì¼ ìƒìˆ˜ - ì¹´ë“œ ê¸°ë³¸ ìŠ¤íƒ€ì¼
const cardBaseStyle = {
  p: 2,
  borderRadius: '8px',
  boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
  textAlign: 'center',
  transition: 'all 0.3s ease',
};

// ê³µí†µ ìŠ¤íƒ€ì¼ ìƒìˆ˜ - í˜¸ë²„ íš¨ê³¼
const cardHoverStyle = {
  transform: 'translateY(-5px)',
  boxShadow: '0 8px 24px rgba(0,0,0,0.15)',
};

// ê³µí†µ ìŠ¤íƒ€ì¼ ìƒìˆ˜ - í•„í„° ì»´í¬ë„ŒíŠ¸ ê¸°ë³¸ ìŠ¤íƒ€ì¼
const filterBaseStyle = {
  borderRadius: '30px',
  backgroundColor: 'white',
  transition: 'all 0.2s ease',
};

// ê³µí†µ ìŠ¤íƒ€ì¼ ìƒìˆ˜ - í…Œì´ë¸” ì…€ ê¸°ë³¸ ìŠ¤íƒ€ì¼
const tableCellBaseStyle = {
  p: '12px 20px',
  ...fontStyles
};

// ì‹¬ê°ë„ë³„ ìŠ¤íƒ€ì¼ (HTML ë””ìì¸ê³¼ ìœ ì‚¬í•˜ê²Œ ìˆ˜ì •)
const getSeverityStyles = (severity) => {
  // ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ì´ ë¹„êµí•˜ê¸° ìœ„í•´ ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ê³  ë§¤í•‘
  const severityLower = severity ? severity.toLowerCase() : '';
  
  const styles = {
    'critical': { bg: 'rgba(255, 7, 58, 0.15)', color: '#ff073a' },
    'high':     { bg: 'rgba(255, 84, 0, 0.15)', color: '#ff5400' },
    'medium':   { bg: 'rgba(255, 190, 11, 0.15)', color: '#e5a800' },
    'low':      { bg: 'rgba(56, 176, 0, 0.15)', color: '#38b000' },
    'none':     { bg: 'rgba(108, 117, 125, 0.15)', color: '#6c757d' }
  };
  
  return styles[severityLower] || styles['none'];
};

// ìƒíƒœë³„ ìŠ¤íƒ€ì¼ (HTML ë””ìì¸ì— ë§ì¶¤)
const getStatusStyles = (status) => {
  const styles = {
    'ì‹ ê·œë“±ë¡':  { bg: 'rgba(58, 134, 255, 0.15)', color: '#3a86ff' },
    'ë¶„ì„ì¤‘':   { bg: 'rgba(131, 56, 236, 0.15)', color: '#8338ec' },
    'ë¦´ë¦¬ì¦ˆ ì™„ë£Œ': { bg: 'rgba(56, 176, 0, 0.15)', color: '#38b000' },
    'ë¶„ì„ë¶ˆê°€': { bg: 'rgba(244, 67, 54, 0.15)', color: '#f44336' }
  };
  return styles[status] || { bg: 'rgba(108, 117, 125, 0.15)', color: '#6c757d' };
};

// ì‹¬ê°ë„ë³„ ìƒ‰ìƒ ì„¤ì • í•¨ìˆ˜
const getSeverityColor = (severity, theme) => {
  // ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ì´ ë¹„êµí•˜ê¸° ìœ„í•´ ì†Œë¬¸ìë¡œ ë³€í™˜
  const severityLower = severity ? severity.toLowerCase() : '';
  
  switch (severityLower) {
    case 'critical':
      return theme.palette.error.main;
    case 'high':
      return theme.palette.secondary.main;
    case 'medium':
      return theme.palette.warning.main;
    case 'low':
      return theme.palette.info.main;
    default:
      return theme.palette.text.secondary;
  }
};

// ìƒíƒœë³„ ìƒ‰ìƒ ì„¤ì • í•¨ìˆ˜
const getStatusColor = (status, theme) => {
  switch (status) {
    case 'ì‹ ê·œë“±ë¡':
      return theme.palette.info.main;
    case 'ë¶„ì„ì¤‘':
      return theme.palette.warning.main;
    case 'ë¦´ë¦¬ì¦ˆ ì™„ë£Œ':
      return theme.palette.success.main;
    case 'ë¶„ì„ë¶ˆê°€':
      return theme.palette.error.main;
    default:
      return theme.palette.text.secondary;
  }
};

const CVECardSkeleton = () => (
  <Card elevation={0} variant="outlined" sx={{ height: '100%' }}>
    <Skeleton animation="wave" height={30} />
  </Card>
);

const CVEDetailWrapper = ({ cveId, open, onClose }) => {
  const { data: cve, isLoading, isError, error, refetch } = useCVEDetail(cveId, {
    enabled: !!cveId && open,
    refetchOnWindowFocus: false
  });

  useEffect(() => {
    if (error) console.error('CVE ì„¸ë¶€ ì •ë³´ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜:', error);
  }, [error]);

  if (!cveId || !open) return null;

  if (isLoading) {
    return (
      <Dialog open={open} onClose={onClose} maxWidth="md" fullWidth>
        <DialogTitle>CVE ì„¸ë¶€ ì •ë³´ ë¡œë“œ ì¤‘...</DialogTitle>
        <DialogContent>
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
            <CircularProgress />
          </Box>
        </DialogContent>
      </Dialog>
    );
  }

  if (isError) {
    return (
      <Dialog open={open} onClose={onClose}>
        <DialogTitle>ì˜¤ë¥˜ ë°œìƒ</DialogTitle>
        <DialogContent>
          <Typography color="error">ë°ì´í„° ë¡œë”© ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</Typography>
          <Button onClick={refetch}>ë‹¤ì‹œ ì‹œë„</Button>
        </DialogContent>
        <DialogActions>
          <Button onClick={onClose}>ë‹«ê¸°</Button>
        </DialogActions>
      </Dialog>
    );
  }

  return <CVEDetail cveId={cveId} open={open} onClose={onClose} />;
};

const StatisticsSection = React.memo(({ statsData, totalCount, theme }) => {
  return (
    <Grid container spacing={2} sx={{ mb: 3 }}>
      <Grid item xs={12} sm={6} md={3}>
        <Card
          elevation={0}
          sx={{
            ...cardBaseStyle,
            '&:hover': cardHoverStyle,
            background: `linear-gradient(135deg, ${alpha(theme.palette.primary.main, 0.05)} 0%, ${alpha(theme.palette.primary.main, 0.1)} 100%)`
          }}
        >
          <Typography variant="caption" sx={{ textTransform: 'uppercase', color: theme.palette.text.secondary }}>
            ì „ì²´ CVE
          </Typography>
          <Typography variant="h4" sx={{ fontWeight: 'bold', color: theme.palette.primary.main, my: 1 }}>
            {totalCount}
          </Typography>
          <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>ë“±ë¡ëœ ì·¨ì•½ì </Typography>
        </Card>
      </Grid>
      <Grid item xs={12} sm={6} md={3}>
        <Card
          elevation={0}
          sx={{
            ...cardBaseStyle,
            '&:hover': cardHoverStyle,
            background: `linear-gradient(135deg, ${alpha(theme.palette.secondary.main, 0.05)} 0%, ${alpha(theme.palette.secondary.main, 0.1)} 100%)`
          }}
        >
          <Typography variant="caption" sx={{ textTransform: 'uppercase', color: theme.palette.text.secondary }}>
            ìœ„í—˜ë„ ë†’ìŒ
          </Typography>
          <Typography variant="h4" sx={{ fontWeight: 'bold', color: theme.palette.secondary.main, my: 1 }}>
            {statsData.highSeverityCount || 0}
          </Typography>
          <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>ì‹¬ê°í•œ ì·¨ì•½ì </Typography>
        </Card>
      </Grid>
      <Grid item xs={12} sm={6} md={3}>
        <Card
          elevation={0}
          sx={{
            ...cardBaseStyle,
            '&:hover': cardHoverStyle,
            background: `linear-gradient(135deg, ${alpha(theme.palette.info.main, 0.05)} 0%, ${alpha(theme.palette.info.main, 0.1)} 100%)`
          }}
        >
          <Typography variant="caption" sx={{ textTransform: 'uppercase', color: theme.palette.text.secondary }}>
            ìµœê·¼ 7ì¼
          </Typography>
          <Typography variant="h4" sx={{ fontWeight: 'bold', color: theme.palette.info.main, my: 1 }}>
            {statsData.newLastWeekCount || 0}
          </Typography>
          <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>ì‹ ê·œ ë“±ë¡</Typography>
        </Card>
      </Grid>
      <Grid item xs={12} sm={6} md={3}>
        <Card
          elevation={0}
          sx={{
            ...cardBaseStyle,
            '&:hover': cardHoverStyle,
            background: `linear-gradient(135deg, ${alpha(theme.palette.success.main, 0.05)} 0%, ${alpha(theme.palette.success.main, 0.1)} 100%)`
          }}
        >
          <Typography variant="caption" sx={{ textTransform: 'uppercase', color: theme.palette.text.secondary }}>
            ì™„ë£Œë¨
          </Typography>
          <Typography variant="h4" sx={{ fontWeight: 'bold', color: theme.palette.success.main, my: 1 }}>
            {statsData.completedCount}
          </Typography>
          <Typography variant="body2" sx={{ color: theme.palette.text.secondary }}>ë¶„ì„ ì™„ë£Œ</Typography>
        </Card>
      </Grid>
    </Grid>
  );
});

const FilterBar = React.memo(({ 
  searchInput, 
  statusFilter, 
  severityFilter, 
  sortOption, 
  handleSearchChange, 
  handleStatusFilterChange, 
  handleSeverityFilterChange, 
  handleSortOptionChange, 
  handleRefresh,
  theme
}) => {
  return (
    <Box
      sx={{
        backgroundColor: theme.palette.background.paper,
        p: 2.5,
        borderRadius: '8px',
        boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
        mb: 3,
        display: 'flex',
        flexWrap: 'wrap',
        gap: 2,
        alignItems: 'center',
        transition: 'all 0.3s ease',
        '&:hover': {
          boxShadow: '0 6px 20px rgba(0,0,0,0.15)'
        }
      }}
    >
      <Box sx={{ flex: 1, position: 'relative', minWidth: 300 }}>
        <SearchIcon
          sx={{
            position: 'absolute',
            left: 15,
            top: '50%',
            transform: 'translateY(-50%)',
            color: theme.palette.text.secondary
          }}
        />
        <TextField
          placeholder="CVE ID, í‚¤ì›Œë“œ ë˜ëŠ” ì œëª©ìœ¼ë¡œ ê²€ìƒ‰"
          size="small"
          value={searchInput}
          onChange={handleSearchChange}
          fullWidth
          sx={{
            '& .MuiOutlinedInput-root': {
              borderRadius: '30px',
              pl: '45px',
              backgroundColor: 'white',
              transition: 'all 0.2s ease',
              '& fieldset': { borderColor: '#e0e0e0' },
              '&:hover fieldset': { borderColor: theme.palette.primary.main },
              '&.Mui-focused': {
                boxShadow: `0 0 0 2px ${alpha(theme.palette.primary.main, 0.2)}`
              }
            }
          }}
        />
      </Box>
      <FormControl size="small" sx={{ minWidth: 150 }}>
        <InputLabel sx={fontStyles}>ìƒíƒœë³„ í•„í„°</InputLabel>
        <Select
          value={statusFilter}
          label="ìƒíƒœë³„ í•„í„°"
          onChange={handleStatusFilterChange}
          sx={{
            ...filterBaseStyle,
            '&:hover': {
              boxShadow: `0 0 0 2px ${alpha(theme.palette.primary.main, 0.2)}`
            }
          }}
        >
          <MenuItem value="">ì „ì²´</MenuItem>
          <MenuItem value="ì‹ ê·œë“±ë¡">ì‹ ê·œë“±ë¡</MenuItem>
          <MenuItem value="ë¶„ì„ì¤‘">ë¶„ì„ì¤‘</MenuItem>
          <MenuItem value="ë¦´ë¦¬ì¦ˆ ì™„ë£Œ">ë¦´ë¦¬ì¦ˆ ì™„ë£Œ</MenuItem>
          <MenuItem value="ë¶„ì„ë¶ˆê°€">ë¶„ì„ë¶ˆê°€</MenuItem>
        </Select>
      </FormControl>
      <FormControl size="small" sx={{ minWidth: 150 }}>
        <InputLabel sx={fontStyles}>ì‹¬ê°ë„ë³„ í•„í„°</InputLabel>
        <Select
          value={severityFilter}
          label="ì‹¬ê°ë„ë³„ í•„í„°"
          onChange={handleSeverityFilterChange}
          sx={{
            ...filterBaseStyle,
            '&:hover': {
              boxShadow: `0 0 0 2px ${alpha(theme.palette.primary.main, 0.2)}`
            }
          }}
        >
          <MenuItem value="">ì „ì²´</MenuItem>
          <MenuItem value="CRITICAL">ì‹¬ê°</MenuItem>
          <MenuItem value="HIGH">ë†’ìŒ</MenuItem>
          <MenuItem value="MEDIUM">ì¤‘ê°„</MenuItem>
          <MenuItem value="LOW">ë‚®ìŒ</MenuItem>
        </Select>
      </FormControl>
      <FormControl size="small" sx={{ minWidth: 150 }}>
        <InputLabel sx={fontStyles}>ì •ë ¬ ê¸°ì¤€</InputLabel>
        <Select
          value={sortOption}
          label="ì •ë ¬ ê¸°ì¤€"
          onChange={handleSortOptionChange}
          sx={{
            ...filterBaseStyle,
            '&:hover': {
              boxShadow: `0 0 0 2px ${alpha(theme.palette.primary.main, 0.2)}`
            }
          }}
        >
          <MenuItem value="newest">ìµœì‹ ìˆœ</MenuItem>
          <MenuItem value="severity">ì‹¬ê°ë„ìˆœ</MenuItem>
          <MenuItem value="status">ìƒíƒœìˆœ</MenuItem>
        </Select>
      </FormControl>
      <Tooltip title="ìƒˆë¡œê³ ì¹¨">
        <IconButton 
          onClick={handleRefresh}
          sx={{
            transition: 'all 0.2s ease',
            '&:hover': {
              backgroundColor: alpha(theme.palette.primary.main, 0.1),
              transform: 'rotate(180deg)'
            }
          }}
        >
          <RefreshIcon />
        </IconButton>
      </Tooltip>
    </Box>
  );
});

const TableSkeletonRow = React.memo(() => (
  <TableRow>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
    <TableCell><Skeleton variant="text" /></TableCell>
  </TableRow>
));

const NoDataRow = ({ colSpan, searchQuery, onResetSearch, theme }) => (
  <TableRow>
    <TableCell
      colSpan={colSpan}
      sx={{ ...tableCellBaseStyle, textAlign: 'center', py: 4 }}
    >
      <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', py: 2 }}>
        <SearchOffIcon sx={{ fontSize: 48, color: theme.palette.text.secondary, mb: 1 }} />
        <Typography variant="body1" sx={{ color: theme.palette.text.secondary }}>
          ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤
        </Typography>
        {searchQuery && (
          <>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
              ê²€ìƒ‰ì–´: "{searchQuery}"
            </Typography>
            <Button
              onClick={onResetSearch}
              variant="outlined"
              size="small"
              sx={{ mt: 2 }}
            >
              ê²€ìƒ‰ ì´ˆê¸°í™”
            </Button>
          </>
        )}
      </Box>
    </TableCell>
  </TableRow>
);

const CVETable = React.memo(({ 
  cves, 
  isLoading, 
  page, 
  totalCount, 
  rowsPerPage, 
  onPageChange, 
  onRowsPerPageChange, 
  onCVEClick,
  theme,
  sortOption,
  searchQuery,
  onResetSearch,
  onDeleteClick
}) => {
  return (
    <Paper
      elevation={0}
      sx={{
        width: '100%',
        borderRadius: '8px',
        overflow: 'hidden',
        boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
        mb: 4,
        transition: 'box-shadow 0.3s ease',
        '&:hover': {
          boxShadow: '0 6px 20px rgba(0,0,0,0.15)'
        }
      }}
    >
      <TableContainer sx={{ maxHeight: '60vh' }}>
        <Table stickyHeader sx={{ minWidth: 900 }}>
          <TableHead>
            <TableRow>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>CVE ID</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ì œëª©</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ì‹¬ê°ë„</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ìƒíƒœ</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ë“±ë¡ì¼</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ìµœì¢… ìˆ˜ì •ì¼</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ì•¡ì…˜</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {isLoading ? (
              // ë¡œë”© ì¤‘ì¼ ë•Œ ìŠ¤ì¼ˆë ˆí†¤ UI í‘œì‹œ
              Array.from(new Array(5)).map((_, index) => (
                <TableSkeletonRow key={`skeleton-${index}`} />
              ))
            ) : cves && cves.length > 0 ? (
              cves.map((cve, index) => {
                console.log(`CVE í•­ëª© ë Œë”ë§ ì‹œì‘ [${index}]:`, {
                  cveId: cve.cveId,
                  title: cve.title,
                  status: cve.status,
                  severity: cve.severity
                });
                
                try {
                  return (
                    <TableRow
                      key={cve.cveId || `cve-${index}`}
                      onClick={() => onCVEClick(cve)}
                      sx={{
                        cursor: 'pointer',
                        transition: 'background-color 0.2s',
                        '&:hover': {
                          backgroundColor: alpha(theme.palette.primary.main, 0.04)
                        }
                      }}
                    >
                      <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'medium', color: theme.palette.primary.main }}>
                        {cve.cveId || '-'}
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        <Tooltip title={cve.title || ''} placement="top">
                          <Typography
                            variant="body2"
                            sx={{
                              maxWidth: 400,
                              overflow: 'hidden',
                              textOverflow: 'ellipsis',
                              whiteSpace: 'nowrap'
                            }}
                          >
                            {cve.title || '-'}
                          </Typography>
                        </Tooltip>
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        <Chip
                          label={cve.severity ? cve.severity.toUpperCase() : 'ë¯¸ì •'}
                          size="small"
                          sx={{
                            backgroundColor: alpha(getSeverityColor(cve.severity, theme), 0.1),
                            color: getSeverityColor(cve.severity, theme),
                            fontWeight: 'medium',
                            borderRadius: '4px'
                          }}
                        />
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        <Chip
                          label={cve.status || 'ë¯¸ì •'}
                          size="small"
                          sx={{
                            backgroundColor: alpha(getStatusColor(cve.status, theme), 0.1),
                            color: getStatusColor(cve.status, theme),
                            fontWeight: 'medium',
                            borderRadius: '4px'
                          }}
                        />
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        {formatDateTime(cve.createdAt || cve.created_at, DATE_FORMATS.DISPLAY.DEFAULT)}
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        {formatDateTime(cve.lastModifiedAt || cve.last_modified_at, DATE_FORMATS.DISPLAY.DEFAULT)}
                      </TableCell>
                      <TableCell sx={tableCellBaseStyle}>
                        <Box sx={{ display: 'flex', gap: 1 }}>
                          <Tooltip title="ì‚­ì œ">
                            <IconButton
                              size="small"
                              color="error"
                              onClick={(e) => onDeleteClick(e, cve)}
                              sx={{
                                '&:hover': {
                                  backgroundColor: alpha(theme.palette.error.main, 0.1),
                                }
                              }}
                            >
                              <DeleteIcon fontSize="small" />
                            </IconButton>
                          </Tooltip>
                        </Box>
                      </TableCell>
                    </TableRow>
                  );
                } catch (error) {
                  console.error(`CVE í•­ëª© ë Œë”ë§ ì¤‘ ì˜¤ë¥˜ [${index}]:`, error);
                  return (
                    <TableRow key={`error-${index}`}>
                      <TableCell colSpan={7} sx={{ ...tableCellBaseStyle, textAlign: 'center', py: 4 }}>
                        <Typography variant="body2" color="error">ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</Typography>
                      </TableCell>
                    </TableRow>
                  );
                }
              })
            ) : (
              <NoDataRow 
                colSpan={7} 
                searchQuery={searchQuery} 
                onResetSearch={onResetSearch}
                theme={theme}
              />
            )}
          </TableBody>
        </Table>
      </TableContainer>
      <TablePagination
        rowsPerPageOptions={[1, 5, 10, 25]}
        component="div"
        count={totalCount} 
        rowsPerPage={rowsPerPage}
        page={page - 1}
        onPageChange={onPageChange}
        onRowsPerPageChange={onRowsPerPageChange}
        labelRowsPerPage="í˜ì´ì§€ë‹¹ í–‰ ìˆ˜"
        labelDisplayedRows={({ from, to, count }) => {
          // ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ëŠ” ê²½ìš°
          if (count === 0) return 'ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ';
          // ì¼ë°˜ì ì¸ ê²½ìš°
          return `${from}-${to} / ì´ ${count !== -1 ? count : '?'}ê°œ${searchQuery ? ' (ê²€ìƒ‰ ê²°ê³¼)' : ''}`;
        }}
        sx={{
          borderTop: `1px solid ${theme.palette.divider}`,
          '& .MuiToolbar-root': {
            ...fontStyles,
            height: 56
          }
        }}
      />
    </Paper>
  );
});

// í…Œì´ë¸” ë¡œë”© ìƒíƒœë¥¼ ìœ„í•œ ìŠ¤ì¼ˆë ˆí†¤ UI
const CVETableSkeleton = () => {
  const theme = useTheme();
  
  return (
    <Paper
      elevation={0}
      sx={{
        width: '100%',
        borderRadius: '8px',
        overflow: 'hidden',
        boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
        mb: 4
      }}
    >
      <TableContainer>
        <Table sx={{ minWidth: 900 }}>
          <TableHead>
            <TableRow>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>CVE ID</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ì œëª©</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ì‹¬ê°ë„</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ìƒíƒœ</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ë“±ë¡ì¼</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ìµœì¢… ìˆ˜ì •ì¼</TableCell>
              <TableCell sx={{ ...tableCellBaseStyle, fontWeight: 'bold', backgroundColor: alpha(theme.palette.primary.main, 0.08) }}>ì•¡ì…˜</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {Array.from(new Array(5)).map((_, index) => (
              <TableRow key={`skeleton-${index}`}>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
                <TableCell><Skeleton animation="wave" height={30} /></TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Paper>
  );
};

// ì—ëŸ¬ í‘œì‹œ ì»´í¬ë„ŒíŠ¸
const ErrorDisplay = ({ error, onRetry }) => {
  const theme = useTheme();
  
  return (
    <Paper
      elevation={0}
      sx={{
        p: 3,
        borderRadius: '8px',
        textAlign: 'center',
        boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
        mb: 4
      }}
    >
      <Typography variant="h6" color="error" sx={{ mb: 2 }}>
        ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤
      </Typography>
      <Typography variant="body2" color="text.secondary" sx={{ mb: 3 }}>
        {error?.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.'}
      </Typography>
      <Button
        variant="contained"
        color="primary"
        onClick={onRetry}
        startIcon={<RefreshIcon />}
        sx={{
          borderRadius: '20px',
          boxShadow: 'none',
          '&:hover': { boxShadow: 'none' }
        }}
      >
        ë‹¤ì‹œ ì‹œë„
      </Button>
    </Paper>
  );
};

// ë¹ˆ ìƒíƒœ í‘œì‹œ ì»´í¬ë„ŒíŠ¸
const EmptyStateDisplay = ({ searchQuery, onResetSearch, isFiltered }) => {
  const theme = useTheme();
  
  return (
    <Paper
      elevation={0}
      sx={{
        p: 4,
        borderRadius: '8px',
        textAlign: 'center',
        boxShadow: '0 4px 16px rgba(0,0,0,0.1)',
        mb: 4,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      <SearchOffIcon sx={{ fontSize: 64, color: theme.palette.text.secondary, mb: 2 }} />
      
      <Typography variant="h6" sx={{ mb: 1 }}>
        {searchQuery ? 'ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤' : 'ë“±ë¡ëœ CVEê°€ ì—†ìŠµë‹ˆë‹¤'}
      </Typography>
      
      {isFiltered ? (
        <>
          <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
            {searchQuery ? `"${searchQuery}"ì— ëŒ€í•œ ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.` : 'í˜„ì¬ í•„í„° ì¡°ê±´ì— ë§ëŠ” CVEê°€ ì—†ìŠµë‹ˆë‹¤.'}
          </Typography>
          <Button
            variant="outlined"
            color="primary"
            onClick={onResetSearch}
            sx={{
              borderRadius: '20px',
              mt: 1
            }}
          >
            í•„í„° ì´ˆê¸°í™”
          </Button>
        </>
      ) : (
        <Typography variant="body2" color="text.secondary">
          ìƒˆë¡œìš´ CVEë¥¼ ë“±ë¡í•´ ë³´ì„¸ìš”.
        </Typography>
      )}
    </Paper>
  );
};

const CVEList = () => {
  const theme = useTheme();
  const navigate = useNavigate();
  const { currentUser: user } = useAuth();
  const { enqueueSnackbar } = useSnackbar();
  const { emit } = useSocket();
  const queryClient = useQueryClient(); 

  // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ êµ¬ë…
  useCVEListUpdates(queryClient);

  // ì „ì²´ CVE ê°œìˆ˜ ì¡°íšŒ (ì£¼ì„ ì²˜ë¦¬ - í…Œì´ë¸”ì˜ totalCountë¡œ ëŒ€ì²´)
  // const { data: totalCVECount = 0, isLoading: isTotalCountLoading } = useTotalCVECount();

  // í†µê³„ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¿¼ë¦¬
  const { data: backendStats, isLoading: isLoadingStats } = useCVEStats();
  
  // í•„í„° ìƒíƒœ (ìƒíƒœ, ì‹¬ê°ë„, ì •ë ¬ ì˜µì…˜)
  const [page, setPage] = useState(1);
  const [rowsPerPage, setRowsPerPage] = useState(1); // í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ 1ë¡œ ë³€ê²½
  const [searchQuery, setSearchQuery] = useState('');
  const [statusFilter, setStatusFilter] = useState('');
  const [severityFilter, setSeverityFilter] = useState('');
  const [sortOption, setSortOption] = useState('newest');
  
  // ë‹¤ì´ì–¼ë¡œê·¸ ë° ê²€ìƒ‰ ê´€ë ¨ ìƒíƒœ
  const [createDialogOpen, setCreateDialogOpen] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [cveToDelete, setCveToDelete] = useState(null);
  const [searchInput, setSearchInput] = useState('');
  const [selectedCVE, setSelectedCVE] = useState(null);
  const [detailOpen, setDetailOpen] = useState(false);
  
  // ê²€ìƒ‰ ë””ë°”ìš´ìŠ¤ ref
  const searchTimeoutRef = useRef(null);

  // ìƒë‹¨ ì•¡ì…˜ ë²„íŠ¼ ë Œë”ë§ (ìƒˆ CVE ìƒì„±, í¬ë¡¤ëŸ¬ ì—…ë°ì´íŠ¸)
  const renderActionButtons = () => (
    <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 3, flexWrap: 'wrap', gap: 2 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
        <Button
          variant="contained"
          color="primary"
          startIcon={<AddIcon />}
          onClick={() => setCreateDialogOpen(true)}
          sx={{
            ...fontStyles,
            borderRadius: '20px',
            fontWeight: 500,
            boxShadow: '0 4px 12px rgba(58, 134, 255, 0.2)',
            background: 'linear-gradient(135deg, #3a86ff, #8338ec)',
            '&:hover': {
              background: 'linear-gradient(135deg, #2a76ef, #7328dc)',
              boxShadow: '0 6px 16px rgba(58, 134, 255, 0.3)'
            }
          }}
        >
          ìƒˆ CVE ìƒì„±
        </Button>
        <CrawlerUpdateButton />
      </Box>
    </Box>
  );

  // React Query: CVE ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (í•„í„°ì™€ ì •ë ¬ ì˜µì…˜ ë°˜ì˜)
  const { 
    data: queryData, 
    isLoading, 
    isError, 
    error: queryError, 
    refetch: refetchCVEList 
  } = useCVEList({ 
    page, 
    rowsPerPage, 
    search: searchQuery,
    status: statusFilter,
    severity: severityFilter,
    sortBy: sortOption === 'newest' ? 'createdAt' : sortOption === 'severity' ? 'severity' : 'status',
    sortOrder: sortOption === 'newest' ? 'desc' : (sortOption === 'severity' ? 'desc' : 'asc')
  });
  
  // ì¿¼ë¦¬ ì‹¤í–‰ í›„ ë¡œê¹… ì¶”ê°€
  useEffect(() => {
    console.log('ì¿¼ë¦¬ ë§¤ê°œë³€ìˆ˜:', {
      page,
      rowsPerPage,
      í•„í„°: { ìƒíƒœ: statusFilter, ì‹¬ê°ë„: severityFilter, ê²€ìƒ‰ì–´: searchQuery },
      ì •ë ¬: sortOption
    });
    console.log('ì¿¼ë¦¬ ê²°ê³¼:', queryData?.items?.length, 'ì•„ì´í…œ ì¤‘', queryData?.total || queryData?.totalItems, 'ì´ ì•„ì´í…œ');
    
    // ë°±ì—”ë“œ ê²€ìƒ‰ APIì— ì „ë‹¬ë˜ëŠ” ì‹¤ì œ íŒŒë¼ë¯¸í„° êµ¬ì¡° ì¶œë ¥ (ë°±ì—”ë“œ /cves/list ì—”ë“œí¬ì¸íŠ¸ì— ë§ì¶¤)
    console.log('ë°±ì—”ë“œë¡œ ì „ì†¡ë˜ëŠ” ê²€ìƒ‰ íŒŒë¼ë¯¸í„°:', { 
      search: searchQuery,
      page: page,
      limit: rowsPerPage,
      status: statusFilter,
      severity: severityFilter,
      sort_by: sortOption === 'newest' ? 'createdAt' : sortOption === 'severity' ? 'severity' : 'status',
      sort_order: sortOption === 'newest' ? 'desc' : (sortOption === 'severity' ? 'desc' : 'asc')
    });
    
    // ì²« ë²ˆì§¸ ì•„ì´í…œ ë””ë²„ê¹… ë¡œê¹…
    if (queryData?.items && queryData.items.length > 0) {
      console.log('ì²« ë²ˆì§¸ CVE ì•„ì´í…œ ë°ì´í„°:', queryData.items[0]);
      console.log('í•„ë“œ í™•ì¸:', {
        id: queryData.items[0].id,
        cveId: queryData.items[0].cveId,
        title: queryData.items[0].title,
        status: queryData.items[0].status,
        severity: queryData.items[0].severity,
        createdAt: queryData.items[0].createdAt,
        lastModifiedAt: queryData.items[0].lastModifiedAt
      });
    }
  }, [queryData, page, rowsPerPage, statusFilter, severityFilter, searchQuery, sortOption]);
  
  const cves = useMemo(() => queryData?.items || [], [queryData]);
  const totalCount = useMemo(() => queryData?.total || queryData?.totalItems || 0, [queryData]);
  
  // í†µê³„ ë°ì´í„° (ë°±ì—”ë“œ API ê²°ê³¼ì™€ ë¡œì»¬ ë°ì´í„° ê²°í•©)
  const statsData = useMemo(() => {
    // ë°±ì—”ë“œ í†µê³„ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì‚¬ìš©í•˜ë˜, totalCountëŠ” í•­ìƒ í…Œì´ë¸” ë°ì´í„°ì™€ ë™ì¼í•˜ê²Œ ì‚¬ìš©
    if (backendStats) {
      return {
        ...backendStats,
        totalCount  // í…Œì´ë¸” ë°ì´í„°ì™€ ë™ì¼í•œ totalCount ì‚¬ìš© (ì¤‘ìš”)
      };
    }
    
    // ë°±ì—”ë“œ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ í˜„ì¬ í˜ì´ì§€ ë°ì´í„°ë¡œ ê³„ì‚° (ì„ì‹œ ë°©ë²•)
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    
    return {
      totalCount,  // í…Œì´ë¸” ë°ì´í„°ì™€ ë™ì¼í•œ totalCount ì‚¬ìš© (ì¤‘ìš”)
      newLastWeekCount: cves.filter(cve => new Date(cve.createdAt) >= oneWeekAgo).length,
      highSeverityCount: cves.filter(cve => 
        cve.severity?.toLowerCase() === 'critical' || 
        cve.severity?.toLowerCase() === 'high'
      ).length,
      inProgressCount: cves.filter(cve => cve.status === 'ë¶„ì„ì¤‘').length,
      completedCount: cves.filter(cve => cve.status === 'ë¦´ë¦¬ì¦ˆ ì™„ë£Œ').length
    };
  }, [cves, totalCount, backendStats]);

  // ê°œì„ ëœ ê²€ìƒ‰ í•¸ë“¤ëŸ¬ - ë””ë°”ìš´ìŠ¤ ë° ìœ íš¨ì„± ê²€ì‚¬ ê°•í™”
  const handleSearchChange = useCallback((e) => {
    // í˜„ì¬ ì…ë ¥ê°’ ì„¤ì •
    const inputValue = e.target.value;
    setSearchInput(inputValue);
    
    // ì´ì „ íƒ€ì´ë¨¸ í´ë¦¬ì–´
    clearTimeout(searchTimeoutRef.current);
    
    // ê²€ìƒ‰ì–´ê°€ ë„ˆë¬´ ì§§ìœ¼ë©´ ê²€ìƒ‰í•˜ì§€ ì•ŠìŒ (ê³µë°±ë§Œ ìˆëŠ” ê²½ìš° ì œì™¸)
    const trimmedValue = inputValue.trim();
    
    // ê²€ìƒ‰ ì…ë ¥ê°’ ë””ë²„ê¹…
    console.log('ê²€ìƒ‰ ì…ë ¥ ê°’:', inputValue, 'ì •ì œëœ ê°’:', trimmedValue, 'ê¸¸ì´:', trimmedValue.length);
    
    // ë””ë°”ìš´ìŠ¤ ì²˜ë¦¬ - ì…ë ¥ í›„ 300ms í›„ì— ê²€ìƒ‰ ì‹¤í–‰
    searchTimeoutRef.current = setTimeout(() => {
      // ê²€ìƒ‰ì–´ê°€ ë¹„ì–´ìˆê±°ë‚˜ ê³µë°±ë§Œ ìˆëŠ” ê²½ìš°
      if (trimmedValue === '' && searchQuery !== '') {
        console.log('ê²€ìƒ‰ì–´ ì´ˆê¸°í™”');
        setSearchQuery('');
        setPage(1);
        
        // ê²€ìƒ‰ ì´ˆê¸°í™” ì‹œ ìºì‹œ ë¬´íš¨í™”
        queryClient.invalidateQueries({
          queryKey: [QUERY_KEYS.CVE.list],
          refetchType: 'active'
        });
      } 
      // ê²€ìƒ‰ì–´ê°€ 1ê¸€ì ì´ìƒì¸ ê²½ìš°
      else if (trimmedValue.length >= 1 && trimmedValue !== searchQuery) {
        console.log('ê²€ìƒ‰ ì¿¼ë¦¬ ì„¤ì •:', trimmedValue);
        // ì¿¼ë¦¬ ìºì‹œ ë¬´íš¨í™” í›„ ìƒˆ ê²€ìƒ‰ ì‹¤í–‰
        queryClient.invalidateQueries({
          queryKey: [QUERY_KEYS.CVE.list],
          refetchType: 'active'
        });
        setSearchQuery(trimmedValue);
        setPage(1); // í˜ì´ì§€ ì´ˆê¸°í™”
      }
    }, 300);
  }, [searchQuery, queryClient]);

  // ê²€ìƒ‰ ë¦¬ì…‹ í•¸ë“¤ëŸ¬ ê°œì„ 
  const handleResetSearch = useCallback(() => {
    console.log('ê²€ìƒ‰ ì´ˆê¸°í™”');
    setSearchInput('');
    setSearchQuery('');
    
    // ê²€ìƒ‰ ì´ˆê¸°í™” ì‹œ ìºì‹œ ë¬´íš¨í™”
    queryClient.invalidateQueries({
      queryKey: [QUERY_KEYS.CVE.list],
      refetchType: 'active'
    });
    
    setPage(1);
  }, [queryClient]);

  // í•„í„° í•¸ë“¤ëŸ¬ë“¤
  const handleStatusFilterChange = useCallback((e) => {
    setStatusFilter(e.target.value);
    setPage(1);
  }, []);

  const handleSeverityFilterChange = useCallback((e) => {
    setSeverityFilter(e.target.value);
    setPage(1);
  }, []);

  const handleSortOptionChange = useCallback((e) => {
    setSortOption(e.target.value);
    setPage(1);
  }, []);

  // í˜ì´ì§€ ë³€ê²½ í•¸ë“¤ëŸ¬ì— ë””ë°”ìš´ì‹± ì ìš© (ë¹ ë¥¸ ì—°ì† í´ë¦­ ë°©ì§€)
  const pageChangeTimeoutRef = useRef(null);
  
  const handlePageChange = useCallback((event, newPage) => {
    // ì´ì „ íƒ€ì„ì•„ì›ƒì´ ìˆìœ¼ë©´ ì·¨ì†Œ
    if (pageChangeTimeoutRef.current) {
      clearTimeout(pageChangeTimeoutRef.current);
    }
    
    // ìƒˆë¡œìš´ íƒ€ì„ì•„ì›ƒ ì„¤ì • (150ms ë””ë°”ìš´ìŠ¤)
    pageChangeTimeoutRef.current = setTimeout(() => {
      setPage(newPage + 1);
      pageChangeTimeoutRef.current = null;
    }, 150);
  }, []);

  const handleRowsPerPageChange = useCallback((event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(1);
  }, []);

  const handleRefresh = useCallback(() => {
    refetchCVEList();
    enqueueSnackbar('ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì¤‘...', { variant: 'info', autoHideDuration: 1000 });
  }, [refetchCVEList, enqueueSnackbar]);

  const handleCVEClick = useCallback((cve) => {
    setSelectedCVE(cve);
    setDetailOpen(true);
  }, []);

  const handleDetailClose = useCallback(() => {
    setDetailOpen(false);
    setSelectedCVE(null);
  }, []);

  const handleCreateCVE = useCallback(() => {
    setCreateDialogOpen(true);
  }, []);

  const handleCreateDialogClose = useCallback(() => {
    setCreateDialogOpen(false);
  }, []);

  // ìƒˆë¡œìš´ í›… ì‚¬ìš©
  const deleteMutation = useDeleteCVE();
  const createMutation = useCreateCVE();

  const handleCreateSubmit = useCallback(async (cveData) => {
    try {
      await createMutation.mutateAsync(cveData);
      // ì„±ê³µ ë©”ì‹œì§€ëŠ” useCVEService ë‚´ë¶€ì—ì„œ ì²˜ë¦¬ë¨
      handleCreateDialogClose();
    } catch (error) {
      // ì—ëŸ¬ ë©”ì‹œì§€ëŠ” useCVEService ë‚´ë¶€ì—ì„œ ì²˜ë¦¬ë¨
      console.error('CVE ìƒì„± ì¤‘ ì˜¤ë¥˜:', error);
    }
  }, [createMutation, handleCreateDialogClose]);

  const handleCreateFormSubmit = (event) => {
    event.preventDefault();
    const formData = new FormData(event.target);
    const data = {
      cveId: formData.get('cveId'),
      title: formData.get('title'),
      description: formData.get('description'),
      status: formData.get('status') || 'ì‹ ê·œë“±ë¡'
    };
    handleCreateSubmit(data);
  };

  const handleDeleteClick = useCallback((e, cve) => {
    e.stopPropagation();
    setCveToDelete(cve);
    setDeleteDialogOpen(true);
  }, []);

  const handleDeleteCancel = useCallback(() => {
    setDeleteDialogOpen(false);
    setCveToDelete(null);
  }, []);

  const handleDeleteConfirm = useCallback(async () => {
    if (!cveToDelete) return;
    try {
      const cveId = cveToDelete.cveId;
      await deleteMutation.mutateAsync(cveId);
      setDeleteDialogOpen(false);
      setCveToDelete(null);
      // ì„±ê³µ ë©”ì‹œì§€ëŠ” useCVEService ë‚´ë¶€ì—ì„œ ì²˜ë¦¬ë¨
    } catch (error) {
      // ì—ëŸ¬ ë©”ì‹œì§€ëŠ” useCVEService ë‚´ë¶€ì—ì„œ ì²˜ë¦¬ë¨
      console.error('CVE ì‚­ì œ ì¤‘ ì˜¤ë¥˜:', error);
    }
  }, [cveToDelete, deleteMutation]);

  const handleCVECreated = useCallback((newCVEData) => {
    handleCreateDialogClose();
    refetchCVEList();
  }, [handleCreateDialogClose, refetchCVEList]);

  return (
    <Box sx={{ width: '100%', px: { sm: 2, md: 3 } }}>
      {/* ìƒë‹¨ ì•¡ì…˜ ë²„íŠ¼ ì¶”ê°€ */}
      {renderActionButtons()}
      
      <StatisticsSection 
        statsData={statsData} 
        totalCount={totalCount} 
        theme={theme} 
      />

      {/* í•„í„° ì„¹ì…˜ */}
      <FilterBar 
        searchInput={searchInput}
        statusFilter={statusFilter}
        severityFilter={severityFilter}
        sortOption={sortOption}
        handleSearchChange={handleSearchChange}
        handleStatusFilterChange={handleStatusFilterChange}
        handleSeverityFilterChange={handleSeverityFilterChange}
        handleSortOptionChange={handleSortOptionChange}
        handleRefresh={handleRefresh}
        theme={theme}
      />

      {isLoading ? (
        <CVETableSkeleton />
      ) : isError ? (
        <ErrorDisplay error={queryError} onRetry={handleRefresh} />
      ) : (
        <>
          {cves.length === 0 ? (
            <EmptyStateDisplay 
              searchQuery={searchQuery} 
              onResetSearch={handleResetSearch}
              isFiltered={!!statusFilter || !!severityFilter || !!searchQuery}
            />
          ) : (
            <CVETable 
              cves={cves} 
              isLoading={isLoading} 
              page={page} 
              totalCount={totalCount}
              rowsPerPage={rowsPerPage}
              onPageChange={handlePageChange}
              onRowsPerPageChange={handleRowsPerPageChange}
              onCVEClick={handleCVEClick}
              theme={theme}
              sortOption={sortOption}
              searchQuery={searchQuery}
              onResetSearch={handleResetSearch}
              onDeleteClick={handleDeleteClick}
            />
          )}
        </>
      )}

      {/* ë‹¤ì´ì–¼ë¡œê·¸ ì»´í¬ë„ŒíŠ¸ë“¤ */}
      <CreateCVE open={createDialogOpen} onSuccess={handleCVECreated} onClose={handleCreateDialogClose} />

      {/* ìƒì„¸ë³´ê¸° ëª¨ë‹¬ */}
      {selectedCVE && (
        <CVEDetailWrapper
          cveId={selectedCVE.cveId}
          open={detailOpen}
          onClose={handleDetailClose}
        />
      )}

      <Dialog open={deleteDialogOpen} onClose={handleDeleteCancel}>
        <DialogTitle sx={{ p: 2 }}>CVE ì‚­ì œ í™•ì¸</DialogTitle>
        <DialogContent sx={{ px: 3, pt: 1, pb: 2 }}>
          <Typography sx={fontStyles}>
            '{cveToDelete?.cveId || ""}' í•­ëª©ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?
          </Typography>
          <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
            ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
          </Typography>
        </DialogContent>
        <DialogActions sx={{ px: 3, pb: 2 }}>
          <Button onClick={handleDeleteCancel} color="inherit">ì·¨ì†Œ</Button>
          <Button
            onClick={handleDeleteConfirm}
            color="error"
            variant="contained"
            disabled={deleteMutation.isPending}
            startIcon={deleteMutation.isPending ? <CircularProgress size={20} color="inherit" /> : null}
            sx={{
              boxShadow: 'none',
              '&:hover': { boxShadow: 'none', backgroundColor: 'error.dark' }
            }}
          >
            ì‚­ì œ
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default CVEList;


============================================================
File: /home/CVEHub/frontend/src/features/cve/CVEDetailInfoPanel.tsx
------------------------------------------------------------
import React, { useState, useCallback, memo } from 'react';
import {
  Grid,
  Typography,
  Box,
  Paper,
  IconButton,
  SxProps,
  Theme,
} from '@mui/material';
import CircleIcon from '@mui/icons-material/Circle';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import InlineEditText from './components/InlineEditText';

// íƒ€ì… ì •ì˜
interface StatusOption {
  label: string;
  description: string;
}

interface SeverityOption {
  value: string;
  label: string;
  color: string;
}

interface CVEData {
  title?: string;
  description?: string;
  status?: string;
  severity?: string;
  [key: string]: any; // ê¸°íƒ€ í•„ë“œë¥¼ ìœ„í•œ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜
}

interface CVEDetailInfoPanelProps {
  cveData: CVEData;
  onUpdateField: (field: string, value: string) => void;
  canEdit: boolean;
}

// ìƒìˆ˜ ë° ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ (ì›ë˜ CVEDetailì— ìˆë˜ ê²ƒë“¤)
// ë³„ë„ íŒŒì¼(constants/cveConstants.ts, utils/cveUtils.ts)ë¡œ ë¶„ë¦¬í•˜ëŠ” ê²ƒì„ ê°•ë ¥íˆ ê¶Œì¥í•©ë‹ˆë‹¤.
const STATUS_OPTIONS: Record<string, StatusOption> = {
  'ì‹ ê·œë“±ë¡': { label: 'ì‹ ê·œë“±ë¡', description: 'ìƒˆë¡œ ë“±ë¡ëœ CVE' },
  'ë¶„ì„ì¤‘': { label: 'ë¶„ì„ì¤‘', description: 'ë³´ì•ˆ ì „ë¬¸ê°€ê°€ ë¶„ì„ ì§„í–‰ì¤‘' },
  'ë¦´ë¦¬ì¦ˆ ì™„ë£Œ': { label: 'ë¦´ë¦¬ì¦ˆ ì™„ë£Œ', description: 'ë¶„ì„ì´ ì™„ë£Œë˜ì–´ ë¦´ë¦¬ì¦ˆë¨' },
  'ë¶„ì„ë¶ˆê°€': { label: 'ë¶„ì„ë¶ˆê°€', description: 'ë¶„ì„ì´ ë¶ˆê°€ëŠ¥í•œ ìƒíƒœ' }
};

const getStatusColor = (status: string): string => {
  switch (status) {
    case 'ë¶„ì„ì¤‘':      return '#2196f3';
    case 'ì‹ ê·œë“±ë¡':    return '#ff9800';
    case 'ë¦´ë¦¬ì¦ˆ ì™„ë£Œ': return '#4caf50';
    case 'ë¶„ì„ë¶ˆê°€':    return '#f44336';
    default:           return '#757575';
  }
};

const statusCardStyle: SxProps<Theme> = {
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'center',
  padding: '8px 12px',
  minHeight: '60px',
  border: '1px solid',
  borderRadius: 1,
  cursor: 'pointer',
  transition: 'all 0.2s',
  '&:hover': {
    backgroundColor: 'rgba(0, 0, 0, 0.04)',
    boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
  }
};

const SEVERITY_OPTIONS: SeverityOption[] = [
  { value: 'Critical', label: 'Critical', color: '#d32f2f' },
  { value: 'High', label: 'High', color: '#f44336' },
  { value: 'Medium', label: 'Medium', color: '#ff9800' },
  { value: 'Low', label: 'Low', color: '#4caf50' }
];

// Severity ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸° (ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ì´ ë¹„êµ ì¶”ê°€)
const getSeverityColor = (severity: string | undefined): string => {
  // severityê°€ nullì´ë‚˜ undefinedì¼ ê²½ìš° ë¹ˆ ë¬¸ìì—´ë¡œ ì²˜ë¦¬
  const lowerCaseSeverity = (severity || '').toLowerCase();
  const option = SEVERITY_OPTIONS.find(opt => opt.value.toLowerCase() === lowerCaseSeverity);
  return option ? option.color : '#757575'; // ê¸°ë³¸ ìƒ‰ìƒ
};
// --- ìƒìˆ˜ ë° ìœ í‹¸ë¦¬í‹° ë ---

const CVEDetailInfoPanel: React.FC<CVEDetailInfoPanelProps> = memo(({ cveData, onUpdateField, canEdit }) => {
  const [detailExpanded, setDetailExpanded] = useState<boolean>(false);

  // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ì— ì°¸ì¡° ì•ˆì •ì„± ë³´ì¥
  const handleTitleSave = useCallback((newTitle: string): void => {
    // ê°’ì´ ì‹¤ì œë¡œ ë³€ê²½ë˜ì—ˆëŠ”ì§€ í™•ì¸ í›„ ì—…ë°ì´íŠ¸ ìš”ì²­
    if (canEdit && newTitle !== cveData?.title) {
      onUpdateField('title', newTitle);
    }
  }, [canEdit, cveData?.title, onUpdateField]);

  const handleDescriptionSave = useCallback((newDescription: string): void => {
    // ê°’ì´ ì‹¤ì œë¡œ ë³€ê²½ë˜ì—ˆëŠ”ì§€ í™•ì¸ í›„ ì—…ë°ì´íŠ¸ ìš”ì²­
    if (canEdit && newDescription !== cveData?.description) {
      onUpdateField('description', newDescription);
    }
  }, [canEdit, cveData?.description, onUpdateField]);

  const handleStatusClick = useCallback((newStatus: string): void => {
    // í¸ì§‘ ê¶Œí•œì´ ìˆê³  ì‹¤ì œ ê°’ì´ ë³€ê²½ëœ ê²½ìš°ì—ë§Œ ì—…ë°ì´íŠ¸
    if (canEdit && newStatus !== cveData?.status) {
      onUpdateField('status', newStatus);
    }
  }, [canEdit, cveData?.status, onUpdateField]);

  const handleSeverityClick = useCallback((newSeverity: string): void => {
    // í¸ì§‘ ê¶Œí•œì´ ìˆê³  ì‹¤ì œ ê°’ì´ ë³€ê²½ëœ ê²½ìš°ì—ë§Œ ì—…ë°ì´íŠ¸
    if (canEdit && newSeverity !== cveData?.severity) {
      onUpdateField('severity', newSeverity);
    }
  }, [canEdit, cveData?.severity, onUpdateField]);

  // ì„¤ëª… í•„ë“œ í™•ì¥/ì¶•ì†Œ í† ê¸€ í•¸ë“¤ëŸ¬
  const toggleDetailExpanded = useCallback(() => {
    setDetailExpanded(prev => !prev);
  }, []);

  // ì„¤ëª… í•„ë“œ í¸ì§‘ ì¢…ë£Œ ì‹œ ì¶•ì†Œ í•¸ë“¤ëŸ¬
  const handleDescriptionEditEnd = useCallback(() => {
    // í¸ì§‘ì´ ëë‚œ í›„ ì•½ê°„ì˜ ë”œë ˆì´ í›„ì— ì¶•ì†Œ (UX ê°œì„ )
    setTimeout(() => setDetailExpanded(false), 100);
  }, []);

  return (
    <Grid container spacing={2}>
      {/* ì¢Œì¸¡: Title, Description */}
      <Grid item xs={12} md={7}>
        {/* Title */}
        <Box mb={2}>
          <Typography variant="subtitle2" color="text.secondary" gutterBottom>
            Title
          </Typography>
          <Paper variant="outlined" sx={{ p: 1, borderRadius: 1, mb: 2 }}>
            <InlineEditText
              value={cveData?.title || ''}
              onSave={handleTitleSave}
              placeholder="ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
              disabled={!canEdit}
              fontSize="0.9rem"
            />
          </Paper>
        </Box>

        {/* Description */}
        <Box>
          <Typography variant="subtitle2" color="text.secondary" gutterBottom>
            Description
          </Typography>
          <Box sx={{ position: 'relative' }}>
            <Paper
              className="description-container"
              variant="outlined"
              sx={{
                p: 1,
                borderRadius: 1,
                border: '1px solid',
                borderColor: 'divider',
                overflow: 'hidden',
                transition: 'max-height 0.3s ease-in-out',
                height: 'auto',
                maxHeight: detailExpanded ? '500px' : '100px',
                display: 'flex',
                flexDirection: 'column'
              }}
            >
              <InlineEditText
                value={cveData?.description || ''}
                multiline
                maxHeight={detailExpanded ? '500px' : '100px'}
                onSave={handleDescriptionSave}
                placeholder="ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”..."
                disabled={!canEdit}
                fontSize="0.85rem"
                onEditingStart={() => setDetailExpanded(true)}
                onEditingEnd={handleDescriptionEditEnd}
              />
            </Paper>
            {/* í™•ì¥/ì¶•ì†Œ ë²„íŠ¼ */}
            <Box sx={{ position: 'absolute', bottom: 4, right: 4 }}>
              <IconButton size="small" onClick={toggleDetailExpanded}>
                {detailExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}
              </IconButton>
            </Box>
          </Box>
        </Box>
      </Grid>

      {/* ìš°ì¸¡: Status, Severity */}
      <Grid item xs={12} md={5}>
        {/* Status */}
        <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1 }}>
          Status
        </Typography>
        <Box
          sx={{
            display: 'grid',
            gridTemplateColumns: 'repeat(2, 1fr)',
            gap: 1.5,
            height: '150px' // ê³ ì • ë†’ì´ ìœ ì§€
          }}
        >
          {Object.entries(STATUS_OPTIONS).map(([value, { label, description }]) => {
            const isSelected = value === cveData?.status;
            const currentStatusColor = getStatusColor(value);
            return (
              <Paper
                key={value}
                elevation={0}
                sx={{
                  ...statusCardStyle, // ê¸°ë³¸ ìŠ¤íƒ€ì¼ ì ìš©
                  bgcolor: isSelected ? 'action.selected' : 'background.paper',
                  borderColor: isSelected ? currentStatusColor : 'divider',
                  cursor: canEdit ? 'pointer' : 'default', // í¸ì§‘ ê°€ëŠ¥í•  ë•Œë§Œ ì»¤ì„œ ë³€ê²½
                  // í˜¸ë²„ ìŠ¤íƒ€ì¼ì€ canEditì¼ ë•Œë§Œ ì ìš©
                  ...(canEdit && {
                    '&:hover': {
                      backgroundColor: 'rgba(0, 0, 0, 0.04)',
                      boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
                    }
                  }),
                }}
                onClick={() => handleStatusClick(value)}
              >
                <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 1, width: '100%' }}>
                  <CircleIcon sx={{ fontSize: 8, color: currentStatusColor, flexShrink: 0, mt: 0.7 }} />
                  <Box sx={{ display: 'flex', flexDirection: 'column', width: '100%', minWidth: 0 }}>
                    <Typography variant="body2" sx={{ fontWeight: isSelected ? 600 : 400, color: isSelected ? currentStatusColor : 'text.primary', lineHeight: 1.2 }}>
                      {label}
                    </Typography>
                    <Typography variant="caption" color="text.secondary">
                      {description}
                    </Typography>
                  </Box>
                </Box>
              </Paper>
            );
          })}
        </Box>

        {/* Severity */}
        <Box sx={{ mt: 2 }}>
          <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1 }}>
            Severity
          </Typography>
          <Box sx={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: 1 }}>
            {SEVERITY_OPTIONS.map((option) => {
              const backendSeverity = (cveData?.severity || '').toLowerCase();
              const optionValue = option.value.toLowerCase();
              const isSelected = optionValue === backendSeverity;
              const currentSeverityColor = getSeverityColor(option.value); // ì˜µì…˜ ê°’ ê¸°ì¤€ìœ¼ë¡œ ìƒ‰ìƒ ê°€ì ¸ì˜¤ê¸°

              return (
                <Paper
                  key={option.value}
                  elevation={0}
                  sx={{
                    display: 'flex',
                    flexDirection: 'column',
                    justifyContent: 'center',
                    alignItems: 'center', // ì¤‘ì•™ ì •ë ¬
                    minHeight: '40px',
                    border: '1px solid',
                    borderRadius: 1,
                    p: 1, // íŒ¨ë”©
                    textAlign: 'center',
                    cursor: canEdit ? 'pointer' : 'default',
                    transition: 'all 0.2s',
                    bgcolor: isSelected ? 'action.selected' : 'background.paper',
                    borderColor: isSelected ? currentSeverityColor : 'divider',
                    // í˜¸ë²„ ìŠ¤íƒ€ì¼
                    ...(canEdit && {
                      '&:hover': {
                        backgroundColor: 'rgba(0, 0, 0, 0.04)',
                        borderColor: currentSeverityColor, // í˜¸ë²„ ì‹œ í•´ë‹¹ ìƒ‰ìƒìœ¼ë¡œ í…Œë‘ë¦¬ ë³€ê²½
                        boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
                      }
                    }),
                  }}
                  onClick={() => handleSeverityClick(option.value)}
                >
                  <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', gap: 0.5 }}> {/* ì•„ì´ì½˜ê³¼ í…ìŠ¤íŠ¸ ê°„ê²© ì¡°ì • */}
                    <CircleIcon sx={{ fontSize: 8, color: currentSeverityColor, flexShrink: 0 }} />
                    <Typography
                      variant="body2"
                      sx={{
                        fontWeight: isSelected ? 600 : 400,
                        color: isSelected ? currentSeverityColor : 'text.primary'
                      }}
                    >
                      {option.label}
                    </Typography>
                  </Box>
                </Paper>
              );
            })}
          </Box>
        </Box>
      </Grid>
    </Grid>
  );
});

// displayName ì„¤ì • (React DevToolsì—ì„œ ë””ë²„ê¹… ì‹œ ìœ ìš©)
CVEDetailInfoPanel.displayName = 'CVEDetailInfoPanel';

export default CVEDetailInfoPanel;


============================================================
File: /home/CVEHub/frontend/src/features/cve/CreateCVE.tsx
------------------------------------------------------------
import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Button,
  TextField,
  Typography,
  Paper,
  Grid,
  Divider,
  Chip,
  IconButton,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Autocomplete,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Alert,
  Link,
  useTheme,
  alpha,
  SelectChangeEvent,
  TextFieldProps,
  Theme,
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
} from '@mui/icons-material';
// ê¸°ì¡´ hook ë° ìœ í‹¸ë¦¬í‹° importëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€
import { useCreateCVE } from 'features/cve/hooks/useCVEMutation';
import { useSnackbar } from 'notistack';
import { useNavigate } from 'react-router-dom';
import { useQueryClient } from '@tanstack/react-query';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { getUser } from 'shared/utils/storage/tokenStorage';
import { getUtcTimestamp } from 'shared/utils/dateUtils';
import { ApiResponse } from 'shared/api/types/api';
import { 
  CVEDetail,
  CVEData, 
  FormData, 
  PoCFile as PoC, 
  SnortRuleFile as SnortRule, 
  ReferenceFile as Reference, 
  SelectOption 
} from 'features/cve/types/cve';

// íƒ€ì… ì •ì˜
interface CreateCVEProps {
  open?: boolean;
  onClose: () => void;
  onSuccess?: (data: CVEData) => void;
}

// ìƒìˆ˜ ì •ì˜
const POC_SOURCES: Record<string, string> = { Etc: "Etc", Metasploit: "Metasploit", "Nuclei-Templates": "Nuclei-Templates" };
const SNORT_RULE_TYPES: Record<string, string> = { "ì‚¬ìš©ì ì •ì˜": "USER_DEFINED", "IPS": "IPS", "ONE": "ONE", "UTM": "UTM", "Emerging-Threats": "EMERGING_THREATS", "Snort Official": "SNORT_OFFICIAL" };
const SNORT_RULE_TYPE_OPTIONS: Array<{ label: string; value: string }> = Object.entries(SNORT_RULE_TYPES).map(([label, value]) => ({ label, value }));
const STATUS_OPTIONS: SelectOption[] = [{ value: 'ì‹ ê·œë“±ë¡', label: 'ì‹ ê·œë“±ë¡' }, { value: 'ë¶„ì„ì¤‘', label: 'ë¶„ì„ì¤‘' }, { value: 'ë¦´ë¦¬ì¦ˆ ì™„ë£Œ', label: 'ë¦´ë¦¬ì¦ˆ ì™„ë£Œ' }, { value: 'ë¶„ì„ë¶ˆê°€', label: 'ë¶„ì„ë¶ˆê°€' }];
const SEVERITY_OPTIONS: SelectOption[] = [{ value: 'Critical', label: 'Critical' }, { value: 'High', label: 'High' }, { value: 'Medium', label: 'Medium' }, { value: 'Low', label: 'Low' }, { value: 'None', label: 'None' }];

// ìŠ¤íƒ€ì¼ ìƒìˆ˜ ë° í•¨ìˆ˜
const antdBorderColor = '#d9d9d9';
const antdPrimaryColor = '#1677ff';
const antdBorderRadius = '6px';
const antdInputHeight = '32px';
const antdListBgColor = '#fafafa';

// ì…ë ¥ í•„ë“œ ê³µí†µ ìŠ¤íƒ€ì¼ (AntD ìœ ì‚¬)
const inputStyles = (theme: Theme) => ({
  borderRadius: antdBorderRadius,
  '& .MuiOutlinedInput-root': {
    borderRadius: antdBorderRadius,
    '& fieldset': {
      borderColor: antdBorderColor,
    },
    '&:hover fieldset': {
      borderColor: theme.palette.primary.main,
    },
    '&.Mui-focused fieldset': {
      borderColor: theme.palette.primary.main,
      borderWidth: '1px',
    },
  },
  '& .MuiInputLabel-outlined': {}
});

// íƒœê·¸(Chip) ìŠ¤íƒ€ì¼ (AntD Tag ìœ ì‚¬)
const tagStyles = (theme: Theme, type: string, value: string) => {
  let colors: { bgcolor: string; color: string } = { bgcolor: alpha(theme.palette.grey[500], 0.1), color: theme.palette.text.secondary }; // Default (None/Unknown)

  if (type === 'severity') {
    const severityLower = value ? String(value).toLowerCase() : '';
    switch (severityLower) {
      case 'critical': colors = { bgcolor: alpha(theme.palette.error.main, 0.1), color: theme.palette.error.dark }; break;
      case 'high': colors = { bgcolor: alpha(theme.palette.warning.main, 0.15), color: theme.palette.warning.dark }; break;
      case 'medium': colors = { bgcolor: alpha(theme.palette.info.main, 0.1), color: theme.palette.info.dark }; break;
      case 'low': colors = { bgcolor: alpha(theme.palette.success.light, 0.2), color: theme.palette.success.dark }; break;
    }
  } else if (type === 'status') {
    switch (value) {
      case 'ì‹ ê·œë“±ë¡': colors = { bgcolor: alpha(theme.palette.primary.light, 0.15), color: theme.palette.primary.dark }; break;
      case 'ë¶„ì„ì¤‘': colors = { bgcolor: alpha(theme.palette.secondary.light, 0.15), color: theme.palette.secondary.dark }; break;
      case 'ë¦´ë¦¬ì¦ˆ ì™„ë£Œ': colors = { bgcolor: alpha(theme.palette.success.light, 0.2), color: theme.palette.success.dark }; break;
      case 'ë¶„ì„ë¶ˆê°€': colors = { bgcolor: alpha(theme.palette.error.light, 0.1), color: theme.palette.error.dark }; break;
    }
  }

  return {
    ...colors,
    height: '22px',
    fontSize: '0.75rem',
    borderRadius: '4px',
    border: `1px solid ${colors.bgcolor}`,
    mr: 0.5,
    mb: 0.5,
  };
};

// ì»´í¬ë„ŒíŠ¸ ì‹œì‘
const CreateCVE: React.FC<CreateCVEProps> = ({ open = false, onClose, onSuccess }) => {
  // ë¨¸í…Œë¦¬ì–¼ UI í…Œë§ˆë¥¼ ê°€ì ¸ì˜¤ê³  íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •
  const theme: Theme = useTheme();
  const { enqueueSnackbar } = useSnackbar();

  // ìƒíƒœ ì •ì˜
  const [formData, setFormData] = useState<FormData>({
    cveId: '',
    title: '',
    description: '',
    status: 'ì‹ ê·œë“±ë¡',
    severity: 'Low',
    tags: [],
    exploitStatus: 'Unknown',
  });

  const [poc, setPoc] = useState<PoC[]>([]);
  const [snortRule, setSnortRule] = useState<SnortRule[]>([]);
  const [reference, setReference] = useState<Reference[]>([]);

  const [newPoc, setNewPoc] = useState<Omit<PoC, 'id' | 'created_by' | 'last_modified_by'>>({ source: POC_SOURCES.Etc, url: '' });
  const [newSnortRule, setNewSnortRule] = useState<Omit<SnortRule, 'id' | 'created_by' | 'last_modified_by'>>({ rule: '', type: 'USER_DEFINED' });
  const [newReference, setNewReference] = useState<string>('');
  const [error, setError] = useState<string>('');

  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const currentUser = getUser();
  const username = currentUser?.username || 'anonymous';

  const { mutate, isPending, error: mutationError } = useCreateCVE({
    onSuccess: (response: ApiResponse<CVEDetail>) => {
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.CVE.lists(), refetchType: 'active' });
      enqueueSnackbar('CVEê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤', { variant: 'success' });
      if (onSuccess && response.data) {
        // response.dataë¥¼ CVEData í˜•íƒœë¡œ ë³€í™˜í•˜ì—¬ ì „ë‹¬
        const cveData: CVEData = {
          cveId: response.data.cveId,
          title: response.data.title || '',
          description: response.data.description || '',
          status: response.data.status,
          severity: response.data.severity || '',
          tags: (response.data.tags as string[]) || [],
          exploitStatus: (response.data.exploitStatus as string) || '',
          // ë°°ì—´ í˜•íƒœë¡œ ë³€í™˜í•  ë•ŒëŠ” ë¦¬í„´íƒ€ì…ì— ë§ê²Œ ë³€í™˜í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤
          poc: Array.isArray(response.data.poc) 
            ? (response.data.poc as any[]).map(poc => ({
                source: poc.source || '',
                url: poc.url || ''
              })) 
            : [],
          snortRule: Array.isArray(response.data.snortRule) 
            ? (response.data.snortRule as any[]).map(rule => ({
                rule: rule.rule || '',
                type: rule.type || ''
              })) 
            : [],
          reference: Array.isArray(response.data.reference) 
            ? (response.data.reference as any[]).map(ref => ({
                url: ref.url || ''
              })) 
            : [],
        };
        onSuccess(cveData);
      }
      handleClose();
    },
    onError: (error: Error) => handleError(error)
  });

  const handleError = (error: Error): void => {
    const errorMsg = `CVE ìƒì„± ì‹¤íŒ¨: ${error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`;
    enqueueSnackbar(errorMsg, { variant: 'error' });
    setError(errorMsg);
  };

  // í¼ í•„ë“œ ë³€ê²½ í•¸ë“¤ëŸ¬
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement> | SelectChangeEvent<string>): void => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  // Autocomplete (Tags) í•¸ë“¤ëŸ¬
  const handleTagsChange = (event: React.SyntheticEvent, newValue: string[]): void => {
    setFormData(prev => ({ ...prev, tags: newValue }));
  };

  // ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸° ë° í¼ ì´ˆê¸°í™”
  const handleClose = (): void => {
    setFormData({
      cveId: '',
      title: '',
      description: '',
      status: 'ì‹ ê·œë“±ë¡',
      severity: 'Low',
      tags: [],
      exploitStatus: 'Unknown'
    });
    setPoc([]);
    setSnortRule([]);
    setReference([]);
    setNewPoc({ source: POC_SOURCES.Etc, url: '' });
    setNewSnortRule({ rule: '', type: 'USER_DEFINED' });
    setNewReference('');
    setError('');
    onClose();
  };

  // ëª©ë¡ ì¶”ê°€/ì‚­ì œ í•¸ë“¤ëŸ¬
  const handleAddPoc = (): void => {
    if (!newPoc.url.trim()) return;
    setPoc(prev => [...prev, {
      ...newPoc,
      id: `poc-${Date.now()}`,
      created_by: username,
      last_modified_by: username
    }]);
    setNewPoc({ source: POC_SOURCES.Etc, url: '' });
  };

  const handleRemovePoc = (id: string): void => {
    setPoc(prev => prev.filter(item => item.id !== id));
  };

  const handleAddSnortRule = (): void => {
    if (!newSnortRule.rule.trim()) return;
    setSnortRule(prev => [...prev, {
      ...newSnortRule,
      id: `snort-${Date.now()}`,
      created_by: username,
      last_modified_by: username
    }]);
    setNewSnortRule({ rule: '', type: 'USER_DEFINED' });
  };

  const handleRemoveSnortRule = (id: string): void => {
    setSnortRule(prev => prev.filter(item => item.id !== id));
  };

  const handleAddReference = (): void => {
    if (!newReference.trim()) return;
    const utcTime = getUtcTimestamp();
    setReference(prev => [...prev, {
      url: newReference.trim(),
      id: `ref-${Date.now()}`,
      created_at: utcTime,
      created_by: username,
      last_modified_at: null,
      last_modified_by: username
    }]);
    setNewReference('');
  };

  const handleRemoveReference = (id: string): void => {
    setReference(prev => prev.filter(item => item.id !== id));
  };

  const handleSubmit = async (e: React.FormEvent): Promise<void> => {
    e.preventDefault();

    if (!formData.cveId.trim()) {
      setError('CVE IDëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.');
      enqueueSnackbar('í•„ìˆ˜ ì…ë ¥ ê°’ì„ í™•ì¸í•´ì£¼ì„¸ìš”.', { variant: 'warning' });
      return;
    }
    setError('');

    const cveData: CVEData = {
      ...formData,
      poc: poc.map(({ id, ...rest }) => rest),
      snortRule: snortRule.map(({ id, ...rest }) => rest),
      reference: reference.map(({ id, ...rest }) => rest),
    };

    mutate(cveData);
  };

  return (
    <Dialog
      open={open}
      onClose={handleClose}
      maxWidth="md"
      fullWidth
      PaperProps={{ sx: { minHeight: '80vh', borderRadius: antdBorderRadius } }}
    >
      <DialogTitle sx={{ pb: 1, borderBottom: `1px solid ${antdBorderColor}` }}>
        <Typography variant="h6" component="div" sx={{ fontWeight: 500 }}>
          ìƒˆ CVE ë“±ë¡
        </Typography>
      </DialogTitle>
      <DialogContent sx={{ pt: '20px !important', backgroundColor: '#f5f5f5' }}>
        {error && (
          <Alert severity="error" onClose={() => setError('')} sx={{ mb: 2, borderRadius: antdBorderRadius }}>
            {error}
          </Alert>
        )}

        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
          {/* ê¸°ë³¸ ì •ë³´ ì„¹ì…˜ */}
          <Paper elevation={0} sx={{ p: 2.5, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
            <Typography variant="subtitle1" sx={{ mb: 2.5, fontWeight: 500 }}>ê¸°ë³¸ ì •ë³´</Typography>
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6} md={4} lg={3}>
                <TextField
                  required
                  fullWidth
                  label="CVE ID"
                  name="cveId"
                  value={formData.cveId}
                  onChange={handleInputChange}
                  helperText="Format: CVE-YYYY-NNNNN"
                  size="small"
                  sx={inputStyles(theme)}
                  error={!formData.cveId.trim() && !!error}
                />
              </Grid>
              <Grid item xs={12} sm={6} md={8} lg={5}>
                <TextField
                  fullWidth
                  label="ì œëª©"
                  name="title"
                  value={formData.title}
                  onChange={handleInputChange}
                  size="small"
                  sx={inputStyles(theme)}
                />
              </Grid>
              <Grid item xs={12} sm={6} md={4} lg={2}>
                <FormControl fullWidth size="small" sx={inputStyles(theme)}>
                  <InputLabel>ìƒíƒœ</InputLabel>
                  <Select
                    name="status"
                    value={formData.status}
                    onChange={handleInputChange}
                    label="ìƒíƒœ"
                  >
                    {STATUS_OPTIONS.map(option => (
                      <MenuItem key={option.value} value={option.value}>{option.label}</MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>
              <Grid item xs={12} sm={6} md={4} lg={2}>
                <FormControl fullWidth size="small" sx={inputStyles(theme)}>
                  <InputLabel>ì‹¬ê°ë„</InputLabel>
                  <Select
                    name="severity"
                    value={formData.severity}
                    onChange={handleInputChange}
                    label="ì‹¬ê°ë„"
                  >
                    {SEVERITY_OPTIONS.map(option => (
                      <MenuItem key={option.value} value={option.value}>{option.label}</MenuItem>
                    ))}
                  </Select>
                </FormControl>
              </Grid>
            </Grid>
            <TextField
              label="ì„¤ëª…"
              name="description"
              value={formData.description}
              onChange={handleInputChange}
              multiline
              rows={4}
              fullWidth
              size="small"
              sx={{ ...inputStyles(theme), mt: 2 }}
            />
            <Autocomplete
              multiple
              freeSolo
              options={[]}
              value={formData.tags}
              onChange={handleTagsChange}
              renderTags={(value: string[], getTagProps) =>
                value.map((option, index) => (
                  <Chip
                    label={option}
                    size="small"
                    sx={tagStyles(theme, 'tag', option)}
                    {...getTagProps({ index })}
                  />
                ))
              }
              renderInput={(params) => (
                <TextField
                  {...params}
                  label="íƒœê·¸"
                  placeholder="íƒœê·¸ ì…ë ¥ í›„ Enter"
                  size="small"
                  sx={{ ...inputStyles(theme), mt: 2 }}
                />
              )}
              sx={{ mt: 2 }}
            />
          </Paper>

          {/* PoC ì„¹ì…˜ */}
          <Paper elevation={0} sx={{ p: 2.5, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
            <Typography variant="subtitle1" sx={{ mb: 2, fontWeight: 500 }}>Proof of Concepts (PoC)</Typography>
            <Box sx={{ display: 'flex', gap: 1, mb: 2, alignItems: 'center' }}>
              <FormControl size="small" sx={{ ...inputStyles(theme), width: '25%', minWidth: 150 }}>
                <InputLabel>Source</InputLabel>
                <Select
                  value={newPoc.source}
                  onChange={(e) => setNewPoc(prev => ({ ...prev, source: e.target.value }))}
                  label="Source"
                >
                  {Object.entries(POC_SOURCES).map(([key, value]) => (
                    <MenuItem key={key} value={value}>{value}</MenuItem>
                  ))}
                </Select>
              </FormControl>
              <TextField
                size="small"
                placeholder="PoC URL"
                value={newPoc.url}
                onChange={(e) => setNewPoc(prev => ({ ...prev, url: e.target.value }))}
                sx={{ ...inputStyles(theme), flexGrow: 1 }}
                onKeyDown={(e) => e.key === 'Enter' && handleAddPoc()}
              />
              <Button
                variant="outlined"
                onClick={handleAddPoc}
                startIcon={<AddIcon />}
                sx={{
                  borderRadius: antdBorderRadius,
                  borderColor: antdBorderColor,
                  color: theme.palette.text.secondary,
                  borderStyle: 'dashed',
                  height: antdInputHeight,
                  '&:hover': {
                    borderColor: theme.palette.primary.main,
                    color: theme.palette.primary.main,
                    backgroundColor: alpha(theme.palette.primary.main, 0.05),
                    borderStyle: 'dashed',
                  }
                }}
              >
                ì¶”ê°€
              </Button>
            </Box>
            <Box sx={{ maxHeight: '200px', overflowY: 'auto', p: 1, bgcolor: antdListBgColor, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
              {poc.length === 0 ? (
                <Typography variant="body2" color="textSecondary" align="center" sx={{ p: 2 }}>ì¶”ê°€ëœ PoCê°€ ì—†ìŠµë‹ˆë‹¤.</Typography>
              ) : (
                poc.map((poc) => (
                  <Paper key={poc.id} elevation={0} sx={{ p: 1, mb: 1, display: 'flex', gap: 1, alignItems: 'center', borderRadius: '4px', border: `1px solid ${alpha(antdBorderColor, 0.6)}`, '&:last-child': { mb: 0 } }}>
                    <Typography variant="body2" sx={{ width: '25%', fontWeight: 500, flexShrink: 0 }}>{poc.source}</Typography>
                    <Link href={poc.url} target="_blank" rel="noopener noreferrer" variant="body2" sx={{ flexGrow: 1, wordBreak: 'break-all', color: theme.palette.primary.main }}>
                      {poc.url}
                    </Link>
                    <IconButton onClick={() => handleRemovePoc(poc.id as string)} size="small" sx={{ color: theme.palette.error.main, '&:hover': { bgcolor: alpha(theme.palette.error.main, 0.1) } }}>
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                  </Paper>
                ))
              )}
            </Box>
          </Paper>

          {/* Snort Rules ì„¹ì…˜ */}
          <Paper elevation={0} sx={{ p: 2.5, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
            <Typography variant="subtitle1" sx={{ mb: 2, fontWeight: 500 }}>Snort Rules</Typography>
            <Box sx={{ display: 'flex', gap: 1, mb: 2, alignItems: 'center' }}>
              <FormControl size="small" sx={{ ...inputStyles(theme), width: '30%', minWidth: 180 }}>
                <InputLabel>Rule Type</InputLabel>
                <Select
                  value={newSnortRule.type}
                  onChange={(e) => setNewSnortRule(prev => ({ ...prev, type: e.target.value }))}
                  label="Rule Type"
                >
                  {SNORT_RULE_TYPE_OPTIONS.map(({ label, value }) => (
                    <MenuItem key={value} value={value}>{label}</MenuItem>
                  ))}
                </Select>
              </FormControl>
              <TextField
                size="small"
                placeholder="Snort Rule"
                value={newSnortRule.rule}
                onChange={(e) => setNewSnortRule(prev => ({ ...prev, rule: e.target.value }))}
                sx={{ ...inputStyles(theme), flexGrow: 1 }}
                onKeyDown={(e) => e.key === 'Enter' && handleAddSnortRule()}
              />
              <Button
                variant="outlined"
                onClick={handleAddSnortRule}
                startIcon={<AddIcon />}
                sx={{
                  borderRadius: antdBorderRadius,
                  borderColor: antdBorderColor,
                  color: theme.palette.text.secondary,
                  borderStyle: 'dashed',
                  height: antdInputHeight,
                  '&:hover': {
                    borderColor: theme.palette.primary.main,
                    color: theme.palette.primary.main,
                    backgroundColor: alpha(theme.palette.primary.main, 0.05),
                    borderStyle: 'dashed',
                  }
                }}
              >
                ì¶”ê°€
              </Button>
            </Box>
            <Box sx={{ maxHeight: '200px', overflowY: 'auto', p: 1, bgcolor: antdListBgColor, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
              {snortRule.length === 0 ? (
                <Typography variant="body2" color="textSecondary" align="center" sx={{ p: 2 }}>ì¶”ê°€ëœ Snort Ruleì´ ì—†ìŠµë‹ˆë‹¤.</Typography>
              ) : (
                snortRule.map((rule) => (
                  <Paper key={rule.id} elevation={0} sx={{ p: 1, mb: 1, display: 'flex', gap: 1, alignItems: 'center', borderRadius: '4px', border: `1px solid ${alpha(antdBorderColor, 0.6)}`, '&:last-child': { mb: 0 } }}>
                    <Typography variant="body2" sx={{ width: '30%', fontWeight: 500, flexShrink: 0 }}>
                      {SNORT_RULE_TYPE_OPTIONS.find(opt => opt.value === rule.type)?.label || rule.type}
                    </Typography>
                    <Typography variant="body2" sx={{ flexGrow: 1, whiteSpace: 'pre-wrap', wordBreak: 'break-all', fontFamily: 'monospace', fontSize: '0.8rem' }}>
                      {rule.rule}
                    </Typography>
                    <IconButton onClick={() => handleRemoveSnortRule(rule.id as string)} size="small" sx={{ color: theme.palette.error.main, '&:hover': { bgcolor: alpha(theme.palette.error.main, 0.1) } }}>
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                  </Paper>
                ))
              )}
            </Box>
          </Paper>

          {/* Reference ì„¹ì…˜ */}
          <Paper elevation={0} sx={{ p: 2.5, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
            <Typography variant="subtitle1" sx={{ mb: 2, fontWeight: 500 }}>Reference</Typography>
            <Box sx={{ display: 'flex', gap: 1, mb: 2, alignItems: 'center' }}>
              <TextField
                size="small"
                placeholder="ì°¸ì¡° URL"
                value={newReference}
                onChange={(e) => setNewReference(e.target.value)}
                fullWidth
                sx={inputStyles(theme)}
                onKeyDown={(e) => e.key === 'Enter' && handleAddReference()}
              />
              <Button
                variant="outlined"
                onClick={handleAddReference}
                startIcon={<AddIcon />}
                sx={{
                  borderRadius: antdBorderRadius,
                  borderColor: antdBorderColor,
                  color: theme.palette.text.secondary,
                  borderStyle: 'dashed',
                  height: antdInputHeight,
                  '&:hover': {
                    borderColor: theme.palette.primary.main,
                    color: theme.palette.primary.main,
                    backgroundColor: alpha(theme.palette.primary.main, 0.05),
                    borderStyle: 'dashed',
                  }
                }}
              >
                ì¶”ê°€
              </Button>
            </Box>
            <Box sx={{ maxHeight: '200px', overflowY: 'auto', p: 1, bgcolor: antdListBgColor, borderRadius: antdBorderRadius, border: `1px solid ${antdBorderColor}` }}>
              {reference.length === 0 ? (
                <Typography variant="body2" color="textSecondary" align="center" sx={{ p: 2 }}>ì¶”ê°€ëœ ì°¸ì¡° URLì´ ì—†ìŠµë‹ˆë‹¤.</Typography>
              ) : (
                reference.map((ref) => (
                  <Paper key={ref.id} elevation={0} sx={{ p: 1, mb: 1, display: 'flex', gap: 1, alignItems: 'center', borderRadius: '4px', border: `1px solid ${alpha(antdBorderColor, 0.6)}`, '&:last-child': { mb: 0 } }}>
                    <Link href={ref.url} target="_blank" rel="noopener noreferrer" variant="body2" sx={{ flexGrow: 1, wordBreak: 'break-all', color: theme.palette.primary.main }}>
                      {ref.url}
                    </Link>
                    <IconButton onClick={() => handleRemoveReference(ref.id as string)} size="small" sx={{ color: theme.palette.error.main, '&:hover': { bgcolor: alpha(theme.palette.error.main, 0.1) } }}>
                      <DeleteIcon fontSize="small" />
                    </IconButton>
                  </Paper>
                ))
              )}
            </Box>
          </Paper>
        </Box>
      </DialogContent>
      <DialogActions sx={{ p: 2, borderTop: `1px solid ${antdBorderColor}`, backgroundColor: '#fff' }}>
        <Button
          onClick={handleClose}
          variant="outlined"
          sx={{ borderRadius: antdBorderRadius, borderColor: antdBorderColor, color: theme.palette.text.primary }}
        >
          ì·¨ì†Œ
        </Button>
        <Button
          variant="contained"
          color="primary"
          onClick={handleSubmit}
          disabled={isPending || !formData.cveId.trim()}
          startIcon={isPending ? <CircularProgress size={20} color="inherit" /> : null}
          sx={{
            borderRadius: antdBorderRadius,
            boxShadow: 'none',
          }}
        >
          CVE ìƒì„±
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default CreateCVE;


============================================================
File: /home/CVEHub/frontend/src/features/cve/tests/BridgeTest.tsx
------------------------------------------------------------
// src/features/cve/tests/BridgeTest.tsx
import React from 'react';
import { CVEDetail, Reference, PoC, Comment } from '../types/bridge';

/**
 * ë¸Œë¦¿ì§€ íƒ€ì… í…ŒìŠ¤íŠ¸ ì»´í¬ë„ŒíŠ¸
 */
const BridgeTest: React.FC = () => {
  // í…ŒìŠ¤íŠ¸ ê°ì²´ ìƒì„±
  const testCVE: CVEDetail = {
    cveId: 'CVE-2023-1234',
    title: 'í…ŒìŠ¤íŠ¸ CVE',
    status: 'ì‹ ê·œë“±ë¡',
    createdBy: 'admin',
    lastModifiedBy: 'admin',
    createdAt: new Date(),
    reference: [],
    poc: [],
    snortRule: [],
    modificationHistory: []
  };
  
  console.log('í…ŒìŠ¤íŠ¸ CVE:', testCVE);
  
  return (
    <div>
      <h2>ë¸Œë¦¿ì§€ íƒ€ì… í…ŒìŠ¤íŠ¸</h2>
      <pre>{JSON.stringify(testCVE, null, 2)}</pre>
    </div>
  );
};

export default BridgeTest;


============================================================
File: /home/CVEHub/frontend/src/features/cve/services/cveService.js
------------------------------------------------------------
// cveService.js
import api from 'shared/api/config/axios';
import { CASE_CONVERSION_CONFIG } from 'config';
import logger from 'shared/utils/logging';
import { camelToSnake, snakeToCamel } from 'shared/utils/caseConverter';

// ë³€í™˜ì—ì„œ ì œì™¸í•  í•„ë“œ ëª©ë¡
const EXCLUDED_FIELDS = CASE_CONVERSION_CONFIG.EXCLUDED_FIELDS;

// ë‚ ì§œ í•„ë“œ ëª©ë¡ (ë¡œê¹…ìš©)
const DATE_FIELDS = [
  'created_at', 'createdAt', 
  'last_modified_at', 'lastModifiedAt',
  'updated_at', 'updatedAt',
  'published_date', 'publishedDate',
  'expiration_date', 'expirationDate',
  'timestamp', 'date'
];

// ì§„í–‰ ì¤‘ì¸ ìš”ì²­ì„ ì¶”ì í•˜ê¸° ìœ„í•œ ë§µ
const pendingRequests = new Map();

/**
 * CVE ë°ì´í„°ë¥¼ ê´€ë¦¬í•˜ëŠ” ì„œë¹„ìŠ¤ í´ë˜ìŠ¤
 * ë°±ì—”ë“œ APIì™€ í†µì‹ í•˜ì—¬ CVE ë°ì´í„°ì˜ CRUD ì‘ì—…ì„ ì²˜ë¦¬
 * @class CVEService
 */
class CVEService {
  /**
   * CVE ëª©ë¡ ì¡°íšŒ
   * @param {Object} filters - í˜ì´ì§€ë„¤ì´ì…˜, ê²€ìƒ‰, í•„í„°ë§ ì˜µì…˜
   * @returns {Promise<Object>} ì‘ë‹µ ë°ì´í„° (results, pagination í¬í•¨)
   */
  async getCVEs(filters = {}) {
    try {
      logger.info('cveService', 'ëª©ë¡ ì¡°íšŒ ìš”ì²­', {
        page: filters.page,
        limit: filters.rowsPerPage,
        search: filters.search
      });
      
      // ë°±ì—”ë“œ APIì™€ í˜¸í™˜ë˜ëŠ” íŒŒë¼ë¯¸í„°ë¡œ ë³€í™˜
      const params = {};
      
      // í˜ì´ì§€ë„¤ì´ì…˜ ì²˜ë¦¬
      if (filters.page !== undefined) {
        params.page = Number(filters.page); // í˜ì´ì§€ ë²ˆí˜¸ ê·¸ëŒ€ë¡œ ì „ë‹¬
      }
      
      if (filters.rowsPerPage !== undefined) {
        params.limit = filters.rowsPerPage;
      }
      
      // ê²€ìƒ‰ì–´ ì²˜ë¦¬
      if (filters.search) {
        // ê²€ìƒ‰ì–´ëŠ” 'search' íŒŒë¼ë¯¸í„°ë¡œ ì „ë‹¬ (ë°±ì—”ë“œ APIì— ë§ì¶¤)
        params.search = filters.search;
      }
      
      // ì •ë ¬ ì²˜ë¦¬
      if (filters.sortBy) {
        params.sort_by = filters.sortBy; // ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤ ì‚¬ìš© (ë°±ì—”ë“œ APIì— ë§ì¶¤)
        params.sort_order = filters.sortOrder || 'desc';
      }
      
      // í•„í„° ì²˜ë¦¬ (severity, status ë“±)
      if (filters.filters) {
        Object.entries(filters.filters).forEach(([key, value]) => {
          if (value !== undefined && value !== null && value !== '') {
            // ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤ë¡œ ë³€í™˜ ì—†ì´ ê·¸ëŒ€ë¡œ ì „ë‹¬
            params[key] = value;
          }
        });
      }
      
      // API ì—”ë“œí¬ì¸íŠ¸ ì„ íƒ (/cves/list ì‚¬ìš©)
      const endpoint = '/cves/list';
      
      // ìºì‹œ ìš°íšŒë¥¼ ìœ„í•œ í—¤ë” ì¶”ê°€ (ê²€ìƒ‰ì–´ê°€ ìˆëŠ” ê²½ìš°)
      const headers = filters.search ? {
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache',
        'x-refresh': 'true'
      } : {};
      
      const response = await api.get(endpoint, {
        params,
        headers
      });
      
      // ì‘ë‹µ í˜•ì‹ í‘œì¤€í™”
      const result = {
        items: response.data?.results || response.data?.items || [],
        total: response.data?.pagination?.total || response.data?.total || 0,
        page: filters.page || 1, 
        limit: filters.rowsPerPage || 10
      };
      
      logger.info('cveService', 'ëª©ë¡ ì¡°íšŒ ì„±ê³µ', { 
        count: result.items.length || 0,
        total: result.total || 0,
        search: filters.search || ''
      });
      
      return result;
    } catch (error) {
      logger.error('cveService', 'ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨', { error: error.message });
      throw this._handleError(error, 'ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨');
    }
  }

  /**
   * CVE ìƒì„¸ ì •ë³´ ì¡°íšŒ
   * @param {string} cveId - ì¡°íšŒí•  CVE ID
   * @param {Object} options - ìš”ì²­ ì˜µì…˜
   * @returns {Promise<Object>} - CVE ìƒì„¸ ì •ë³´
   */
  async getCVEById(cveId, options = {}) {
    if (!cveId) {
      throw new Error('CVE IDê°€ í•„ìš”í•©ë‹ˆë‹¤');
    }
    
    try {
      // ë™ì¼í•œ CVE IDì— ëŒ€í•œ ì§„í–‰ ì¤‘ì¸ ìš”ì²­ì´ ìˆëŠ”ì§€ í™•ì¸
      const requestKey = `cve_${cveId}_${options.bypassCache ? 'bypass' : 'normal'}`;
      
      // ì´ë¯¸ ì§„í–‰ ì¤‘ì¸ ìš”ì²­ì´ ìˆìœ¼ë©´ í•´ë‹¹ Promise ë°˜í™˜
      if (pendingRequests.has(requestKey)) {
        logger.info('cveService', 'ì§„í–‰ ì¤‘ì¸ ìš”ì²­ ì¬ì‚¬ìš©', { 
          cveId,
          bypassCache: !!options.bypassCache
        });
        return pendingRequests.get(requestKey);
      }
      
      // ìºì‹œ ìš°íšŒ ì˜µì…˜ ì¶”ê°€
      const headers = options.bypassCache ? {
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache',
        'x-refresh': 'true'
      } : {};
      
      logger.info('cveService', 'CVE ìƒì„¸ ì •ë³´ ìš”ì²­', { 
        cveId,
        bypassCache: !!options.bypassCache
      });
      
      // ìƒˆë¡œìš´ ìš”ì²­ ìƒì„± ë° ì¶”ì 
      const requestPromise = api.get(`/cves/${cveId}`, { headers })
        .then(response => {
          // ìš”ì²­ ì™„ë£Œ í›„ ë§µì—ì„œ ì œê±°
          pendingRequests.delete(requestKey);
          
          logger.info('cveService', 'CVE ìƒì„¸ ì •ë³´ ì‘ë‹µ', {
            cveId,
            status: response.status
          });
          
          return response.data;
        })
        .catch(error => {
          // ì˜¤ë¥˜ ë°œìƒ ì‹œì—ë„ ë§µì—ì„œ ì œê±°
          pendingRequests.delete(requestKey);
          throw error;
        });
      
      // ì§„í–‰ ì¤‘ì¸ ìš”ì²­ ë§µì— ì¶”ê°€
      pendingRequests.set(requestKey, requestPromise);
      
      return requestPromise;
    } catch (error) {
      logger.error('cveService', 'CVE ìƒì„¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨', { 
        cveId, 
        error: error.message,
        status: error.response?.status
      });
      
      throw this._handleError(error, 'ìƒì„¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨');
    }
  }

  /**
   * ìºì‹œ ìš°íšŒ CVE ìƒì„¸ ì •ë³´ ì¡°íšŒ (ê°•ì œ ìƒˆë¡œê³ ì¹¨)
   * @param {string} cveId - CVE ID
   * @returns {Promise<Object>} ì‘ë‹µ ë°ì´í„°
   */
  async getCVEByIdNoCache(cveId) {
    if (!cveId) {
      logger.warn('cveService', 'getCVEByIdNoCache í˜¸ì¶œ ì‹œ cveIdê°€ ì—†ìŠµë‹ˆë‹¤');
      throw new Error('CVE IDëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤');
    }

    try {
      logger.info('cveService', 'CVE ê°•ì œ ìƒˆë¡œê³ ì¹¨ ìš”ì²­', { cveId });
      const response = await api.get(`/cves/${cveId}`, {
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache',
          'x-refresh': 'true'
        }
      });
      logger.info('cveService', 'CVE ê°•ì œ ìƒˆë¡œê³ ì¹¨ ì„±ê³µ', { cveId });
      return response.data;
    } catch (error) {
      logger.error('cveService', 'CVE ê°•ì œ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨', { cveId, error: error.message });
      throw this._handleError(error, `CVE #${cveId} ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨`);
    }
  }

  /**
   * ìƒˆë¡œìš´ CVEë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
   * @param {Object} cveData - ìƒì„±í•  CVE ë°ì´í„°
   * @param {Object} options - ìš”ì²­ ì˜µì…˜
   * @param {Object} options.meta - ë©”íƒ€ ì •ë³´
   * @returns {Promise<Object>} ìƒì„±ëœ CVE ê°ì²´
   */
  async createCVE(cveData, options = {}) {
    try {
      const url = '/cves';
      
      // ìš”ì²­ ì˜µì…˜ ì¤€ë¹„
      const requestOptions = {
        skipAuthRefresh: false, // ê¸°ë³¸ê°’: ì¸ì¦ ê°±ì‹  í—ˆìš©
        ...(options || {})
      };
      
      // API í˜¸ì¶œ
      const response = await api.post(url, cveData, requestOptions);
      
      // ì‘ë‹µ ë¡œê¹…
      logger.info('cveService', 'ìƒì„± ì„±ê³µ', { 
        id: response.data?.id,
        status: response.status
      });
      
      return response.data;
    } catch (error) {
      // ì—ëŸ¬ ì²˜ë¦¬ ê°•í™”
      logger.error('cveService', 'ìƒì„± ì‹¤íŒ¨', { 
        error: error?.message,
        status: error?.response?.status
      });
      
      // ì—ëŸ¬ ê°ì²´ êµ¬ì¡° í™•ì¸
      const statusCode = error?.response?.status || 500;
      
      // 409 ì—ëŸ¬ (ì¤‘ë³µ CVE) ì²˜ë¦¬
      if (statusCode === 409) {
        // ë°±ì—”ë“œì—ì„œ ì „ë‹¬ëœ ìƒì„¸ ì—ëŸ¬ ë©”ì‹œì§€ ì‚¬ìš©
        const detailMessage = error?.response?.data?.detail || 'ì´ë¯¸ ì¡´ì¬í•˜ëŠ” CVEì…ë‹ˆë‹¤.';
        
        const enhancedError = new Error(detailMessage);
        enhancedError.code = 409;
        enhancedError.status = 409;
        enhancedError.originalError = error;
        enhancedError.isHandled = true; // ì´ë¯¸ ì²˜ë¦¬ëœ ì—ëŸ¬ì„ì„ í‘œì‹œ
        
        // response ê°ì²´ êµ¬ì„±
        enhancedError.response = {
          status: 409,
          data: {
            detail: detailMessage,
            errorCode: error?.response?.data?.errorCode || 'DUPLICATE_CVE'
          }
        };
        
        throw enhancedError;
      }
      
      // ê¸°íƒ€ ì—ëŸ¬ ì²˜ë¦¬
      const errorMessage = error?.response?.data?.detail || 
                          error?.response?.data?.message || 
                          (error?.message && !error?.message.includes('status code')) ? error.message : 
                          'CVE ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
      
      const enhancedError = new Error(errorMessage);
      enhancedError.code = statusCode;
      enhancedError.status = statusCode;
      enhancedError.originalError = error;
      enhancedError.isHandled = true; // ì´ë¯¸ ì²˜ë¦¬ëœ ì—ëŸ¬ì„ì„ í‘œì‹œ
      
      // response ê°ì²´ êµ¬ì„±
      enhancedError.response = {
        status: statusCode,
        data: {
          detail: errorMessage,
          errorCode: error?.response?.data?.errorCode || 'UNKNOWN_ERROR'
        }
      };
      
      throw enhancedError;
    }
  }

  /**
   * CVE ì—…ë°ì´íŠ¸ (ì „ì²´)
   * @param {string} cveId - CVE ID
   * @param {Object} updateData - ì—…ë°ì´íŠ¸í•  ë°ì´í„°
   * @param {Object} options - ìš”ì²­ ì˜µì…˜
   * @returns {Promise<Object>} ì—…ë°ì´íŠ¸ëœ CVE ë°ì´í„°
   */
  async updateCVE(cveId, updateData, options = {}) {
    if (!cveId) {
      logger.warn('cveService', 'updateCVE í˜¸ì¶œ ì‹œ cveIdê°€ ì—†ìŠµë‹ˆë‹¤');
      throw new Error('CVE IDëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤');
    }

    if (!updateData) {
      logger.warn('cveService', 'updateCVE í˜¸ì¶œ ì‹œ updateDataê°€ ì—†ìŠµë‹ˆë‹¤');
      throw new Error('ì—…ë°ì´íŠ¸ ë°ì´í„°ëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤');
    }

    try {
      logger.info('cveService', 'CVE ì—…ë°ì´íŠ¸ ìš”ì²­', { cveId });
      
      // ìš”ì²­ ì˜µì…˜ ì„¤ì •
      const requestOptions = {
        ...(options || {}),
        skipAuthRefresh: options?.skipAuthRefresh ?? false
      };
      
      // ë°±ì—”ë“œì—ì„œ PATCH ë©”ì„œë“œ ì‚¬ìš©í•˜ë¯€ë¡œ ì¼ê´€ì„± ìœ ì§€
      const response = await api.patch(`/cves/${cveId}`, updateData, requestOptions);
      
      logger.info('cveService', 'CVE ì—…ë°ì´íŠ¸ ì„±ê³µ', { 
        cveId,
        status: response.status
      });
      
      return response.data;
    } catch (error) {
      logger.error('cveService', 'CVE ì—…ë°ì´íŠ¸ ì‹¤íŒ¨', { 
        cveId, 
        error: error.message,
        status: error.response?.status
      });
      
      // ì—ëŸ¬ ê°ì²´ ê°•í™” (config ì •ë³´ ë³´ì¡´)
      const enhancedError = {
        ...error,
        code: error?.response?.status || 500,
        message: error?.response?.data?.detail || error?.response?.data?.message || error?.message || `CVE #${cveId} ì—…ë°ì´íŠ¸ ì‹¤íŒ¨`,
        config: {
          ...(error?.config || {}),
          skipAuthRefresh: options?.skipAuthRefresh ?? false
        }
      };
      
      throw enhancedError;
    }
  }

  /**
   * CVEì˜ íŠ¹ì • í•„ë“œë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   * @param {string} cveId - CVE ID
   * @param {string} fieldName - í•„ë“œ ì´ë¦„
   * @param {any} fieldValue - í•„ë“œ ê°’
   * @param {Object} options - ìš”ì²­ ì˜µì…˜
   * @returns {Promise<Object>} ì—…ë°ì´íŠ¸ëœ CVE ë°ì´í„°
   */
  async updateCVEField(cveId, fieldName, fieldValue, options = {}) {
    if (!cveId) {
      logger.warn('cveService', 'updateCVEField í˜¸ì¶œ ì‹œ cveIdê°€ ì—†ìŠµë‹ˆë‹¤');
      throw new Error('CVE IDëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤');
    }

    if (!fieldName) {
      logger.warn('cveService', 'updateCVEField í˜¸ì¶œ ì‹œ fieldNameì´ ì—†ìŠµë‹ˆë‹¤');
      throw new Error('í•„ë“œ ì´ë¦„ì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤');
    }

    try {
      logger.info('cveService', 'CVE í•„ë“œ ì—…ë°ì´íŠ¸ ìš”ì²­', { 
        cveId, 
        field: fieldName
      });
      
      // ì—…ë°ì´íŠ¸í•  ë°ì´í„° êµ¬ì„±
      const updateData = {
        [fieldName]: fieldValue
      };
      
      // ìš”ì²­ ì˜µì…˜ ì„¤ì • (optionsê°€ undefinedì—¬ë„ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬)
      const requestOptions = {
        ...(options || {}),
        skipAuthRefresh: options?.skipAuthRefresh ?? false
      };
      
      // PATCH ìš”ì²­ ë³´ë‚´ê¸°
      const response = await api.patch(`/cves/${cveId}`, updateData, requestOptions);
      
      logger.info('cveService', 'CVE í•„ë“œ ì—…ë°ì´íŠ¸ ì„±ê³µ', { 
        cveId,
        field: fieldName,
        status: response.status
      });
      
      return response.data;
    } catch (error) {
      logger.error('cveService', 'CVE í•„ë“œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨', { 
        cveId, 
        field: fieldName,
        error: error.message,
        status: error.response?.status
      });
      
      // ì—ëŸ¬ ê°ì²´ ê°•í™” (config ì •ë³´ ë³´ì¡´, optionsê°€ undefinedì—¬ë„ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬)
      const safeOptions = options || {};
      const enhancedError = {
        ...error,
        code: error?.response?.status || 500,
        message: error?.response?.data?.detail || error?.response?.data?.message || error?.message || `CVE #${cveId} í•„ë“œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨`,
        config: {
          ...(error?.config || {}),
          skipAuthRefresh: safeOptions.skipAuthRefresh ?? false
        }
      };
      
      throw enhancedError;
    }
  }

  /**
   * CVE ìƒíƒœ ì—…ë°ì´íŠ¸
   * @param {string} cveId - CVE ID
   * @param {string} status - ì—…ë°ì´íŠ¸í•  ìƒíƒœ ê°’
   * @returns {Promise<Object>} ì—…ë°ì´íŠ¸ëœ CVE ë°ì´í„°
   */
  async updateCVEStatus(cveId, status) {
    if (!cveId) {
      logger.warn('cveService', 'updateCVEStatus í˜¸ì¶œ ì‹œ cveIdê°€ ì—†ìŠµë‹ˆë‹¤');
      throw new Error('CVE IDëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤');
    }

    if (!status) {
      logger.warn('cveService', 'updateCVEStatus í˜¸ì¶œ ì‹œ statusê°€ ì—†ìŠµë‹ˆë‹¤');
      throw new Error('ìƒíƒœ ê°’ì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤');
    }

    try {
      logger.info('cveService', 'CVE ìƒíƒœ ì—…ë°ì´íŠ¸ ìš”ì²­', { cveId });
      
      // MongoDB ObjectId ê´€ë ¨ ë¡œì§ ì œê±° - cve_idë§Œ ì‚¬ìš©
      const url = `/cves/${cveId}`;
      
      // ìƒíƒœ í•„ë“œë§Œ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°ì´í„° êµ¬ì¡° ìƒì„±
      const updateData = {
        status: status
      };
      
      // axios ëŒ€ì‹  fetch API ì‚¬ìš© (ì¸í„°ì…‰í„° ë¬¸ì œ ìš°íšŒ)
      const token = localStorage.getItem('accessToken');
      if (!token) {
        throw new Error('ì¸ì¦ í† í°ì´ ì—†ìŠµë‹ˆë‹¤');
      }
      
      // ë°ì´í„°ë¥¼ ìŠ¤ë„¤ì´í¬ ì¼€ì´ìŠ¤ë¡œ ë³€í™˜
      const snakeCaseData = camelToSnake(updateData, { excludeFields: EXCLUDED_FIELDS });
      
      const response = await fetch(url, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify(snakeCaseData)
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.detail || `ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
      }
      
      const responseData = await response.json();
      
      // ì‘ë‹µ ë°ì´í„°ë¥¼ ì¹´ë©œ ì¼€ì´ìŠ¤ë¡œ ë³€í™˜ (ìµœì‹  êµ¬í˜„ì— ë§ê²Œ ìˆ˜ì •)
      const camelCaseData = snakeToCamel(responseData, { 
        excludeFields: EXCLUDED_FIELDS,
        processDate: true,
        requestUrl: url
      });
      
      logger.info('cveService', 'CVE ìƒíƒœ ì—…ë°ì´íŠ¸ ì„±ê³µ', { 
        cveId, 
        status,
        responseStatus: response.status
      });
      
      return camelCaseData;
    } catch (error) {
      // ì˜¤ë¥˜ ë¡œê¹…
      logger.error('cveService', 'CVE ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨', { 
        cveId, 
        status, 
        error: error.message
      });
      
      // ì˜¤ë¥˜ ë©”ì‹œì§€ ê°œì„  - skipAuthRefresh ê´€ë ¨ ì½”ë“œ ì œê±°
      const errorMessage = error.message || `CVE #${cveId} ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨`;
      
      // ë‹¨ìˆœí•œ Error ê°ì²´ ë°˜í™˜ (axios ì¸í„°ì…‰í„° ì˜ì¡´ì„± ì œê±°)
      const simpleError = new Error(errorMessage);
      simpleError.code = error.code || 500;
      simpleError.status = error.status || 500;
      
      throw simpleError;
    }
  }

  /**
   * CVE ì‚­ì œ
   * @param {string} cveId - CVE ID
   * @param {Object} options - ìš”ì²­ ì˜µì…˜
   * @returns {Promise<boolean>} ì„±ê³µ ì—¬ë¶€
   */
  async deleteCVE(cveId, options = {}) {
    if (!cveId) {
      logger.warn('cveService', 'deleteCVE í˜¸ì¶œ ì‹œ cveIdê°€ ì—†ìŠµë‹ˆë‹¤');
      throw new Error('CVE IDëŠ” í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤');
    }

    try {
      logger.info('cveService', 'CVE ì‚­ì œ ìš”ì²­', { cveId });
      
      // ìš”ì²­ ì˜µì…˜ ì„¤ì •
      const requestOptions = {
        ...(options || {}),
        skipAuthRefresh: options?.skipAuthRefresh ?? false
      };
      
      // DELETE ìš”ì²­ ë³´ë‚´ê¸°
      const response = await api.delete(`/cves/${cveId}`, { ...requestOptions });
      
      logger.info('cveService', 'CVE ì‚­ì œ ì„±ê³µ', { 
        cveId,
        status: response.status
      });
      
      // ì°¸ê³ : ì´ ì„œë¹„ìŠ¤ ë ˆì´ì–´ì—ì„œëŠ” ìºì‹œ ë¬´íš¨í™”ë¥¼ ì§ì ‘ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
      // React Queryì˜ useMutation í›…ì—ì„œ onSuccess ì½œë°±ì„ í†µí•´ ìºì‹œ ë¬´íš¨í™” ì²˜ë¦¬
      // queryClient.invalidateQueries([QUERY_KEYS.CVE_LIST]) í˜•íƒœë¡œ ì²˜ë¦¬í•´ì•¼ í•¨
      
      return true; // ì‚­ì œ ì„±ê³µ ì‹œ true ë°˜í™˜
    } catch (error) {
      logger.error('cveService', 'CVE ì‚­ì œ ì‹¤íŒ¨', { 
        cveId, 
        error: error.message,
        status: error.response?.status
      });
      
      // ì—ëŸ¬ ê°ì²´ ê°•í™” (config ì •ë³´ ë³´ì¡´)
      const enhancedError = {
        ...error,
        code: error?.response?.status || 500,
        message: error?.response?.data?.detail || error?.response?.data?.message || error?.message || `CVE #${cveId} ì‚­ì œ ì‹¤íŒ¨`,
        config: {
          ...(error?.config || {}),
          skipAuthRefresh: options?.skipAuthRefresh ?? false
        }
      };
      
      throw enhancedError;
    }
  }

  /**
   * CVE ì „ì²´ ê°œìˆ˜ ì¡°íšŒ (í•„í„°ë§ ì—†ì´ DBì— ì¡´ì¬í•˜ëŠ” ëª¨ë“  CVE ê°œìˆ˜)
   * @returns {Promise<number>} ì „ì²´ CVE ê°œìˆ˜
   */
  async getTotalCVECount() {
    try {
      const response = await api.get('/cves/total-count');
      return response.data.count;
    } catch (error) {
      logger.error('cveService', 'ì „ì²´ CVE ê°œìˆ˜ ì¡°íšŒ ì‹¤íŒ¨', { error: error.message });
      throw this._handleError(error, 'ì „ì²´ CVE ê°œìˆ˜ ì¡°íšŒ ì‹¤íŒ¨');
    }
  }

  /**
   * ì—ëŸ¬ í•¸ë“¤ë§ ê³µí†µ ë©”ì„œë“œ
   * @private
   * @param {Error} error - ë°œìƒí•œ ì—ëŸ¬
   * @param {string} defaultMessage - ê¸°ë³¸ ì—ëŸ¬ ë©”ì‹œì§€
   * @returns {Error} ì²˜ë¦¬ëœ ì—ëŸ¬
   */
  _handleError(error, defaultMessage = 'ìš”ì²­ ì‹¤íŒ¨') {
    // axios ì˜¤ë¥˜ í˜•íƒœ í™•ì¸
    if (error.response) {
      // ì„œë²„ ì‘ë‹µì´ ìˆì§€ë§Œ 2xx ì™¸ì˜ ìƒíƒœ ì½”ë“œ
      const statusCode = error.response.status;
      
      // ì„œë²„ ë©”ì‹œì§€ ì¶”ì¶œ (detail í•„ë“œ ìš°ì„ , ì—†ìœ¼ë©´ message, error ìˆœìœ¼ë¡œ í™•ì¸)
      const serverMessage = 
        error.response.data?.detail || 
        error.response.data?.message || 
        error.response.data?.error || 
        'ì•Œ ìˆ˜ ì—†ëŠ” ì„œë²„ ì˜¤ë¥˜';
      
      // íŠ¹ì • ìƒíƒœ ì½”ë“œì— ë”°ë¥¸ ì²˜ë¦¬
      switch (statusCode) {
        case 400:
          return new Error(`ì˜ëª»ëœ ìš”ì²­: ${serverMessage}`);
        case 401:
          return new Error('ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤');
        case 403:
          return new Error('ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤');
        case 404:
          return new Error('ìì›ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        case 409:
          return new Error(`ì¶©ëŒ ë°œìƒ: ${serverMessage}`);
        case 422:
          return new Error(`ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨: ${serverMessage}`);
        case 500:
          return new Error(`ì„œë²„ ì˜¤ë¥˜: ${serverMessage}`);
        default:
          return new Error(`${defaultMessage}: ${serverMessage} (${statusCode})`);
      }
    } else if (error.request) {
      // ìš”ì²­ì€ ë³´ëƒˆì§€ë§Œ ì‘ë‹µì´ ì—†ìŒ (ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜)
      return new Error('ì„œë²„ì—ì„œ ì‘ë‹µì´ ì—†ìŠµë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•˜ì„¸ìš”.');
    } else {
      // ìš”ì²­ ì„¤ì • ì¤‘ ì˜¤ë¥˜
      return new Error(`${defaultMessage}: ${error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
    }
  }
}

// cveService ì‹±ê¸€í†¤ ê°ì²´ ìƒì„± ë° ë‚´ë³´ë‚´ê¸°
export default new CVEService();



============================================================
File: /home/CVEHub/frontend/src/features/cve/components/MentionInput.tsx
------------------------------------------------------------
import React, { useState, useRef, useCallback, useEffect, useLayoutEffect, ChangeEvent, KeyboardEvent, MouseEvent } from 'react';
import {
  TextField,
  Popper,
  Paper,
  List,
  ListItem,
  ListItemText,
  CircularProgress,
  Box,
  TextFieldProps
} from '@mui/material';
import api from 'shared/api/config/axios';
import logger from 'shared/utils/logging';
import { useQueryClient } from '@tanstack/react-query';
import { debounce } from 'lodash';

// ì‚¬ìš©ì íƒ€ì… ì •ì˜
interface User {
  username: string;
  displayName?: string;
  [key: string]: any;
}

// ë©˜ì…˜ ì‚¬ìš©ì íƒ€ì… ì •ì˜
export interface MentionUser {
  id: string;
  display: string;
}

// ì»´í¬ë„ŒíŠ¸ Props íƒ€ì… ì •ì˜
interface MentionInputProps {
  value: string;
  onChange?: (value: string) => void;
  onSubmit?: (value: string) => void;
  placeholder?: string;
  loading?: boolean;
  fullWidth?: boolean;
  multiline?: boolean;
  rows?: number;
  variant?: TextFieldProps['variant'];
  size?: TextFieldProps['size'];
  users?: MentionUser[];
  inputRef?: React.RefObject<HTMLDivElement>;
}

// ë©˜ì…˜ ìƒíƒœ íƒ€ì… ì •ì˜
interface MentionState {
  active: boolean;
  query: string;
  startPos: number;
}

// ResizeObserver ì˜¤ë¥˜ ë°©ì§€ í•¨ìˆ˜
const preventResizeObserverError = (): void => {
  // ResizeObserver ë£¨í”„ ì˜¤ë¥˜ ë°©ì§€ë¥¼ ìœ„í•œ ì „ì—­ í•¸ë“¤ëŸ¬
  window.addEventListener('error', (e: ErrorEvent) => {
    if (e.message === 'ResizeObserver loop limit exceeded' ||
        e.message.includes('ResizeObserver') ||
        e.message.includes('loop completed with undelivered notifications')) {
      e.stopImmediatePropagation();
      return true;
    }
    return false;
  });
};

const MentionInput: React.FC<MentionInputProps> = ({
  value,
  onChange,
  onSubmit,
  placeholder,
  loading = false,
  fullWidth = true,
  multiline = true,
  rows = 3,
  variant = "outlined",
  size = "small",
  users = [],
  inputRef: externalInputRef
}) => {
  const [inputValue, setInputValue] = useState<string>(value || '');
  const [mentionState, setMentionState] = useState<MentionState>({ active: false, query: '', startPos: 0 });
  const [suggestions, setSuggestions] = useState<User[]>([]);
  const [anchorEl, setAnchorEl] = useState<HTMLDivElement | null>(null);
  const [selectedIndex, setSelectedIndex] = useState<number>(0);
  const [searchLoading, setSearchLoading] = useState<boolean>(false);
  const internalInputRef = useRef<HTMLDivElement | null>(null);
  const inputRef = externalInputRef || internalInputRef;
  const queryClient = useQueryClient();
  const lastSearchRef = useRef<string>('');

  // ë””ë°”ìš´ìŠ¤ëœ ê²€ìƒ‰ í•¨ìˆ˜ ìƒì„±
  const debouncedSearch = useRef(
    debounce(async (query: string) => {
      if (!query || query.length < 2 || query === lastSearchRef.current) {
        return;
      }
      
      lastSearchRef.current = query;
      setSearchLoading(true);
      
      try {
        // ì™¸ë¶€ì—ì„œ ì „ë‹¬ë°›ì€ usersê°€ ìˆëŠ” ê²½ìš° ì‚¬ìš©
        if (users && users.length > 0) {
          const filteredUsers = users
            .filter(user => user.id.toLowerCase().includes(query.toLowerCase()) || 
                           user.display.toLowerCase().includes(query.toLowerCase()))
            .map(user => ({
              username: user.id,
              displayName: user.display
            }));
          
          setSuggestions(filteredUsers);
          setSearchLoading(false);
          return;
        }
        
        // ì™¸ë¶€ usersê°€ ì—†ëŠ” ê²½ìš° API í˜¸ì¶œ
        // ìºì‹œì—ì„œ ê²€ìƒ‰ ê²°ê³¼ í™•ì¸
        const cacheKey = ['auth', 'search', query];
        const cachedResults = queryClient.getQueryData<User[]>(cacheKey);
        
        if (cachedResults) {
          setSuggestions(cachedResults);
          setSearchLoading(false);
          return;
        }
        
        const response = await api.get('/auth/search', {
          params: { query }
        });
        
        // ê°œë°œ í™˜ê²½ì—ì„œë§Œ ë¡œê·¸ ì¶œë ¥
        if (process.env.NODE_ENV === 'development') {
          logger.debug('[MentionInput] Search query:', query);
          logger.debug('[MentionInput] Search results:', response.data);
        }
        
        // ì‘ë‹µ ë°ì´í„° ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
        const responseData = response.data || [];
        
        if (Array.isArray(responseData)) {
          setSuggestions(responseData);
          // ê²°ê³¼ë¥¼ ìºì‹œì— ì €ì¥
          queryClient.setQueryData(cacheKey, responseData);
        } else {
          logger.error('[MentionInput] Invalid response format:', response.data);
          setSuggestions([]);
        }
      } catch (error) {
        logger.error('[MentionInput] Search error:', error);
        setSuggestions([]);
      } finally {
        setSearchLoading(false);
      }
    }, 300) // 300ms ë””ë°”ìš´ìŠ¤
  ).current;

  // ë©˜ì…˜ ì¿¼ë¦¬ê°€ ë³€ê²½ë  ë•Œ ê²€ìƒ‰ ì‹¤í–‰
  useEffect(() => {
    if (mentionState.active && mentionState.query) {
      const cleanQuery = mentionState.query.trim();
      if (cleanQuery.length >= 2) {
        debouncedSearch(cleanQuery);
      } else if (cleanQuery.length === 0) {
        setSuggestions([]);
      }
    }
    
    return () => {
      debouncedSearch.cancel(); // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ë””ë°”ìš´ìŠ¤ ì·¨ì†Œ
    };
  }, [mentionState.query, debouncedSearch]);

  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ResizeObserver ì˜¤ë¥˜ ë°©ì§€ í•¨ìˆ˜ ì‹¤í–‰
  useEffect(() => {
    preventResizeObserverError();
  }, []);

  // ì…ë ¥ ìš”ì†Œì˜ ë„ˆë¹„ë¥¼ ì¸¡ì •í•˜ì—¬ Popper ë„ˆë¹„ ì„¤ì •
  useLayoutEffect(() => {
    if (inputRef.current && mentionState.active) {
      try {
        const width = inputRef.current.offsetWidth;
        setAnchorEl(inputRef.current);
      } catch (e) {
        setAnchorEl(null);
      }
    }
  }, [mentionState.active]);

  // ì…ë ¥ ì²˜ë¦¬
  const handleInputChange = useCallback((e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const newText = e.target.value;
    const cursorPos = e.target.selectionStart || 0;
    
    setInputValue(newText);
    setMentionState((prev) => ({ ...prev, startPos: cursorPos }));

    // @ ë¬¸ì ì´í›„ì˜ í…ìŠ¤íŠ¸ ì¶”ì¶œ
    const textBeforeCursor = newText.slice(0, cursorPos);
    const lastAtSymbol = textBeforeCursor.lastIndexOf('@');
    
    if (lastAtSymbol !== -1 && lastAtSymbol < cursorPos) {
      const searchText = textBeforeCursor.slice(lastAtSymbol + 1);
      // í•œê¸€, ì˜ë¬¸, ìˆ«ìë§Œ í—ˆìš©í•˜ëŠ” ì •ê·œì‹
      const validSearchPattern = /^[ê°€-í£a-zA-Z0-9\s]*$/;
      
      if (validSearchPattern.test(searchText)) {
        setMentionState((prev) => ({ ...prev, active: true, query: searchText }));
      } else {
        setMentionState((prev) => ({ ...prev, active: false, query: '' }));
        setAnchorEl(null);
        setSuggestions([]);
      }
    } else {
      setMentionState((prev) => ({ ...prev, active: false, query: '' }));
      setAnchorEl(null);
      setSuggestions([]);
    }
    
    if (onChange) {
      onChange(newText);
    }
  }, [onChange]);

  // ë©˜ì…˜ í´ë¦­ ì²˜ë¦¬
  const handleMentionClick = useCallback((username: string) => {
    const textBeforeMention = inputValue.slice(0, mentionState.startPos);
    const lastAtSymbol = textBeforeMention.lastIndexOf('@');
    const textAfterMention = inputValue.slice(mentionState.startPos);
    
    const newText = 
      textBeforeMention.slice(0, lastAtSymbol) + 
      `@${username} ` + 
      textAfterMention;
    
    setInputValue(newText);
    setMentionState((prev) => ({ ...prev, active: false, query: '' }));
    setAnchorEl(null);
    setSuggestions([]);
    
    if (onChange) {
      onChange(newText);
    }
  }, [inputValue, mentionState.startPos, onChange]);

  // í¬ì»¤ìŠ¤ê°€ ì™¸ë¶€ë¡œ ì´ë™í–ˆì„ ë•Œ íŒì—… ë‹«ê¸°
  const handleClickAway = useCallback(() => {
    setMentionState((prev) => ({ ...prev, active: false, query: '' }));
    setAnchorEl(null);
    setSuggestions([]);
  }, []);

  // Enter í‚¤ ì²˜ë¦¬ í•¨ìˆ˜ ì¶”ê°€
  const handleKeyDown = useCallback((e: KeyboardEvent<HTMLDivElement>) => {
    // multilineì´ trueì¼ ë•ŒëŠ” Shift + Enterë¡œ ì¤„ë°”ê¿ˆ
    // multilineì´ falseì¼ ë•ŒëŠ” Enterë¡œ ì œì¶œ
    if (e.key === 'Enter' && !e.shiftKey && !multiline) {
      e.preventDefault();
      if (onSubmit && inputValue.trim()) {
        onSubmit(inputValue);
      }
    }
    
    // ESC í‚¤ë¡œ ë©˜ì…˜ íŒì—… ë‹«ê¸°
    if (e.key === 'Escape' && mentionState.active) {
      e.preventDefault();
      setMentionState((prev) => ({ ...prev, active: false, query: '' }));
      setAnchorEl(null);
      setSuggestions([]);
    }
  }, [onSubmit, inputValue, multiline, mentionState.active]);

  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ íƒ€ì´ë¨¸ ì •ë¦¬
  useEffect(() => {
    return () => {
      debouncedSearch.cancel(); // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ë””ë°”ìš´ìŠ¤ ì·¨ì†Œ
    };
  }, [debouncedSearch]);

  return (
    <Box onClick={handleClickAway}>
      <div style={{ position: 'relative' }}>
        <TextField
          fullWidth={fullWidth}
          multiline={multiline}
          rows={rows}
          value={inputValue}
          onChange={handleInputChange}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          variant={variant}
          size={size}
          inputRef={inputRef}
          disabled={loading}
        />
        {mentionState.active && Boolean(anchorEl) && suggestions.length > 0 && (
          <Popper
            open={true}
            anchorEl={anchorEl}
            placement="bottom-start"
            style={{ width: 'auto', zIndex: 1300 }}
          >
            <Paper 
              elevation={3}
              sx={{
                maxHeight: '200px',
                overflow: 'auto',
                mt: 1
              }}
            >
              <List>
                {searchLoading ? (
                  <ListItem>
                    <CircularProgress size={20} />
                  </ListItem>
                ) : suggestions.length > 0 ? (
                  suggestions.map((user) => (
                    <ListItem
                      key={user.username}
                      button
                      onClick={() => handleMentionClick(user.username)}
                      sx={{
                        '&:hover': {
                          backgroundColor: 'action.hover'
                        }
                      }}
                    >
                      <ListItemText 
                        primary={user.username}
                        secondary={user.displayName || user.username}
                        primaryTypographyProps={{
                          variant: 'body2',
                          fontWeight: 'medium'
                        }}
                        secondaryTypographyProps={{
                          variant: 'caption'
                        }}
                      />
                    </ListItem>
                  ))
                ) : (
                  <ListItem>
                    <ListItemText 
                      primary="ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."
                      sx={{ textAlign: 'center', color: 'text.secondary' }}
                    />
                  </ListItem>
                )}
              </List>
            </Paper>
          </Popper>
        )}
      </div>
    </Box>
  );
};

export default MentionInput;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/CommentsTab.tsx
------------------------------------------------------------
import React, { useState, useEffect, useCallback, useMemo, useRef, memo, Fragment } from 'react';
import {
  Box,
  Typography,
  Button,
  CircularProgress,
} from '@mui/material';
import Comment from './Comment';
import MentionInput from './MentionInput';
import api from 'shared/api/config/axios';
import { useSnackbar } from 'notistack';
import { useQueryClient, useQuery } from '@tanstack/react-query';
import {
  ListHeader,
  EmptyState
} from './CommonStyles';
import { Comment as CommentIcon } from '@mui/icons-material';
import { SOCKET_EVENTS } from 'core/socket/services/constants';
import logger from 'shared/utils/logging';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { useSocket } from 'core/socket/hooks/useSocket';

// ì»¤ìŠ¤í…€ í›…ê³¼ íƒ€ì… ì„í¬íŠ¸
import { useCommentMutations } from 'features/cve/hooks/useCommentMutation';
import { CommentData, CommentProps } from 'features/cve/types/CommentTypes';
import { MentionUser } from '../types';

// ì‚¬ìš©ì íƒ€ì… ì •ì˜
interface User {
  id: string;
  username: string;
  displayName?: string;
  profileImage?: string;
  isAdmin?: boolean;
}

// CVE ìƒì„¸ ë°ì´í„° íƒ€ì…
interface CVEDetailData {
  cveId: string;
  comments?: CommentData[];
  [key: string]: any;
}

// ì»´í¬ë„ŒíŠ¸ Props íƒ€ì…
interface CommentsTabProps {
  cve: CVEDetailData;
  onCommentCountChange?: (count: number) => void;
  currentUser?: User | null;
  refreshTrigger?: number;
  parentSendMessage?: (type: string, data: Record<string, unknown>) => Promise<boolean | null> | boolean | null;
  highlightCommentId?: string | null;
}

/**
 * ëŒ“ê¸€ íƒ­ ì»´í¬ë„ŒíŠ¸
 */
const CommentsTab: React.FC<CommentsTabProps> = memo((props) => {
  const {
    cve,
    onCommentCountChange,
    currentUser,
    refreshTrigger = 0,
    parentSendMessage,
  } = props;

  const { enqueueSnackbar } = useSnackbar();
  const queryClient = useQueryClient();

  // --- ìƒíƒœ ê´€ë¦¬ ---
  const [newComment, setNewComment] = useState<string>('');
  const [replyingTo, setReplyingTo] = useState<CommentData | null>(null);
  const [editingCommentId, setEditingCommentId] = useState<string | null>(null);
  const [mentionInputKey, setMentionInputKey] = useState<number>(0);

  const commentInputRef = useRef<HTMLDivElement>(null);

  // --- useSocket í›… ì‚¬ìš© ---
  const { emit, on, connected } = useSocket();

  // --- í•¸ë“¤ëŸ¬ í•¨ìˆ˜ ---
  const handleStartEdit = useCallback((commentId: string): void => {
    setEditingCommentId(commentId);
    setReplyingTo(null);
  }, []);

  const handleFinishEdit = useCallback((): void => {
    setEditingCommentId(null);
  }, []);

  const handleStartReply = useCallback((comment: CommentData): void => {
    setReplyingTo(comment);
    setEditingCommentId(null);
  }, []);

  const handleCancelReply = useCallback((): void => {
    setReplyingTo(null);
  }, []);
  
  // --- ëŒ“ê¸€ ê´€ë ¨ ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ ì²˜ë¦¬ ---
  
  // ìƒˆ ëŒ“ê¸€ ì•Œë¦¼ ì²˜ë¦¬ ì½œë°±
  const handleCommentNotification = useCallback((message: { type: string; data?: { author?: string } }): void => {
    if (
      message.type === SOCKET_EVENTS.COMMENT_ADDED &&
      message.data?.author &&
      currentUser?.username &&
      message.data.author !== currentUser.username
    ) {
      logger.info('CommentsTab', 'ìƒˆë¡œìš´ ëŒ“ê¸€ ì•Œë¦¼ ìˆ˜ì‹ ', { author: message.data.author });
      enqueueSnackbar('ìƒˆë¡œìš´ ëŒ“ê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.', {
        variant: 'info',
        autoHideDuration: 3000,
        anchorOrigin: { vertical: 'bottom', horizontal: 'right' }
      });
    }
  }, [currentUser?.username, enqueueSnackbar]);

  // ëŒ“ê¸€ ìºì‹œ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ì›¹ì†Œì¼“ ìˆ˜ì‹  ì‹œ)
  const updateCommentsCache = useCallback((
    cachedData: CVEDetailData | undefined, 
    eventData: { type: string; data?: { comments?: CommentData[] }; updateId?: string | number }
  ): CVEDetailData | undefined => {
    if (!cachedData || !eventData?.data?.comments) {
      return cachedData; // ì—…ë°ì´íŠ¸í•  ë°ì´í„° ì—†ìœ¼ë©´ ì›ë³¸ ë°˜í™˜
    }
    logger.info('CommentsTab', 'ì›¹ì†Œì¼“: ëŒ“ê¸€ ìºì‹œ ì—…ë°ì´íŠ¸', { eventType: eventData.type, updateId: eventData.updateId || Date.now() });
    // ìƒˆ ë°ì´í„° ê°ì²´ ìƒì„± ë° ëŒ“ê¸€ ì—…ë°ì´íŠ¸
    return { ...cachedData, comments: eventData.data.comments };
  }, []);

  // ëŒ“ê¸€ ê´€ë ¨ ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ë° í•´ì œ
  useEffect(() => {
    if (!connected || !cve.cveId) return; // ì—°ê²° ë° cveId í™•ì¸

    const queryKey = QUERY_KEYS.CVE.detail(cve.cveId);

    const handleSocketEvent = (eventName: string, eventData: any): void => {
      logger.info(`CommentsTab: Socket ${eventName} ìˆ˜ì‹ `, eventData);
      
      // ì•Œë¦¼ ì²˜ë¦¬
      if (eventName === SOCKET_EVENTS.COMMENT_ADDED) {
        handleCommentNotification(eventData);
      }
      
      // ìºì‹œ ì—…ë°ì´íŠ¸ - ê°œì„ ëœ ë¡œì§
      if (eventData?.data?.comments) {
        // í˜„ì¬ ìºì‹œëœ ë°ì´í„° í™•ì¸
        const currentData = queryClient.getQueryData<CVEDetailData>(queryKey);
        
        // íŠ¹ë³„íˆ COMMENT_DELETED ì´ë²¤íŠ¸ì¸ ê²½ìš°, ì´ë¯¸ ë‚™ê´€ì  ì—…ë°ì´íŠ¸ê°€ ì ìš©ëœ ìƒíƒœë¼ë©´
        // ê¹œë¹¡ì„ ë°©ì§€ë¥¼ ìœ„í•´ ìºì‹œ ì—…ë°ì´íŠ¸ ìŠ¤í‚µ (ì¤‘ë³µ ì—…ë°ì´íŠ¸ ë°©ì§€)
        if (eventName === SOCKET_EVENTS.COMMENT_DELETED && currentData?.comments) {
          const deletedCommentId = eventData.deletedCommentId;
          
          // ì´ë¯¸ ë‚™ê´€ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ëœ ìƒíƒœì¸ì§€ í™•ì¸
          const isAlreadyOptimisticallyUpdated = currentData.comments.some(
            c => (c.id === deletedCommentId && c.isOptimistic) ||
                 !currentData.comments.some(c => c.id === deletedCommentId)
          );
          
          if (isAlreadyOptimisticallyUpdated) {
            logger.info('CommentsTab: ì´ë¯¸ ë‚™ê´€ì  ì—…ë°ì´íŠ¸ê°€ ì ìš©ë¨, ì†Œì¼“ ì—…ë°ì´íŠ¸ ìŠ¤í‚µ', { 
              eventName, deletedCommentId 
            });
            // ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ë§ˆì»¤ ì œê±°ë§Œ ìˆ˜í–‰
            queryClient.setQueryData<CVEDetailData>(queryKey, (oldData) => {
              if (!oldData?.comments) return oldData;
              
              const sanitizedComments = oldData.comments.map(comment => {
                if (comment.isOptimistic) {
                  const { isOptimistic, ...rest } = comment as any;
                  return rest;
                }
                return comment;
              });
              
              return { ...oldData, comments: sanitizedComments };
            });
            return;
          }
        }
        
        // ì¼ë°˜ì ì¸ ìºì‹œ ì—…ë°ì´íŠ¸ ì§„í–‰
        queryClient.setQueryData<CVEDetailData>(queryKey, (oldData) =>
          updateCommentsCache(oldData, eventData)
        );
        
        // ëŒ“ê¸€ ìˆ˜ ì—…ë°ì´íŠ¸
        const newActiveCount = (eventData.data.comments || []).filter((c: CommentData) => !c.isDeleted).length;
        onCommentCountChange?.(newActiveCount);
      } else if (eventName !== SOCKET_EVENTS.COMMENT_DELETED) {
        // COMMENT_DELETEDê°€ ì•„ë‹Œ ì´ë²¤íŠ¸ì—ì„œë§Œ ìºì‹œ ë¬´íš¨í™” ê³ ë ¤
        // comments ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ìºì‹œ ë¬´íš¨í™” ê³ ë ¤
        logger.warn(`Socket ${eventName}: comments ë°ì´í„° ì—†ìŒ, ìºì‹œ ë¬´íš¨í™”`, { eventData });
        queryClient.invalidateQueries({ queryKey });
      }
    };

    const unsubAdded = on(SOCKET_EVENTS.COMMENT_ADDED, (data) => handleSocketEvent(SOCKET_EVENTS.COMMENT_ADDED, data));
    const unsubUpdated = on(SOCKET_EVENTS.COMMENT_UPDATED, (data) => handleSocketEvent(SOCKET_EVENTS.COMMENT_UPDATED, data));
    const unsubDeleted = on(SOCKET_EVENTS.COMMENT_DELETED, (data) => handleSocketEvent(SOCKET_EVENTS.COMMENT_DELETED, data));

    return () => {
      unsubAdded();
      unsubUpdated();
      unsubDeleted();
    };
  }, [connected, cve.cveId, queryClient, handleCommentNotification, updateCommentsCache, on, onCommentCountChange]);

  // --- ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ (ë©˜ì…˜ìš©) ---
  const { data: users = [], isLoading: isUsersLoading } = useQuery<User[], Error>({
    queryKey: ['users', 'search'],
    queryFn: async (): Promise<User[]> => {
      try {
        const response = await api.get<{ data: User[] }>('/auth/search');
        return response.data?.data || [];
      } catch (error) {
        logger.error('ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:', error);
        throw new Error('ì‚¬ìš©ì ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    },
    gcTime: 10 * 60 * 1000,
    staleTime: 5 * 60 * 1000,
    initialData: [],
  });

  // --- ë°ì´í„° ê°€ê³µ (Memoization) ---
  const organizeComments = useCallback((commentsArray: CommentData[] = []): CommentData[] => {
    // ì…ë ¥ ë°°ì—´ì´ ì—†ì„ ê²½ìš° ë¹ˆ ë°°ì—´ ë°˜í™˜
    if (!commentsArray || commentsArray.length === 0) return [];

    const commentMap = new Map<string, CommentData>();
    const rootComments: CommentData[] = [];

    commentsArray.forEach(comment => {
      // isDeleted ëŒ“ê¸€ë„ í¬í•¨í•˜ì—¬ Map ìƒì„±
      commentMap.set(comment.id, { ...comment, children: [], depth: 0 });
    });

    commentsArray.forEach(comment => {
      const current = commentMap.get(comment.id);
      if (current && comment.parentId && commentMap.has(comment.parentId)) {
        const parent = commentMap.get(comment.parentId);
        if (parent) {
          current.depth = (parent.depth ?? 0) + 1;
          parent.children = parent.children || []; // children ì´ˆê¸°í™”
          parent.children.push(current);
        } else {
          current.depth = 0;
          rootComments.push(current);
        }
      } else if (current) {
        current.depth = 0;
        rootComments.push(current);
      }
    });

    const sortByDate = (arr: CommentData[]): void => {
      // Date ê°ì²´ë¡œ ë³€í™˜ í›„ ë¹„êµ (íƒ€ì… ì•ˆì •ì„±)
      arr.sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
      arr.forEach(item => {
        if (item.children && item.children.length > 0) {
          sortByDate(item.children);
        }
      });
    };

    sortByDate(rootComments);
    return rootComments;
  }, []);

  // í™œì„± ëŒ“ê¸€ ìˆ˜ ê³„ì‚°
  const activeCommentCount = useMemo((): number => {
    return (cve.comments || []).filter(comment => !comment.isDeleted).length;
  }, [cve.comments]);

  // ê³„ì¸µ êµ¬ì¡°ë¡œ ì •ë¦¬ëœ ëŒ“ê¸€ ëª©ë¡
  const organizedComments = useMemo((): CommentData[] => {
    // ëŒ“ê¸€ ëª©ë¡ ë¡œê¹… (ë””ë²„ê¹… ìš©ë„)
    logger.info('CommentsTab: ëŒ“ê¸€ ë°ì´í„° ìƒíƒœ', { 
      cveId: cve.cveId,
      commentsAvailable: Array.isArray(cve.comments),
      commentsCount: Array.isArray(cve.comments) ? cve.comments.length : 0,
      firstComment: Array.isArray(cve.comments) && cve.comments.length > 0 ? cve.comments[0] : null
    });
    
    return organizeComments(cve.comments); // undefined ë°©ì§€
  }, [cve.comments, organizeComments]);

  // ëŒ“ê¸€ ìˆ˜ ë³€ê²½ ì‹œ ì½œë°± í˜¸ì¶œ
  useEffect(() => {
    onCommentCountChange?.(activeCommentCount);
  }, [activeCommentCount, onCommentCountChange]);

  // --- ëŒ“ê¸€ ê´€ë ¨ mutations ì‚¬ìš© ---
  const {
    createComment,
    editCommentMutation,
    replyCommentMutation,
    deleteCommentMutation,
    isLoading: isMutationLoading
  } = useCommentMutations(
    cve.cveId,
    currentUser,
    onCommentCountChange,
    parentSendMessage
  );

  // --- ì…ë ¥ í•¸ë“¤ëŸ¬ ---
  const handleCommentChange = useCallback((value: string): void => {
    setNewComment(value);
  }, []);

  // ëŒ“ê¸€ ì œì¶œ í•¸ë“¤ëŸ¬
  const handleSubmit = useCallback((): void => {
    if (!newComment.trim()) {
      enqueueSnackbar('ëŒ“ê¸€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', { variant: 'warning' });
      return;
    }
    createComment(newComment);
    // ì„±ê³µ ì‹œ ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
    setNewComment('');
    setMentionInputKey(prev => prev + 1);
  }, [newComment, createComment, enqueueSnackbar]);

  // ëŒ“ê¸€ ìˆ˜ì • í•¸ë“¤ëŸ¬
  const editComment = useCallback((commentId: string, content: string): Promise<any> => {
    return new Promise((resolve) => {
      if (!content.trim()) {
        enqueueSnackbar('ëŒ“ê¸€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', { variant: 'warning' });
        resolve(null);
        return;
      }
      editCommentMutation.mutate({ commentId, content });
      resolve(null);
    });
  }, [editCommentMutation, enqueueSnackbar]);

  // ë‹µê¸€ ì‘ì„± í•¸ë“¤ëŸ¬
  const replyComment = useCallback((parentId: string, content: string): Promise<any> => {
    return new Promise((resolve) => {
      if (!content.trim()) {
        enqueueSnackbar('ë‹µê¸€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', { variant: 'warning' });
        resolve(null);
        return;
      }
      replyCommentMutation.mutate({ parentId, content });
      setReplyingTo(null); // ë‹µê¸€ ëª¨ë“œ ì¢…ë£Œ
      resolve(null);
    });
  }, [replyCommentMutation, enqueueSnackbar, setReplyingTo]);

  // ëŒ“ê¸€ ì‚­ì œ í•¸ë“¤ëŸ¬
  const deleteComment = useCallback((commentId: string, permanent: boolean): Promise<any> => {
    return new Promise((resolve) => {
      deleteCommentMutation.mutate({ commentId, permanent });
      resolve(null);
    });
  }, [deleteCommentMutation]);

  // --- refreshTrigger ë³€ê²½ ì‹œ ìºì‹œ ë¬´íš¨í™” ---
  useEffect(() => {
    if (refreshTrigger > 0 && cve.cveId) {
      logger.info('CommentsTab: refreshTrigger ë³€ê²½, ìºì‹œ ë¬´íš¨í™”', { refreshTrigger });
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.CVE.detail(cve.cveId) });
    }
  }, [refreshTrigger, cve.cveId, queryClient]);

  // --- ëŒ“ê¸€ ë Œë”ë§ ---
  const CommentItem = useCallback(({ comment }: { comment: CommentData }) => {
    const isEditingThis = editingCommentId === comment.id;
    const isReplyingToThis = replyingTo?.id === comment.id;

    // MentionInputì— í•„ìš”í•œ users íƒ€ì… ë³€í™˜
    const usersForMention: MentionUser[] = users.map(u => ({
      id: u.username,
      display: u.displayName || u.username,
    }));

    const commentProps: CommentProps = {
      comment,
      isEditing: isEditingThis,
      replyMode: isReplyingToThis,
      onStartEdit: handleStartEdit,
      onFinishEdit: handleFinishEdit,
      onEdit: editComment,
      onReply: handleStartReply,
      onReplyCancel: handleCancelReply,
      onReplySubmit: replyComment,
      onDelete: deleteComment,
      currentUsername: currentUser?.username,
      isAdmin: currentUser?.isAdmin ?? false,
      depth: comment.depth ?? 0,
      cveId: cve.cveId,
      usersForMention: usersForMention,
      parentSendMessage,
      isSubmitting: isMutationLoading,
    };
    return <Comment {...commentProps} />;
  }, [
    editingCommentId, 
    replyingTo, 
    handleStartEdit, 
    handleFinishEdit, 
    editComment, 
    handleStartReply, 
    handleCancelReply, 
    replyComment, 
    deleteComment, 
    currentUser, 
    cve.cveId, 
    users, 
    parentSendMessage, 
    isMutationLoading
  ]);

  const MemoizedCommentItem = useMemo(() => memo(CommentItem), [CommentItem]);

  // ì¬ê·€ ëŒ“ê¸€ ë Œë”ë§
  const renderComment = useCallback((comment: CommentData) => {
    return (
      <Fragment key={comment.id}>
        <MemoizedCommentItem comment={comment} />
        {comment.children?.map(child => renderComment(child))}
      </Fragment>
    );
  }, [MemoizedCommentItem]);

  // MentionInput props ì¤€ë¹„
  const mentionInputUsers: MentionUser[] = useMemo(() => users.map(u => ({
    id: u.username,
    display: u.displayName || u.username,
  })), [users]);

  // MentionInput í•¸ë“¤ëŸ¬
  const handleMentionInputChange = useCallback((value: string | React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>): void => {
    if (typeof value === 'string') {
      setNewComment(value);
    } else {
      setNewComment(value.target.value);
    }
  }, []);

  return (
    <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      <ListHeader>
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          <CommentIcon color="action" />
          <Typography variant="h6" color="text.primary">
            ëŒ“ê¸€ ({activeCommentCount})
          </Typography>
          {(isUsersLoading || isMutationLoading) && <CircularProgress size={20} sx={{ ml: 1 }} />}
        </Box>
      </ListHeader>

      {(!editingCommentId && !replyingTo) && (
        <Box sx={{ mb: 2, px: 2, flexShrink: 0 }}>
          <Box sx={{ display: 'flex', gap: 1, alignItems: 'flex-start' }}>
            <Box sx={{ flex: 1 }}>
              <MentionInput
                key={mentionInputKey}
                value={newComment}
                onChange={handleMentionInputChange}
                onSubmit={handleSubmit}
                placeholder="ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”... (@ë¡œ ì‚¬ìš©ì ë©˜ì…˜)"
                loading={isMutationLoading}
                users={mentionInputUsers}
                inputRef={commentInputRef}
              />
            </Box>
            <Button
              variant="contained"
              color="primary"
              onClick={handleSubmit}
              disabled={isMutationLoading || !newComment.trim()}
              sx={{ mt: '8px', height: 'fit-content' }}
            >
              {isMutationLoading ? 'ì‘ì„±ì¤‘...' : 'ì‘ì„±'}
            </Button>
          </Box>
        </Box>
      )}

      <Box sx={{ flex: 1, overflowY: 'auto', px: 2, pb: 2 }}>
        {organizedComments.length > 0 ? (
          organizedComments.map(comment => renderComment(comment))
        ) : (
          // ë°ì´í„° ë¡œë”© ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ë¹ˆ ìƒíƒœ í‘œì‹œ
          !isUsersLoading && !isMutationLoading && (
            <EmptyState>
              <Typography variant="body1" color="text.secondary">
                ì•„ì§ ëŒ“ê¸€ì´ ì—†ìŠµë‹ˆë‹¤. ì²« ëŒ“ê¸€ì„ ì‘ì„±í•´ë³´ì„¸ìš”!
              </Typography>
            </EmptyState>
          )
        )}
      </Box>
    </Box>
  );
});

CommentsTab.displayName = 'CommentsTab';
export default CommentsTab;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/SnortRulesTab.tsx
------------------------------------------------------------
import React, { memo } from 'react';
import GenericDataTab from './GenericDataTab';
import { snortRuleTabConfig } from './tabConfigs';
import { CVEDetail, SnortRule, GenericDataTabBaseProps, GenericDataTabProps, SnortRuleTabProps } from '../types/cve';

// SnortRuleTab ì»´í¬ë„ŒíŠ¸ì˜ props ì¸í„°í˜ì´ìŠ¤ - types/cve.tsì— ì •ì˜ëœ GenericDataTabBaseProps ì‚¬ìš©

// ì´ì „ ë²„ì „ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼ ì»´í¬ë„ŒíŠ¸
const SnortRuleTab: React.FC<SnortRuleTabProps> = memo((props) => {
  // GenericDataTabì´ JavaScriptë¡œ ì‘ì„±ë˜ì–´ ìˆì–´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì¸í„°í˜ì´ìŠ¤ì™€ í˜¸í™˜ë˜ì§€ ì•ŠìŒ
  // any íƒ€ì…ìœ¼ë¡œ ë‹¨ì–¸í•˜ì—¬ íƒ€ì… ì˜¤ë¥˜ í•´ê²°
  return React.createElement(GenericDataTab as any, {
    ...props,
    tabConfig: snortRuleTabConfig
  });
});

// displayName ì„¤ì • (React DevToolsì—ì„œ ë””ë²„ê¹… ì‹œ ìœ ìš©)
SnortRuleTab.displayName = 'SnortRuleTab';

export default SnortRuleTab;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/SeverityChip.tsx
------------------------------------------------------------
import React from 'react';
import { Chip, Tooltip, Theme, useTheme } from '@mui/material';
import { alpha } from '@mui/system';
import { SeverityChipProps } from '../types/cve';

// ì‹¬ê°ë„ íƒ€ì… ì •ì˜
type SeverityLevel = 'critical' | 'high' | 'medium' | 'low' | 'unknown';

// ì‹¬ê°ë„ ì„¤ì • ì¸í„°í˜ì´ìŠ¤
interface SeverityConfig {
  color: string;
  backgroundColor: string;
  label: string;
  tooltip: string;
}

/**
 * CVE ì‹¬ê°ë„ë¥¼ í‘œì‹œí•˜ëŠ” ì¹© ì»´í¬ë„ŒíŠ¸
 * @param {string} severity - ì‹¬ê°ë„ (critical, high, medium, low)
 * @returns {JSX.Element} ì‹¬ê°ë„ í‘œì‹œ Chip ì»´í¬ë„ŒíŠ¸
 */
const SeverityChip: React.FC<SeverityChipProps> = ({
  severity = 'unknown',
}) => {
  // ì‹¬ê°ë„ ë ˆë²¨ì— ë”°ë¥¸ ì„¤ì •
  const severityConfig: Record<SeverityLevel, SeverityConfig> = {
    critical: {
      color: '#7b1fa2', // ë³´ë¼ìƒ‰
      backgroundColor: '#f3e5f5',
      label: 'ì‹¬ê°',
      tooltip: 'ì‹¬ê°í•œ ìˆ˜ì¤€ì˜ ì·¨ì•½ì ì…ë‹ˆë‹¤. ì¦‰ì‹œ ì¡°ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.'
    },
    high: {
      color: '#c62828', // ë¹¨ê°„ìƒ‰
      backgroundColor: '#ffebee',
      label: 'ë†’ìŒ',
      tooltip: 'ë†’ì€ ìˆ˜ì¤€ì˜ ì·¨ì•½ì ì…ë‹ˆë‹¤. ë¹ ë¥¸ ì¡°ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.'
    },
    medium: {
      color: '#ef6c00', // ì£¼í™©ìƒ‰
      backgroundColor: '#fff3e0',
      label: 'ì¤‘ê°„',
      tooltip: 'ì¤‘ê°„ ìˆ˜ì¤€ì˜ ì·¨ì•½ì ì…ë‹ˆë‹¤. ê³„íšì ì¸ ì¡°ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.'
    },
    low: {
      color: '#2e7d32', // ì´ˆë¡ìƒ‰
      backgroundColor: '#e8f5e9',
      label: 'ë‚®ìŒ',
      tooltip: 'ë‚®ì€ ìˆ˜ì¤€ì˜ ì·¨ì•½ì ì…ë‹ˆë‹¤. ì¼ë°˜ì ì¸ ê´€ë¦¬ ì²´ê³„ ë‚´ì—ì„œ ì²˜ë¦¬ ê°€ëŠ¥í•©ë‹ˆë‹¤.'
    },
    unknown: {
      color: '#546e7a', // íšŒìƒ‰
      backgroundColor: '#eceff1',
      label: 'ì•Œ ìˆ˜ ì—†ìŒ',
      tooltip: 'ì‹¬ê°ë„ê°€ ì •ì˜ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì•Œ ìˆ˜ ì—†ëŠ” ìˆ˜ì¤€ì…ë‹ˆë‹¤.'
    }
  };

  // ì‹¬ê°ë„ ê°’ì´ ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš° 'unknown' ì‚¬ìš©
  const normalizedSeverity = (severity && severity.toLowerCase() in severityConfig) 
    ? severity.toLowerCase() as SeverityLevel 
    : 'unknown';
  
  const config = severityConfig[normalizedSeverity];

  return (
    <Tooltip title={config.tooltip} arrow placement="top">
      <Chip
        label={config.label}
        size="small"
        sx={{
          color: config.color,
          backgroundColor: config.backgroundColor,
          fontWeight: 'bold',
          borderRadius: '4px',
          minWidth: '60px',
          '& .MuiChip-label': {
            padding: '0 8px',
          }
        }}
      />
    </Tooltip>
  );
};

// React 18ì—ì„œëŠ” defaultProps ëŒ€ì‹  í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ ê¸°ë³¸ê°’ ì‚¬ìš©

export default SeverityChip;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/InlineEditText.tsx
------------------------------------------------------------
// InlineEditText.tsx
import React, { useState, useEffect, useRef, ChangeEvent, KeyboardEvent } from 'react';
import { TextField, Typography, Box, TextFieldProps } from '@mui/material';
import { Edit as EditIcon } from '@mui/icons-material';

interface InlineEditTextProps {
  value: string;
  onSave: (value: string) => void;
  placeholder?: string;
  multiline?: boolean;
  disabled?: boolean;
  maxHeight?: string | number;
  fontSize?: string | number;
  externalEdit?: boolean; // ì™¸ë¶€ì—ì„œ í¸ì§‘ ëª¨ë“œë¥¼ ì œì–´í•˜ëŠ” prop
  onEditingStart?: () => void;
  onEditingEnd?: () => void;
}

const InlineEditText: React.FC<InlineEditTextProps> = ({
  value,
  onSave,
  placeholder = 'ì…ë ¥í•˜ì„¸ìš”...',
  multiline = false,
  disabled = false,
  maxHeight,
  fontSize = 'inherit',
  externalEdit = false,
  onEditingStart = () => {},
  onEditingEnd = () => {}
}) => {
  const [isEditing, setIsEditing] = useState(externalEdit);
  const [editedValue, setEditedValue] = useState(value || '');
  const textFieldRef = useRef<HTMLDivElement | null>(null);

  // ì™¸ë¶€ propì´ ë³€ê²½ë˜ë©´ ë‚´ë¶€ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸
  useEffect(() => {
    setIsEditing(externalEdit);
  }, [externalEdit]);

  useEffect(() => {
    setEditedValue(value || '');
  }, [value]);

  // í…ìŠ¤íŠ¸ í•„ë“œì˜ ë†’ì´ë¥¼ ì¡°ì •í•˜ëŠ” í•¨ìˆ˜
  const adjustTextFieldHeight = (): void => {
    if (multiline && textFieldRef.current) {
      const inputElement = textFieldRef.current.querySelector('textarea');
      if (inputElement) {
        // ìë™ ë†’ì´ ì¡°ì • ë¡œì§
        inputElement.style.height = 'auto';
        inputElement.style.height = `${inputElement.scrollHeight}px`;
      }
    }
  };

  // í¸ì§‘ ëª¨ë“œ ë³€ê²½ ì‹œ ë†’ì´ ì¡°ì •
  useEffect(() => {
    if (isEditing) {
      adjustTextFieldHeight();
    }
  }, [isEditing, editedValue]);

  const handleClick = (e: React.MouseEvent): void => {
    if (!disabled && !isEditing) {
      setIsEditing(true);
      onEditingStart();
    }
  };

  const handleBlur = (): void => {
    if (editedValue !== value) {
      onSave(editedValue);
    }
    setIsEditing(false);
    onEditingEnd();
  };

  const handleKeyPress = (e: KeyboardEvent<HTMLDivElement>): void => {
    if (e.key === 'Enter' && !multiline) {
      if (editedValue !== value) {
        onSave(editedValue);
      }
      setIsEditing(false);
      onEditingEnd();
    }
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>): void => {
    setEditedValue(e.target.value);
    // ê°’ì´ ë³€ê²½ë  ë•Œë§ˆë‹¤ ë†’ì´ ì¡°ì • (ë©€í‹°ë¼ì¸ì¸ ê²½ìš°)
    if (multiline) {
      setTimeout(adjustTextFieldHeight, 0);
    }
  };

  return (
    <Box
      onClick={handleClick}
      onMouseDown={(e) => e.stopPropagation()}
      sx={{
        position: 'relative',
        cursor: disabled ? 'default' : 'pointer',
        width: '100%',
        height: '100%',
      }}
    >
      {isEditing ? (
        <TextField
          inputRef={textFieldRef}
          fullWidth
          multiline={multiline}
          value={editedValue}
          onChange={handleChange}
          onBlur={handleBlur}
          onKeyPress={handleKeyPress}
          autoFocus
          variant="standard"
          InputProps={{
            sx: {
              fontSize: fontSize,
              '&:before, &:after': { display: 'none' },
            },
          }}
          sx={{
            '& .MuiInputBase-root': {
              padding: '4px 8px',
              bgcolor: 'background.paper',
              borderRadius: 1,
              width: '100%',
              overflow: multiline ? 'hidden' : 'auto',
            },
          }}
        />
      ) : (
        <Box
          sx={{
            display: 'flex',
            alignItems: 'flex-start',
            gap: 1,
            p: '4px 8px',
            height: '100%',
            overflow: 'hidden', // ìŠ¤í¬ë¡¤ í‘œì‹œ ì•ˆí•¨
          }}
        >
          <Typography
            sx={{
              flex: 1,
              fontSize: fontSize,
              whiteSpace: multiline ? 'pre-wrap' : 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
            }}
          >
            {value || placeholder}
          </Typography>
          {!disabled && (
            <EditIcon
              className="edit-icon"
              sx={{
                fontSize: 16,
                opacity: 0,
                transition: 'opacity 0.2s',
                color: 'text.secondary',
                mt: 0.5,
                flexShrink: 0,
              }}
            />
          )}
        </Box>
      )}
    </Box>
  );
};

export default InlineEditText;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/PoCTab.tsx
------------------------------------------------------------
import React, { memo } from 'react';
import GenericDataTab from './GenericDataTab';
import { pocTabConfig } from './tabConfigs';
import { CVEDetail, SnortRule, GenericDataTabBaseProps, GenericDataTabProps, SnortRuleTabProps } from '../types/cve';

// SnortRuleTab ì»´í¬ë„ŒíŠ¸ì˜ props ì¸í„°í˜ì´ìŠ¤ - types/cve.tsì— ì •ì˜ëœ GenericDataTabBaseProps ì‚¬ìš©

// ì´ì „ ë²„ì „ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼ ì»´í¬ë„ŒíŠ¸
const pocTab: React.FC<SnortRuleTabProps> = memo((props) => {
  // GenericDataTabì´ JavaScriptë¡œ ì‘ì„±ë˜ì–´ ìˆì–´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì¸í„°í˜ì´ìŠ¤ì™€ í˜¸í™˜ë˜ì§€ ì•ŠìŒ
  // any íƒ€ì…ìœ¼ë¡œ ë‹¨ì–¸í•˜ì—¬ íƒ€ì… ì˜¤ë¥˜ í•´ê²°
  return React.createElement(GenericDataTab as any, {
    ...props,
    tabConfig: pocTabConfig
  });
});

// displayName ì„¤ì • (React DevToolsì—ì„œ ë””ë²„ê¹… ì‹œ ìœ ìš©)
pocTab.displayName = 'SnortRuleTab';

export default pocTab;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/Comment.tsx
------------------------------------------------------------
import React, { useState, useMemo, ChangeEvent } from 'react';
import {
  Box,
  Typography,
  IconButton,
  Button,
  Stack,
  Tooltip,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions
} from '@mui/material';
import {
  Delete as DeleteIcon,
  Edit as EditIcon,
  Reply as ReplyIcon,
  Visibility as VisibilityIcon,
  VisibilityOff as VisibilityOffIcon
} from '@mui/icons-material';
import { formatDistanceToNow, parseISO } from 'date-fns';
import { ko } from 'date-fns/locale';
import { StyledListItem } from './CommonStyles';
import MentionInput from './MentionInput';
import { highlightMentions } from 'shared/utils/mentionUtils';
import { CommentProps } from '../types/cve';

/**
 * ëŒ“ê¸€ ì»´í¬ë„ŒíŠ¸
 */
const Comment: React.FC<CommentProps> = React.memo(({
  comment,
  depth = 0,
  currentUsername,
  isAdmin,
  isEditing,
  onEdit,
  onDelete,
  onReplySubmit,
  onReply,        // ë¶€ëª¨ì—ì„œ ê´€ë¦¬í•˜ëŠ” ë‹µê¸€ ëª¨ë“œ ì‹œì‘ í•¸ë“¤ëŸ¬
  onReplyCancel,  // ë¶€ëª¨ì—ì„œ ê´€ë¦¬í•˜ëŠ” ë‹µê¸€ ëª¨ë“œ ì¢…ë£Œ í•¸ë“¤ëŸ¬
  replyMode,      // ë¶€ëª¨ì—ì„œ ì „ë‹¬ë°›ì€ í˜„ì¬ ë‹µê¸€ ëª¨ë“œ ì—¬ë¶€
  children,
  onStartEdit,
  onFinishEdit,
}) => {
  // ìˆ˜ì • ëª¨ë“œì—ì„œì˜ ë¡œì»¬ ì…ë ¥ ìƒíƒœ
  const [editContent, setEditContent] = useState<string>(comment.content);
  // ë‹µê¸€ ì…ë ¥ ìƒíƒœ
  const [replyContent, setReplyContent] = useState<string>('');
  // ì‚­ì œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸ ìƒíƒœ
  const [deleteDialogOpen, setDeleteDialogOpen] = useState<boolean>(false);
  // ì‚­ì œëœ ëŒ“ê¸€ ì›ë³¸ ë³´ê¸° í† ê¸€
  const [showOriginal, setShowOriginal] = useState<boolean>(false);

  const isDeleted = comment.isDeleted;
  const isAuthor = currentUsername === comment.createdBy;
  const canModify = isAdmin || isAuthor;

  // ë‚ ì§œ í¬ë§· í•¨ìˆ˜ë¥¼ useMemoë¡œ ìµœì í™”
  const formattedDate = useMemo(() => {
    if (!comment.createdAt) return '';
    try {
      const date = typeof comment.createdAt === 'string' 
        ? parseISO(comment.createdAt) 
        : comment.createdAt;
      return formatDistanceToNow(date, { addSuffix: true, locale: ko });
    } catch {
      return typeof comment.createdAt === 'string' 
        ? comment.createdAt 
        : comment.createdAt.toString();
    }
  }, [comment.createdAt]);

  // ìˆ˜ì • ëª¨ë“œ í† ê¸€
  const handleEditToggle = (): void => {
    if (isEditing) {
      console.log('=== Comment Edit Debug ===');
      console.log('Saving edited comment:', {
        commentId: comment.id,
        content: editContent,
        currentUser: currentUsername
      });

      onEdit?.(comment.id || '', editContent)
        .then(response => {
          console.log('Edit success:', response);
          onFinishEdit?.();
        })
        .catch(error => {
          console.error('Edit error:', {
            status: error.response?.status,
            data: error.response?.data,
            message: error.message
          });
        });
    } else {
      setEditContent(comment.content);
      onStartEdit?.(comment.id || '');
    }
  };

  const handleCancelEdit = (): void => {
    onFinishEdit?.();
  };

  // ì‚­ì œ ë‹¤ì´ì–¼ë¡œê·¸
  const handleDeleteClick = (): void => {
    console.log('=== Comment Delete Debug ===');
    console.log('Opening delete dialog:', {
      commentId: comment.id,
      currentUser: currentUsername,
      isAdmin
    });
    setDeleteDialogOpen(true);
  };

  const handleDeleteConfirm = (permanent: boolean = false): void => {
    console.log('Confirming delete:', {
      commentId: comment.id,
      permanent,
      currentUser: currentUsername
    });

    onDelete?.(comment.id || '', permanent)
      .then(response => {
        console.log('Delete success:', response);
        setDeleteDialogOpen(false);
      })
      .catch(error => {
        console.error('Delete error:', {
          status: error.response?.status,
          data: error.response?.data,
          message: error.message
        });
      });
  };

  // ë‹µê¸€ ì•„ì´ì½˜ í´ë¦­
  const handleReplyIconClick = (): void => {
    if (replyMode) {
      // ì´ë¯¸ ë‹µê¸€ ëª¨ë“œ -> ì·¨ì†Œ
      onReplyCancel?.();
      setReplyContent('');
    } else {
      // ë‹µê¸€ ëª¨ë“œ ì‹œì‘
      onReply?.(comment);
    }
  };

  // ë‹µê¸€ ì œì¶œ
  const handleReplySubmitLocal = (): void => {
    if (!replyContent.trim()) return;
    
    console.log('=== Comment Reply Debug ===');
    console.log('Submitting reply:', {
      parentId: comment.id,
      content: replyContent,
      currentUser: currentUsername
    });

    onReplySubmit?.(comment.id || '', replyContent)
      .then(response => {
        console.log('Reply submission success:', response);
        onReplyCancel?.();
        setReplyContent('');
      })
      .catch(error => {
        console.error('Reply submission error:', {
          status: error.response?.status,
          data: error.response?.data,
          message: error.message
        });
      });
  };

  // ëŒ“ê¸€ ë‚´ìš© ë Œë”ë§
  const renderContent = (): React.ReactNode => {
    // ìˆ˜ì • ëª¨ë“œ
    if (isEditing) {
      return (
        <Box sx={{ mt: 1 }}>
          <MentionInput
            value={editContent}
            onChange={(value: string) => setEditContent(value)}
            placeholder="ëŒ“ê¸€ì„ ìˆ˜ì •í•˜ì„¸ìš”..."
          />
          <Stack direction="row" spacing={1} sx={{ mt: 1, justifyContent: 'flex-end' }}>
            <Button size="small" onClick={handleCancelEdit}>
              ì·¨ì†Œ
            </Button>
            <Button 
              size="small" 
              variant="contained"
              onClick={handleEditToggle}
              disabled={!editContent.trim()}
            >
              ìˆ˜ì • ì™„ë£Œ
            </Button>
          </Stack>
        </Box>
      );
    }

    // ì‚­ì œëœ ëŒ“ê¸€ ì²˜ë¦¬
    if (isDeleted && !showOriginal) {
      return (
        <Typography variant="body2" color="text.secondary" sx={{ fontStyle: 'italic' }}>
          ì‚­ì œëœ ëŒ“ê¸€ì…ë‹ˆë‹¤.
        </Typography>
      );
    }

    // ì¼ë°˜ ëŒ“ê¸€
    return (
      <Typography
        variant="body2"
        component="div"
        dangerouslySetInnerHTML={{
          __html: highlightMentions(comment.content),
        }}
        sx={{
          wordBreak: 'break-word',
          '& .mention': {
            color: 'primary.main',
            fontWeight: 'medium',
            '&:hover': {
              textDecoration: 'underline',
              cursor: 'pointer',
            },
          },
        }}
      />
    );
  };

  return (
    <StyledListItem
      elevation={1}
      sx={{
        ml: depth * 3,  // ë“¤ì—¬ì“°ê¸° ê°„ê²©
        border: '1px solid',
        borderColor: 'divider',
        borderLeft: depth > 0 ? `2px solid rgba(25, 118, 210, 0.12)` : '1px solid rgba(0, 0, 0, 0.12)',  // primary ì»¬ëŸ¬ì˜ ì—°í•œ ë²„ì „
        position: 'relative',
        '&::before': depth > 0 ? {
          content: '""',
          position: 'absolute',
          left: -16,
          top: 0,
          bottom: 0,
          width: 16,
          borderLeft: '1px solid',
          borderColor: 'divider',
          opacity: 0.5
        } : {}
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'flex-start', gap: 1 }}>
        <Box sx={{ flex: 1 }}>
          {/* ì‘ì„±ì + ì‹œê°„ */}
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
            <Typography variant="subtitle2">{comment.createdBy}</Typography>
            <Typography variant="caption" color="text.secondary">
              {formattedDate}
            </Typography>
          </Box>

          {/* ëŒ“ê¸€ ë³¸ë¬¸ */}
          {renderContent()}
        </Box>

        {/* ìš°ì¸¡ ì•„ì´ì½˜ë“¤ */}
        <Box>
          {!isDeleted && (
            <Stack direction="row" spacing={1}>
              {canModify && (
                <>
                  {/* ìˆ˜ì • ì•„ì´ì½˜ */}
                  <IconButton size="small" onClick={handleEditToggle}>
                    <EditIcon fontSize="small" />
                  </IconButton>
                  {/* ì‚­ì œ ì•„ì´ì½˜ */}
                  <IconButton size="small" onClick={handleDeleteClick} color="error">
                    <DeleteIcon fontSize="small" />
                  </IconButton>
                </>
              )}
              {/* ë‹µê¸€ ì•„ì´ì½˜ */}
              <IconButton size="small" onClick={handleReplyIconClick}>
                <ReplyIcon fontSize="small" />
              </IconButton>
            </Stack>
          )}
          {isDeleted && isAdmin && (
            <Stack direction="row" spacing={1}>
              <Tooltip title="ì˜êµ¬ ì‚­ì œ">
                <IconButton size="small" onClick={handleDeleteClick} color="error">
                  <DeleteIcon fontSize="small" />
                </IconButton>
              </Tooltip>
              <Tooltip title={showOriginal ? 'ì‚­ì œëœ ëŒ“ê¸€ ìˆ¨ê¸°ê¸°' : 'ì‚­ì œëœ ëŒ“ê¸€ ë³´ê¸°'}>
                <IconButton size="small" onClick={() => setShowOriginal(!showOriginal)}>
                  {showOriginal ? <VisibilityOffIcon fontSize="small" /> : <VisibilityIcon fontSize="small" />}
                </IconButton>
              </Tooltip>
            </Stack>
          )}
        </Box>
      </Box>

      {/* ë‹µê¸€ ì‘ì„± ì˜ì—­ */}
      {replyMode && !isDeleted && (
        <Box sx={{ mt: 2 }}>
          <MentionInput
            value={replyContent}
            onChange={(value: string) => setReplyContent(value)}
            placeholder="ë‹µê¸€ì„ ì…ë ¥í•˜ì„¸ìš”..."
          />
          <Stack direction="row" spacing={1} sx={{ mt: 1, justifyContent: 'flex-end' }}>
            <Button
              size="small"
              onClick={() => {
                onReplyCancel?.();
                setReplyContent('');
              }}
            >
              ì·¨ì†Œ
            </Button>
            <Button
              size="small"
              variant="contained"
              onClick={handleReplySubmitLocal}
              disabled={!replyContent.trim()}
            >
              ë‹µê¸€ ë‹¬ê¸°
            </Button>
          </Stack>
        </Box>
      )}

      {/* ì‚­ì œ ë‹¤ì´ì–¼ë¡œê·¸ */}
      <Dialog open={deleteDialogOpen} onClose={() => setDeleteDialogOpen(false)}>
        <DialogTitle>ëŒ“ê¸€ ì‚­ì œ</DialogTitle>
        <DialogContent>
          {isAdmin ? (
            <>
              <Typography>ê´€ë¦¬ì ê¶Œí•œìœ¼ë¡œ ì‚­ì œ ë°©ì‹ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</Typography>
              <Typography color="error" sx={{ mt: 1 }}>
                * ì˜êµ¬ ì‚­ì œëœ ëŒ“ê¸€ì€ ë³µêµ¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
              </Typography>
            </>
          ) : (
            <Typography>ì´ ëŒ“ê¸€ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?</Typography>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteDialogOpen(false)}>ì·¨ì†Œ</Button>
          {isAdmin ? (
            <>
              <Button onClick={() => handleDeleteConfirm(false)} color="warning">
                ì¼ë°˜ ì‚­ì œ
              </Button>
              <Button onClick={() => handleDeleteConfirm(true)} color="error">
                ì˜êµ¬ ì‚­ì œ
              </Button>
            </>
          ) : (
            <Button onClick={() => handleDeleteConfirm(false)} color="error">
              ì‚­ì œ
            </Button>
          )}
        </DialogActions>
      </Dialog>

      {/* ìì‹(ëŒ€ëŒ“ê¸€) */}
      {children}
    </StyledListItem>
  );
}, (prevProps, nextProps) => {
  // ìµœì í™”ëœ ë¹„êµ ë¡œì§
  return prevProps.comment.id === nextProps.comment.id &&
         prevProps.comment.content === nextProps.comment.content &&
         prevProps.comment.lastModifiedAt === nextProps.comment.lastModifiedAt &&
         prevProps.comment.isDeleted === nextProps.comment.isDeleted &&
         prevProps.isEditing === nextProps.isEditing &&
         prevProps.replyMode === nextProps.replyMode;
});

// displayName ì„¤ì • (ë””ë²„ê¹… ìš©ì´ì„± í–¥ìƒ)
Comment.displayName = 'Comment';

export default Comment;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/tabConfigs.tsx
------------------------------------------------------------
// tabConfigs.ts
import React, { ReactElement, ReactNode } from 'react';
import {
  Science as ScienceIcon,
  Shield as ShieldIcon,
  Link as LinkIcon,
  Code as CodeIcon,
} from '@mui/icons-material';
import {
  Chip,
  Typography,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  TextField,
  SelectChangeEvent,
  ChipProps
} from '@mui/material';
// íƒ€ì…ì„ ì„í¬íŠ¸
import {
  PoCSourceInfo,
  RuleTypeInfo,
  BaseItem,
  PoCItem,
  SnortRuleItem,
  ReferenceItem,
  DataItem,
  ExtendedTabConfig
} from '../types/TabTypes';
// ChipLabelì´ CommonStylesì— ì •ì˜ë˜ì–´ ìˆë‹¤ê³  ê°€ì •
import { ChipLabel } from './CommonStyles'; // ê²½ë¡œ í™•ì¸ í•„ìš”

// --- PoC íƒ­ ì„¤ì • ---
export const POC_SOURCES: Record<string, PoCSourceInfo> = {
  Etc: { label: 'Etc', color: 'default' },
  Metasploit: { label: 'Metasploit', color: 'secondary' },
  'Nuclei-Templates': { label: 'Nuclei Templates', color: 'primary' },
  GitHub: { label: 'GitHub', color: 'info' },
  ExploitDB: { label: 'Exploit-DB', color: 'warning' },
};

export const DEFAULT_POC: PoCItem = {
  source: 'Etc',
  url: '',
  description: '',
};

export const pocTabConfig: ExtendedTabConfig<PoCItem> = {
  icon: CodeIcon,
  title: 'Proof of Concept',
  itemName: 'PoC',
  dataField: 'poc',
  wsFieldName: 'poc',
  defaultItem: DEFAULT_POC,
  emptyTitle: 'ë“±ë¡ëœ PoC ì •ë³´ ì—†ìŒ',
  emptyDescription: 'ì•„ì§ ì´ ì·¨ì•½ì ì— ëŒ€í•œ PoC ì½”ë“œê°€ ë“±ë¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
  addButtonText: 'PoC ì¶”ê°€',
  editButtonText: 'PoC ìˆ˜ì •',
  deleteButtonText: 'PoC ì‚­ì œ',
  validateItem: (item) => (item.url && item.url.trim() !== '') || 'URLì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.',
  checkDuplicate: (item, items, excludeIndex = -1) => {
    const currentUrl = item.url.trim().toLowerCase();
    return (items || []).some((poc, index) =>
      index !== excludeIndex && poc.url.trim().toLowerCase() === currentUrl
    );
  },
  
  renderItemLabel: (item: PoCItem): ReactElement => (
    <>
      <Chip
        label={
          <ChipLabel>
            <CodeIcon sx={{ fontSize: 16, mr: 0.5 }} />
            {POC_SOURCES[item.source]?.label || item.source}
          </ChipLabel>
        }
        size="small"
        color={POC_SOURCES[item.source]?.color || 'default'}
        variant="outlined"
        sx={{ minWidth: 80, mr: 1 }}
      />
      <Typography
        component="a"
        href={item.url.startsWith('http') ? item.url : `https://${item.url}`}
        target="_blank"
        rel="noopener noreferrer"
        sx={{
          color: 'info.main',
          textDecoration: 'none',
          fontWeight: 400,
          wordBreak: 'break-all',
          '&:hover': { textDecoration: 'underline', color: 'info.dark' },
        }}
      >
        {item.url}
      </Typography>
    </>
  ),
  renderDialogContent: (item: PoCItem, updateItemState: <K extends keyof PoCItem>(item: PoCItem, field: K, value: PoCItem[K]) => void, isEdit: boolean): ReactElement => (
    <>
      <FormControl fullWidth margin="normal">
        <InputLabel id="poc-source-label">Source</InputLabel>
        <Select
          labelId="poc-source-label"
          value={item.source}
          onChange={(e: SelectChangeEvent) => updateItemState(item, 'source', e.target.value as string)}
          label="Source"
        >
          {Object.entries(POC_SOURCES).map(([value, { label }]) => (
            <MenuItem key={value} value={value}>{label}</MenuItem>
          ))}
        </Select>
      </FormControl>
      <TextField
        required
        fullWidth
        margin="normal"
        label="URL"
        value={item.url}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => updateItemState(item, 'url', e.target.value)}
        error={!item.url || item.url.trim() === ''}
        helperText={!item.url || item.url.trim() === '' ? "URLì€ í•„ìˆ˜ ì…ë ¥ í•­ëª©ì…ë‹ˆë‹¤." : ""}
        placeholder="https://example.com/poc"
      />
      <TextField
        fullWidth
        margin="normal"
        label="Description (Optional)"
        value={item.description || ''}
        onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => updateItemState(item, 'description', e.target.value)}
        multiline
        rows={3}
      />
    </>
  )
}; // ì„¸ë¯¸ì½œë¡  ì¶”ê°€

// --- Snort Rules íƒ­ ì„¤ì • ---
export const RULE_TYPES: Record<string, RuleTypeInfo> = {
  USER_DEFINED: { label: 'ì‚¬ìš©ì ì •ì˜', color: 'default' },
  IPS: { label: 'IPS', color: 'primary' },
  ONE: { label: 'ONE', color: 'secondary' },
  UTM: { label: 'UTM', color: 'success' },
  'Emerging-Threats': { label: 'Emerging Threats', color: 'warning' },
  SNORT_OFFICIAL: { label: 'Snort Official', color: 'info' }
};

export const DEFAULT_RULE: SnortRuleItem = {
  type: 'Emerging-Threats',
  rule: '',
  description: '',
};

export const snortRuleTabConfig: ExtendedTabConfig<SnortRuleItem> = {
  icon: ShieldIcon,
  title: 'Snort Rules',
  itemName: 'ê·œì¹™',
  dataField: 'snortRule',
  wsFieldName: 'snort_rule',
  defaultItem: DEFAULT_RULE,
  emptyTitle: 'ë“±ë¡ëœ Snort ê·œì¹™ ì—†ìŒ',
  emptyDescription: 'ì•„ì§ ì´ ì·¨ì•½ì ì— ëŒ€í•œ Snort ê·œì¹™ì´ ì •ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
  addButtonText: 'ê·œì¹™ ì¶”ê°€',
  editButtonText: 'ê·œì¹™ ìˆ˜ì •',
  deleteButtonText: 'ê·œì¹™ ì‚­ì œ',
  validateItem: (item) => (item.rule && item.rule.trim() !== '') || 'ê·œì¹™ ë‚´ìš©ì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.',
  prepareItemForSave: (item, isUpdate, kstTime) => {
    const now = kstTime?.toISOString() || new Date().toISOString();
    const username = item.currentUser?.username || 'anonymous';
    if (isUpdate) {
      return {
        id: item.id, // ìˆ˜ì • ì‹œ ID í¬í•¨
        type: item.type,
        rule: item.rule,
        description: item.description,
        last_modified_at: now,
        last_modified_by: username,
      };
    } else {
      return {
        type: item.type,
        rule: item.rule,
        description: item.description,
        created_at: now,
        created_by: username,
      };
    }
  },
  renderItemLabel: (item: SnortRuleItem): ReactElement => (
    <Chip
      label={
        <ChipLabel>
          <ShieldIcon sx={{ fontSize: 16, mr: 0.5 }} />
          {RULE_TYPES[item.type]?.label || item.type}
        </ChipLabel>
      }
      size="small"
      color={RULE_TYPES[item.type]?.color || 'default'}
      variant="outlined"
      sx={{ minWidth: 80 }}
    />
  ),
  renderItemContent: (item) => (
    <Typography
      variant="body2"
      component="pre"
      sx={{
        fontSize: '0.813rem',
        fontFamily: 'monospace',
        maxHeight: '6em',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'pre-wrap',
        wordBreak: 'break-all',
        m: 0, p: 0, lineHeight: 1.4,
      }}
    >
      {item.rule}
    </Typography>
  ),
  renderDialogContent: (item: SnortRuleItem, updateItemState: <K extends keyof SnortRuleItem>(item: SnortRuleItem, field: K, value: SnortRuleItem[K]) => void, isEdit: boolean): ReactElement => (
    <>
      <FormControl fullWidth margin="normal">
        <InputLabel id="rule-type-label">Type</InputLabel>
        <Select
          labelId="rule-type-label"
          value={item.type}
          onChange={(e: SelectChangeEvent) => updateItemState(item, 'type', e.target.value as string)}
          label="Type"
        >
          {Object.entries(RULE_TYPES).map(([value, { label }]) => (
            <MenuItem key={value} value={value}>{label}</MenuItem>
          ))}
        </Select>
      </FormControl>
      <TextField
        required
        fullWidth
        margin="normal"
        label="Rule"
        value={item.rule}
        onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => updateItemState(item, 'rule', e.target.value)}
        error={!item.rule || item.rule.trim() === ''}
        helperText={!item.rule || item.rule.trim() === '' ? "ê·œì¹™ ë‚´ìš©ì€ í•„ìˆ˜ ì…ë ¥ í•­ëª©ì…ë‹ˆë‹¤." : ""}
        multiline
        rows={5}
        placeholder={`alert tcp any any -> any any (msg:"Example Rule"; sid:1000001;)`}
        InputProps={{ sx: { fontFamily: 'monospace' } }}
      />  
      <TextField
        fullWidth
        margin="normal"
        label="Description (Optional)"
        value={item.description || ''}
        onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => updateItemState(item, 'description', e.target.value)}
        multiline
        rows={2}
      />
    </>
  )
}; // ì„¸ë¯¸ì½œë¡  ì¶”ê°€

// --- Reference íƒ­ ì„¤ì • ---
export const REFERENCE_TYPES: Record<string, string> = {
  NVD: 'NVD',
  ADVISORY: 'Advisory',
  EXPLOIT: 'Exploit',
  PATCH: 'Patch',
  REPORT: 'Report',
  TOOL: 'Tool',
  OTHER: 'Other',
}; // ì„¸ë¯¸ì½œë¡  ì¶”ê°€

export const DEFAULT_REFERENCE: ReferenceItem = {
  type: 'OTHER',
  url: '',
  description: '',
}; // ì„¸ë¯¸ì½œë¡  ì¶”ê°€

export const referenceTabConfig: ExtendedTabConfig<ReferenceItem> = {
  icon: LinkIcon,
  title: 'Reference',
  itemName: 'ì°¸ì¡° ë§í¬',
  dataField: 'reference',
  wsFieldName: 'reference',
  defaultItem: DEFAULT_REFERENCE,
  emptyTitle: 'ë“±ë¡ëœ ì°¸ì¡° ë§í¬ ì—†ìŒ',
  emptyDescription: 'ì•„ì§ ì´ ì·¨ì•½ì ê³¼ ê´€ë ¨ëœ ì°¸ì¡° ë§í¬ê°€ ë“±ë¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
  addButtonText: 'ë§í¬ ì¶”ê°€',
  editButtonText: 'ë§í¬ ìˆ˜ì •',
  deleteButtonText: 'ë§í¬ ì‚­ì œ',
  validateItem: (item) => (item.url && item.url.trim() !== '') || 'URLì€ í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.',
  checkDuplicate: (item, items, excludeIndex = -1) => {
    const currentUrl = item.url.trim().toLowerCase();
    return (items || []).some((ref, index) =>
      index !== excludeIndex && ref.url.trim().toLowerCase() === currentUrl
    );
  },
  renderItemLabel: (item: ReferenceItem): ReactElement => (
    <>
      <Chip
        label={REFERENCE_TYPES[item.type] || item.type}
        size="small"
        color="info"
        variant="outlined"
        sx={{ mr: 1 }}
      />
      <Typography
        component="a"
        href={item.url.startsWith('http') ? item.url : `https://${item.url}`}
        target="_blank"
        rel="noopener noreferrer"
        sx={{
          color: 'info.main',
          textDecoration: 'none',
          fontWeight: 400,
          wordBreak: 'break-all',
          '&:hover': { textDecoration: 'underline', color: 'info.dark' },
        }}
      >
        {item.url}
      </Typography>
    </>
  ),
  renderDialogContent: (item: ReferenceItem, updateItemState: <K extends keyof ReferenceItem>(item: ReferenceItem, field: K, value: ReferenceItem[K]) => void, isEdit: boolean): ReactElement => (
    <>
      <FormControl fullWidth margin="normal">
        <InputLabel id="reference-type-label">Type</InputLabel>
        <Select
          labelId="reference-type-label"
          value={item.type}
          onChange={(e: SelectChangeEvent) => updateItemState(item, 'type', e.target.value as string)}
          label="Type"
        >
          {Object.entries(REFERENCE_TYPES).map(([value, label]) => (
            <MenuItem key={value} value={value}>{label}</MenuItem>
          ))}
        </Select>
      </FormControl>
      <TextField
        required
        fullWidth
        margin="normal"
        label="URL"
        value={item.url}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => updateItemState(item, 'url', e.target.value)}
        error={!item.url || item.url.trim() === ''}
        helperText={!item.url || item.url.trim() === '' ? "URLì€ í•„ìˆ˜ ì…ë ¥ í•­ëª©ì…ë‹ˆë‹¤." : ""}
        placeholder="https://example.com/reference"
      />
      <TextField
        fullWidth
        margin="normal"
        label="Description (Optional)"
        value={item.description || ''}
        onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => updateItemState(item, 'description', e.target.value)}
        multiline
        rows={3}
      />
    </>
  )
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/HistoryTab.tsx
------------------------------------------------------------
import React from 'react';
import {
  Box,
  Typography,
  Paper,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Chip,
  Tooltip
} from '@mui/material';
import {
  Timeline,
  TimelineItem,
  TimelineSeparator,
  TimelineConnector,
  TimelineContent,
  TimelineDot,
  TimelineOppositeContent
} from '@mui/lab';
import {
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  Person as PersonIcon,
  Code as CodeIcon,
  Security as SecurityIcon,
  Link as LinkIcon,
  Title as TitleIcon,
  Description as DescriptionIcon,
  Assignment as AssignmentIcon,
  Note as NoteIcon
} from '@mui/icons-material';
import { formatDateTime, TIME_ZONES } from 'shared/utils/dateUtils';
import { HistoryTabProps, HistoryItem, HistoryChange } from '../types/cve';

// í•„ë“œë³„ ì•„ì´ì½˜ ë§¤í•‘
const FIELD_ICONS: Record<string, React.ReactElement> = {
  title: <TitleIcon />,
  description: <DescriptionIcon />,
  status: <AssignmentIcon />,
  assigned_to: <PersonIcon />,
  notes: <NoteIcon />,
  snort_rule: <SecurityIcon />,
  poc: <CodeIcon />,
  reference: <LinkIcon />
};

// ì•¡ì…˜ë³„ ìƒ‰ìƒ ë§¤í•‘
const ACTION_COLORS: Record<string, 'success' | 'primary' | 'error'> = {
  add: 'success',
  edit: 'primary',
  delete: 'error'
};

// ì•¡ì…˜ë³„ í•œê¸€ í…ìŠ¤íŠ¸
const ACTION_TEXT: Record<string, string> = {
  add: 'ì¶”ê°€',
  edit: 'ìˆ˜ì •',
  delete: 'ì‚­ì œ'
};

/**
 * ìˆ˜ì • ì´ë ¥ íƒ­ ì»´í¬ë„ŒíŠ¸
 * @param props HistoryTabProps
 * @returns React ì»´í¬ë„ŒíŠ¸
 */
const HistoryTab: React.FC<HistoryTabProps> = ({ modificationHistory = [] }) => {

  if (!Array.isArray(modificationHistory) || modificationHistory.length === 0) {
    return (
      <Box sx={{ p: 3, textAlign: 'center' }}>
        <Typography color="text.secondary">
          ìˆ˜ì • ì´ë ¥ì´ ì—†ìŠµë‹ˆë‹¤.
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ p: 3 }}>
      <Timeline>
        {modificationHistory.map((history: HistoryItem, historyIndex: number) => (
          <TimelineItem key={historyIndex}>
            <TimelineOppositeContent color="text.secondary">
              {formatDateTime(history.modifiedAt || history.lastModifiedAt, undefined, TIME_ZONES.KST)}
            </TimelineOppositeContent>
            <TimelineSeparator>
              <TimelineDot color="primary">
                <PersonIcon />
              </TimelineDot>
              {historyIndex < modificationHistory.length - 1 && <TimelineConnector />}
            </TimelineSeparator>
            <TimelineContent>
              <Paper 
                elevation={0} 
                sx={{ 
                  p: 2, 
                  bgcolor: 'background.default',
                  border: '1px solid',
                  borderColor: 'divider',
                  borderRadius: 2
                }}
              >
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>
                  <Typography variant="subtitle2" component="span">
                    {history.username}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    ë‹˜ì´ ë³€ê²½ì‚¬í•­ì„ {history.changes?.length || 0}ê±´ ì ìš©í–ˆìŠµë‹ˆë‹¤
                  </Typography>
                </Box>
                <List dense>
                  {history.changes?.map((change: HistoryChange, changeIndex: number) => (
                    <ListItem 
                      key={changeIndex}
                      sx={{
                        borderRadius: 1,
                        '&:hover': {
                          bgcolor: 'action.hover'
                        }
                      }}
                    >
                      <ListItemIcon>
                        <Tooltip title={change.fieldName || change.field}>
                          {FIELD_ICONS[change.field] ? FIELD_ICONS[change.field] : <EditIcon />}
                        </Tooltip>
                      </ListItemIcon>
                      <ListItemText
                        primary={
                          <Box component="span" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            {change.summary}
                            <Chip
                              label={ACTION_TEXT[change.action] || change.action}
                              size="small"
                              color={ACTION_COLORS[change.action] || 'primary'}
                              sx={{ height: 20 }}
                            />
                          </Box>
                        }
                        secondary={
                          change.detailType === 'detailed' && (
                            <Box component="span" sx={{ display: 'block', mt: 1 }}>
                              {change.before && change.after && (
                                <Box component="span" sx={{ display: 'block' }}>
                                  <Typography component="span" variant="body2" color="text.secondary" display="block">
                                    ë³€ê²½ ì „: {change.before}
                                  </Typography>
                                  <Typography component="span" variant="body2" color="text.secondary" display="block">
                                    ë³€ê²½ í›„: {change.after}
                                  </Typography>
                                </Box>
                              )}
                              {change.items && change.items.length > 0 && (
                                <Box component="span" sx={{ display: 'block', mt: 1 }}>
                                  {change.items.map((item, idx) => (
                                    <Paper
                                      key={idx}
                                      variant="outlined"
                                      sx={{ 
                                        p: 1, 
                                        mt: 1,
                                        bgcolor: 'background.paper',
                                        borderRadius: 1
                                      }}
                                    >
                                      <Typography component="span" variant="body2" color="text.secondary">
                                        {item.type && `[${item.type}] `}
                                        {item.rule || item.url || JSON.stringify(item)}
                                      </Typography>
                                    </Paper>
                                  ))}
                                </Box>
                              )}
                            </Box>
                          )
                        }
                      />
                    </ListItem>
                  ))}
                </List>
              </Paper>
            </TimelineContent>
          </TimelineItem>
        ))}
      </Timeline>
    </Box>
  );
};

export default HistoryTab;



============================================================
File: /home/CVEHub/frontend/src/features/cve/components/GenericDataTab.tsx
------------------------------------------------------------
import React, { useState, useEffect, useCallback, useMemo, memo, ReactNode } from 'react';
import {
  Typography,
  Box,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Tooltip,
  Fade,
  Button,
  CircularProgress, // ë¡œë”© ìƒíƒœ í‘œì‹œ
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
  Edit as EditIcon,
  Launch as LaunchIcon,
  SvgIconComponent, // ì•„ì´ì½˜ íƒ€ì…
} from '@mui/icons-material';
import {
  StyledListItem,
  ActionButton,
  ActionIconButton,
  ListHeader,
  EmptyState,
} from './CommonStyles'; // ìŠ¤íƒ€ì¼ ì»´í¬ë„ŒíŠ¸ ê²½ë¡œ (í™•ì¸ í•„ìš”)
import { useQueryClient, InvalidateQueryFilters } from '@tanstack/react-query'; // React Query íƒ€ì…
import api from 'shared/api/config/axios'; // Axios ì¸ìŠ¤í„´ìŠ¤ ê²½ë¡œ (í™•ì¸ í•„ìš”)
import { useSnackbar, OptionsObject, SnackbarMessage } from 'notistack'; // ìŠ¤ë‚µë°” íƒ€ì…
import { SOCKET_EVENTS } from 'core/socket/services/constants'; // ì†Œì¼“ ìƒìˆ˜ ê²½ë¡œ (í™•ì¸ í•„ìš”)
import { useSocket } from 'core/socket/hooks/useSocket'; // useSocket í›… ê²½ë¡œ (í™•ì¸ í•„ìš”)
import { formatDateTime } from 'shared/utils/dateUtils'; // ë‚ ì§œ ìœ í‹¸ ê²½ë¡œ (í™•ì¸ í•„ìš”)
import { AxiosError } from 'axios'; // Axios íƒ€ì…
import { QUERY_KEYS } from 'shared/api/queryKeys'; // ì¿¼ë¦¬ í‚¤ ê²½ë¡œ (í™•ì¸ í•„ìš”)
import logger from 'shared/utils/logging'; // ë¡œê±° ê²½ë¡œ (í™•ì¸ í•„ìš”)

// --- ì¸í„°í˜ì´ìŠ¤ ë° íƒ€ì… ì •ì˜ ---

// User íƒ€ì… (ë‹¤ë¥¸ íŒŒì¼ì—ì„œ import í•˜ê±°ë‚˜ ì—¬ê¸°ì„œ ì •ì˜)
interface User {
  id?: string | number; // id ì¶”ê°€
  username: string;
  // í•„ìš”í•œ ë‹¤ë¥¸ ì‚¬ìš©ì ì†ì„±...
}

// CVE ë°ì´í„° íƒ€ì… (ìµœì†Œ í•„ìš” í•„ë“œ)
interface CVEDetailData {
  cveId: string;
  // dataFieldì— í•´ë‹¹í•˜ëŠ” í•„ë“œë¥¼ í¬í•¨í•´ì•¼ í•¨ (ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ ì‚¬ìš© ë˜ëŠ” êµ¬ì²´ì  í•„ë“œ ëª…ì‹œ)
  [key: string]: any; // ì‹¤ì œ íƒ€ì…ì— ë§ê²Œ ìˆ˜ì • ê¶Œì¥
}

// ê¸°ë³¸ ì•„ì´í…œ ì¸í„°í˜ì´ìŠ¤ (ëª¨ë“  ë°ì´í„° ì•„ì´í…œì˜ ê¸°ë³¸ êµ¬ì¡°)
interface BaseItem {
  id?: string | number; // idëŠ” ë°±ì—”ë“œì—ì„œ ì˜¤ëŠ” ì‹¤ì œ ì‹ë³„ìì¼ ìˆ˜ ìˆìŒ
  description?: string;
  created_by?: string; // ê¸°ì¡´ ì†ŒìŠ¤ì½”ë“œì™€ í•„ë“œëª… í†µì¼
  created_at?: string | Date; // ê¸°ì¡´ ì†ŒìŠ¤ì½”ë“œì™€ í•„ë“œëª… í†µì¼
  last_modified_by?: string; // ìˆ˜ì •ì ì •ë³´ (í•„ìš”ì‹œ)
  last_modified_at?: string | Date; // ìˆ˜ì • ì‹œê°„ (í•„ìš”ì‹œ)
  url?: string; // URL ì†ì„±
  [key: string]: any; // ìœ ì—°ì„±ì„ ìœ„í•œ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ (êµ¬ì²´ì ì¸ íƒ€ì… ì‚¬ìš© ê¶Œì¥)
}

// ê° íƒ­ì—ì„œ ì‚¬ìš©ë  êµ¬ì²´ì ì¸ ì•„ì´í…œ íƒ€ì… (BaseItem í™•ì¥, ì˜ˆì‹œ)
interface PoCItem extends BaseItem {
  source: string;
  url: string; // í•„ìˆ˜
}

interface SnortRuleItem extends BaseItem {
  type: string;
  rule: string; // í•„ìˆ˜
}

interface ReferenceItem extends BaseItem {
  type: string;
  url: string; // í•„ìˆ˜
}

// ëª¨ë“  ì•„ì´í…œ íƒ€ì…ì„ í¬í•¨í•˜ëŠ” ìœ ë‹ˆì˜¨ íƒ€ì… (êµ¬ì²´ì ì¸ íƒ€ì… ì¶”ê°€ í•„ìš”)
type DataItem = BaseItem & (PoCItem | SnortRuleItem | ReferenceItem | Record<string, any>); // Record<string, any>ëŠ” ì„ì‹œ

// íƒ­ ì„¤ì • íƒ€ì… (ì œë„¤ë¦­ T ì‚¬ìš©)
interface TabConfig<T extends DataItem> {
  icon?: SvgIconComponent | React.ElementType; // ì•„ì´ì½˜ (Optional)
  title: string;
  itemName: string;
  dataField: keyof CVEDetailData | string; // CVE ë°ì´í„° ê°ì²´ì˜ í‚¤ ë˜ëŠ” ë¬¸ìì—´
  wsFieldName: string; // ì›¹ì†Œì¼“ í•„ë“œëª…
  defaultItem: T; // ê¸°ë³¸ ì•„ì´í…œ ê°ì²´
  emptyTitle: string;
  emptyDescription: string;
  // addButtonText ì‚­ì œ -> Add ${itemName} ì‚¬ìš©
  // editButtonText ì‚­ì œ -> Edit ${itemName} ì‚¬ìš©
  // deleteButtonText ì‚­ì œ -> Delete ì‚¬ìš©
  validateItem?: (item: T) => boolean | string; // ìœ íš¨ì„± ê²€ì‚¬ (ê²°ê³¼: boolean ë˜ëŠ” ì—ëŸ¬ ë©”ì‹œì§€ string)
  checkDuplicate?: (item: T, items: T[], excludeIndex?: number) => boolean; // ì¤‘ë³µ ê²€ì‚¬
  renderItemLabel: (item: T) => ReactNode; // í•„ìˆ˜
  renderItemContent?: (item: T) => ReactNode; // Optional
  renderDialogContent: ( // í•„ìˆ˜
    item: T,
    updateItemState: <K extends keyof T>(item: T, field: K, value: T[K]) => void, // ì œë„¤ë¦­ ë°©ì‹ìœ¼ë¡œ ë³€ê²½
    isEdit: boolean
  ) => ReactNode;
  prepareItemForSave?: (item: Partial<T>, isUpdate: boolean, currentUser?: User | null) => Partial<T> | Record<string, any>; // ì‚¬ìš©ì ì •ë³´ ì „ë‹¬
}

// ë¶€ëª¨ë¡œë¶€í„° ë°›ëŠ” ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜ íƒ€ì…
type SendMessageFn = (type: string, data: Record<string, unknown>) => void;

// useSocket í›… ë°˜í™˜ íƒ€ì… (ì‹¤ì œ ë°˜í™˜ íƒ€ì…ì— ë§ì¶°ì•¼ í•¨)
interface SocketHookReturn {
  socket?: any; // ì‹¤ì œ ì†Œì¼“ ê°ì²´ íƒ€ì…ìœ¼ë¡œ êµì²´ í•„ìš” (e.g., Socket from 'socket.io-client')
  emit: SendMessageFn;
  on: (eventName: string, callback: (data: any) => void) => void;
  off: (eventName: string, callback: (data: any) => void) => void;
  connected: boolean;
}

// ì»´í¬ë„ŒíŠ¸ Props íƒ€ì…
interface GenericDataTabProps<T extends DataItem> {
  cve: CVEDetailData;
  currentUser?: User | null;
  refreshTrigger: number; // ìƒˆë¡œê³ ì¹¨ íŠ¸ë¦¬ê±° (í•„ìˆ˜)
  tabConfig: TabConfig<T>; // í•´ë‹¹ íƒ­ì˜ ì„¤ì • ê°ì²´ (í•„ìˆ˜)
  parentSendMessage?: SendMessageFn; // Optional (useSocketìœ¼ë¡œ ëŒ€ì²´ ê°€ëŠ¥ì„± ìˆìŒ)
  onCountChange?: (count: number) => void; // Optional
}

// API ì‘ë‹µ íƒ€ì… (ì˜ˆì‹œ)
interface CveUpdateResponse {
    data: CVEDetailData; // ì‘ë‹µ ë°ì´í„° êµ¬ì¡° í™•ì¸ í•„ìš”
}

// --- ì»´í¬ë„ŒíŠ¸ êµ¬í˜„ ---

// ì œë„¤ë¦­ íƒ€ì… Të¥¼ ì‚¬ìš©í•˜ì—¬ ì»´í¬ë„ŒíŠ¸ ì •ì˜
const GenericDataTab = memo(<T extends DataItem>(props: GenericDataTabProps<T>) => {
  const {
    cve,
    currentUser,
    refreshTrigger,
    tabConfig,
    // parentSendMessage, // useSocketì˜ emitìœ¼ë¡œ ëŒ€ì²´ë˜ì—ˆìœ¼ë¯€ë¡œ ì£¼ì„ ì²˜ë¦¬ ë˜ëŠ” ì œê±°
    onCountChange = () => {}, // ê¸°ë³¸ê°’ í•¨ìˆ˜
  } = props;

  const { enqueueSnackbar } = useSnackbar();
  const queryClient = useQueryClient();

  // --- ìƒíƒœ ê´€ë¦¬ ---
  const [loading, setLoading] = useState(false); // ë¡œë”© ìƒíƒœ
  const [open, setOpen] = useState(false); // ë‹¤ì´ì–¼ë¡œê·¸ ì—´ë¦¼ ìƒíƒœ
  const [newItem, setNewItem] = useState<T>({ ...tabConfig.defaultItem }); // ìƒˆ ì•„ì´í…œ
  const [selectedItem, setSelectedItem] = useState<T & { originalIndex?: number } | null>(null); // ì„ íƒëœ ì•„ì´í…œ (ì›ë³¸ ì¸ë±ìŠ¤ í¬í•¨ ê°€ëŠ¥)
  // const [selectedIndex, setSelectedIndex] = useState<number>(-1); // selectedItem.originalIndex ë¡œ ëŒ€ì²´ ê°€ëŠ¥
  const [error, setError] = useState<string | null>(null); // ë‹¤ì´ì–¼ë¡œê·¸ ë‚´ ì—ëŸ¬ ë©”ì‹œì§€

  // --- Socket ì„¤ì • ---
  const { socket, emit, on, off, connected } = useSocket(); // useSocket í›… ì‚¬ìš©

  // ë°ì´í„° ë°°ì—´ ì°¸ì¡° (propìœ¼ë¡œ ë°›ì€ cve ì‚¬ìš©)
  // dataFieldê°€ stringì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ íƒ€ì… ë‹¨ì–¸ ì‚¬ìš© (ë°±ì—”ë“œ ì‘ë‹µ êµ¬ì¡°ì— ë”°ë¼ ì¡°ì •)
  const items: T[] = useMemo(() =>
    (cve && typeof tabConfig.dataField === 'string' && cve[tabConfig.dataField] as T[]) || [],
    [cve, tabConfig.dataField]
  );

  // --- í•¸ë“¤ëŸ¬ ë° ì½œë°± ---

  // ë‹¤ì´ì–¼ë¡œê·¸ ë‚´ ì•„ì´í…œ ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ì œë„¤ë¦­ ì‚¬ìš©)
  const updateItemState = useCallback(<K extends keyof T>(item: T, field: K, value: T[K]) => {
      if (selectedItem) {
          // ì„ íƒëœ ì•„ì´í…œ ì—…ë°ì´íŠ¸ (ìˆ˜ì • ëª¨ë“œ)
          setSelectedItem(prev => prev ? { ...prev, [field]: value } : null);
      } else {
          // ìƒˆ ì•„ì´í…œ ì—…ë°ì´íŠ¸ (ì¶”ê°€ ëª¨ë“œ)
          setNewItem(prev => ({ ...prev, [field]: value }));
      }
      setError(null); // ì…ë ¥ ë³€ê²½ ì‹œ ì—ëŸ¬ ì´ˆê¸°í™”
  }, [selectedItem]); // ì˜ì¡´ì„± ë°°ì—´ì— selectedItem ì¶”ê°€

  // refreshTrigger ë³€ê²½ ì‹œ ìºì‹œ ë¬´íš¨í™”
  useEffect(() => {
    if (refreshTrigger > 0 && cve?.cveId) {
      logger.info(`GenericDataTab (${tabConfig.title}): refreshTrigger ê°ì§€, ìºì‹œ ë¬´íš¨í™”`);
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.CVE.detail(cve.cveId) } as InvalidateQueryFilters);
    }
  }, [refreshTrigger, queryClient, cve?.cveId, tabConfig.title]);

  // ì•„ì´í…œ ìˆ˜ ë³€ê²½ ì‹œ ì½œë°± í˜¸ì¶œ
  useEffect(() => {
    onCountChange(items.length);
  }, [items.length, onCountChange]);

  // ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ë°ì´í„° ì—…ë°ì´íŠ¸ ìˆ˜ì‹ )
  useEffect(() => {
    if (!connected || !cve?.cveId || !tabConfig.wsFieldName) return;

    const handleDataUpdated = (data: { cveId?: string; field?: string; cve?: CVEDetailData }) => {
      if (data?.cveId === cve.cveId && data?.field === tabConfig.wsFieldName && data?.cve) {
        logger.debug('GenericDataTab', `${tabConfig.itemName} ë°ì´í„° ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ ìˆ˜ì‹ `, { cveId: data.cveId, field: data.field });
        // React Query ìºì‹œ ì§ì ‘ ì—…ë°ì´íŠ¸
        queryClient.setQueryData<CVEDetailData>(QUERY_KEYS.CVE.detail(cve.cveId), data.cve);
        // ì•„ì´í…œ ìˆ˜ ì—…ë°ì´íŠ¸ (ìºì‹œ ì—…ë°ì´íŠ¸ í›„ ìë™ìœ¼ë¡œ ë°˜ì˜ë  ìˆ˜ë„ ìˆìŒ, í•„ìš”ì‹œ í˜¸ì¶œ)
        const updatedItems = (data.cve[tabConfig.dataField as keyof CVEDetailData] as T[]) || [];
        onCountChange(updatedItems.length);
      }
    };

    const eventName = SOCKET_EVENTS.DATA_UPDATED; // ì‹¤ì œ ì‚¬ìš©í•˜ëŠ” ì´ë²¤íŠ¸ ì´ë¦„ìœ¼ë¡œ í™•ì¸/ë³€ê²½ í•„ìš”
    on(eventName, handleDataUpdated);

    return () => { // í´ë¦°ì—…
      off(eventName, handleDataUpdated);
    };
  }, [connected, cve?.cveId, tabConfig.wsFieldName, tabConfig.itemName, tabConfig.dataField, on, off, queryClient, onCountChange]); // tabConfig.dataField ì¶”ê°€

  // ìœ íš¨ì„± ê²€ì‚¬ í•¨ìˆ˜
  const isItemValid = useCallback((item: T): boolean => {
    // ë¹ˆ ê°’ ì²´í¬ ë“± ê¸°ë³¸ ìœ íš¨ì„± ì¶”ê°€ ê°€ëŠ¥
    if (!item) return false;
    const validationResult = tabConfig.validateItem ? tabConfig.validateItem(item) : true;
    return typeof validationResult === 'boolean' ? validationResult : false; // boolean ê²°ê³¼ë§Œ ìœ íš¨
  }, [tabConfig.validateItem]);

  // ì¤‘ë³µ ê²€ì‚¬ í•¨ìˆ˜
  const isDuplicateItem = useCallback((item: T, excludeIndex: number = -1): boolean => {
    return tabConfig.checkDuplicate ? tabConfig.checkDuplicate(item, items, excludeIndex) : false;
  }, [tabConfig.checkDuplicate, items]); // items ì˜ì¡´ì„± ì¶”ê°€

  // ë‹¤ì´ì–¼ë¡œê·¸ ë²„íŠ¼ í™œì„±í™” ì¡°ê±´
  const isButtonEnabled = useMemo(() => {
    const itemToCheck = selectedItem ?? newItem;
    if (!isItemValid(itemToCheck)) {
      return false; // ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ë¹„í™œì„±í™”
    }
    // ìˆ˜ì • ì‹œì—ëŠ” handleUpdateItemì—ì„œ, ì¶”ê°€ ì‹œì—ëŠ” handleAddItemì—ì„œ ì¤‘ë³µ ê²€ì‚¬
    return !loading; // ë¡œë”© ì¤‘ ì•„ë‹ ë•Œ í™œì„±í™”
  }, [selectedItem, newItem, isItemValid, loading]); // isDuplicateItem ì œê±°, loading ì¶”ê°€

  // ì¶”ê°€ ë²„íŠ¼ í´ë¦­
  const handleAddClick = useCallback(() => {
    setSelectedItem(null);
    setNewItem({ ...tabConfig.defaultItem }); // í•­ìƒ defaultItemìœ¼ë¡œ ì´ˆê¸°í™”
    setError(null);
    setOpen(true);
  }, [tabConfig.defaultItem]);

  // ìˆ˜ì • ë²„íŠ¼ í´ë¦­
  const handleEditClick = useCallback((item: T, index: number) => {
    setSelectedItem({ ...item, originalIndex: index }); // ì›ë³¸ ì¸ë±ìŠ¤ ì €ì¥
    setError(null);
    setOpen(true);
  }, []);

  // ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°
  const handleClose = useCallback(() => {
    // activeElementê°€ HTMLElementì¸ì§€ í™•ì¸ í›„ blur í˜¸ì¶œ
    if (document.activeElement instanceof HTMLElement) {
        document.activeElement.blur();
    }
    setTimeout(() => {
      setOpen(false);
      // ìƒíƒœ ì´ˆê¸°í™”ëŠ” ë‹¤ì´ì–¼ë¡œê·¸ê°€ ì™„ì „íˆ ë‹«íŒ í›„ ì‹¤í–‰ë  ìˆ˜ ìˆë„ë¡ ë³´ì¥
      setSelectedItem(null);
      setNewItem({ ...tabConfig.defaultItem });
      setError(null); // ì—ëŸ¬ ìƒíƒœ ì´ˆê¸°í™”
    }, 150); // Fade Transition ì‹œê°„ì„ ê³ ë ¤í•˜ì—¬ ì•½ê°„ì˜ ì§€ì—° ì¶”ê°€ (Material UI ê¸°ë³¸ê°’)
  }, [tabConfig.defaultItem]);

  // ë°ì´í„° ì—…ë°ì´íŠ¸ ì„±ê³µ ì²˜ë¦¬ (ê³µí†µ ë¡œì§)
  const handleUpdateSuccess = useCallback((responseData: CVEDetailData, successMessage: string) => {
      // React Query ìºì‹œ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cve.cveId), responseData);

      // ì†Œì¼“ ì´ë²¤íŠ¸ ì „ì†¡ (emit ì‚¬ìš©)
      if (connected) {
          emit(SOCKET_EVENTS.DATA_UPDATED, { // ì‹¤ì œ ì´ë²¤íŠ¸ ì´ë¦„ ì‚¬ìš©
              cveId: cve.cveId,
              field: tabConfig.wsFieldName,
              cve: responseData, // ì „ì²´ CVE ë°ì´í„° ì „ì†¡
          });
      } else {
          logger.warn('[GenericDataTab] Socket not connected, skipping emit.');
      }

      // UI ì—…ë°ì´íŠ¸ ë° ì•Œë¦¼
      if (document.activeElement instanceof HTMLElement) {
          document.activeElement.blur();
      }
      setTimeout(() => {
          handleClose(); // ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸° ë° ìƒíƒœ ì´ˆê¸°í™”
          enqueueSnackbar(successMessage as SnackbarMessage, { variant: 'success' });
      }, 0); // ì¦‰ì‹œ ì‹¤í–‰í•˜ë˜, call stack ë¶„ë¦¬

      // ì•„ì´í…œ ìˆ˜ ì—…ë°ì´íŠ¸ (ìºì‹œ ì—…ë°ì´íŠ¸ë¡œ ë°˜ì˜ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì„ íƒì )
      // const updatedItems = (responseData[tabConfig.dataField as keyof CVEDetailData] as T[]) || [];
      // onCountChange(updatedItems.length);

  }, [queryClient, cve.cveId, connected, emit, tabConfig.wsFieldName, handleClose, enqueueSnackbar /*, onCountChange, tabConfig.dataField*/]);

  // API ì—ëŸ¬ ì²˜ë¦¬ (ê³µí†µ ë¡œì§)
  const handleApiError = useCallback((error: unknown, action: string) => {
    const errorMessage = (error instanceof AxiosError ? error.response?.data?.detail || error.message : (error as Error).message)
                     || `${tabConfig.itemName} ${action} ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.`;
    logger.error(`Failed to ${action} ${tabConfig.itemName}:`, error);
    setError(errorMessage); // ë‹¤ì´ì–¼ë¡œê·¸ ë‚´ ì—ëŸ¬ í‘œì‹œ
    // ìŠ¤ë‚µë°” ì—ëŸ¬ëŠ” ê°„ê²°í•˜ê²Œ í‘œì‹œí•˜ê±°ë‚˜, ë‹¤ì´ì–¼ë¡œê·¸ ë‚´ ì—ëŸ¬ì™€ ì¤‘ë³µë˜ë¯€ë¡œ ì œê±° ê°€ëŠ¥
    // enqueueSnackbar(errorMessage as SnackbarMessage, { variant: 'error' });
  }, [tabConfig.itemName]); // setError ì¶”ê°€

  // ì•„ì´í…œ ì¶”ê°€ í•¸ë“¤ëŸ¬
  const handleAddItem = useCallback(async () => {
    setError(null); // ì´ì „ ì—ëŸ¬ ì´ˆê¸°í™”

    // ìœ íš¨ì„± ê²€ì‚¬ (ë²„íŠ¼ í™œì„±í™” ë¡œì§ê³¼ ë³„ê°œë¡œ í•œ ë²ˆ ë” ì²´í¬)
    if (!isItemValid(newItem)) {
      const validationMessage = typeof tabConfig.validateItem === 'function'
          ? tabConfig.validateItem(newItem) || 'ì…ë ¥ê°’ì„ í™•ì¸í•´ì£¼ì„¸ìš”.' // validateItemì´ string ë°˜í™˜ ì‹œ ì‚¬ìš©
          : 'ì…ë ¥ê°’ì„ í™•ì¸í•´ì£¼ì„¸ìš”.';
      setError(validationMessage as string);
      // enqueueSnackbar(validationMessage as SnackbarMessage, { variant: 'warning' }); // ë‹¤ì´ì–¼ë¡œê·¸ ì—ëŸ¬ë¡œ ëŒ€ì²´
      return;
    }
    // ì¤‘ë³µ ê²€ì‚¬
    if (isDuplicateItem(newItem)) {
      setError('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í•­ëª©ì…ë‹ˆë‹¤.');
      // enqueueSnackbar('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í•­ëª©ì…ë‹ˆë‹¤.', { variant: 'error' }); // ë‹¤ì´ì–¼ë¡œê·¸ ì—ëŸ¬ë¡œ ëŒ€ì²´
      return;
    }

    setLoading(true);

    // ìƒì„±ì ì •ë³´ ì¶”ê°€ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    const newItemWithMeta: Partial<T> = {
      ...newItem,
      created_by: currentUser?.username || 'anonymous',
      // created_at ë“± íƒ€ì„ìŠ¤íƒ¬í”„ëŠ” prepareItemForSave ë˜ëŠ” ë°±ì—”ë“œì—ì„œ ì²˜ë¦¬
    };

    // ì €ì¥ìš© ë°ì´í„° ì¤€ë¹„ (prepareItemForSave ì‚¬ìš©)
    const finalItemPayload = tabConfig.prepareItemForSave
      ? tabConfig.prepareItemForSave(newItemWithMeta, false, currentUser)
      : newItemWithMeta;

    // ê¸°ì¡´ ì•„ì´í…œ ë°°ì—´ì— ìƒˆ ì•„ì´í…œ ì¶”ê°€ (ì—…ë°ì´íŠ¸í•  ì „ì²´ ë°°ì—´)
    const updatedItems = [...items, finalItemPayload as T]; // íƒ€ì… ë‹¨ì–¸ ì£¼ì˜

    try {
      const response = await api.patch<CveUpdateResponse>(`/cves/${cve.cveId}`, {
        [tabConfig.dataField as string]: updatedItems,
      }, { skipAuthRefresh: false }); // skipAuthRefresh ëª…ì‹œ

      handleUpdateSuccess(response.data.data, `${tabConfig.itemName}ì´(ê°€) ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);

    } catch (error) {
      handleApiError(error, 'ì¶”ê°€');
      // ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ë¡¤ë°±ì€ React Queryê°€ ê´€ë¦¬í•˜ë¯€ë¡œ ëª…ì‹œì  ë¡¤ë°± ë¶ˆí•„ìš”
    } finally {
      setLoading(false);
    }
  }, [
      newItem, items, tabConfig, currentUser, isItemValid, isDuplicateItem, cve.cveId,
      handleUpdateSuccess, handleApiError, // ê³µí†µ í•¨ìˆ˜ ì‚¬ìš©
      // queryClient, emit, enqueueSnackbar, onCountChange, // handleUpdateSuccess/handleApiErrorë¡œ ì´ë™
  ]);

  // ì•„ì´í…œ ì‚­ì œ í•¸ë“¤ëŸ¬
  const handleDeleteItem = useCallback(async (indexToDelete: number) => {
    // ì‚­ì œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸ ì¶”ê°€ ê³ ë ¤
    // if (!window.confirm(`${tabConfig.itemName} í•­ëª©ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
    //   return;
    // }

    setLoading(true); // ê°œë³„ ì•„ì´í…œ ë¡œë”© ìƒíƒœëŠ” ì•„ì§ ì—†ìœ¼ë¯€ë¡œ ì „ì²´ ë¡œë”© ì‚¬ìš©

    const updatedItems = items.filter((_, i) => i !== indexToDelete);

    try {
      const response = await api.patch<CveUpdateResponse>(`/cves/${cve.cveId}`, {
        [tabConfig.dataField as string]: updatedItems,
        // action: 'delete' // ë°±ì—”ë“œê°€ ìš”êµ¬í•˜ëŠ” ê²½ìš° ì¶”ê°€
      }, { skipAuthRefresh: false });

      // ì‚­ì œ ì„±ê³µ ì‹œ ìŠ¤ë‚µë°” ì•Œë¦¼ (handleUpdateSuccessëŠ” ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°ê°€ í¬í•¨ë¨)
      enqueueSnackbar(`${tabConfig.itemName}ì´(ê°€) ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`, { variant: 'success' });
      // ìºì‹œ ì—…ë°ì´íŠ¸ëŠ” í•„ìš” (handleUpdateSuccessì™€ ìœ ì‚¬í•˜ê²Œ)
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cve.cveId), response.data.data);
      // ì†Œì¼“ ì´ë²¤íŠ¸ ì „ì†¡
      if (connected) {
          emit(SOCKET_EVENTS.DATA_UPDATED, {
              cveId: cve.cveId,
              field: tabConfig.wsFieldName,
              cve: response.data.data,
          });
      }
       // ì•„ì´í…œ ìˆ˜ ì—…ë°ì´íŠ¸ (í•„ìš”ì‹œ)
       onCountChange(updatedItems.length);


    } catch (error) {
       // ì‚­ì œ ì‹¤íŒ¨ ì‹œ ìŠ¤ë‚µë°” ì•Œë¦¼
      const errorMessage = (error instanceof AxiosError ? error.response?.data?.detail || error.message : (error as Error).message)
                       || `${tabConfig.itemName} ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.`;
      logger.error(`Failed to delete ${tabConfig.itemName}:`, error);
      enqueueSnackbar(errorMessage as SnackbarMessage, { variant: 'error' });
      // ëª…ì‹œì ì¸ ë¡¤ë°± ë¶ˆí•„ìš” (React Query ìºì‹œ ì‚¬ìš©)
    } finally {
      setLoading(false);
    }
  }, [
      items, tabConfig, cve.cveId, queryClient, emit, enqueueSnackbar, connected, onCountChange, // í•„ìš”í•œ ì˜ì¡´ì„± ì¶”ê°€
      // handleApiError ì‚­ì œ (ì§ì ‘ ì—ëŸ¬ ì²˜ë¦¬)
  ]);

  // ì•„ì´í…œ ìˆ˜ì • í•¸ë“¤ëŸ¬
  const handleUpdateItem = useCallback(async () => {
    if (!selectedItem) return; // ìˆ˜ì •í•  ì•„ì´í…œ ì—†ìœ¼ë©´ ì¤‘ë‹¨

    setError(null); // ì´ì „ ì—ëŸ¬ ì´ˆê¸°í™”

    const itemToUpdate = { ...selectedItem }; // ë³µì‚¬ë³¸ ì‚¬ìš©
    const originalIndex = itemToUpdate.originalIndex; // ì›ë³¸ ì¸ë±ìŠ¤ ê°€ì ¸ì˜¤ê¸°
    if (typeof originalIndex !== 'number' || originalIndex < 0) {
        logger.error("Invalid originalIndex for update", selectedItem);
        setError("í•­ëª© ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. (Invalid Index)");
        return;
    }
    delete (itemToUpdate as any).originalIndex; // ë‚´ë¶€ìš© ì¸ë±ìŠ¤ ì œê±°

    // ìœ íš¨ì„± ê²€ì‚¬
    if (!isItemValid(itemToUpdate as T)) {
      const validationMessage = typeof tabConfig.validateItem === 'function'
          ? tabConfig.validateItem(itemToUpdate as T) || 'ì…ë ¥ê°’ì„ í™•ì¸í•´ì£¼ì„¸ìš”.'
          : 'ì…ë ¥ê°’ì„ í™•ì¸í•´ì£¼ì„¸ìš”.';
      setError(validationMessage as string);
      // enqueueSnackbar(validationMessage as SnackbarMessage, { variant: 'warning' });
      return;
    }
    // ì¤‘ë³µ ê²€ì‚¬ (ìê¸° ìì‹  ì œì™¸)
    if (isDuplicateItem(itemToUpdate as T, originalIndex)) {
      setError('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í•­ëª©ì…ë‹ˆë‹¤.');
      // enqueueSnackbar('ì´ë¯¸ ì¡´ì¬í•˜ëŠ” í•­ëª©ì…ë‹ˆë‹¤.', { variant: 'error' });
      return;
    }

    setLoading(true);

    // ìˆ˜ì •ì ì •ë³´ ì¶”ê°€ (í•„ìš”ì‹œ)
    const updatedItemWithMeta: Partial<T> = {
      ...itemToUpdate,
      last_modified_by: currentUser?.username || 'anonymous',
      // last_modified_atì€ prepareItemForSave ë˜ëŠ” ë°±ì—”ë“œì—ì„œ ì²˜ë¦¬
    };

    // ì €ì¥ìš© ë°ì´í„° ì¤€ë¹„
    const finalItemPayload = tabConfig.prepareItemForSave
      ? tabConfig.prepareItemForSave(updatedItemWithMeta, true, currentUser)
      : updatedItemWithMeta;

    // ì—…ë°ì´íŠ¸ëœ ì•„ì´í…œ ë°°ì—´ ìƒì„±
    const updatedItems = items.map((item, i) =>
      i === originalIndex ? (finalItemPayload as T) : item // íƒ€ì… ë‹¨ì–¸ ì£¼ì˜
    );

    try {
      const response = await api.patch<CveUpdateResponse>(`/cves/${cve.cveId}`, {
        [tabConfig.dataField as string]: updatedItems,
      }, { skipAuthRefresh: false });

      handleUpdateSuccess(response.data.data, `${tabConfig.itemName}ì´(ê°€) ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.`);

    } catch (error) {
      handleApiError(error, 'ìˆ˜ì •');
      // ë¡¤ë°±ì€ React Queryê°€ ì²˜ë¦¬
    } finally {
      setLoading(false);
    }
  }, [
      selectedItem, items, tabConfig, currentUser, isItemValid, isDuplicateItem, cve.cveId,
      handleUpdateSuccess, handleApiError, // ê³µí†µ í•¨ìˆ˜ ì‚¬ìš©
      // queryClient, emit, enqueueSnackbar, onCountChange, // handleUpdateSuccess/handleApiErrorë¡œ ì´ë™
  ]);

  // ì €ì¥ ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬ (ë‹¤ì´ì–¼ë¡œê·¸)
  const handleSave = useCallback(() => {
    if (document.activeElement instanceof HTMLElement) {
        document.activeElement.blur();
    }
    // ë¹„ë™ê¸° ì²˜ë¦¬í•˜ì—¬ blur() ì™„ë£Œ í›„ ì‹¤í–‰ ë³´ì¥
    setTimeout(() => {
      if (selectedItem) {
        handleUpdateItem();
      } else {
        handleAddItem();
      }
    }, 0);
  }, [selectedItem, handleUpdateItem, handleAddItem]);

  // --- ë Œë”ë§ ---
  return (
    <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
      {/* í—¤ë” */}
      <ListHeader> {/* CommonStylesì˜ ListHeader ì‚¬ìš© (padding, border ë“± í¬í•¨ ê°€ì •) */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
          {/* tabConfig.iconì´ ìˆìœ¼ë©´ ë Œë”ë§, color="primary" ì ìš© */}
          {tabConfig.icon && React.createElement(tabConfig.icon, { color: "primary" })}
          <Typography variant="h6" color="text.primary">
            {tabConfig.title} ({items.length}) {/* ì•„ì´í…œ ìˆ˜ í‘œì‹œ */}
          </Typography>
          {/* ë¡œë”© ìƒíƒœ í‘œì‹œ */}
          {/* í—¤ë” ì „ì²´ ë¡œë”©ë³´ë‹¤ ë²„íŠ¼ ë¡œë”©ì´ ë” ì í•©í•  ìˆ˜ ìˆìŒ */}
          {/* {loading && <CircularProgress size={20} sx={{ ml: 1 }} />} */}
        </Box>
        {/* ì¶”ê°€ ë²„íŠ¼ - ActionButton ì‚¬ìš© */}
        <ActionButton
          variant="contained"
          startIcon={<AddIcon />}
          onClick={handleAddClick}
          disabled={loading} // ì „ì²´ ë¡œë”© ìƒíƒœì— ë”°ë¼ ë¹„í™œì„±í™”
        >
          {`Add ${tabConfig.itemName}`} {/* ê¸°ì¡´ í…ìŠ¤íŠ¸ í˜•ì‹ ì‚¬ìš© */}
        </ActionButton>
      </ListHeader>

      {/* ì»¨í…ì¸  ì˜ì—­ */}
      {items.length === 0 ? (
        // ì•„ì´í…œ ì—†ì„ ë•Œ ë¹ˆ ìƒíƒœ í™”ë©´ - EmptyState ì‚¬ìš©
        <EmptyState>
          {/* ì•„ì´ì½˜ ìŠ¤íƒ€ì¼ ì›ë³¸ ì ìš© */}
          {tabConfig.icon && React.createElement(tabConfig.icon, {
            sx: { fontSize: 48, color: 'primary.main', opacity: 0.7 }
          })}
          <Typography variant="h6" gutterBottom /* sx={{ mt: 1 }} ì œê±° */>
            {tabConfig.emptyTitle}
          </Typography>
          <Typography variant="body2" color="text.secondary" /* sx={{ mb: 2 }} ì œê±° */>
            {tabConfig.emptyDescription}
          </Typography>
          <Button
            variant="outlined"
            startIcon={<AddIcon />}
            onClick={handleAddClick}
            disabled={loading}
            sx={{ mt: 2 }} // ì›ë³¸ ìŠ¤íƒ€ì¼ ì ìš©
          >
            {`Add First ${tabConfig.itemName}`} {/* ê¸°ì¡´ í…ìŠ¤íŠ¸ í˜•ì‹ ì‚¬ìš© */}
          </Button>
        </EmptyState>
      ) : (
        // ì•„ì´í…œ ëª©ë¡
        <Box sx={{
          flex: 1,
          overflowY: 'auto',
          px: 2, // ì¢Œìš° íŒ¨ë”©
          py: 1, // ìƒí•˜ íŒ¨ë”©
          '& > *:not(:last-child)': { mb: 2 } // ì•„ì´í…œ ê°„ ê°„ê²© ì›ë³¸ ì ìš© (mb: 2)
        }}>
          {items.map((item, index) => (
            <StyledListItem key={item.id ?? `item-${index}`} elevation={0}>
              <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                {/* ìƒë‹¨: ë¼ë²¨ ë° ì•¡ì…˜ ë²„íŠ¼ */}
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                  {/* ì¢Œì¸¡: ë¼ë²¨ */}
                  <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, flexWrap: 'wrap', mr: 1 }}>
                    {tabConfig.renderItemLabel(item)}
                  </Box>
                  {/* ìš°ì¸¡: ì•¡ì…˜ ë²„íŠ¼ */}
                  <Box sx={{ display: 'flex', gap: 1, flexShrink: 0 }}>
                    {/* URL ì—´ê¸° ë²„íŠ¼ (item.urlì´ ìˆì„ ë•Œë§Œ) */}
                    {('url' in item && item.url) && (
                      <Tooltip title="Open URL">
                        {/* <a> íƒœê·¸ë¡œ ActionIconButtonì„ ê°ìŒ‰ë‹ˆë‹¤. */}
                        <a
                          href={(item.url as string).startsWith('http') ? (item.url as string) : `https://${item.url as string}`}
                          target="_blank"
                          rel="noopener noreferrer"
                          style={{ textDecoration: 'none', color: 'inherit' }} // ë§í¬ ë°‘ì¤„ ì œê±° ë° ì•„ì´ì½˜ ìƒ‰ìƒ ìƒì†
                          aria-label={`Open URL for ${tabConfig.renderItemLabel(item)}`} // ì ‘ê·¼ì„± í–¥ìƒ
                        >
                          <ActionIconButton
                            size="small"
                            disabled={loading}
                            // component, href, target, rel ì†ì„± ì œê±°
                          >
                            <LaunchIcon fontSize="small" />
                          </ActionIconButton>
                        </a>
                      </Tooltip>
                    )}
                    {/* ìˆ˜ì • ë²„íŠ¼ */}
                    <Tooltip title="Edit">
                      <ActionIconButton size="small" onClick={() => handleEditClick(item, index)} disabled={loading}>
                        <EditIcon fontSize="small" />
                      </ActionIconButton>
                    </Tooltip>
                    {/* ì‚­ì œ ë²„íŠ¼ */}
                    <Tooltip title="Delete">
                      <ActionIconButton size="small" color="error" onClick={() => handleDeleteItem(index)} disabled={loading}>
                        <DeleteIcon fontSize="small" />
                      </ActionIconButton>
                    </Tooltip>
                  </Box>
                </Box>

                {/* ì„¤ëª… (ìˆì„ ê²½ìš°) */}
                {item.description && (
                  <Typography
                    variant="body2"
                    color="text.secondary"
                    sx={{
                      pl: 2,
                      borderLeft: '2px solid',
                      borderColor: 'divider',
                      wordBreak: 'break-word'
                    }}
                  >
                    {item.description}
                  </Typography>
                )}

                {/* ì¶”ê°€ ì»¨í…ì¸  (ì„¤ì •ëœ ê²½ìš°) */}
                {tabConfig.renderItemContent && (
                    <Box sx={{ mt: 0.5 }}>{tabConfig.renderItemContent(item)}</Box>
                )}

                {/* í•˜ë‹¨: ë©”íƒ€ ì •ë³´ */}
                { (item.created_by || item.created_at) && (
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mt: 0.5 }}>
                      {item.created_by && (
                          <Typography variant="caption" color="text.secondary">
                              Added by {item.created_by}
                          </Typography>
                      )}
                      {item.created_by && item.created_at && (
                          <Typography variant="caption" color="text.secondary" sx={{ lineHeight: '1' }}>â€¢</Typography>
                      )}
                      {item.created_at && (
                          <Tooltip title={`Created at: ${new Date(item.created_at).toLocaleString()}`}>
                              <Typography variant="caption" color="text.secondary">
                                  {formatDateTime(item.created_at)}
                              </Typography>
                          </Tooltip>
                      )}
                    </Box>
                )}
              </Box>
            </StyledListItem>
          ))}
        </Box>
      )}

      {/* ì¶”ê°€/ìˆ˜ì • ë‹¤ì´ì–¼ë¡œê·¸ */}
      <Dialog
        open={open}
        onClose={handleClose} // onClose í•¸ë“¤ëŸ¬ ì‚¬ìš©
        maxWidth="sm"
        fullWidth
        TransitionComponent={Fade} // Fade íŠ¸ëœì§€ì…˜ ì‚¬ìš©
        PaperProps={{ sx: { borderRadius: 3 } }} // ì›ë³¸ borderRadius ì ìš©
        keepMounted={false} // í•„ìš”ì‹œ falseë¡œ ì„¤ì •í•˜ì—¬ ì„±ëŠ¥ ìµœì í™”
        disableRestoreFocus={false} // ì›ë³¸ ì„¤ì • ìœ ì§€
        disableEnforceFocus={false} // ì›ë³¸ ì„¤ì • ìœ ì§€
        disableAutoFocus={false} // ì›ë³¸ ì„¤ì • ìœ ì§€
        disablePortal={false} // ì›ë³¸ ì„¤ì • ìœ ì§€
        aria-labelledby="generic-dialog-title"
      >
        <DialogTitle id="generic-dialog-title">
          {/* ê¸°ì¡´ í…ìŠ¤íŠ¸ í˜•ì‹ ì‚¬ìš© */}
          {selectedItem ? `Edit ${tabConfig.itemName}` : `Add ${tabConfig.itemName}`}
        </DialogTitle>
        <DialogContent dividers /* ì»¨í…ì¸  êµ¬ë¶„ì„  ì¶”ê°€ (ìœ ì§€) */>
          {/* ë‹¤ì´ì–¼ë¡œê·¸ ì»¨í…ì¸  ë Œë”ë§ (ì•„ì´í…œê³¼ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ì „ë‹¬) */}
          {tabConfig.renderDialogContent(
            selectedItem ?? newItem, // ìˆ˜ì • ì¤‘ì´ë©´ selectedItem, ì•„ë‹ˆë©´ newItem
            updateItemState, // ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ì „ë‹¬
            selectedItem !== null // ìˆ˜ì • ëª¨ë“œ ì—¬ë¶€ ì „ë‹¬
          )}
          {/* ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ (ë‹¤ì´ì–¼ë¡œê·¸ í•˜ë‹¨) */}
          {error && <Typography color="error" variant="caption" sx={{ mt: 1, display: 'block' }}>{error}</Typography>}
        </DialogContent>
        <DialogActions sx={{ px: 3, py: 2 }} /* íŒ¨ë”© ìœ ì§€ */>
          <Button onClick={handleClose} color="inherit" /* ìƒ‰ìƒ ìœ ì§€ */>Cancel</Button>
          <Button
            variant="contained"
            onClick={handleSave}
            disabled={!isButtonEnabled || loading} // ë¡œë”© ì¤‘ì¼ ë•Œë„ ë¹„í™œì„±í™”
            startIcon={loading ? <CircularProgress size={16} color="inherit" /> : undefined} // ë¡œë”© ì•„ì´ì½˜ ìœ ì§€
            autoFocus={true} // ì›ë³¸ autoFocus ì ìš©
          >
            {/* ê¸°ì¡´ í…ìŠ¤íŠ¸ í˜•ì‹ ì‚¬ìš© */}
            {selectedItem ? 'Save' : 'Add'}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}); // memo ë

GenericDataTab.displayName = 'GenericDataTab'; // DevTools ì´ë¦„ ì„¤ì •
export default GenericDataTab;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/CrawlerUpdateButton.tsx
------------------------------------------------------------
// CrawlerUpdateButton.tsx - ë¦¬íŒ©í† ë§ ë²„ì „
import React, { useState, useEffect, useCallback, useRef, MouseEvent } from 'react';
import { useSnackbar } from 'notistack';
import {
  Button, Menu, MenuItem, Dialog, DialogTitle, DialogContent, Typography, Box, 
  LinearProgress, IconButton, Tooltip, Divider, Paper, CircularProgress, 
  Stepper, Step, StepLabel, Card, Grid, Avatar
} from '@mui/material';
import {
  CloudDownload as CloudDownloadIcon,
  Close as CloseIcon,
  Error as ErrorIcon,
  Settings as SettingsIcon,
  DataObject as DataObjectIcon,
  Storage as StorageIcon,
  CheckCircle as CheckCircleIcon,
  Update as UpdateIcon,
  KeyboardArrowDown as ArrowDownIcon,
  InfoOutlined as InfoIcon
} from '@mui/icons-material';
import { useQueryClient } from '@tanstack/react-query';
import api from 'shared/api/config/axios';
import { useSocket } from 'core/socket/hooks/useSocket';
import { formatDistance } from 'date-fns';
import { ko } from 'date-fns/locale';
import logger, { LOG_LEVEL } from 'shared/utils/logging';
import { SOCKET_EVENTS, SOCKET_STATE } from 'core/socket/services/constants';
import { get } from 'lodash';
import { StageInfo, UpdatedCVEs, Crawler, CrawlerStatusResponse, ProgressState, CrawlerUpdateData } from 'features/crawler/types';

// ê°œë°œ í™˜ê²½ì—ì„œ ë””ë²„ê·¸ ë¡œê¹…
if (process.env.NODE_ENV === 'development') {
  logger.setLogLevel(LOG_LEVEL.DEBUG);
  logger.setEnabled(true);
}

// í¬ë¡¤ëŸ¬ ì§„í–‰ ë‹¨ê³„ ì •ì˜
const CRAWLER_STAGES: StageInfo[] = [
  {
    key: 'preparing',
    label: 'ì¤€ë¹„ ì¤‘',
    description: 'í¬ë¡¤ëŸ¬ ì´ˆê¸°í™” ë° ì €ì¥ì†Œ ì—°ê²° ì¤€ë¹„',
    icon: <SettingsIcon fontSize="small" />,
    color: '#3f51b5',
    backendValues: ['ì¤€ë¹„ ì¤‘', 'ì¤€ë¹„', 'ì´ˆê¸°í™”', 'ì—°ê²°', 'ì§„í–‰ ì¤‘']
  },
  {
    key: 'fetching',
    label: 'ë°ì´í„° ìˆ˜ì§‘',
    description: 'ì†ŒìŠ¤ì—ì„œ ë°ì´í„° ìˆ˜ì§‘ ì¤‘',
    icon: <CloudDownloadIcon fontSize="small" />,
    color: '#2196f3',
    backendValues: ['ë°ì´í„° ìˆ˜ì§‘', 'ìˆ˜ì§‘', 'ì§„í–‰ ì¤‘']
  },
  {
    key: 'processing',
    label: 'ë°ì´í„° ì²˜ë¦¬',
    description: 'ìˆ˜ì§‘ëœ ë°ì´í„° ì²˜ë¦¬ ë° ë¶„ì„',
    icon: <DataObjectIcon fontSize="small" />,
    color: '#00bcd4',
    backendValues: ['ë°ì´í„° ì²˜ë¦¬', 'ì²˜ë¦¬', 'ì§„í–‰ ì¤‘']
  },
  {
    key: 'saving',
    label: 'ì €ì¥ ì¤‘',
    description: 'ì²˜ë¦¬ëœ ë°ì´í„° ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥',
    icon: <StorageIcon fontSize="small" />,
    color: '#009688',
    backendValues: ['ì €ì¥ ì¤‘', 'ì €ì¥', 'ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸', 'ì—…ë°ì´íŠ¸', 'ì§„í–‰ ì¤‘']
  },
  {
    key: 'completed',
    label: 'ì™„ë£Œ',
    description: 'í¬ë¡¤ë§ ì‘ì—… ì™„ë£Œ',
    icon: <CheckCircleIcon fontSize="small" />,
    color: '#4caf50',
    backendValues: ['ì™„ë£Œ', 'done', 'complete', 'finished', 'completed']
  },
  {
    key: 'error',
    label: 'ì˜¤ë¥˜',
    description: 'í¬ë¡¤ë§ ì‘ì—… ì¤‘ ì˜¤ë¥˜ ë°œìƒ',
    icon: <ErrorIcon fontSize="small" />,
    color: '#f44336',
    backendValues: ['ì˜¤ë¥˜', 'error', 'ì‹¤íŒ¨', 'failed']
  }
];

// í¬ë¡¤ëŸ¬ ëª©ë¡
const CRAWLERS: Crawler[] = [
  { id: 'nuclei', name: 'Nuclei Templates', type: 'nuclei' },
  { id: 'metasploit', name: 'Metasploit', type: 'metasploit' },
  { id: 'emerging_threats', name: 'EmergingThreats Rules', type: 'emerging_threats' }
];

/**
 * ë‹¨ê³„ ì¸ë±ìŠ¤ ì¶”ì¶œ í•¨ìˆ˜
 */
const getStageIndex = (stageName: string | undefined): number => {
  if (!stageName) return 0;

  const lowerStageName = String(stageName).toLowerCase().trim();
  
  // 1. í‚¤ ë§¤ì¹­
  const stageIndex = CRAWLER_STAGES.findIndex((stage) => stage.key === lowerStageName);
  if (stageIndex >= 0) return stageIndex;

  // 2. ë°±ì—”ë“œ ê°’ ë§¤ì¹­
  for (let i = 0; i < CRAWLER_STAGES.length; i++) {
    const stage = CRAWLER_STAGES[i];
    if (
      stage.backendValues &&
      stage.backendValues.some(
        (value) =>
          value.toLowerCase() === lowerStageName ||
          lowerStageName.includes(value.toLowerCase()) ||
          value.toLowerCase().includes(lowerStageName)
      )
    ) {
      return i;
    }
  }

  return 0; // ì¤€ë¹„ ì¤‘ ë°˜í™˜
};

/**
 * CrawlerUpdateButton ì»´í¬ë„ŒíŠ¸
 */
const CrawlerUpdateButton: React.FC = () => {
  const { enqueueSnackbar } = useSnackbar();
  const queryClient = useQueryClient();
  const socket = useSocket();
  const { connected } = socket;

  // ë©”ë‰´ì™€ ë‹¤ì´ì–¼ë¡œê·¸ ìƒíƒœ
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [progressOpen, setProgressOpen] = useState<boolean>(false);
  const [selectedCrawler, setSelectedCrawler] = useState<Crawler | null>(null);

  // ì§„í–‰ ìƒíƒœ
  const [progress, setProgress] = useState<ProgressState>({
    stage: '',
    percent: 0,
    message: ''
  });
  const [isRunning, setIsRunning] = useState<boolean>(false);
  const [loading, setLoading] = useState<boolean>(false);
  const [activeStep, setActiveStep] = useState<number>(0);
  const [hasError, setHasError] = useState<boolean>(false);
  const [lastUpdate, setLastUpdate] = useState<Record<string, unknown>>({});
  const [updatedCVEs, setUpdatedCVEs] = useState<UpdatedCVEs | null>(null);

  // ì›¹ì†Œì¼“ê³¼ í´ë§ ê´€ë ¨ ìƒíƒœ
  const [isSocketConnected, setIsSocketConnected] = useState<boolean>(false);
  const [lastWebSocketUpdate, setLastWebSocketUpdate] = useState<Date | null>(null);
  const [pollTimer, setPollTimer] = useState<NodeJS.Timeout | null>(null);

  // ì°¸ì¡°
  const buttonRef = useRef<HTMLButtonElement | null>(null);
  const dialogRef = useRef<HTMLDivElement | null>(null);

  // ---- í¬ë¡¤ëŸ¬ ìƒíƒœ ê´€ë¦¬ ------------------------------------------------

  // í¬ë¡¤ëŸ¬ ìƒíƒœ ë¡œë“œ
  const loadCrawlerStatus = useCallback(async (): Promise<void> => {
    try {
      setLoading(true);
      const response = await api.get<CrawlerStatusResponse>('/crawler/status');
      const statusData = response.data;

      setIsRunning(statusData.isRunning);

      // ë‹¨ê³„ ì •ë³´
      if (statusData.currentStatus) {
        const currentStatus = statusData.currentStatus;
        if (typeof currentStatus.stage === 'string') {
          const stageIndex = getStageIndex(currentStatus.stage);
          setActiveStep(stageIndex);
        }
        setProgress((prev) => ({
          stage: currentStatus.stage_label || currentStatus.stage || '',
          percent: typeof currentStatus.percent === 'number' ? currentStatus.percent : 0,
          message: currentStatus.message || ''
        }));
      }

      // í¬ë¡¤ëŸ¬ë³„ ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„
      const newLastUpdate: Record<string, unknown> = {};
      if (statusData.results) {
        Object.keys(statusData.results).forEach((crawlerType) => {
          const crawler = CRAWLERS.find((c) => c.type === crawlerType);
          if (crawler) {
            newLastUpdate[crawler.id] = statusData.lastUpdate;
          }
        });
      }
      // ë‚˜ë¨¸ì§€ í¬ë¡¤ëŸ¬ëŠ” ê¸°ë³¸ê°’
      CRAWLERS.forEach((crawler) => {
        if (!newLastUpdate[crawler.id]) {
          newLastUpdate[crawler.id] = null;
        }
      });
      // ì „ì²´ ì‹œìŠ¤í…œ ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸
      newLastUpdate['default'] = statusData.lastUpdate;
      setLastUpdate(newLastUpdate);
    } catch (error) {
      logger.error('í¬ë¡¤ëŸ¬', 'ìƒíƒœ ë¡œë“œ ì‹¤íŒ¨:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  // ---- í´ë§ ê´€ë¦¬ --------------------------------------------------------

  // í´ë§ ì¤‘ì§€
  const stopPolling = useCallback(() => {
    if (pollTimer) {
      logger.info('í´ë§ ì¤‘ì§€');
      clearInterval(pollTimer);
      setPollTimer(null);
    }
  }, [pollTimer]);

  // í´ë§ ì‹œì‘
  const startPolling = useCallback(() => {
    if (pollTimer) clearInterval(pollTimer);
    
    logger.info('í´ë§ ì‹œì‘');
    const timer = setInterval(async () => {
      try {
        if (!isRunning) {
          stopPolling();
          return;
        }
        await loadCrawlerStatus();
      } catch (error) {
        logger.error('í´ë§', 'í¬ë¡¤ëŸ¬ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨:', error);
      }
    }, 3000);
    
    setPollTimer(timer);
  }, [pollTimer, isRunning, loadCrawlerStatus, stopPolling]);

  // ---- ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ ì²˜ë¦¬ ------------------------------------------------

  // ì—°ê²° ìƒíƒœ ë³€ê²½ ì²˜ë¦¬ í•¨ìˆ˜
  const handleConnectionStateChange = useCallback((data: any) => {
    if (data.state === SOCKET_STATE.CONNECTED) {
      setIsSocketConnected(true);
    } else if (data.state === SOCKET_STATE.DISCONNECTED) {
      setIsSocketConnected(false);
    }
  }, []);

  // í¬ë¡¤ëŸ¬ ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ ì²˜ë¦¬
  const handleCrawlerUpdateEvent = useCallback(
    (rawData: any) => {
      // ë°ì´í„° ì¶”ì¶œ
      const extractedData: CrawlerUpdateData = {
        stage: get(rawData, 'data.data.stage') || get(rawData, 'data.stage') || get(rawData, 'stage'),
        stage_label: get(rawData, 'data.data.stage_label') || get(rawData, 'data.stage_label') || get(rawData, 'stage_label'),
        percent: get(rawData, 'data.data.percent') || get(rawData, 'data.percent') || get(rawData, 'percent'),
        message: get(rawData, 'data.data.message') || get(rawData, 'data.message') || get(rawData, 'message'),
        isRunning: get(rawData, 'data.data.isRunning') || get(rawData, 'data.isRunning') || get(rawData, 'isRunning'),
        hasError: get(rawData, 'data.data.hasError') || get(rawData, 'data.hasError') || get(rawData, 'hasError'),
        updatedCves: get(rawData, 'data.data.updatedCves') || get(rawData, 'data.updatedCves') || get(rawData, 'updatedCves')
      };

      try {
        // ë‹¨ê³„ ì •ë³´ ì—…ë°ì´íŠ¸
        if (typeof extractedData.stage === 'string') {
          const index = getStageIndex(extractedData.stage);
          setActiveStep(index);
        }

        // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
        setProgress((prev) => ({
          ...prev,
          stage: extractedData.stage_label || 
                 (extractedData.stage && CRAWLER_STAGES[getStageIndex(extractedData.stage)]?.label) || 
                 extractedData.stage || 
                 '',
          percent: typeof extractedData.percent === 'number' ? extractedData.percent : prev.percent,
          message: extractedData.message || prev.message
        }));

        // ì™„ë£Œ / ì˜¤ë¥˜ ìƒíƒœ íŒë‹¨
        const stageValue = String(extractedData.stage || '').toLowerCase();
        const isCompleted = CRAWLER_STAGES.find((st) => st.key === 'completed')?.backendValues.some((val) =>
          stageValue.includes(val.toLowerCase())
        );
        const isError = CRAWLER_STAGES.find((st) => st.key === 'error')?.backendValues.some((val) =>
          stageValue.includes(val.toLowerCase())
        );

        if (isError) {
          setHasError(true);
          setIsRunning(false);
        } else if (isCompleted) {
          setHasError(false);
          setIsRunning(false);
          setProgress((prev) => ({ ...prev, message: 'ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.' }));
          enqueueSnackbar('í¬ë¡¤ëŸ¬ ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. CVE ëª©ë¡ì„ ê°±ì‹ í•©ë‹ˆë‹¤.', {
            variant: 'success',
            autoHideDuration: 4000
          });
          queryClient.invalidateQueries({ queryKey: ['cves'] });
        } else {
          setHasError(false);
          setIsRunning(true);
        }

        // ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„
        setLastUpdate((prev) => ({ ...prev, default: new Date().toISOString() }));
        setLastWebSocketUpdate(new Date());
      } catch (err) {
        logger.error('handleCrawlerUpdateEvent', 'ë°ì´í„° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜', err);
      }
    },
    [enqueueSnackbar, queryClient]
  );

  // ì†Œì¼“ ì´ë²¤íŠ¸ êµ¬ë… ì„¤ì •
  useEffect(() => {
    // ì´ë²¤íŠ¸ êµ¬ë… ì„¤ì •
    const stateUnsubscribe = socket.on(
      SOCKET_EVENTS.CONNECTION_STATE_CHANGE, 
      handleConnectionStateChange
    );
    
    // í¬ë¡¤ëŸ¬ ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ êµ¬ë…
    const updateUnsubscribe = socket.on(
      SOCKET_EVENTS.CRAWLER_UPDATE_PROGRESS, 
      handleCrawlerUpdateEvent
    );
    
    // ì´ˆê¸° ìƒíƒœ ì„¤ì •
    setIsSocketConnected(connected);
    
    // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ êµ¬ë… í•´ì œ
    return () => {
      stateUnsubscribe();
      updateUnsubscribe();
    };
  }, [connected, handleConnectionStateChange, handleCrawlerUpdateEvent]);

  // ì—°ê²° ìƒíƒœ ë° í´ë§ ê´€ë¦¬
  useEffect(() => {
    if (isRunning) {
      // ì›¹ì†Œì¼“ ì—°ê²° ìƒíƒœ í™•ì¸
      if (!connected) {
        if (!pollTimer) {
          logger.info('CrawlerUpdateButton', 'ì›¹ì†Œì¼“ ì—°ê²° ì—†ìŒ - í´ë§ ì‹œì‘');
          startPolling();
        }
      } else {
        // ì›¹ì†Œì¼“ì´ ì—°ê²°ë˜ì–´ ìˆê³  ìµœì†Œ í•œ ë²ˆ ì´ìƒì˜ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•œ ê²½ìš° í´ë§ ì¤‘ì§€
        if (pollTimer && lastWebSocketUpdate) {
          logger.info('CrawlerUpdateButton', 'ì›¹ì†Œì¼“ ì—°ê²° ê°ì§€ - í´ë§ ì¤‘ì§€');
          stopPolling();
        }
      }
    } else {
      // ì‹¤í–‰ ì¤‘ì´ ì•„ë‹ˆë©´ í´ë§ ì¤‘ì§€
      if (pollTimer) {
        logger.info('CrawlerUpdateButton', 'í¬ë¡¤ëŸ¬ ì‹¤í–‰ ì¤‘ì§€ - í´ë§ ì¤‘ì§€');
        stopPolling();
      }
    }
  }, [isRunning, connected, pollTimer, lastWebSocketUpdate, startPolling, stopPolling]);

  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ í´ë§ ì¤‘ì§€
  useEffect(() => {
    return () => {
      if (pollTimer) {
        logger.info('CrawlerUpdateButton', 'ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ - í´ë§ ì¤‘ì§€');
        clearInterval(pollTimer);
      }
    };
  }, [pollTimer]);

  // ì´ˆê¸° ìƒíƒœ ë¡œë“œ
  useEffect(() => {
    const timer = setTimeout(() => {
      loadCrawlerStatus();
    }, 500);
    return () => clearTimeout(timer);
  }, [loadCrawlerStatus]);

  // ---- UI ì´ë²¤íŠ¸ ------------------------------------------------

  const handleClick = (event: MouseEvent<HTMLButtonElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleSelect = (crawler: Crawler) => {
    setSelectedCrawler(crawler);
    setAnchorEl(null);
    runCrawler(crawler);
  };

  const runCrawler = async (crawler: Crawler) => {
    try {
      setSelectedCrawler(crawler);
      setProgressOpen(true);
      setProgress({ stage: 'ì¤€ë¹„ ì¤‘', percent: 0, message: 'í¬ë¡¤ëŸ¬ ì´ˆê¸°í™” ì¤‘...' });
      setActiveStep(0);
      setHasError(false);
      setUpdatedCVEs(null);

      await api.post(`/crawler/run/${crawler.type}`, { id: crawler.id });
      startPolling();
    } catch (error: any) {
      logger.error('í¬ë¡¤ëŸ¬', 'ì‹¤í–‰ ì˜¤ë¥˜:', error);
      setHasError(true);
      const errorMessage = error.response?.data?.detail || 'í¬ë¡¤ëŸ¬ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
      setProgress({
        stage: 'ì˜¤ë¥˜',
        percent: 0,
        message: errorMessage
      });
      enqueueSnackbar(errorMessage, {
        variant: 'error',
        autoHideDuration: 5000
      });
    }
  };

  // ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ í¬ë§·íŒ…
  const formatLastUpdate = (lastUpdateObj: unknown): string => {
    if (!lastUpdateObj) return 'ì—†ìŒ';
    try {
      if (typeof lastUpdateObj === 'string') {
        const date = new Date(lastUpdateObj);
        return formatDistance(date, new Date(), { addSuffix: true, locale: ko });
      }
      if (typeof lastUpdateObj === 'object' && lastUpdateObj !== null) {
        const obj = lastUpdateObj as Record<string, any>;
        const dateString = obj.datetime || obj.date || obj.timestamp;
        if (dateString) {
          const date = new Date(dateString);
          return formatDistance(date, new Date(), { addSuffix: true, locale: ko });
        }
      }
      return 'ì—†ìŒ';
    } catch (e) {
      console.error('ë‚ ì§œ í¬ë§·íŒ… ì˜¤ë¥˜:', e);
      return 'ì•Œ ìˆ˜ ì—†ìŒ';
    }
  };

  const handleCloseDialog = useCallback(() => {
    if (isRunning) return;
    if (buttonRef.current) {
      buttonRef.current.focus();
    }
    setTimeout(() => {
      setProgressOpen(false);
    }, 10);
  }, [isRunning]);

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && progressOpen && !isRunning) {
        handleCloseDialog();
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [progressOpen, isRunning, handleCloseDialog]);

  // ---- ë Œë”ë§ ì»´í¬ë„ŒíŠ¸ ------------------------------------------------

  // í¬ë¡¤ëŸ¬ ë‹¨ê³„ í‘œì‹œ ì»´í¬ë„ŒíŠ¸
  const CrawlerStepper = () => (
    <Card elevation={0} sx={{ p: 3, bgcolor: 'background.paper', borderRadius: 2, mb: 3 }}>
      <Stepper activeStep={activeStep} orientation="horizontal">
        {CRAWLER_STAGES.map((stage, index) => (
          <Step key={stage.key}>
            <StepLabel
              error={hasError && index === activeStep}
              optional={
                index === activeStep ? (
                  <Typography
                    variant="caption"
                    color={
                      index === activeStep
                        ? hasError
                          ? 'error.main'
                          : 'primary.main'
                        : 'text.secondary'
                    }
                  >
                    {index === activeStep ? progress.message || stage.description : stage.description}
                  </Typography>
                ) : null
              }
              StepIconProps={{
                icon:
                  hasError && index === activeStep ? (
                    <ErrorIcon color="error" />
                  ) : (
                    <Avatar
                      sx={{
                        bgcolor:
                          index < activeStep
                            ? stage.color
                            : index === activeStep
                            ? hasError
                              ? 'error.main'
                              : stage.color
                            : 'grey.300',
                        width: 24,
                        height: 24,
                        boxShadow:
                          index === activeStep && !hasError
                            ? '0 0 0 2px #fff, 0 0 0 4px ' + stage.color
                            : 'none',
                        animation:
                          index === activeStep && !hasError && isRunning
                            ? 'pulse 1.5s infinite'
                            : 'none',
                        '@keyframes pulse': {
                          '0%': { boxShadow: '0 0 0 0 rgba(33, 150, 243, 0.4)' },
                          '70%': { boxShadow: '0 0 0 6px rgba(33, 150, 243, 0)' },
                          '100%': { boxShadow: '0 0 0 0 rgba(33, 150, 243, 0)' }
                        }
                      }}
                    >
                      {stage.icon}
                    </Avatar>
                  )
              }}
            >
              <Typography
                variant="body2"
                fontWeight={index === activeStep ? 'bold' : 'normal'}
                color={
                  index === activeStep
                    ? hasError
                      ? 'error.main'
                      : 'primary.main'
                    : 'text.primary'
                }
              >
                {stage.label}
                {index === activeStep && isRunning && !hasError && (
                  <Box
                    component="span"
                    sx={{ ml: 0.5, display: 'inline-flex', alignItems: 'center' }}
                  >
                    <CircularProgress
                      size={12}
                      color="primary"
                      thickness={5}
                      sx={{ color: stage.color }}
                    />
                  </Box>
                )}
              </Typography>
            </StepLabel>
          </Step>
        ))}
      </Stepper>
    </Card>
  );

  // ì§„í–‰ë¥  í‘œì‹œ ì»´í¬ë„ŒíŠ¸
  const ProgressIndicator = () => (
    <Box sx={{ mb: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
        <Typography
          variant="subtitle1"
          fontWeight="500"
          sx={{
            display: 'flex',
            alignItems: 'center',
            color: hasError
              ? 'error.main'
              : CRAWLER_STAGES[activeStep]?.color || 'primary.main'
          }}
        >
          {CRAWLER_STAGES[activeStep]?.icon && (
            <Box component="span" sx={{ mr: 1, display: 'inline-flex' }}>
              {CRAWLER_STAGES[activeStep]?.icon}
            </Box>
          )}
          {progress.stage || CRAWLER_STAGES[activeStep]?.label}
        </Typography>
      </Box>

      <Box sx={{ position: 'relative', mb: 1 }}>
        <LinearProgress
          variant="determinate"
          value={progress.percent || 0}
          sx={{
            height: 10,
            borderRadius: 5,
            bgcolor: 'background.paper',
            '& .MuiLinearProgress-bar': {
              bgcolor: hasError
                ? 'error.main'
                : CRAWLER_STAGES[activeStep]?.color || 'primary.main',
              transition: 'transform 0.3s ease-in-out'
            }
          }}
        />
        {isRunning && !hasError && (
          <LinearProgress
            variant="indeterminate"
            sx={{
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              height: 10,
              borderRadius: 5,
              opacity: 0.3,
              bgcolor: 'transparent',
              '& .MuiLinearProgress-bar': {
                bgcolor: CRAWLER_STAGES[activeStep]?.color || 'primary.main'
              }
            }}
          />
        )}
      </Box>

      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography
          variant="body2"
          sx={{
            color: 'text.secondary',
            maxWidth: '85%',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            whiteSpace: 'nowrap'
          }}
        >
          {progress.message || 'ì´ˆê¸°í™” ì¤‘...'}
        </Typography>
        {isRunning ? (
          <CircularProgress size={16} color="primary" thickness={5} />
        ) : hasError ? (
          <ErrorIcon fontSize="small" color="error" />
        ) : progress.percent >= 100 ? (
          <CheckCircleIcon fontSize="small" color="success" />
        ) : null}
      </Box>

      {lastWebSocketUpdate && (
        <Typography
          variant="caption"
          sx={{ mt: 1, display: 'block', textAlign: 'right', color: 'text.secondary' }}
        >
          ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸:{' '}
          {formatDistance(lastWebSocketUpdate, new Date(), { addSuffix: true, locale: ko })}
        </Typography>
      )}
    </Box>
  );

  // ìƒíƒœ ì¹´ë“œ ì»´í¬ë„ŒíŠ¸
  const StatusCard = () => (
    <Card
      elevation={0}
      sx={{
        p: 2,
        bgcolor: hasError ? 'error.light' : `${CRAWLER_STAGES[activeStep]?.color}15`,
        borderLeft: hasError
          ? '4px solid #f44336'
          : `4px solid ${CRAWLER_STAGES[activeStep]?.color}`,
        borderRadius: 1
      }}
    >
      <Grid container spacing={2} alignItems="center">
        <Grid item>
          <Avatar
            sx={{
              bgcolor: hasError
                ? 'error.main'
                : CRAWLER_STAGES[activeStep]?.color,
              width: 40,
              height: 40
            }}
          >
            {hasError ? <ErrorIcon /> : CRAWLER_STAGES[activeStep]?.icon}
          </Avatar>
        </Grid>
        <Grid item xs>
          <Typography variant="subtitle1" fontWeight="500">
            {hasError ? 'ì˜¤ë¥˜ ë°œìƒ' : CRAWLER_STAGES[activeStep]?.label}
          </Typography>
          <Typography variant="body2" color="text.secondary">
            {hasError
              ? progress.message
              : CRAWLER_STAGES[activeStep]?.description}
          </Typography>
        </Grid>
      </Grid>
    </Card>
  );

  // ì—…ë°ì´íŠ¸ëœ CVE ëª©ë¡ ì»´í¬ë„ŒíŠ¸
  const UpdatedCVEList = () => {
    if (!updatedCVEs || updatedCVEs.count === 0) {
      return null;
    }

    return (
      <Box sx={{ mt: 3 }}>
        <Divider sx={{ my: 2 }} />
        <Typography
          variant="h6"
          gutterBottom
          sx={{ display: 'flex', alignItems: 'center' }}
        >
          <CheckCircleIcon sx={{ mr: 1, color: 'success.main' }} />
          ì—…ë°ì´íŠ¸ëœ CVE ({updatedCVEs.count}ê°œ)
        </Typography>
        <Box
          sx={{
            maxHeight: '300px',
            overflow: 'auto',
            mt: 1,
            '&::-webkit-scrollbar': {
              width: '8px'
            },
            '&::-webkit-scrollbar-thumb': {
              backgroundColor: 'rgba(0,0,0,0.2)',
              borderRadius: '4px'
            }
          }}
        >
          {updatedCVEs.items.map((cve, index) => (
            <Paper
              key={index}
              elevation={1}
              sx={{
                p: 2,
                mb: 1,
                borderLeft: '4px solid #2196f3',
                borderRadius: 1,
                transition: 'all 0.2s',
                ':hover': {
                  boxShadow: 3,
                  transform: 'translateY(-2px)'
                }
              }}
            >
              <Typography variant="subtitle1" fontWeight="bold" color="primary.main">
                {cve.cveId}
              </Typography>
              <Typography variant="body2">{cve.title}</Typography>
            </Paper>
          ))}
        </Box>
      </Box>
    );
  };

  return (
    <>
      <Box sx={{ display: 'flex', alignItems: 'center' }}>
        <Button
          variant="contained"
          color="primary"
          onClick={handleClick}
          startIcon={loading ? <CircularProgress size={20} color="inherit" /> : <UpdateIcon />}
          endIcon={<ArrowDownIcon />}
          disabled={isRunning || loading}
          sx={{
            mr: 1,
            borderRadius: '30px',
            boxShadow: 'none',
            '&:hover': { boxShadow: 'none', backgroundColor: '#1565c0' }
          }}
          ref={buttonRef}
        >
          í¬ë¡¤ëŸ¬ ì—…ë°ì´íŠ¸
        </Button>

        <Menu anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={handleClose}>
          {CRAWLERS.map((crawler) => (
            <MenuItem
              key={crawler.id}
              onClick={() => handleSelect(crawler)}
              sx={{
                display: 'flex',
                justifyContent: 'space-between',
                minWidth: '200px'
              }}
            >
              <span>{crawler.name}</span>
              <Tooltip
                title={`ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${formatLastUpdate(lastUpdate[crawler.id])}`}
                placement="right"
              >
                <InfoIcon
                  fontSize="small"
                  color={lastUpdate[crawler.id] ? 'action' : 'disabled'}
                  sx={{ ml: 1 }}
                />
              </Tooltip>
            </MenuItem>
          ))}
        </Menu>
      </Box>

      <Dialog
        open={progressOpen}
        onClose={handleCloseDialog}
        maxWidth="md"
        fullWidth
        PaperProps={{
          sx: { borderRadius: 2 },
          ref: dialogRef
        }}
        aria-labelledby="crawler-progress-dialog-title"
        disableRestoreFocus={true}
        keepMounted
      >
        <DialogTitle id="crawler-progress-dialog-title">
          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Typography variant="h6">
              {selectedCrawler?.name || 'í¬ë¡¤ëŸ¬'} ì—…ë°ì´íŠ¸ ì§„í–‰ ìƒí™©
            </Typography>
            {!isRunning && (
              <IconButton
                onClick={handleCloseDialog}
                size="small"
                aria-label="ë‹«ê¸°"
                edge="end"
                tabIndex={0}
                sx={{
                  '&:focus': {
                    outline: '2px solid #3f51b5',
                    outlineOffset: '2px'
                  }
                }}
              >
                <CloseIcon />
              </IconButton>
            )}
          </Box>
        </DialogTitle>

        <DialogContent>
          <Box sx={{ mb: 4 }}>
            <CrawlerStepper />
            <ProgressIndicator />
            <StatusCard />
          </Box>

          <UpdatedCVEList />
        </DialogContent>

        <Box sx={{ display: 'flex', justifyContent: 'flex-end', p: 2 }}>
          <Button
            onClick={handleCloseDialog}
            disabled={isRunning}
            color="primary"
            variant="contained"
            startIcon={<CloseIcon />}
            aria-label="ë‹¤ì´ì–¼ë¡œê·¸ ë‹«ê¸°"
            tabIndex={0}
            sx={{
              '&.Mui-disabled': {
                bgcolor: 'rgba(0, 0, 0, 0.12)',
                color: 'rgba(0, 0, 0, 0.26)'
              },
              '&:focus': {
                outline: '2px solid #3f51b5',
                outlineOffset: '2px'
              }
            }}
          >
            ë‹«ê¸°
          </Button>
        </Box>
      </Dialog>
    </>
  );
};

export default CrawlerUpdateButton;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/ReferencesTab.tsx
------------------------------------------------------------
import React, { memo } from 'react';
import GenericDataTab from './GenericDataTab';
import { referenceTabConfig } from './tabConfigs';
import { CVEDetail, SnortRule, GenericDataTabBaseProps, GenericDataTabProps, SnortRuleTabProps } from '../types/cve';

// SnortRuleTab ì»´í¬ë„ŒíŠ¸ì˜ props ì¸í„°í˜ì´ìŠ¤ - types/cve.tsì— ì •ì˜ëœ GenericDataTabBaseProps ì‚¬ìš©

// ì´ì „ ë²„ì „ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼ ì»´í¬ë„ŒíŠ¸
const referenceTab: React.FC<SnortRuleTabProps> = memo((props) => {
  // GenericDataTabì´ JavaScriptë¡œ ì‘ì„±ë˜ì–´ ìˆì–´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì¸í„°í˜ì´ìŠ¤ì™€ í˜¸í™˜ë˜ì§€ ì•ŠìŒ
  // any íƒ€ì…ìœ¼ë¡œ ë‹¨ì–¸í•˜ì—¬ íƒ€ì… ì˜¤ë¥˜ í•´ê²°
  return React.createElement(GenericDataTab as any, {
    ...props,
    tabConfig: referenceTabConfig
  });
});

// displayName ì„¤ì • (React DevToolsì—ì„œ ë””ë²„ê¹… ì‹œ ìœ ìš©)
referenceTab.displayName = 'SnortRuleTab';

export default referenceTab;


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/CommonStyles.tsx
------------------------------------------------------------
// CommonStyles.tsx
import { styled } from '@mui/material/styles';
import { Paper, Button, IconButton, Box, Theme } from '@mui/material';

export const StyledListItem = styled(Paper)(({ theme }: { theme: Theme }) => ({
  padding: '8px',
  marginBottom: '6px',
  backgroundColor: '#ffffff',
  borderRadius: theme.shape.borderRadius,
  border: `1px solid ${theme.palette.divider}`,
  '& + &': {
    marginTop: '6px'
  },
  '& .MuiTypography-root': {
    fontSize: '0.75rem',
    lineHeight: 1.4
  },
  '& .MuiTypography-caption': {
    fontSize: '0.65rem'
  },
  transition: 'all 0.2s ease-in-out',
  '&:hover': {
    transform: 'translateY(-2px)',
    boxShadow: theme.shadows[2]
  }
}));

export const ActionButton = styled(Button)(({ theme }: { theme: Theme }) => ({
  textTransform: 'none',
  borderRadius: theme.shape.borderRadius,
  padding: '4px 12px',
  fontSize: '0.75rem',
  fontWeight: 500,
  '&.MuiButton-outlined': {
    borderColor: theme.palette.divider,
    '&:hover': {
      backgroundColor: theme.palette.action.hover,
      borderColor: theme.palette.text.primary
    }
  }
}));

export const ActionIconButton = styled(IconButton)(({ theme }: { theme: Theme }) => ({
  color: theme.palette.text.secondary,
  '&:hover': {
    backgroundColor: theme.palette.action.hover,
    color: theme.palette.text.primary
  }
}));

export const ListHeader = styled('div')(({ theme }: { theme: Theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
  alignItems: 'center',
  marginBottom: theme.spacing(2)
}));

export const ChipLabel = styled('span')(({ theme }: { theme: Theme }) => ({
  display: 'flex',
  alignItems: 'center',
  gap: theme.spacing(0.5),
  fontSize: '0.75rem'
}));

export const EmptyState = styled(Paper)(({ theme }: { theme: Theme }) => ({
  padding: theme.spacing(2),
  textAlign: 'center',
  borderRadius: theme.shape.borderRadius * 2,
  backgroundColor: '#ffffff',
  border: `1px dashed ${theme.palette.divider}`,
  color: theme.palette.text.secondary,
  '& .MuiTypography-root': {
    fontSize: '0.75rem'
  },
}));

export const TabContentContainer = styled(Box)(({ theme }: { theme: Theme }) => ({
  display: 'flex',
  flexDirection: 'column',
  height: '100%',
  minHeight: 0,
  overflow: 'hidden'
}));

export const TabContentScroll = styled(Box)(({ theme }: { theme: Theme }) => ({
  flex: 1,
  minHeight: 0,
  overflowY: 'auto',
  padding: theme.spacing(1),
  '&::-webkit-scrollbar': {
    width: '6px',
    backgroundColor: 'transparent'
  },
  '&::-webkit-scrollbar-thumb': {
    backgroundColor: 'rgba(0, 0, 0, 0.1)',
    borderRadius: '3px',
    '&:hover': {
      backgroundColor: 'rgba(0, 0, 0, 0.2)'
    }
  }
}));


============================================================
File: /home/CVEHub/frontend/src/features/cve/components/TabPanel.tsx
------------------------------------------------------------
import React from 'react';
import { Box } from '@mui/material';
import { TabPanelProps } from '../types/cve';

/**
 * íƒ­ íŒ¨ë„ ì»´í¬ë„ŒíŠ¸ - ì„ íƒëœ íƒ­ì˜ ë‚´ìš©ì„ í‘œì‹œí•©ë‹ˆë‹¤.
 *
 * @param children íƒ­ íŒ¨ë„ì— í‘œì‹œí•  ë‚´ìš©
 * @param value í˜„ì¬ ì„ íƒëœ íƒ­ ì¸ë±ìŠ¤
 * @param index ì´ íŒ¨ë„ì˜ ì¸ë±ìŠ¤
 * @param other ê¸°íƒ€ props
 */
const TabPanel: React.FC<TabPanelProps> = ({ children, value, index, ...other }) => {
  if (value !== index) return null;  // ì„ íƒë˜ì§€ ì•Šì€ íƒ­ì€ ë Œë”ë§í•˜ì§€ ì•ŠìŒ

  return (
    <Box
      role="tabpanel"
      id={`tabpanel-${index}`}
      aria-labelledby={`tab-${index}`}
      sx={{
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        overflow: 'auto',
        '&::-webkit-scrollbar': {
          width: '8px',
          backgroundColor: 'transparent'
        },
        '&::-webkit-scrollbar-thumb': {
          backgroundColor: 'rgba(0, 0, 0, 0.1)',
          borderRadius: '4px',
          '&:hover': {
            backgroundColor: 'rgba(0, 0, 0, 0.2)'
          }
        }
      }}
      {...other}
    >
      <Box sx={{ p: 3 }}>
        {children}
      </Box>
    </Box>
  );
};

export default TabPanel;



============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/useCommentMutation.ts
------------------------------------------------------------
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useSnackbar } from 'notistack';
import { AxiosError } from 'axios';
import api from 'shared/api/config/axios';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { SOCKET_EVENTS } from 'core/socket/services/constants';
import logger from 'shared/utils/logging';
import { CommentData } from '../types/CommentTypes';

// íƒ€ì… ì •ì˜
export interface CVEDetailData {
  cveId: string;
  comments?: CommentData[];
  [key: string]: any;
}

// API ì‘ë‹µ íƒ€ì…
export interface CveApiResponse extends CVEDetailData {
  newComment?: CommentData;
  message?: string;
  status?: string;
}

export type MutationError = Error | AxiosError<{ detail?: string }>;

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
export const extractMentions = (content: string): string[] =>
  content.match(/@(\w+)/g)?.map(mention => mention.substring(1)) || [];

/**
 * ëŒ“ê¸€ ê´€ë ¨ mutation hooks
 */
export const useCommentMutations = (
  cveId: string,
  currentUser?: { username: string; displayName?: string } | null,
  onCommentCountChange?: (count: number) => void,
  parentSendMessage?: (type: string, data: Record<string, unknown>) => Promise<boolean | null> | boolean | null
) => {
  const { enqueueSnackbar } = useSnackbar();
  const queryClient = useQueryClient();

  // ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ìœ í‹¸ë¦¬í‹°
  const performOptimisticUpdate = async (
    updateFn: (cachedData: CVEDetailData) => CVEDetailData
  ): Promise<CVEDetailData | null> => {
    const queryKey = QUERY_KEYS.CVE.detail(cveId);
    await queryClient.cancelQueries({ queryKey });
    const previousData = queryClient.getQueryData<CVEDetailData>(queryKey);

    if (previousData) {
      try {
        const optimisticData = updateFn(previousData);
        queryClient.setQueryData<CVEDetailData>(queryKey, optimisticData);
        logger.info('CommentsTab: ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì ìš©', { queryKey });
        const newActiveCount = (optimisticData.comments || []).filter(c => !c.isDeleted).length;
        onCommentCountChange?.(newActiveCount);
        return previousData;
      } catch (error) {
        logger.error('CommentsTab: ë‚™ê´€ì  ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ì˜¤ë¥˜', error);
        return previousData;
      }
    }
    return null;
  };

  // ê³µí†µ ì—ëŸ¬ í•¸ë“¤ëŸ¬
  const handleMutationError = (
    error: MutationError, 
    context: CVEDetailData | null | undefined, 
    defaultMessage: string
  ) => {
    logger.error(`${defaultMessage} ì‹¤íŒ¨:`, error);
    if (context) { // ë¡¤ë°±
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), context);
      const rollbackActiveCount = (context.comments || []).filter(c => !c.isDeleted).length;
      onCommentCountChange?.(rollbackActiveCount);
    }
    // Axios ì—ëŸ¬ ì‘ë‹µì—ì„œ detail ë©”ì‹œì§€ ì¶”ì¶œ ì‹œë„
    const detail = (error as AxiosError<{ detail?: string }>)?.response?.data?.detail;
    enqueueSnackbar(detail || defaultMessage, { variant: 'error' });
  };

  // 1. ëŒ“ê¸€ ìƒì„± mutation
  const createCommentMutation = useMutation<CveApiResponse, MutationError, string, CVEDetailData | null>({
    mutationFn: async (content) => {
      const mentions = extractMentions(content);
      const response = await api.post<CveApiResponse>(`/cves/${cveId}/comments`, { content, mentions });
      return response.data;
    },
    onMutate: async (content) => {
      if (!currentUser) return null;
      return performOptimisticUpdate(cachedData => {
        const tempId = `temp-comment-${Date.now()}`;
        const tempComment: CommentData = { 
          id: tempId, 
          content, 
          author: currentUser.username, 
          authorName: currentUser.displayName || currentUser.username, 
          createdAt: new Date().toISOString(), 
          parentId: undefined, 
          isDeleted: false, 
          isOptimistic: true 
        };
        const comments = cachedData.comments || [];
        return { ...cachedData, comments: [...comments, tempComment] };
      });
    },
    onSuccess: async (responseData, content) => {
      logger.info('ëŒ“ê¸€ ì‘ì„± ì„±ê³µ', { 
        responseAvailable: !!responseData,
        commentsAvailable: !!responseData.comments,
        commentsCount: responseData.comments ? responseData.comments.length : 0,
        cveId
      });
      
      // ì„œë²„ ì‘ë‹µì— comments ë°°ì—´ì´ í¬í•¨ëœ ê²½ìš° ìºì‹œ ì—…ë°ì´íŠ¸
      if (responseData && responseData.comments) {
        logger.info('ëŒ“ê¸€ ì‘ì„± í›„ ì „ì²´ CVE ë°ì´í„° ìˆ˜ì‹ ', { 
          commentsCount: responseData.comments.length 
        });
        
        // ì†Œì¼“ ì´ë²¤íŠ¸ ì „ì†¡
        await parentSendMessage?.(SOCKET_EVENTS.COMMENT_ADDED, { 
          cveId, 
          data: { 
            comments: responseData.comments,
            author: currentUser?.username
          }, 
        });
        
        // ì„±ê³µ ì‹œ ìºì‹œ ì—…ë°ì´íŠ¸
        queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), responseData);
        const newActiveCount = (responseData.comments || []).filter(c => !c.isDeleted).length;
        onCommentCountChange?.(newActiveCount);
        enqueueSnackbar('ëŒ“ê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.', { variant: 'success' });
      } else {
        // ì„œë²„ë¡œë¶€í„° ì™„ì „í•œ ë°ì´í„°ë¥¼ ë°›ì§€ ëª»í•œ ê²½ìš° ì¿¼ë¦¬ ë¬´íš¨í™”
        logger.warn('ëŒ“ê¸€ ì‘ì„± ì„±ê³µí–ˆìœ¼ë‚˜ ì‘ë‹µì— comments ë°ì´í„°ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ', responseData);
        queryClient.invalidateQueries({ 
          queryKey: QUERY_KEYS.CVE.detail(cveId),
          refetchType: 'active'
        });
        enqueueSnackbar('ëŒ“ê¸€ì´ ì‘ì„±ë˜ì—ˆì§€ë§Œ ìµœì‹  ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ì…ë‹ˆë‹¤.', { variant: 'info' });
      }
    },
    onError: (error, variables, context) => 
      handleMutationError(error, context, 'ëŒ“ê¸€ ì‘ì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ'),
  });

  // 2. ëŒ“ê¸€ ìˆ˜ì • mutation
  interface EditCommentVariables { 
    commentId: string; 
    content: string; 
  }

  const editCommentMutation = useMutation<CveApiResponse, MutationError, EditCommentVariables, CVEDetailData | null>({
    mutationFn: async ({ commentId, content }) => {
      const response = await api.patch<CveApiResponse>(`/cves/${cveId}/comments/${commentId}`, { content });
      return response.data;
    },
    onMutate: async ({ commentId, content }) => {
      return performOptimisticUpdate(cachedData => {
        const comments = cachedData.comments || [];
        const updatedComments = comments.map(c => 
          c.id === commentId 
            ? { 
                ...c, 
                content, 
                lastModifiedAt: new Date().toISOString(), 
                isOptimistic: true 
              } 
            : c
        );
        return { ...cachedData, comments: updatedComments };
      });
    },
    onSuccess: async (responseData, { commentId, content }) => {
      logger.info('ëŒ“ê¸€ ìˆ˜ì • ì„±ê³µ', { commentId });
      const mentions = extractMentions(content);
      if (mentions.length > 0 && currentUser) {
        await parentSendMessage?.(SOCKET_EVENTS.MENTION_ADDED, { 
          type: 'mention', 
          recipients: mentions, 
          content: `${currentUser.displayName || currentUser.username}ë‹˜ì´ ëŒ“ê¸€ì—ì„œ íšŒì›ë‹˜ì„ ë©˜ì…˜í–ˆìŠµë‹ˆë‹¤.`, 
          metadata: { cveId, commentId, comment_content: content } 
        });
      }
      await parentSendMessage?.(SOCKET_EVENTS.COMMENT_UPDATED, { 
        cveId, 
        cve: responseData,
        updatedCommentId: commentId 
      });
      // ì„±ê³µ ì‹œ ìºì‹œ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), responseData);
      enqueueSnackbar('ëŒ“ê¸€ì´ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.', { variant: 'success' });
    },
    onError: (error, variables, context) => 
      handleMutationError(error, context, 'ëŒ“ê¸€ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ'),
  });

  // 3. ë‹µê¸€ ì‘ì„± mutation
  interface ReplyCommentVariables { 
    parentId: string; 
    content: string; 
  }

  const replyCommentMutation = useMutation<CveApiResponse, MutationError, ReplyCommentVariables, CVEDetailData | null>({
    mutationFn: async ({ parentId, content }) => {
      const mentions = extractMentions(content);
      const response = await api.post<CveApiResponse>(`/cves/${cveId}/comments`, { 
        content, 
        parent_id: parentId, 
        mentions 
      });
      return response.data;
    },
    onMutate: async ({ parentId, content }) => {
      if (!currentUser) return null;
      return performOptimisticUpdate(cachedData => {
        const tempId = `temp-reply-${Date.now()}`;
        const tempComment: CommentData = { 
          id: tempId, 
          content, 
          author: currentUser.username, 
          authorName: currentUser.displayName || currentUser.username, 
          createdAt: new Date().toISOString(), 
          parentId, 
          isDeleted: false, 
          isOptimistic: true 
        };
        const comments = cachedData.comments || [];
        return { ...cachedData, comments: [...comments, tempComment] };
      });
    },
    onSuccess: async (responseData, { parentId, content }) => {
      const newCommentId = responseData.newComment?.id;
      logger.info('ë‹µê¸€ ì‘ì„± ì„±ê³µ', { parentId, newCommentId });
      const mentions = extractMentions(content);
      if (mentions.length > 0 && currentUser && newCommentId) {
        await parentSendMessage?.(SOCKET_EVENTS.MENTION_ADDED, { 
          type: 'mention', 
          recipients: mentions, 
          content: `${currentUser.displayName || currentUser.username}ë‹˜ì´ ë‹µê¸€ì—ì„œ íšŒì›ë‹˜ì„ ë©˜ì…˜í–ˆìŠµë‹ˆë‹¤.`, 
          metadata: { cveId, commentId: newCommentId, comment_content: content } 
        });
      }
      await parentSendMessage?.(SOCKET_EVENTS.COMMENT_ADDED, { 
        cveId, 
        cve: responseData,
        newComment: responseData.newComment 
      });
      // ì„±ê³µ ì‹œ ìºì‹œ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), responseData);
      const newActiveCount = (responseData.comments || []).filter(c => !c.isDeleted).length;
      onCommentCountChange?.(newActiveCount); // ëŒ“ê¸€ ìˆ˜ ì—…ë°ì´íŠ¸
      enqueueSnackbar('ë‹µê¸€ì´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.', { variant: 'success' });
    },
    onError: (error, variables, context) => 
      handleMutationError(error, context, 'ë‹µê¸€ ì‘ì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ'),
  });

  // 4. ëŒ“ê¸€ ì‚­ì œ mutation
  interface DeleteCommentVariables { 
    commentId: string; 
    permanent: boolean; 
  }

  const deleteCommentMutation = useMutation<CveApiResponse, MutationError, DeleteCommentVariables, CVEDetailData | null>({
    mutationFn: async ({ commentId, permanent }) => {
      const response = await api.delete<CveApiResponse>(`/cves/${cveId}/comments/${commentId}`, { 
        params: { permanent } 
      });
      return response.data;
    },
    onMutate: async ({ commentId, permanent }) => {
      // ë¨¼ì € ì§„í–‰ ì¤‘ì¸ ì¿¼ë¦¬ë¥¼ ì·¨ì†Œí•´ì„œ ë‚™ê´€ì  ì—…ë°ì´íŠ¸ì™€ ì¶©ëŒ ë°©ì§€
      await queryClient.cancelQueries({ queryKey: QUERY_KEYS.CVE.detail(cveId) });
      
      // ì´ì „ ìƒíƒœ ì €ì¥
      const previousData = queryClient.getQueryData<CVEDetailData>(QUERY_KEYS.CVE.detail(cveId));
      
      if (!previousData) return null;
      
      try {
        // ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì ìš©
        const cachedData = { ...previousData };
        const comments = cachedData.comments || [];
        
        // ì˜êµ¬ ì‚­ì œ ì‹œ ëª©ë¡ì—ì„œ ì œê±°, ì†Œí”„íŠ¸ ì‚­ì œ ì‹œ isDeleted í”Œë˜ê·¸ë§Œ ì„¤ì •
        const updatedComments = permanent
          ? comments.filter(c => c.id !== commentId)
          : comments.map(c => c.id === commentId ? { ...c, isDeleted: true, isOptimistic: true } : c);
        
        const optimisticData = { ...cachedData, comments: updatedComments };
        
        // ìºì‹œ ì—…ë°ì´íŠ¸
        queryClient.setQueryData<CVEDetailData>(QUERY_KEYS.CVE.detail(cveId), optimisticData);
        
        // ëŒ“ê¸€ ìˆ˜ ì—…ë°ì´íŠ¸ (ë‚™ê´€ì ìœ¼ë¡œ)
        const newActiveCount = updatedComments.filter(c => !c.isDeleted).length;
        onCommentCountChange?.(newActiveCount);
        
        logger.info('CommentsTab: ëŒ“ê¸€ ì‚­ì œ ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì™„ë£Œ', { commentId, permanent });
        
        return previousData;
      } catch (error) {
        logger.error('CommentsTab: ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì˜¤ë¥˜', error);
        return previousData;
      }
    },
    onSuccess: async (responseData, { commentId, permanent }) => {
      logger.info('ëŒ“ê¸€ ì‚­ì œ ì„±ê³µ', { commentId, permanent });
      
      // ì†Œì¼“ ì´ë²¤íŠ¸ ë°œìƒ
      await parentSendMessage?.(SOCKET_EVENTS.COMMENT_DELETED, { 
        cveId, 
        cve: responseData,
        deletedCommentId: commentId, 
        isPermanent: permanent 
      });
      
      // ì´ë¯¸ ë‚™ê´€ì  ì—…ë°ì´íŠ¸ë¥¼ í†µí•´ UIê°€ ì—…ë°ì´íŠ¸ëìœ¼ë¯€ë¡œ,
      // ì„œë²„ì˜ ì‘ë‹µê³¼ í´ë¼ì´ì–¸íŠ¸ ìƒíƒœê°€ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì¦ í›„ 
      // í•„ìš”í•œ ê²½ìš°ì—ë§Œ ì—…ë°ì´íŠ¸ (ê¹œë¹¡ì„ ë°©ì§€)
      const currentData = queryClient.getQueryData<CVEDetailData>(QUERY_KEYS.CVE.detail(cveId));
      
      if (currentData) {
        // ì„œë²„ ì‘ë‹µì— ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ë§ˆì»¤ ì œê±° (ì°¸ì¡° ë¹„êµë¥¼ ìœ„í•´)
        const sanitizedComments = responseData.comments?.map(comment => {
          const { isOptimistic, ...rest } = comment as any;
          return rest;
        });
        
        const updatedResponseData = {
          ...responseData,
          comments: sanitizedComments
        };
        
        // refetchActive: true ì˜µì…˜ì€ ì‚¬ìš©í•˜ì§€ ì•Šê³  ìˆ˜ë™ìœ¼ë¡œ ìƒíƒœ ê´€ë¦¬
        // setQueryDataë¡œ ìƒíƒœ ì—…ë°ì´íŠ¸ (refetch ì—†ì´ ìƒíƒœ ì—…ë°ì´íŠ¸)
        queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), updatedResponseData);
      }
      
      // ëŒ“ê¸€ ìˆ˜ ì—…ë°ì´íŠ¸
      const newActiveCount = (responseData.comments || []).filter(c => !c.isDeleted).length;
      onCommentCountChange?.(newActiveCount);
      
      enqueueSnackbar(permanent ? 'ëŒ“ê¸€ì´ ì˜êµ¬ì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.' : 'ëŒ“ê¸€ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', { 
        variant: 'success' 
      });
    },
    onError: (error, variables, context) => {
      // ë¡¤ë°± ì²˜ë¦¬ ê°œì„ 
      if (context) {
        const previousData = context as CVEDetailData;
        // ì›ë˜ ìƒíƒœë¡œ ë³µì›
        queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), previousData);
        
        // ëŒ“ê¸€ ìˆ˜ë„ ë³µì›
        const rollbackActiveCount = (previousData.comments || []).filter(c => !c.isDeleted).length;
        onCommentCountChange?.(rollbackActiveCount);
      }
      
      // ì‚¬ìš©ìì—ê²Œ ì˜¤ë¥˜ ì•Œë¦¼
      const detail = (error as AxiosError<{ detail?: string }>)?.response?.data?.detail;
      enqueueSnackbar(detail || 'ëŒ“ê¸€ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', { variant: 'error' });
      
      logger.error('ëŒ“ê¸€ ì‚­ì œ ì‹¤íŒ¨:', error);
    }
  });

  return {
    createCommentMutation,
    editCommentMutation,
    replyCommentMutation,
    deleteCommentMutation,
    // í¸ì˜ë¥¼ ìœ„í•œ í•¸ë“¤ëŸ¬ í•¨ìˆ˜ë“¤
    createComment: (content: string) => {
      if (!content.trim()) {
        enqueueSnackbar('ëŒ“ê¸€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', { variant: 'warning' });
        return;
      }
      createCommentMutation.mutate(content);
    },
    editComment: (commentId: string, content: string) => {
      if (!content.trim()) {
        enqueueSnackbar('ëŒ“ê¸€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', { variant: 'warning' });
        return;
      }
      editCommentMutation.mutate({ commentId, content });
    },
    replyComment: (parentId: string, content: string) => {
      if (!content.trim()) {
        enqueueSnackbar('ë‹µê¸€ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.', { variant: 'warning' });
        return;
      }
      replyCommentMutation.mutate({ parentId, content });
    },
    deleteComment: (commentId: string, permanent: boolean = false) => {
      deleteCommentMutation.mutate({ commentId, permanent });
    },
    // ë¡œë”© ìƒíƒœ í†µí•©
    isLoading: 
      createCommentMutation.isPending || 
      editCommentMutation.isPending || 
      replyCommentMutation.isPending || 
      deleteCommentMutation.isPending
  };
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/socket/useCVESubscription.ts
------------------------------------------------------------
// socket/useCVESubscription.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { useSocket } from 'core/socket/hooks/useSocket';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { useQueryClient } from '@tanstack/react-query';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import logger from 'shared/utils/logging';
import socketService from 'core/socket/services/socketService';
import socketEventBus from 'core/socket/services/socketEventBus';
import { SUBSCRIPTION_EVENTS } from 'core/socket/services/constants';
import { Subscription } from 'rxjs';

// êµ¬ë…ì íƒ€ì… ì •ì˜
export interface Subscriber {
  id: string;
  userId: string;
  username: string;
  displayName: string;
  profileImage?: string;
}

// êµ¬ë… ìƒíƒœ íƒ€ì…
interface SubscriptionState {
  isSubscribed: boolean;
  isLoading: boolean;
  error: string | null;
}

// êµ¬ë… ìƒíƒœ ì´ë²¤íŠ¸ íƒ€ì…
interface SubscriptionStatusEvent {
  cveId: string;
  subscribed: boolean;
}

/**
 * CVE êµ¬ë… ê´€ë ¨ í›…
 * - êµ¬ë…/êµ¬ë…ì·¨ì†Œ ì•¡ì…˜ ì œê³µ
 * - êµ¬ë…ì ì •ë³´ ì¡°íšŒ (ì¤‘ì•™ ê´€ë¦¬ ì‹œìŠ¤í…œ í™œìš©)
 */
export function useCVESubscription(cveId: string) {
  const { connected } = useSocket();
  const { user } = useAuth();
  const queryClient = useQueryClient();
  
  // êµ¬ë… ìƒíƒœ (ë¡œì»¬ ìƒíƒœë¡œ ê´€ë¦¬)
  const [state, setState] = useState<SubscriptionState>({
    isSubscribed: false, // ì´ˆê¸°ê°’ì€ false, ì´í›„ useEffectì—ì„œ ì—…ë°ì´íŠ¸ë¨
    isLoading: false,
    error: null
  });
  
  // ê¸°ë³¸ì ì¸ refs
  const componentIdRef = useRef(`cve-subscription-${cveId}`);
  const attemptedInitialSubscriptionRef = useRef(false);
  const subscriptionsRef = useRef<Subscription[]>([]);
  
  // êµ¬ë…ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (ì¤‘ì•™ ê´€ë¦¬ ì‹œìŠ¤í…œì—ì„œ)
  const getSubscribers = useCallback(() => {
    // ì¿¼ë¦¬ í´ë¼ì´ì–¸íŠ¸ì—ì„œ êµ¬ë…ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    const subscribersKey = [QUERY_KEYS.CVE_SUBSCRIBERS, cveId];
    let subscribers: Subscriber[] = queryClient.getQueryData(subscribersKey) || [];
    
    return subscribers;
  }, [cveId, queryClient]);
  
  // êµ¬ë…í•˜ê¸°
  const subscribe = useCallback((silent: boolean = false) => {
    if (!connected || !user) {
      if (!silent) {
        setState(prev => ({
          ...prev,
          error: 'ì†Œì¼“ ì—°ê²°ì´ ì—†ê±°ë‚˜ ë¡œê·¸ì¸ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.'
        }));
      }
      return;
    }
    
    setState(prev => ({
      ...prev,
      isLoading: true,
      error: null
    }));
    
    logger.debug('useCVESubscription', `CVE êµ¬ë… ì‹œë„: ${cveId}`, { cveId });
    
    try {
      // ì´ë²¤íŠ¸ ë²„ìŠ¤ë¥¼ í†µí•´ êµ¬ë… ìš”ì²­ ì´ë²¤íŠ¸ ë°œí–‰ ëŒ€ì‹ 
      // socketServiceì˜ updateSubscription ë©”ì„œë“œ ì‚¬ìš©
      socketService.updateSubscription(cveId, true);
      
      // ì„±ê³µ ì‹œ UI ìƒíƒœ ì—…ë°ì´íŠ¸ - ì‹¤ì œ ìƒíƒœëŠ” ì´ë²¤íŠ¸ ì‘ë‹µìœ¼ë¡œ ì—…ë°ì´íŠ¸ë¨
      setState(prev => ({
        ...prev,
        isLoading: false
      }));
      
      logger.info('useCVESubscription', `CVE êµ¬ë… ìš”ì²­ ì„±ê³µ: ${cveId}`, { cveId });
    } catch (error: any) {
      // ì‹¤íŒ¨ ì‹œ ì˜¤ë¥˜ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error?.message || 'êµ¬ë… ìš”ì²­ ì‹¤íŒ¨'
      }));
      
      logger.error('useCVESubscription', `CVE êµ¬ë… ì‹¤íŒ¨: ${cveId}`, { 
        cveId, 
        error 
      });
    }
  }, [cveId, connected, user]);
  
  // êµ¬ë… ì·¨ì†Œí•˜ê¸°
  const unsubscribe = useCallback((silent: boolean = false) => {
    if (!connected) {
      if (!silent) {
        setState(prev => ({
          ...prev,
          error: 'ì†Œì¼“ ì—°ê²°ì´ ì—†ìŠµë‹ˆë‹¤.'
        }));
      }
      return;
    }
    
    setState(prev => ({
      ...prev,
      isLoading: true,
      error: null
    }));
    
    logger.debug('useCVESubscription', `CVE êµ¬ë… ì·¨ì†Œ ì‹œë„: ${cveId}`, { cveId });
    
    try {
      // ì´ë²¤íŠ¸ ë²„ìŠ¤ë¥¼ í†µí•´ êµ¬ë… ì·¨ì†Œ ìš”ì²­ ì´ë²¤íŠ¸ ë°œí–‰ ëŒ€ì‹ 
      // socketServiceì˜ updateSubscription ë©”ì„œë“œ ì‚¬ìš©
      socketService.updateSubscription(cveId, false);
      
      // ì„±ê³µ ì‹œ UI ìƒíƒœ ì—…ë°ì´íŠ¸ - ì‹¤ì œ ìƒíƒœëŠ” ì´ë²¤íŠ¸ ì‘ë‹µìœ¼ë¡œ ì—…ë°ì´íŠ¸ë¨
      setState(prev => ({
        ...prev,
        isLoading: false
      }));
      
      logger.info('useCVESubscription', `CVE êµ¬ë… ì·¨ì†Œ ìš”ì²­ ì„±ê³µ: ${cveId}`, { cveId });
    } catch (error: any) {
      // ì‹¤íŒ¨ ì‹œ ì˜¤ë¥˜ ìƒíƒœë¡œ ì—…ë°ì´íŠ¸
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error?.message || 'êµ¬ë… ì·¨ì†Œ ìš”ì²­ ì‹¤íŒ¨'
      }));
      
      logger.error('useCVESubscription', `CVE êµ¬ë… ì·¨ì†Œ ì‹¤íŒ¨: ${cveId}`, {
        cveId,
        error
      });
    }
  }, [cveId, connected]);
  
  // êµ¬ë… ìƒíƒœ ë³€ê²½ ê°ì‹œ (ì´ë²¤íŠ¸ ë²„ìŠ¤ ì‚¬ìš©)
  useEffect(() => {
    // ì´ë²¤íŠ¸ ë²„ìŠ¤ë¥¼ í†µí•œ êµ¬ë… ìƒíƒœ ì—…ë°ì´íŠ¸ êµ¬ë…
    const subscription = socketEventBus.on<SubscriptionStatusEvent>(SUBSCRIPTION_EVENTS.SUBSCRIPTION_STATUS)
      .subscribe(data => {
        if (data && data.cveId === cveId) {
          const isSubscribed = !!data.subscribed;
          
          // ë¡œì»¬ ìƒíƒœì™€ ë‹¤ë¥¼ ê²½ìš°ì—ë§Œ ì—…ë°ì´íŠ¸
          if (state.isSubscribed !== isSubscribed) {
            setState(prev => ({
              ...prev,
              isSubscribed,
              isLoading: false,
              error: null
            }));
            
            logger.debug('useCVESubscription', `êµ¬ë… ìƒíƒœ ì—…ë°ì´íŠ¸: ${isSubscribed ? 'êµ¬ë…ì¤‘' : 'ë¯¸êµ¬ë…'}`, {
              cveId,
              isSubscribed
            });
          }
        }
      });
    
    // êµ¬ë… ì¶”ì ì„ ìœ„í•´ refì— ì €ì¥
    subscriptionsRef.current.push(subscription);
    
    return () => {
      // êµ¬ë… ì •ë¦¬
      subscription.unsubscribe();
    };
  }, [cveId, state.isSubscribed]);
  
  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ëª¨ë“  êµ¬ë… ì •ë¦¬
  useEffect(() => {
    return () => {
      // ëª¨ë“  RxJS êµ¬ë… ì •ë¦¬
      subscriptionsRef.current.forEach(subscription => {
        if (subscription && !subscription.closed) {
          subscription.unsubscribe();
        }
      });
      subscriptionsRef.current = [];
      
      logger.debug('useCVESubscription', `êµ¬ë… í›… ì •ë¦¬: ${cveId}`, { cveId });
    };
  }, [cveId]);
  
  return {
    // êµ¬ë… ê´€ë ¨ ìƒíƒœ ë° ì•¡ì…˜
    isSubscribed: state.isSubscribed,
    isLoading: state.isLoading,
    error: state.error,
    subscribe,
    unsubscribe,
    
    // êµ¬ë…ì ëª©ë¡ ì ‘ê·¼ì
    getSubscribers,
  };
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/socket/cveHandlers.ts
------------------------------------------------------------
// frontend/src/features/cve/hooks/socket/cveHandlers.ts
import { QueryClient } from '@tanstack/react-query';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import logger from 'shared/utils/logging';
import socketService from 'core/socket/services/socketService';
import { 
  SOCKET_EVENTS, 
  CVE_EVENTS, 
  SUBSCRIPTION_EVENTS 
} from 'core/socket/services/constants';

/**
 * CVE ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ëª¨ìŒ
 */

/**
 * CVE ì›¹ì†Œì¼“ ì—…ë°ì´íŠ¸ ì²˜ë¦¬ í•¨ìˆ˜
 * ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ë¡œ ìˆ˜ì‹ ëœ CVE ë³€ê²½ì‚¬í•­ì„ React Query ìºì‹œì— ë°˜ì˜
 */
export const handleCVESubscriptionUpdate = (
  queryClient: QueryClient,
  data: { type?: string; payload?: any; }
) => {
  if (!data || !data.type) {
    logger.warn('handleCVESubscriptionUpdate', 'ìœ íš¨í•˜ì§€ ì•Šì€ ì´ë²¤íŠ¸ ë°ì´í„°', { data });
    return;
  }

  const { type, payload } = data;
  const logData = { type, payloadId: payload?.id };
  const eventId = Date.now().toString(36) + Math.random().toString(36).substr(2);

  // ì„œë²„ê°€ ë³´ë‚´ëŠ” ë°ì´í„° í˜•ì‹ ë¡œê¹… (í–¥ìƒëœ ë””ë²„ê¹…)
  logger.info('handleCVESubscriptionUpdate', `ìƒì„¸ ì´ë²¤íŠ¸ ë°ì´í„° ë¡œê¹…(${eventId})`, {
    type,
    payload: payload ? {
      id: payload.id,
      cveId: payload.cveId,
      cve_id: payload.cve_id,
      keys: payload ? Object.keys(payload) : [],
      hasSubscribers: payload?.subscribers !== undefined,
      subscribersCount: Array.isArray(payload?.subscribers) ? payload.subscribers.length : 'ì—†ìŒ',
      isSubscribed: payload?.subscribed
    } : 'í˜ì´ë¡œë“œ ì—†ìŒ',
    rawData: {
      type,
      keys: Object.keys(data),
      payloadType: payload ? typeof payload : 'ì—†ìŒ',
    },
    timestamp: new Date().toISOString()
  });

  switch (type) {
    case CVE_EVENTS.CVE_CREATED:
      logger.info('handleCVESubscriptionUpdate', `CVE ìƒì„± ì´ë²¤íŠ¸(${eventId}) ìˆ˜ì‹ `, logData);
      queryClient.invalidateQueries({ 
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
      logger.debug('handleCVESubscriptionUpdate', `CVE ìƒì„± ì´ë²¤íŠ¸(${eventId}) ì²˜ë¦¬ ì™„ë£Œ`);
      break;

    case CVE_EVENTS.CVE_UPDATED:
      logger.info('handleCVESubscriptionUpdate', `CVE ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸(${eventId}) ìˆ˜ì‹ `, logData);
      
      // êµ¬ë… ìƒíƒœ ê´€ë ¨ ì •ë³´ê°€ ìˆìœ¼ë©´ ì¶”ê°€ ë¡œê¹…
      if (payload?.subscribed !== undefined || payload?.subscribers !== undefined) {
        logger.info('handleCVESubscriptionUpdate', `êµ¬ë… ê´€ë ¨ ì •ë³´ í¬í•¨ë¨(${eventId})`, {
          cveId: payload.id,
          isSubscribed: payload.subscribed,
          subscribersCount: Array.isArray(payload.subscribers) ? payload.subscribers.length : 'ì•Œ ìˆ˜ ì—†ìŒ',
          subscribersFormat: Array.isArray(payload.subscribers) 
            ? `ë°°ì—´: [${payload.subscribers.slice(0, 2).map(s => JSON.stringify({id: s.id, username: s.username})).join(', ')}${payload.subscribers.length > 2 ? '...' : ''}]`
            : typeof payload.subscribers
        });
        
        // socketService ìƒíƒœ ì—…ë°ì´íŠ¸ (CveIdê°€ ìˆê³  êµ¬ë… ì •ë³´ê°€ ìˆëŠ” ê²½ìš°)
        if (payload.id && typeof payload.subscribed === 'boolean') {
          socketService.updateSubscription(payload.id, payload.subscribed);
          logger.debug('handleCVESubscriptionUpdate', `êµ¬ë… ìƒíƒœ ìë™ ì—…ë°ì´íŠ¸: ${payload.id}`, {
            isSubscribed: payload.subscribed
          });
        }
      }
      
      // ìƒì„¸ ì •ë³´ ìºì‹œ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(
        QUERY_KEYS.CVE.detail(payload.id), 
        (oldData: any) => oldData ? { ...oldData, ...payload } : payload
      );
      // ëª©ë¡ ê°±ì‹ 
      queryClient.invalidateQueries({ 
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
      logger.debug('handleCVESubscriptionUpdate', `CVE ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸(${eventId}) ì²˜ë¦¬ ì™„ë£Œ`);
      break;

    case CVE_EVENTS.CVE_DELETED:
      logger.info('handleCVESubscriptionUpdate', `CVE ì‚­ì œ ì´ë²¤íŠ¸(${eventId}) ìˆ˜ì‹ `, logData);
      
      // ìƒì„¸ ì •ë³´ ìºì‹œ ì œê±°
      queryClient.removeQueries({ 
        queryKey: QUERY_KEYS.CVE.detail(payload.id) 
      });
      // ëª©ë¡ ê°±ì‹ 
      queryClient.invalidateQueries({ 
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
      logger.debug('handleCVESubscriptionUpdate', `CVE ì‚­ì œ ì´ë²¤íŠ¸(${eventId}) ì²˜ë¦¬ ì™„ë£Œ`);
      break;

    default:
      logger.warn('handleCVESubscriptionUpdate', `ì•Œ ìˆ˜ ì—†ëŠ” ì´ë²¤íŠ¸ íƒ€ì…(${eventId})`, { type, payload });
  }
};

/**
 * CVE ìƒì„± ì´ë²¤íŠ¸ ì²˜ë¦¬ í•¨ìˆ˜
 */
export const handleCVECreated = (queryClient: QueryClient, newCve: any) => {
  const eventId = Date.now().toString(36) + Math.random().toString(36).substr(2);
  
  // í–¥ìƒëœ ë¡œê¹… - ì‹¤ì œ ë°ì´í„° í˜•ì‹ ê¸°ë¡
  logger.info('handleCVECreated', `CVE ìƒì„± ë°ì´í„° í˜•ì‹(${eventId})`, {
    // ì›ë³¸ í•„ë“œì™€ ë³€í™˜ëœ í•„ë“œ í•¨ê»˜ ë¡œê¹… (ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ í˜•ì‹ ë¹„êµ)
    id: newCve?.id,
    cveId: newCve?.cveId, 
    cve_id: newCve?.cve_id,
    
    // ë°ì´í„° êµ¬ì¡° ì •ë³´
    dataStructure: {
      keys: Object.keys(newCve || {}),
      types: Object.entries(newCve || {}).reduce((acc, [key, val]) => {
        acc[key] = typeof val;
        return acc;
      }, {} as Record<string, string>)
    },
    
    // ì¤‘ìš” í•„ë“œ ìƒ˜í”Œ (êµ¬ë… ê´€ë ¨)
    subscribed: newCve?.subscribed,
    hasSubscribers: newCve?.subscribers !== undefined,
    subscribersType: newCve?.subscribers ? (Array.isArray(newCve.subscribers) ? 'array' : typeof newCve.subscribers) : 'undefined',
    subscribersCount: Array.isArray(newCve?.subscribers) ? newCve.subscribers.length : 0,
    
    timestamp: new Date().toISOString()
  });
  
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.lists(),
    refetchType: 'active'
  });
  
  // í†µê³„ ë°ì´í„° ì¿¼ë¦¬ë„ í•¨ê»˜ ë¬´íš¨í™”
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.stats(),
    refetchType: 'active'
  });
  
  // í†µê³„ ë°ì´í„° ê°•ì œ ë¦¬íŒ¨ì¹˜ (staleTime ë¬´ì‹œ)
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.stats(),
    type: 'active',
    exact: true
  });
  
  // ì „ì²´ CVE ê°œìˆ˜ ì¿¼ë¦¬ë„ í•¨ê»˜ ë¬´íš¨í™” ë° ë¦¬íŒ¨ì¹˜
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.totalCount(),
    refetchType: 'active'
  });
  
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.totalCount(),
    type: 'active',
    exact: true
  });
  
  logger.debug('handleCVECreated', `CVE ìƒì„± ì´ë²¤íŠ¸(${eventId}) ì²˜ë¦¬ ì™„ë£Œ`, {
    cveId: newCve?.id || newCve?.cveId || newCve?.cve_id
  });
};

/**
 * CVE ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ ì²˜ë¦¬ í•¨ìˆ˜
 */
export const handleCVEUpdated = (queryClient: QueryClient, updatedCve: any) => {
  const eventId = Date.now().toString(36) + Math.random().toString(36).substr(2);
  const updatedCveId = updatedCve?.id || updatedCve?.cveId;
  
  // í–¥ìƒëœ ë¡œê¹… - ë°ì´í„° í˜•ì‹ ë° êµ¬ë… ì •ë³´ ê¸°ë¡
  logger.info('handleCVEUpdated', `CVE ì—…ë°ì´íŠ¸ ë°ì´í„° í˜•ì‹(${eventId})`, {
    // ID ì •ë³´ (ë‹¤ì–‘í•œ í˜•ì‹ ëª¨ë‘ ë¡œê¹…)
    id: updatedCve?.id,
    cveId: updatedCve?.cveId,
    cve_id: updatedCve?.cve_id,
    
    // êµ¬ë… ê´€ë ¨ ì •ë³´
    subscription: {
      isSubscribed: updatedCve?.subscribed,
      subscribersCount: Array.isArray(updatedCve?.subscribers) ? updatedCve.subscribers.length : 0,
      subscribersFormat: updatedCve?.subscribers 
        ? (Array.isArray(updatedCve.subscribers) 
          ? `ë°°ì—´[${updatedCve.subscribers.length}]: ${JSON.stringify(updatedCve.subscribers.slice(0, 1))}`
          : typeof updatedCve.subscribers)
        : 'ì—†ìŒ',
    },
    
    // ì „ì²´ ë°ì´í„° í‚¤ì™€ íƒ€ì…
    dataKeys: Object.keys(updatedCve || {}),
    topLevelTypes: Object.entries(updatedCve || {})
      .filter(([key]) => ['id', 'cveId', 'cve_id', 'subscribed', 'subscribers'].includes(key))
      .reduce((acc, [key, val]) => {
        acc[key] = `${typeof val}${Array.isArray(val) ? `[${(val as any[]).length}]` : ''}`;
        return acc;
      }, {} as Record<string, string>),
      
    timestamp: new Date().toISOString()
  });
  
  // êµ¬ë… ìƒíƒœ ìë™ ì—…ë°ì´íŠ¸ (í•„ìš”í•œ ê²½ìš°)
  if (updatedCveId && typeof updatedCve.subscribed === 'boolean') {
    socketService.updateSubscription(updatedCveId, updatedCve.subscribed);
    logger.debug('handleCVEUpdated', `êµ¬ë… ìƒíƒœ ìë™ ì—…ë°ì´íŠ¸: ${updatedCveId}`, {
      isSubscribed: updatedCve.subscribed
    });
  }
  
  // í†µê³„ ë°ì´í„° ê°•ì œ ë¦¬íŒ¨ì¹˜ (staleTime ë¬´ì‹œ)
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.stats(),
    type: 'active',
    exact: true
  });
  
  // ì „ì²´ CVE ê°œìˆ˜ ì¿¼ë¦¬ë„ í•¨ê»˜ ë¬´íš¨í™” ë° ë¦¬íŒ¨ì¹˜
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.totalCount(),
    refetchType: 'active'
  });
  
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.totalCount(),
    type: 'active',
    exact: true
  });

  // ìƒì„¸ ì •ë³´ ìºì‹œ ì—…ë°ì´íŠ¸
  if (updatedCveId) {
    queryClient.setQueryData(
      QUERY_KEYS.CVE.detail(updatedCveId), 
      (oldData: any) => oldData ? { ...oldData, ...updatedCve } : updatedCve
    );
  }
  
  // ëª©ë¡ ê°±ì‹ 
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.lists(),
    refetchType: 'active'
  });
  
  logger.debug('handleCVEUpdated', `CVE ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸(${eventId}) ì²˜ë¦¬ ì™„ë£Œ`, {
    cveId: updatedCveId
  });
};

/**
 * CVE ì‚­ì œ ì´ë²¤íŠ¸ ì²˜ë¦¬ í•¨ìˆ˜
 */
export const handleCVEDeleted = (queryClient: QueryClient, deletedCve: any) => {
  const eventId = Date.now().toString(36) + Math.random().toString(36).substr(2);
  const deletedCveId = deletedCve?.id || deletedCve?.cveId;
  
  // í–¥ìƒëœ ë¡œê¹… - ë°ì´í„° í˜•ì‹ ì •ë³´ í¬í•¨
  logger.info('handleCVEDeleted', `CVE ì‚­ì œ ë°ì´í„° í˜•ì‹(${eventId})`, {
    // ID ì •ë³´ (ë‹¤ì–‘í•œ í˜•ì‹)
    id: deletedCve?.id,
    cveId: deletedCve?.cveId,
    cve_id: deletedCve?.cve_id,
    
    // ê°ì²´ êµ¬ì¡° ì •ë³´
    dataFormat: {
      keys: Object.keys(deletedCve || {}),
      objectType: typeof deletedCve,
      hasSubscriptionInfo: deletedCve?.subscribed !== undefined || deletedCve?.subscribers !== undefined
    },
    
    timestamp: new Date().toISOString()
  });
  
  // í•´ë‹¹ CVEì˜ ìƒì„¸ ì •ë³´ ìºì‹œ ë¬´íš¨í™”
  if (deletedCveId) {
    queryClient.removeQueries({
      queryKey: QUERY_KEYS.CVE.detail(deletedCveId)
    });
  }
  
  // ëª©ë¡ ê°±ì‹ 
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.lists(),
    refetchType: 'active'
  });
  
  // í†µê³„ ë°ì´í„° ì¿¼ë¦¬ë„ í•¨ê»˜ ë¬´íš¨í™”
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.stats(),
    refetchType: 'active'
  });
  
  // í†µê³„ ë°ì´í„° ê°•ì œ ë¦¬íŒ¨ì¹˜ (staleTime ë¬´ì‹œ)
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.stats(),
    type: 'active',
    exact: true
  });
  
  // ì „ì²´ CVE ê°œìˆ˜ ì¿¼ë¦¬ë„ í•¨ê»˜ ë¬´íš¨í™” ë° ë¦¬íŒ¨ì¹˜
  queryClient.invalidateQueries({ 
    queryKey: QUERY_KEYS.CVE.totalCount(),
    refetchType: 'active'
  });
  
  queryClient.refetchQueries({
    queryKey: QUERY_KEYS.CVE.totalCount(),
    type: 'active',
    exact: true
  });
  
  logger.debug('handleCVEDeleted', `CVE ì‚­ì œ ì´ë²¤íŠ¸(${eventId}) ì²˜ë¦¬ ì™„ë£Œ`, {
    cveId: deletedCveId
  });
};



============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/socket/useCVESocket.ts
------------------------------------------------------------
// core/socket/hooks/useCVESocket.ts
import { useCallback, useRef } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import _ from 'lodash';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { SOCKET_EVENTS } from 'core/socket/services/constants';
import useSocket from 'core/socket/hooks/useSocket';
import { 
  handleCVECreated, 
  handleCVEUpdated, 
  handleCVEDeleted 
} from './cveHandlers';
import logger from 'shared/utils/logging';

/**
 * CVE ê´€ë ¨ ì†Œì¼“ ì´ë²¤íŠ¸ ì²˜ë¦¬ë¥¼ ìœ„í•œ í›…
 * ê¸°ë³¸ ì†Œì¼“ ê¸°ëŠ¥ì— CVE ì´ë²¤íŠ¸ ì²˜ë¦¬ ê¸°ëŠ¥ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
 */
export function useCVESocket(cveId?: string) {
  const queryClient = useQueryClient();
  const reconnectAttemptsRef = useRef(0);
  const isSubscribedRef = useRef(false);
  
  // ì»´í¬ë„ŒíŠ¸ ID - ì‹ë³„ì„ ìœ„í•´ cveId í™œìš©
  const componentId = cveId 
    ? `cve-socket-${cveId}` 
    : 'cve-socket-list';
  
  // ê¸°ë³¸ ì†Œì¼“ í›… ì‚¬ìš©
  const { 
    connected, 
    emit, 
    on, 
    cleanup,
    socket
  } = useSocket(undefined, undefined, [], {
    componentId,
    useRxJS: true
  });
  
  // ë””ë°”ìš´ìŠ¤ëœ ì¿¼ë¦¬ ë¬´íš¨í™” í•¨ìˆ˜
  const invalidateCVEQueries = useCallback(
    _.debounce(() => {
      logger.debug('useCVESocket', 'ë””ë°”ìš´ìŠ¤ëœ ì¿¼ë¦¬ ë¬´íš¨í™” ì‹¤í–‰');
      queryClient.invalidateQueries({
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
    }, 300),
    [queryClient]
  );
  
  // CVE ìƒì„± ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  const onCVECreated = useCallback((data: any) => {
    handleCVECreated(queryClient, data);
  }, [queryClient]);
  
  // CVE ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  const onCVEUpdated = useCallback((data: any) => {
    handleCVEUpdated(queryClient, data);
  }, [queryClient]);
  
  // CVE ì‚­ì œ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  const onCVEDeleted = useCallback((data: any) => {
    handleCVEDeleted(queryClient, data);
  }, [queryClient]);
  
  // CVE ëª©ë¡ êµ¬ë… ê¸°ëŠ¥
  const subscribeCVEList = useCallback(() => {
    if (connected && !isSubscribedRef.current) {
      logger.info('useCVESocket', 'CVE ëª©ë¡ ì—…ë°ì´íŠ¸ êµ¬ë… ìš”ì²­');
      
      // ì„œë²„ì— êµ¬ë… ìš”ì²­ ì „ì†¡
      emit(SOCKET_EVENTS.SUBSCRIBE_CVES, {});
      isSubscribedRef.current = true;
      
      return true;
    }
    return false;
  }, [connected, emit]);
  
  // CVE ëª©ë¡ êµ¬ë… í•´ì œ ê¸°ëŠ¥
  const unsubscribeCVEList = useCallback(() => {
    if (connected && isSubscribedRef.current) {
      logger.info('useCVESocket', 'CVE ëª©ë¡ ì—…ë°ì´íŠ¸ êµ¬ë… í•´ì œ');
      
      // ì„œë²„ì— êµ¬ë… í•´ì œ ìš”ì²­ ì „ì†¡
      emit(SOCKET_EVENTS.UNSUBSCRIBE_CVES, {});
      isSubscribedRef.current = false;
      
      return true;
    }
    return false;
  }, [connected, emit]);
  
  // ë‹¨ì¼ CVE êµ¬ë… ê¸°ëŠ¥
  const subscribeCVE = useCallback((id: string) => {
    if (connected && id) {
      logger.info('useCVESocket', `ë‹¨ì¼ CVE êµ¬ë…: ${id}`);
      emit(SOCKET_EVENTS.SUBSCRIBE_CVE, { cve_id: id });
      return true;
    }
    return false;
  }, [connected, emit]);
  
  // ë‹¨ì¼ CVE êµ¬ë… í•´ì œ ê¸°ëŠ¥
  const unsubscribeCVE = useCallback((id: string) => {
    if (connected && id) {
      logger.info('useCVESocket', `ë‹¨ì¼ CVE êµ¬ë… í•´ì œ: ${id}`);
      emit(SOCKET_EVENTS.UNSUBSCRIBE_CVE, { cve_id: id });
      return true;
    }
    return false;
  }, [connected, emit]);
  
  return {
    // ê¸°ë³¸ ì†Œì¼“ ì†ì„± ë° ë©”ì„œë“œ
    connected,
    socket,
    on,
    emit,
    cleanup,
    
    // CVE íŠ¹í™” ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
    onCVECreated,
    onCVEUpdated,
    onCVEDeleted,
    
    // CVE íŠ¹í™” ê¸°ëŠ¥
    invalidateCVEQueries,
    subscribeCVEList,
    unsubscribeCVEList,
    subscribeCVE,
    unsubscribeCVE,
    
    // ìƒíƒœ ê´€ë¦¬
    isSubscribed: isSubscribedRef.current,
    reconnectAttempts: reconnectAttemptsRef.current
  };
}

export default useCVESocket;



============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/socket/useCVEListSocketUpdates.ts
------------------------------------------------------------
// socket/useCVEListSocketUpdates.ts
import { useRef, useEffect } from 'react';
import { useTimers } from '../utils/cveQueryUtils';
import useCVESocket from './useCVESocket';
import logger from 'shared/utils/logging';
import { CVE_EVENTS } from 'core/socket/services/constants';

/**
 * CVE ëª©ë¡ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í›…
 * ì›¹ì†Œì¼“ì„ í†µí•´ CVE ëª©ë¡ ë³€ê²½ì‚¬í•­ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ìˆ˜ì‹ í•˜ê³  ì¿¼ë¦¬ ìºì‹œë¥¼ ì—…ë°ì´íŠ¸
 * 
 * @returns ì—°ê²° ìƒíƒœ ê°ì²´
 */
export function useCVEListUpdates() {
  // ì½”ì–´ ì†Œì¼“ í›… ì‚¬ìš©
  const { 
    connected, 
    on, 
    cleanup,
    invalidateCVEQueries,
    onCVECreated,
    onCVEUpdated,
    onCVEDeleted,
    subscribeCVEList,
    unsubscribeCVEList
  } = useCVESocket();
  
  const { startTimer, clearTimer, clearAllTimers } = useTimers();
  
  // ì¬ì—°ê²° ìƒíƒœ ì¶”ì 
  const reconnectAttemptsRef = useRef(0);
  
  // êµ¬ë… ìƒíƒœ ê´€ë¦¬ìš© ref
  const isSubscribedRef = useRef(false);
  
  // ì—°ê²° ì†ì‹¤ ë° ë³µêµ¬ ì²˜ë¦¬ ê¸°ëŠ¥ (ê°„ì†Œí™”ë¨)
  const handleConnectionChange = (isConnected: boolean) => {
    if (!isConnected) {
      logger.warn('useCVEListUpdates', 'ì›¹ì†Œì¼“ ì—°ê²° ëŠê¹€ ê°ì§€');
      reconnectAttemptsRef.current = 0;
    } else if (reconnectAttemptsRef.current > 0) {
      logger.info('useCVEListUpdates', 'ì›¹ì†Œì¼“ ì—°ê²° ë³µêµ¬ë¨');
      // ì—°ê²° ë³µêµ¬ í›„ êµ¬ë… ë³µêµ¬ ì‹œë„
      if (isSubscribedRef.current) {
        logger.info('useCVEListUpdates', 'êµ¬ë… ìƒíƒœ ë³µêµ¬ ì‹œë„');
        subscribeCVEList();
      }
    }
  };
  
  // ì›¹ì†Œì¼“ ì´ë²¤íŠ¸ êµ¬ë… ì„¤ì •
  useEffect(() => {
    if (connected && !isSubscribedRef.current) {
      logger.info('useCVEListUpdates', 'CVE ì—…ë°ì´íŠ¸ êµ¬ë… ìš”ì²­ ì „ì†¡');
      
      // ì´ë²¤íŠ¸ êµ¬ë… ì„¤ì •
      const unsubCreated = on(CVE_EVENTS.CVE_CREATED, onCVECreated);
      const unsubUpdated = on(CVE_EVENTS.CVE_UPDATED, onCVEUpdated);
      const unsubDeleted = on(CVE_EVENTS.CVE_DELETED, onCVEDeleted);
      
      // ì„œë²„ì— êµ¬ë… ìš”ì²­ ì „ì†¡
      subscribeCVEList();
      
      isSubscribedRef.current = true;
      
      // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰
      return () => {
        // êµ¬ë… í•´ì œ
        unsubCreated();
        unsubUpdated();
        unsubDeleted();
        
        // ì„œë²„ì— êµ¬ë… í•´ì œ ìš”ì²­ ì „ì†¡
        if (connected) {
          logger.info('useCVEListUpdates', 'CVE ëª©ë¡ ì—…ë°ì´íŠ¸ êµ¬ë… í•´ì œ');
          unsubscribeCVEList();
        }
        
        // ë””ë°”ìš´ìŠ¤ëœ í•¨ìˆ˜ ì·¨ì†Œ
        invalidateCVEQueries.cancel();
        
        // íƒ€ì´ë¨¸ ì •ë¦¬
        clearAllTimers();
        
        // ì†Œì¼“ ì •ë¦¬
        cleanup();
        
        // êµ¬ë… ìƒíƒœ ì´ˆê¸°í™”
        isSubscribedRef.current = false;
      };
    }
    
    // ì—°ê²° ìƒíƒœ ë³€ê²½ ê°ì§€
    handleConnectionChange(connected);
    
    // ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš° ì •ë¦¬ í•¨ìˆ˜ ì œê³µ
    return () => {
      invalidateCVEQueries.cancel();
      clearAllTimers();
    };
  }, [connected, on, cleanup, onCVECreated, onCVEUpdated, onCVEDeleted, subscribeCVEList, unsubscribeCVEList, invalidateCVEQueries, clearAllTimers]);

  // ì—°ê²° ëŠê¹€ í›„ ìë™ ì¬ì—°ê²° ì‹œë„
  useEffect(() => {
    if (!connected && isSubscribedRef.current) {
      const delay = Math.min(
        1000 * Math.pow(2, reconnectAttemptsRef.current),
        10000
      );
      
      logger.warn('useCVEListUpdates', 'ì—°ê²° ëŠê¹€. ì¬ì—°ê²° ì‹œë„ ì˜ˆì•½', {
        ì¬ì‹œë„íšŸìˆ˜: reconnectAttemptsRef.current + 1,
        ì§€ì—°ì‹œê°„: `${delay}ms`
      });
      
      // ì§€ìˆ˜ ë°±ì˜¤í”„ë¡œ ì¬ì—°ê²° ì‹œë„
      const timerKey = 'reconnect-attempt';
      startTimer(timerKey, () => {
        reconnectAttemptsRef.current++;
        
        if (reconnectAttemptsRef.current > 3) {
          logger.error('useCVEListUpdates', 'ìµœëŒ€ ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜ ì´ˆê³¼. ëª©ë¡ ì—…ë°ì´íŠ¸ê°€ ì¤‘ë‹¨ë¨.');
          clearTimer(timerKey);
          return;
        }
        
        // ì„œë²„ì— êµ¬ë… ìš”ì²­ ì¬ì‹œë„
        if (connected) {
          logger.info('useCVEListUpdates', 'ì¬ì—°ê²° ì„±ê³µ. êµ¬ë… ê°±ì‹ ');
          subscribeCVEList();
        }
      }, delay);
      
      return () => {
        clearTimer(timerKey);
      };
    }
  }, [connected, startTimer, clearTimer, subscribeCVEList]);

  return { 
    isConnected: connected,
    reconnectAttempts: reconnectAttemptsRef.current
  };
}

export default useCVEListUpdates;


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/index.ts
------------------------------------------------------------
// hooks/index.ts

// ëª¨ë“  import ë¬¸ì€ íŒŒì¼ ìƒë‹¨ì— ë°°ì¹˜
import { useCVEList, useCVEListQuery } from './query/useCVEListQuery';
import { useCVEDetail, useCVERefresh } from './query/useCVEDetailQuery';
import { useCVEStats, useTotalCVECount } from './query/useCVEStatsQuery';
import { useCVESubscription } from './socket/useCVESubscription';
import { useCVEListUpdates } from './socket/useCVEListSocketUpdates';
import { handleCVESubscriptionUpdate } from './socket/cveHandlers';
import * as mutations from './useCVEMutation';

// ê°œë³„ export
export { useCVEList, useCVEListQuery } from './query/useCVEListQuery';
export { useCVEDetail, useCVERefresh } from './query/useCVEDetailQuery';
export { useCVEStats, useTotalCVECount } from './query/useCVEStatsQuery';
export { useCVESubscription } from './socket/useCVESubscription';
export { useCVEListUpdates } from './socket/useCVEListSocketUpdates';
export { handleCVESubscriptionUpdate } from './socket/cveHandlers';

// ê¸°ì¡´ mutation íŒŒì¼ ê·¸ëŒ€ë¡œ ì‚¬ìš© (export ì¬ë‚´ë³´ë‚´ê¸°)
export * from './useCVEMutation';

// ëª¨ë“  í›…ì„ ê¸°ë³¸ ë‚´ë³´ë‚´ê¸°ë¡œ í¬í•¨
export default {
  useCVEList,
  useCVEListQuery,
  useCVEDetail,
  useCVERefresh,
  useCVEStats,
  useTotalCVECount,
  useCVESubscription,
  useCVEListUpdates,
  handleCVESubscriptionUpdate,
  ...mutations
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/utils/cveQueryUtils.ts
------------------------------------------------------------
// utils/cveQueryUtils.ts
import { useCallback, useEffect, useRef } from 'react';
import _ from 'lodash';
import logger from 'shared/utils/logging';
import { LoggerType } from './types';
import { SubscriptionState, SubscriptionAction } from './types';

/**
 * ì¼ë°˜ í•¨ìˆ˜ìš© ë¡œê±° ìƒì„± í•¨ìˆ˜ (non-React ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì‚¬ìš©)
 * @param prefix - ë¡œê·¸ ë©”ì‹œì§€ í”„ë¦¬í”½ìŠ¤
 * @returns ë¡œê±° ê°ì²´
 */
export const createLogger = (prefix: string): LoggerType => ({
  info: (message, data) => {
    if (data !== undefined) {
      logger.info(prefix, message, data);
    } else {
      logger.info(prefix, message);
    }
  },
  warn: (message, data) => {
    if (data !== undefined) {
      logger.warn(prefix, message, data);
    } else {
      logger.warn(prefix, message);
    }
  },
  error: (message, error) => {
    if (error !== undefined) {
      logger.error(prefix, message, error);
    } else {
      logger.error(prefix, message);
    }
  },
  debug: (message, data) => {
    if (data !== undefined) {
      logger.debug(prefix, message, data);
    } else {
      logger.debug(prefix, message);
    }
  }
});

/**
 * íƒ€ì´ë¨¸ ê´€ë¦¬ ìœ í‹¸ë¦¬í‹° í›…
 * @returns íƒ€ì´ë¨¸ ê´€ë¦¬ í•¨ìˆ˜ë“¤
 */
export function useTimers() {
  const timersRef = useRef<{ [key: string]: number }>({});

  const startTimer = useCallback((key: string, callback: () => void, delay: number) => {
    // ê¸°ì¡´ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ì •ë¦¬
    if (timersRef.current[key]) {
      clearTimeout(timersRef.current[key]);
    }
    // ìƒˆ íƒ€ì´ë¨¸ ì„¤ì •
    timersRef.current[key] = window.setTimeout(callback, delay);
    return () => clearTimer(key);
  }, []);

  const clearTimer = useCallback((key: string) => {
    if (timersRef.current[key]) {
      clearTimeout(timersRef.current[key]);
      delete timersRef.current[key];
    }
  }, []);

  const clearAllTimers = useCallback(() => {
    Object.keys(timersRef.current).forEach(key => {
      clearTimeout(timersRef.current[key]);
    });
    timersRef.current = {};
  }, []);

  useEffect(() => {
    // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ëª¨ë“  íƒ€ì´ë¨¸ ì •ë¦¬
    return clearAllTimers;
  }, [clearAllTimers]);

  return { startTimer, clearTimer, clearAllTimers };
}

/**
 * ì„±ëŠ¥ ì¸¡ì • ìœ í‹¸ë¦¬í‹°
 * @param label - ì¸¡ì • ë¼ë²¨
 * @param action - ì¸¡ì •í•  í•¨ìˆ˜
 * @returns í•¨ìˆ˜ ì‹¤í–‰ ê²°ê³¼
 */
export const measurePerformance = <T extends any>(label: string, action: () => T): T => {
  if (process.env.NODE_ENV !== 'development') return action();
  
  const start = performance.now();
  const result = action();
  const end = performance.now();
  logger.debug(`ì„±ëŠ¥[${label}]: ${end - start}ms`);
  return result;
};

/**
 * êµ¬ë… ìƒíƒœ ë¦¬ë“€ì„œ
 * @param state - í˜„ì¬ ìƒíƒœ
 * @param action - ë””ìŠ¤íŒ¨ì¹˜ëœ ì•¡ì…˜
 * @returns ìƒˆ ìƒíƒœ
 */


export function subscriptionReducer(state: SubscriptionState, action: SubscriptionAction): SubscriptionState {
  switch (action.type) {
    case 'SUBSCRIBE_REQUEST':
      return { 
        ...state, 
        isLoading: true, 
        error: null, 
        isSubscribed: true // ë‚™ê´€ì  ì—…ë°ì´íŠ¸
      };
    
    case 'SUBSCRIBE_SUCCESS':
      return { 
        ...state, 
        isLoading: false, 
        subscribers: action.subscribers, 
        isSubscribed: true 
      };
    
    case 'SUBSCRIBE_FAILURE':
      return { 
        ...state, 
        isLoading: false, 
        error: action.error,
        isSubscribed: false // ì‹¤íŒ¨ ì‹œ êµ¬ë… ì·¨ì†Œ
      };
    
    case 'UNSUBSCRIBE_REQUEST':
      return { 
        ...state, 
        isLoading: true, 
        error: null, 
        isSubscribed: false // ë‚™ê´€ì  ì—…ë°ì´íŠ¸
      };
    
    case 'UNSUBSCRIBE_SUCCESS':
      return { 
        ...state, 
        isLoading: false, 
        subscribers: action.subscribers, 
        isSubscribed: false 
      };
    
    case 'UNSUBSCRIBE_FAILURE':
      return { 
        ...state, 
        isLoading: false, 
        error: action.error,
        // êµ¬ë… ìƒíƒœëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ (ì‹¤íŒ¨í–ˆê¸° ë•Œë¬¸)
      };
    
    case 'UPDATE_SUBSCRIBERS':
      return { 
        ...state, 
        subscribers: action.subscribers, 
        isSubscribed: action.isSubscribed,
        isLoading: false,
        error: null
      };
    
    case 'SET_LOADING':
      return { ...state, isLoading: action.isLoading };
    
    case 'SET_ERROR':
      return { ...state, error: action.error };
    
    case 'CONNECTION_LOST':
      return { 
        ...state, 
        connectionLost: true, 
        error: 'ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ì¬ì—°ê²° ì¤‘...',
        isLoading: true
      };
    
    case 'CONNECTION_RESTORED':
      return { 
        ...state, 
        connectionLost: false, 
        error: null
      };
    
    default:
      return state;
  }
}


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/utils/types.ts
------------------------------------------------------------
// utils/types.ts
import { UseQueryOptions } from '@tanstack/react-query';

/**
 * ë¡œê±° íƒ€ì… ì¸í„°í˜ì´ìŠ¤
 */
export interface LoggerType {
  info: (message: string, data?: any) => void;
  warn: (message: string, data?: any) => void;
  error: (message: string, error?: any) => void;
  debug: (message: string, data?: any) => void;
}

/**
 * í•„í„° íƒ€ì… ì •ì˜
 */
export type Filters = Record<string, any>;

/**
 * ì¿¼ë¦¬ ì˜µì…˜ íƒ€ì… ì •ì˜
 */
export type QueryOptions<T = any> = Omit<UseQueryOptions<T, Error>, 'queryKey' | 'queryFn'>;

/**
 * CVE í•­ëª© ì¸í„°í˜ì´ìŠ¤
 */
export interface CVEItem {
  cveId: string;
  createdAt?: string | Date;
  lastModifiedAt?: string | Date;
  created_at?: string | Date;
  last_modified_at?: string | Date;
  [key: string]: any;
}

/**
 * CVE í†µê³„ íƒ€ì… ì •ì˜
 */
export interface CVEStats {
  byStatus?: Record<string, number>;
  bySeverity?: Record<string, number>;
  byMonth?: Record<string, number>;
  total?: number;
  [key: string]: any;
}

/**
 * êµ¬ë… ìƒíƒœ ì•¡ì…˜ íƒ€ì…
 */
export type SubscriptionAction = 
  | { type: 'SUBSCRIBE_REQUEST' }
  | { type: 'SUBSCRIBE_SUCCESS', subscribers: any[] }
  | { type: 'SUBSCRIBE_FAILURE', error: string }
  | { type: 'UNSUBSCRIBE_REQUEST' }
  | { type: 'UNSUBSCRIBE_SUCCESS', subscribers: any[] }
  | { type: 'UNSUBSCRIBE_FAILURE', error: string }
  | { type: 'UPDATE_SUBSCRIBERS', subscribers: any[], isSubscribed: boolean }
  | { type: 'SET_LOADING', isLoading: boolean }
  | { type: 'SET_ERROR', error: string | null }
  | { type: 'CONNECTION_LOST' }
  | { type: 'CONNECTION_RESTORED' };

/**
 * êµ¬ë… ìƒíƒœ ì¸í„°í˜ì´ìŠ¤
 */
export interface SubscriptionState {
  isSubscribed: boolean;
  subscribers: any[];
  isLoading: boolean;
  error: string | null;
  connectionLost: boolean;
}

/**
 * ì¬ì‹œë„ ê´€ë ¨ ìƒìˆ˜
 */
export const RETRY_CONFIG = {
  MAX_ATTEMPTS: 3,
  INITIAL_DELAY: 1000,
  MAX_DELAY: 10000,
  TIMEOUT: 5000
};

/**
 * êµ¬ë… ê´€ë ¨ ì´ë²¤íŠ¸ ìƒìˆ˜
 */
export const LOCAL_SUBSCRIPTION_EVENTS = {
  SUBSCRIPTION_ERROR: 'SUBSCRIPTION_ERROR',
  UNSUBSCRIPTION_ERROR: 'UNSUBSCRIPTION_ERROR',
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/query/useCVEListQuery.ts
------------------------------------------------------------
// query/useCVEListQuery.ts
import { useQuery } from '@tanstack/react-query';
import { useRef } from 'react';
import cveService from 'features/cve/services/cveService';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { createLogger } from '../utils/cveQueryUtils';
import { Filters, QueryOptions } from '../utils/types';
import type { CVEListResponse } from 'features/cve/types/cve';

/**
 * CVE ëª©ë¡ ì¡°íšŒ í›…
 * í•„í„°ë§ ì˜µì…˜ì„ ì ìš©í•˜ì—¬ CVE ëª©ë¡ì„ ì¡°íšŒ
 * 
 * @param filters - í•„í„° ì˜µì…˜
 * @param options - ì¿¼ë¦¬ ì˜µì…˜
 * @param customService - ì»¤ìŠ¤í…€ ì„œë¹„ìŠ¤ ê°ì²´ (í…ŒìŠ¤íŠ¸ìš©)
 * @returns ì¿¼ë¦¬ ê²°ê³¼
 */
export const useCVEList = (
  filters: Filters = {},
  options: QueryOptions<CVEListResponse> = {},
  customService = cveService
) => {
  const logger = createLogger('useCVEList');
  const requestIdRef = useRef<string>('');

  return useQuery<CVEListResponse, Error>({
    queryKey: QUERY_KEYS.CVE.list(filters),
    queryFn: async () => {
      try {
        // ìš”ì²­ ID ìƒì„± (ë””ë²„ê¹…/ì¶”ì ìš©)
        requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
        logger.info(`ëª©ë¡ ì¡°íšŒ ìš”ì²­(${requestIdRef.current})`, { filters });
        
        const startTime = performance.now();
        const result = await customService.getCVEs(filters);
        const endTime = performance.now();

        // ì‘ë‹µ í•„ë“œ ì •ê·œí™” (ë°±ì—”ë“œ ì‘ë‹µì´ ì¼ê´€ë˜ì§€ ì•Šì„ ê²½ìš° ëŒ€ë¹„)
        if (!result.total && result.totalItems) {
          result.total = result.totalItems;
        }
        if (!result.items && result.results) {
          result.items = result.results;
        }

        logger.info(`ëª©ë¡ ì¡°íšŒ ê²°ê³¼(${requestIdRef.current})`, { 
          totalItems: result.total || result.totalItems || 0,
          itemsCount: result.items?.length || result.results?.length || 0,
          page: filters.page || 1,
          elapsedTime: `${(endTime - startTime).toFixed(2)}ms`
        });

        return result;
      } catch (error: any) {
        // ì˜¤ë¥˜ ë¶„ë¥˜ ë° ì„¸ë¶„í™”ëœ ë¡œê¹…
        if (error.response) {
          logger.error(`ëª©ë¡ ì¡°íšŒ HTTP ì˜¤ë¥˜(${requestIdRef.current})`, {
            status: error.response.status,
            statusText: error.response.statusText,
            url: error.response.config?.url,
            errorData: error.response.data
          });
        } else if (error.request) {
          logger.error(`ëª©ë¡ ì¡°íšŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜(${requestIdRef.current})`, {
            message: error.message,
            code: error.code
          });
        } else {
          logger.error(`ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜(${requestIdRef.current})`, error);
        }
        throw error;
      }
    },
    placeholderData: (oldData) => oldData,
    staleTime: 10000,
    gcTime: 60000,
    refetchOnWindowFocus: true,
    ...options,
  });
};

/**
 * (í•˜ìœ„ í˜¸í™˜ì„±) CVE ëª©ë¡ ì¡°íšŒ í›…
 * ì´ì „ ë²„ì „ APIì™€ì˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼ í•¨ìˆ˜
 * 
 * @param params - ì¡°íšŒ íŒŒë¼ë¯¸í„°
 * @returns ì¿¼ë¦¬ ê²°ê³¼
 * @deprecated useCVEListë¥¼ ì§ì ‘ ì‚¬ìš©í•˜ì„¸ìš”
 */
export const useCVEListQuery = (params: {
  page?: number;
  rowsPerPage?: number;
  filters?: Filters;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
} = {}) => {
  const { 
    page = 0, 
    rowsPerPage = 10, 
    filters = {}, 
    sortBy = 'createdAt', 
    sortOrder = 'desc' 
  } = params;

  const convertedFilters = {
    page,
    rowsPerPage,
    search: filters.search,
    sortBy,
    sortOrder,
    filters
  };

  const logger = createLogger('useCVEListQuery');
  logger.info('í˜¸í™˜ì„± ëª¨ë“œë¡œ í˜¸ì¶œë¨ (deprecated)', { params });
  
  return useCVEList(convertedFilters);
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/query/useCVEStatsQuery.ts
------------------------------------------------------------
// query/useCVEStatsQuery.ts
import { useEffect, useRef, useCallback } from 'react';
import { useQuery } from '@tanstack/react-query';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import api from 'shared/api/config/axios';
import cveService from 'features/cve/services/cveService';
import { createLogger, useTimers } from '../utils/cveQueryUtils';
import { QueryOptions, CVEStats, RETRY_CONFIG } from '../utils/types';

/**
 * CVE í†µê³„ ì •ë³´ ì¡°íšŒ í›…
 * ì‹œìŠ¤í…œì˜ CVE í†µê³„ ì •ë³´ë¥¼ ì¡°íšŒ
 * 
 * @param options - ì¿¼ë¦¬ ì˜µì…˜
 * @returns ì¿¼ë¦¬ ê²°ê³¼
 */
export const useCVEStats = (options: QueryOptions<CVEStats> = {}) => {
  const logger = createLogger('useCVEStats');
  const requestIdRef = useRef('');
  
  return useQuery<CVEStats, Error>({
    queryKey: QUERY_KEYS.CVE.stats(),
    queryFn: async () => {
      try {
        requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
        logger.info(`CVE í†µê³„ ì¡°íšŒ ìš”ì²­(${requestIdRef.current})`);
        
        const startTime = performance.now();
        const response = await api.get('/cves/stats');
        const endTime = performance.now();
        
        const result = response.data;
        logger.info(`CVE í†µê³„ ì¡°íšŒ ê²°ê³¼(${requestIdRef.current})`, { 
          stats: result,
          elapsedTime: `${(endTime - startTime).toFixed(2)}ms`
        });
        
        return result;
      } catch (error: any) {
        // ì„¸ë¶„í™”ëœ ì˜¤ë¥˜ ë¡œê¹…
        if (error.response) {
          logger.error(`CVE í†µê³„ ì¡°íšŒ HTTP ì˜¤ë¥˜(${requestIdRef.current})`, {
            status: error.response.status,
            statusText: error.response.statusText,
            url: error.response.config?.url,
            errorData: error.response.data
          });
        } else if (error.request) {
          logger.error(`CVE í†µê³„ ì¡°íšŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜(${requestIdRef.current})`, {
            message: error.message,
            code: error.code
          });
        } else {
          logger.error(`CVE í†µê³„ ì¡°íšŒ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜(${requestIdRef.current})`, error);
        }
        throw error;
      }
    },
    // ê¸°ë³¸ ì˜µì…˜
    staleTime: 300000, // 5ë¶„
    gcTime: 600000, // 10ë¶„
    ...options
  });
};

/**
 * ì „ì²´ CVE ìˆ˜ ì¡°íšŒ í›…
 * ì‹œìŠ¤í…œì— ë“±ë¡ëœ ì´ CVE ìˆ˜ë¥¼ ì¡°íšŒ
 * 
 * @param options - ì¿¼ë¦¬ ì˜µì…˜
 * @returns ì¿¼ë¦¬ ê²°ê³¼
 */
export const useTotalCVECount = (options: QueryOptions<number> = {}) => {
  const logger = createLogger('useTotalCVECount');
  const requestIdRef = useRef('');
  const { startTimer, clearAllTimers } = useTimers();
  
  // ì¬ì‹œë„ ì¹´ìš´í„°
  const retryCountRef = useRef(0);
  
  // ì¬ì‹œë„ í•¨ìˆ˜
  const retryWithBackoff = useCallback(async (queryFn: () => Promise<number>) => {
    retryCountRef.current++;
    
    if (retryCountRef.current > RETRY_CONFIG.MAX_ATTEMPTS) {
      logger.error(`ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼(${requestIdRef.current})`);
      throw new Error(`ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜(${RETRY_CONFIG.MAX_ATTEMPTS}íšŒ)ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤.`);
    }
    
    const delay = Math.min(
      RETRY_CONFIG.INITIAL_DELAY * Math.pow(2, retryCountRef.current - 1),
      RETRY_CONFIG.MAX_DELAY
    );
    
    logger.info(`ì¬ì‹œë„ ì˜ˆì•½(${requestIdRef.current})`, {
      retryCount: retryCountRef.current,
      delay: `${delay}ms`
    });
    
    return new Promise<number>((resolve, reject) => {
      startTimer(`retry-total-count-${retryCountRef.current}`, async () => {
        try {
          const result = await queryFn();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      }, delay);
    });
  }, [startTimer]);
  
  const query = useQuery<number, Error>({
    queryKey: QUERY_KEYS.CVE.totalCount(),
    queryFn: async () => {
      try {
        requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
        logger.info(`ì „ì²´ CVE ìˆ˜ ì¡°íšŒ ìš”ì²­(${requestIdRef.current})`);
        
        const startTime = performance.now();
        const result = await cveService.getTotalCVECount();
        const endTime = performance.now();
        
        retryCountRef.current = 0; // ì„±ê³µ ì‹œ ì¬ì‹œë„ ì¹´ìš´í„° ë¦¬ì…‹
        
        logger.info(`ì „ì²´ CVE ìˆ˜ ì¡°íšŒ ê²°ê³¼(${requestIdRef.current})`, { 
          count: result,
          elapsedTime: `${(endTime - startTime).toFixed(2)}ms`
        });
        
        return result;
      } catch (error: any) {
        // ì„œë²„ ì˜¤ë¥˜ì¸ ê²½ìš° ì¬ì‹œë„
        if (error.response && error.response.status >= 500) {
          logger.warn(`ì„œë²„ ì˜¤ë¥˜ë¡œ ì¸í•œ ì¬ì‹œë„(${requestIdRef.current})`, {
            status: error.response.status,
            retry: retryCountRef.current + 1
          });
          return retryWithBackoff(() => cveService.getTotalCVECount());
        }
        
        // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ì¸ ê²½ìš° ì¬ì‹œë„
        if (error.code === 'ECONNABORTED' || error.message?.includes('timeout') || !error.response) {
          logger.warn(`ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ë¡œ ì¸í•œ ì¬ì‹œë„(${requestIdRef.current})`, {
            message: error.message,
            retry: retryCountRef.current + 1
          });
          return retryWithBackoff(() => cveService.getTotalCVECount());
        }
        
        // ì„¸ë¶„í™”ëœ ì˜¤ë¥˜ ë¡œê¹…
        if (error.response) {
          logger.error(`ì „ì²´ CVE ìˆ˜ ì¡°íšŒ HTTP ì˜¤ë¥˜(${requestIdRef.current})`, {
            status: error.response.status,
            statusText: error.response.statusText,
            url: error.response.config?.url,
            errorData: error.response.data
          });
        } else {
          logger.error(`ì „ì²´ CVE ìˆ˜ ì¡°íšŒ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜(${requestIdRef.current})`, error);
        }
        
        throw error;
      }
    },
    // ê¸°ë³¸ ì˜µì…˜
    staleTime: 300000, // 5ë¶„
    gcTime: 600000, // 10ë¶„
    ...options
  });
  
  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ íƒ€ì´ë¨¸ ì •ë¦¬
  useEffect(() => {
    return clearAllTimers;
  }, [clearAllTimers]);
  
  return query;
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/query/useCVEDetailQuery.ts
------------------------------------------------------------
// query/useCVEDetailQuery.ts
import { useEffect, useRef, useCallback } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import cveService from 'features/cve/services/cveService';
import { QUERY_KEYS } from 'shared/api/queryKeys';
import { createLogger, useTimers, measurePerformance } from '../utils/cveQueryUtils';
import { QueryOptions, RETRY_CONFIG } from '../utils/types';
import type { CVEDetail } from 'features/cve/types/cve';

/**
 * CVE ìƒì„¸ ì •ë³´ ì¡°íšŒ í›…
 * íŠ¹ì • CVE IDì˜ ìƒì„¸ ì •ë³´ë¥¼ ì¡°íšŒ
 * 
 * @param cveId - CVE ID
 * @param options - ì¿¼ë¦¬ ì˜µì…˜
 * @param customService - ì»¤ìŠ¤í…€ ì„œë¹„ìŠ¤ ê°ì²´ (í…ŒìŠ¤íŠ¸ìš©)
 * @returns ì¿¼ë¦¬ ê²°ê³¼
 */
export const useCVEDetail = (
  cveId: string,
  options: QueryOptions<CVEDetail> = {},
  customService = cveService
) => {
  const logger = createLogger('useCVEDetail');
  const requestIdRef = useRef<string>('');

  const defaultOptions: QueryOptions<CVEDetail> = {
    enabled: !!cveId,
    retry: 1,
    retryDelay: 500,
    staleTime: 60000, // 1ë¶„ìœ¼ë¡œ ì¦ê°€í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬í˜ì¹˜ ì¤„ì´ê¸°
    gcTime: 300000, // 5ë¶„ìœ¼ë¡œ ìœ ì§€
    refetchOnWindowFocus: false, // ì°½ í¬ì»¤ìŠ¤ ì‹œ ë¦¬í˜ì¹˜ ë¹„í™œì„±í™”
    refetchOnMount: false, // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ìë™ ë¦¬í˜ì¹˜ ë¹„í™œì„±í™” (ëª…ì‹œì  í˜¸ì¶œë§Œ í—ˆìš©)
    refetchOnReconnect: false, // ì¬ì—°ê²° ì‹œ ìë™ ë¦¬í˜ì¹˜ ë¹„í™œì„±í™”
  };

  const mergedOptions = { ...defaultOptions, ...options };

  return useQuery<CVEDetail, Error>({
    queryKey: QUERY_KEYS.CVE.detail(cveId),
    queryFn: async () => {
      try {
        requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
        logger.info(`CVE ìƒì„¸ ì¡°íšŒ ìš”ì²­(${requestIdRef.current})`, { cveId });
        
        const startTime = performance.now();
        const result = await customService.getCVEById(cveId);
        const endTime = performance.now();
        const elapsedTime = endTime - startTime;

        logger.info(`CVE ìƒì„¸ ì¡°íšŒ ì™„ë£Œ(${requestIdRef.current})`, { 
          cveId, 
          elapsedTime: `${elapsedTime.toFixed(2)}ms`,
          dataSize: JSON.stringify(result).length
        });

        return result;
      } catch (error: any) {
        // ì„¸ë¶„í™”ëœ ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¡œê¹…
        if (error.response) {
          if (error.response.status === 404) {
            logger.warn(`CVE ìƒì„¸ ì¡°íšŒ - í•­ëª© ì—†ìŒ(${requestIdRef.current})`, { 
              cveId, 
              status: error.response.status 
            });
          } else {
            logger.error(`CVE ìƒì„¸ ì¡°íšŒ HTTP ì˜¤ë¥˜(${requestIdRef.current})`, {
              cveId,
              status: error.response.status,
              statusText: error.response.statusText,
              url: error.response.config?.url,
              errorData: error.response.data
            });
          }
        } else if (error.request) {
          logger.error(`CVE ìƒì„¸ ì¡°íšŒ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜(${requestIdRef.current})`, {
            cveId,
            message: error.message,
            code: error.code
          });
        } else {
          logger.error(`CVE ìƒì„¸ ì¡°íšŒ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜(${requestIdRef.current})`, {
            cveId,
            error
          });
        }
        throw error;
      }
    },
    ...mergedOptions
  });
};

/**
 * CVE ìƒˆë¡œê³ ì¹¨ í›…
 * íŠ¹ì • CVEì˜ ë°ì´í„°ë¥¼ ê°•ì œë¡œ ìƒˆë¡œê³ ì¹¨ (ìºì‹œ ë¬´ì‹œ)
 * 
 * @param cveId - CVE ID
 * @param options - í›… ì˜µì…˜
 * @param customService - ì»¤ìŠ¤í…€ ì„œë¹„ìŠ¤ ê°ì²´ (í…ŒìŠ¤íŠ¸ìš©)
 * @returns ìƒˆë¡œê³ ì¹¨ í•¨ìˆ˜ì™€ ìƒíƒœ
 */
export const useCVERefresh = (
  cveId: string,
  options: any = {},
  customService = cveService
) => {
  const queryClient = useQueryClient();
  const logger = createLogger('useCVERefresh');
  const { startTimer, clearAllTimers } = useTimers();
  const requestIdRef = useRef<string>('');
  
  // ì¬ì‹œë„ ë©”ì»¤ë‹ˆì¦˜ì„ í¬í•¨í•œ ìƒˆë¡œê³ ì¹¨ í•¨ìˆ˜
  const refreshFn = async (retryCount = 0) => {
    try {
      requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
      logger.info(`ê°•ì œ ìƒˆë¡œê³ ì¹¨ ìš”ì²­(${requestIdRef.current})`, { cveId, retryAttempt: retryCount });
      
      const data = await customService.getCVEByIdNoCache(cveId);
      
      // ì„±ê³µ ì‹œ ìºì‹œ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), data);
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.CVE.lists() });
      
      logger.info(`ê°•ì œ ìƒˆë¡œê³ ì¹¨ ì„±ê³µ(${requestIdRef.current})`, { cveId });
      return data;
    } catch (error: any) {
      // ì˜¤ë¥˜ ìœ í˜•ì— ë”°ë¥¸ ì„¸ë¶„í™”ëœ ì²˜ë¦¬
      if (error.response && error.response.status >= 500 && retryCount < RETRY_CONFIG.MAX_ATTEMPTS) {
        // ì„œë²„ ì˜¤ë¥˜ì˜ ê²½ìš° ì§€ìˆ˜ ë°±ì˜¤í”„ë¡œ ì¬ì‹œë„
        const delay = Math.min(
          RETRY_CONFIG.INITIAL_DELAY * Math.pow(2, retryCount),
          RETRY_CONFIG.MAX_DELAY
        );
        
        logger.warn(`ì„œë²„ ì˜¤ë¥˜ë¡œ ì¬ì‹œë„ ì˜ˆì•½(${requestIdRef.current})`, {
          cveId,
          retryAttempt: retryCount + 1,
          delay: `${delay}ms`,
          error: error.message
        });
        
        // ì§€ì •ëœ ì§€ì—° í›„ ì¬ì‹œë„
        return new Promise((resolve, reject) => {
          startTimer(`refresh-retry-${retryCount}`, async () => {
            try {
              const result = await refreshFn(retryCount + 1);
              resolve(result);
            } catch (retryError) {
              reject(retryError);
            }
          }, delay);
        });
      }
      
      // ë‹¤ë¥¸ ì˜¤ë¥˜ëŠ” ìì„¸íˆ ë¡œê¹… í›„ throw
      logger.error(`ê°•ì œ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨(${requestIdRef.current})`, {
        cveId,
        retryAttempt: retryCount,
        errorType: error.response ? 'HTTP ì˜¤ë¥˜' : error.request ? 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜' : 'ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜',
        status: error.response?.status,
        message: error.message
      });
      
      throw error;
    }
  };

  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ íƒ€ì´ë¨¸ ì •ë¦¬
  useEffect(() => {
    return clearAllTimers;
  }, [clearAllTimers]);

  return {
    mutate: refreshFn,
    isLoading: false,
    refresh: refreshFn
  };
};

/**
 * CVE ì—…ë°ì´íŠ¸ í›…
 * íŠ¹ì • CVE ì •ë³´ë¥¼ ì—…ë°ì´íŠ¸í•˜ê¸° ìœ„í•œ ë®¤í…Œì´ì…˜ í›…
 * 
 * @param cveId - CVE ID
 * @param options - ë®¤í…Œì´ì…˜ ì˜µì…˜
 * @returns ë®¤í…Œì´ì…˜ ê²°ê³¼
 */
export const useUpdateCVE = (
  cveId: string,
  options: any = {}
) => {
  const queryClient = useQueryClient();
  const logger = createLogger('useUpdateCVE');
  const requestIdRef = useRef('');
  const { startTimer, clearAllTimers } = useTimers();
  
  // ì¬ì‹œë„ ì¹´ìš´í„°
  const retryCountRef = useRef(0);
  
  // ì¬ì‹œë„ í•¨ìˆ˜
  const retryWithBackoff = useCallback(async (updateData: Partial<CVEDetail>) => {
    retryCountRef.current++;
    
    if (retryCountRef.current > RETRY_CONFIG.MAX_ATTEMPTS) {
      logger.error(`ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼(${requestIdRef.current})`);
      throw new Error(`ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜(${RETRY_CONFIG.MAX_ATTEMPTS}íšŒ)ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤.`);
    }
    
    const delay = Math.min(
      RETRY_CONFIG.INITIAL_DELAY * Math.pow(2, retryCountRef.current - 1),
      RETRY_CONFIG.MAX_DELAY
    );
    
    logger.info(`ì—…ë°ì´íŠ¸ ì¬ì‹œë„ ì˜ˆì•½(${requestIdRef.current})`, {
      cveId,
      retryCount: retryCountRef.current,
      delay: `${delay}ms`
    });
    
    return new Promise((resolve, reject) => {
      startTimer(`retry-update-${retryCountRef.current}`, async () => {
        try {
          const result = await cveService.updateCVE(cveId, updateData);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      }, delay);
    });
  }, [cveId, startTimer]);

  const mutation = {
    mutate: async (updateData: Partial<CVEDetail>) => {
      try {
        requestIdRef.current = Date.now().toString(36) + Math.random().toString(36).substr(2);
        logger.info(`CVE ì—…ë°ì´íŠ¸ ìš”ì²­(${requestIdRef.current}): ${cveId}`, { 
          updateFields: Object.keys(updateData),
          updateData
        });
        
        const startTime = performance.now();
        const result = await cveService.updateCVE(cveId, updateData);
        const endTime = performance.now();
        
        retryCountRef.current = 0; // ì„±ê³µ ì‹œ ì¬ì‹œë„ ì¹´ìš´í„° ë¦¬ì…‹
        
        logger.info(`CVE ì—…ë°ì´íŠ¸ ì„±ê³µ(${requestIdRef.current}): ${cveId}`, {
          elapsedTime: `${(endTime - startTime).toFixed(2)}ms`
        });
        
        // ìºì‹œ ì—…ë°ì´íŠ¸ ì„±ëŠ¥ ì¸¡ì •
        measurePerformance('ìºì‹œ ì—…ë°ì´íŠ¸', () => {
          // ê¸°ì¡´ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
          const previousData = queryClient.getQueryData<CVEDetail>(QUERY_KEYS.CVE.detail(cveId));
          
          if (previousData) {
            // ì—…ë°ì´íŠ¸ëœ ë°ì´í„°ë¡œ ìºì‹œ ì—…ë°ì´íŠ¸
            queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), {
              ...previousData,
              ...updateData,
              lastModifiedAt: new Date().toISOString()
            });
          }
          
          // ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”
          queryClient.invalidateQueries({ 
            queryKey: QUERY_KEYS.CVE.lists(),
            refetchType: 'active'
          });
        });
        
        if (options.onSuccess) {
          options.onSuccess(result, updateData);
        }
        
        return result;
      } catch (error: any) {
        // ì„œë²„ ì˜¤ë¥˜ì¸ ê²½ìš° ì¬ì‹œë„
        if (error.response && error.response.status >= 500) {
          logger.warn(`ì„œë²„ ì˜¤ë¥˜ë¡œ ì¸í•œ ì¬ì‹œë„(${requestIdRef.current})`, {
            cveId,
            status: error.response.status,
            retry: retryCountRef.current + 1
          });
          return retryWithBackoff(updateData);
        }
        
        // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ì¸ ê²½ìš° ì¬ì‹œë„
        if (error.code === 'ECONNABORTED' || error.message?.includes('timeout') || !error.response) {
          logger.warn(`ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ë¡œ ì¸í•œ ì¬ì‹œë„(${requestIdRef.current})`, {
            cveId,
            message: error.message,
            retry: retryCountRef.current + 1
          });
          return retryWithBackoff(updateData);
        }
        
        // ì„¸ë¶„í™”ëœ ì˜¤ë¥˜ ë¡œê¹…
        if (error.response) {
          logger.error(`CVE ì—…ë°ì´íŠ¸ HTTP ì˜¤ë¥˜(${requestIdRef.current}): ${cveId}`, {
            status: error.response.status,
            statusText: error.response.statusText,
            url: error.response.config?.url,
            errorData: error.response.data
          });
        } else {
          logger.error(`CVE ì—…ë°ì´íŠ¸ ì‹¤íŒ¨(${requestIdRef.current}): ${cveId}`, error);
        }
        
        if (options.onError) {
          options.onError(error, updateData);
        }
        
        throw error;
      }
    },
    isLoading: false
  };
  
  // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ íƒ€ì´ë¨¸ ì •ë¦¬
  useEffect(() => {
    return clearAllTimers;
  }, [clearAllTimers]);
  
  return mutation;
};


============================================================
File: /home/CVEHub/frontend/src/features/cve/hooks/useCVEMutation.ts
------------------------------------------------------------
/**
 * CVE ê´€ë ¨ mutation í›… ëª¨ìŒ
 */
import { useMutation, useQueryClient, UseMutationOptions, UseMutationResult, QueryClient } from '@tanstack/react-query';
import cveService from '../services/cveService';
import { useSnackbar } from 'notistack';
import { 
  get, 
  merge, 
  defaultsDeep, 
  debounce, 
  set,
  isArray
} from 'lodash';
import { 
  CVEDetail, 
  CVEData, 
  CVEUpdateRequest, 
  OperationResponse 
} from '../types/cve';
import { QUERY_KEYS } from 'shared/api/queryKeys'
import { ApiResponse, ApiError } from 'shared/api/types/api';
import logger from 'shared/utils/logging';
import { SOCKET_EVENTS } from 'core/socket/services/constants';
/**
 * CVE ìƒì„± ìš”ì²­ íƒ€ì…
 */
export type CreateCVERequest = CVEData;

/**
 * CVE ì—…ë°ì´íŠ¸ ìš”ì²­ íƒ€ì…
 */
export interface UpdateCVEParams {
  cveId: string;
  data: CVEUpdateRequest;
}

/**
 * CVE í•„ë“œ ì—…ë°ì´íŠ¸ ìš”ì²­ íƒ€ì…
 */
export interface UpdateCVEFieldParams {
  cveId: string;
  fieldName: string;
  fieldValue: any;
}

/**
 * CVE ìƒíƒœ ì—…ë°ì´íŠ¸ ìš”ì²­ íƒ€ì…
 */
export interface UpdateCVEStatusParams {
  cveId: string;
  status: string;
}

/**
 * ì‹¤ì‹œê°„ CVE ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸ íƒ€ì…
 */
export interface RealtimeCVEUpdateEvent {
  type: string;
  cveId?: string;
  data?: any;
}

/**
 * ë‚™ê´€ì  ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ íƒ€ì…
 */
export interface UpdateCVEFieldContext {
  previousData?: ApiResponse<CVEDetail>;
}

/**
 * CVE ìƒì„±ì„ ìœ„í•œ mutation í›…
 * ì„±ê³µ ì‹œ CVE ëª©ë¡ ì¿¼ë¦¬ë¥¼ ë¬´íš¨í™”í•˜ì—¬ ìë™ìœ¼ë¡œ ìµœì‹  ë°ì´í„°ë¥¼ ê°€ì ¸ì˜´
 * @param options - React Query ì˜µì…˜
 * @returns useMutation í›…ì—ì„œ ë°˜í™˜ë˜ëŠ” ê²°ê³¼ ê°ì²´
 */
export const useCreateCVE = (
  options: UseMutationOptions<
    ApiResponse<CVEDetail>, 
    ApiError, 
    CreateCVERequest
  > = {}
): UseMutationResult<
  ApiResponse<CVEDetail>, 
  ApiError, 
  CreateCVERequest
> => {
  const queryClient = useQueryClient();
  const { enqueueSnackbar } = useSnackbar();
  const { onSuccess: optionsOnSuccess, onError: optionsOnError, ...restOptions } = options;
  
  return useMutation<ApiResponse<CVEDetail>, ApiError, CreateCVERequest>({
    mutationFn: (cveData) => {
      logger.info('useCreateCVE', 'ìƒì„± ìš”ì²­', { data: cveData });
      
      try {
        // ê¸°ë³¸ ì˜µì…˜ ì„¤ì •
        return cveService.createCVE(cveData, { 
          meta: {
            source: 'useCreateCVE',
            skipAuthRefresh: false // ì¸ì¦ ê°±ì‹  í—ˆìš©
          }
        });
      } catch (error) {
        // ì—ëŸ¬ ë°œìƒ ì‹œ config ì •ë³´ ë³´ì¡´
        const enhancedError = {
          ...error,
          config: {
            ...(error?.config || {}),
            skipAuthRefresh: false
          }
        } as ApiError;
        throw enhancedError;
      }
    },
    onSuccess: (data, variables, context) => {
      // CVE ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™” (ìë™ìœ¼ë¡œ ë‹¤ì‹œ ê°€ì ¸ì˜´)
      queryClient.invalidateQueries({ 
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
      
      // ê¸°ë³¸ ì„±ê³µ ë©”ì‹œì§€ (optionsì— onSuccessê°€ ì—†ì„ ê²½ìš°ì—ë§Œ)
      if (!optionsOnSuccess) {
        enqueueSnackbar('CVEê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.', { variant: 'success' });
      }
      
      logger.info('useCreateCVE', 'ìƒì„± ì„±ê³µ', { 
        id: data?.data?.id,
        cveId: data?.data?.cveId,
        title: data?.data?.title
      });
      
      // optionsì— onSuccessê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ í˜¸ì¶œ
      if (optionsOnSuccess) {
        optionsOnSuccess(data, variables, context);
      }
    },
    onError: (error, variables, context) => {
      // ì—ëŸ¬ ê°ì²´ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
      const safeError = ensureSafeErrorObject(error);
      
      // ê¸°ë³¸ ì—ëŸ¬ ë©”ì‹œì§€ (optionsì— onErrorê°€ ì—†ì„ ê²½ìš°ì—ë§Œ)
      if (!optionsOnError) {
        enqueueSnackbar(`CVE ìƒì„± ì‹¤íŒ¨: ${safeError.message}`, { 
          variant: 'error',
          anchorOrigin: {
            vertical: 'bottom',
            horizontal: 'center',
          }
        });
      }
      
      // 409 ì—ëŸ¬ (ì¤‘ë³µ CVE)ì¸ ê²½ìš° ê²½ê³  ë¡œê·¸, ê·¸ ì™¸ì—ëŠ” ì—ëŸ¬ ë¡œê·¸
      if (safeError?.response?.status === 409) {
        logger.warn('useCreateCVE', 'CVE ì¤‘ë³µ ìƒì„± ì‹œë„', { 
          message: safeError.message,
          errorCode: safeError?.response?.data?.errorCode || 'DUPLICATE_CVE'
        });
      } else {
        logger.error('useCreateCVE', 'ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ', { 
          message: safeError.message,
          status: safeError.response?.status,
          errorCode: safeError?.response?.data?.errorCode
        });
      }
      
      // optionsì— onErrorê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ í˜¸ì¶œ
      if (optionsOnError) {
        optionsOnError(safeError, variables, context);
      }
      
      throw safeError;
    },
    ...restOptions
  });
};

/**
 * CVE ì—…ë°ì´íŠ¸ í›…
 * @param options - í›… ì˜µì…˜
 * @returns ë®¤í…Œì´ì…˜ ê²°ê³¼
 */
export const useUpdateCVE = (
  options: UseMutationOptions<
    ApiResponse<CVEDetail>, 
    ApiError, 
    UpdateCVEParams
  > = {}
): UseMutationResult<
  ApiResponse<CVEDetail>, 
  ApiError, 
  UpdateCVEParams
> => {
  const queryClient = useQueryClient();
  const { enqueueSnackbar } = useSnackbar();
  const { onSuccess: optionsOnSuccess, onError: optionsOnError, ...restOptions } = options;
  
  return useMutation<ApiResponse<CVEDetail>, ApiError, UpdateCVEParams>({
    mutationFn: ({ cveId, data }) => {
      logger.info('useUpdateCVE', 'ì—…ë°ì´íŠ¸ ìš”ì²­', { cveId, data });
      
      try {
        return cveService.updateCVE(cveId, data, {
          skipAuthRefresh: false
        });
      } catch (error) {
        // ì—ëŸ¬ ë°œìƒ ì‹œ config ì •ë³´ ë³´ì¡´
        const enhancedError = {
          ...error,
          config: {
            ...(error?.config || {}),
            skipAuthRefresh: false
          }
        } as ApiError;
        throw enhancedError;
      }
    },
    onSuccess: (data, variables, context) => {
      const { cveId } = variables;
      // CVE ëª©ë¡ ë° ìƒì„¸ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ 
        queryKey: ['cves'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cve', cveId],
        refetchType: 'active'
      });
      
      // ê¸°ë³¸ ì„±ê³µ ë©”ì‹œì§€ (optionsì— onSuccessê°€ ì—†ì„ ê²½ìš°ì—ë§Œ)
      if (!optionsOnSuccess) {
        enqueueSnackbar('CVEê°€ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.', { variant: 'success' });
      }
      
      logger.info('useUpdateCVE', 'ì—…ë°ì´íŠ¸ ì„±ê³µ', { 
        cveId,
        data: data
      });
      
      // optionsì— onSuccessê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ í˜¸ì¶œ
      if (optionsOnSuccess) {
        optionsOnSuccess(data, variables, context);
      }
    },
    onError: (error, variables, context) => {
      // ì—ëŸ¬ ê°ì²´ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
      const safeError = ensureSafeErrorObject(error);
      
      // ê¸°ë³¸ ì—ëŸ¬ ë©”ì‹œì§€ (optionsì— onErrorê°€ ì—†ì„ ê²½ìš°ì—ë§Œ)
      if (!optionsOnError) {
        enqueueSnackbar(`CVE ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${safeError?.message}`, { variant: 'error' });
      }
      
      logger.error('useUpdateCVE', 'ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', { 
        error: safeError?.message,
        code: safeError?.code,
        status: safeError?.response?.status
      });
      
      // optionsì— onErrorê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ í˜¸ì¶œ
      if (optionsOnError) {
        optionsOnError(safeError, variables, context);
      }
      
      throw safeError;
    },
    ...restOptions
  });
};

/**
 * CVE ì‚­ì œ í›…
 * @param options - í›… ì˜µì…˜
 * @returns ë®¤í…Œì´ì…˜ ê²°ê³¼
 */
export const useDeleteCVE = (
  options: UseMutationOptions<
    ApiResponse<OperationResponse>, 
    ApiError, 
    string
  > = {}
): UseMutationResult<
  ApiResponse<OperationResponse>, 
  ApiError, 
  string
> => {
  const queryClient = useQueryClient();
  const { enqueueSnackbar } = useSnackbar();
  const { onSuccess: optionsOnSuccess, onError: optionsOnError, ...restOptions } = options;
  
  return useMutation<ApiResponse<OperationResponse>, ApiError, string>({
    mutationFn: (cveId) => {
      logger.info('useDeleteCVE', 'ì‚­ì œ ìš”ì²­', { cveId });
      
      try {
        // boolean ëŒ€ì‹  ApiResponse<OperationResponse> í˜•íƒœë¡œ ë°˜í™˜í•˜ë„ë¡ ìˆ˜ì •
        return cveService.deleteCVE(cveId, {
          skipAuthRefresh: false
        }).then(success => {
          // boolean ê²°ê³¼ë¥¼ ApiResponse<OperationResponse> í˜•íƒœë¡œ ë³€í™˜
          return {
            success: true,
            message: 'CVEê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.',
            data: {
              success: true,
              message: 'CVEê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.'
            }
          } as ApiResponse<OperationResponse>;
        });
      } catch (error) {
        // ì—ëŸ¬ ë°œìƒ ì‹œ config ì •ë³´ ë³´ì¡´
        const enhancedError = {
          ...error,
          config: {
            ...(error?.config || {}),
            skipAuthRefresh: false
          }
        } as ApiError;
        throw enhancedError;
      }
    },
    onSuccess: (data, cveId, context) => {
      // CVE ëª©ë¡ ë° ìƒì„¸ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ 
        queryKey: ['cves'],
        refetchType: 'active'
      });
      queryClient.invalidateQueries({ 
        queryKey: ['cve', cveId],
        refetchType: 'active'
      });
      
      // ê¸°ë³¸ ì„±ê³µ ë©”ì‹œì§€ (optionsì— onSuccessê°€ ì—†ì„ ê²½ìš°ì—ë§Œ)
      if (!optionsOnSuccess) {
        enqueueSnackbar('CVEê°€ ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', { variant: 'success' });
      }
      
      logger.info('useDeleteCVE', 'ì‚­ì œ ì„±ê³µ', { cveId });
      
      // optionsì— onSuccessê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ í˜¸ì¶œ
      if (optionsOnSuccess) {
        optionsOnSuccess(data, cveId, context);
      }
    },
    onError: (error, cveId, context) => {
      // ì—ëŸ¬ ê°ì²´ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
      const safeError = ensureSafeErrorObject(error);
      
      // ê¸°ë³¸ ì—ëŸ¬ ë©”ì‹œì§€ (optionsì— onErrorê°€ ì—†ì„ ê²½ìš°ì—ë§Œ)
      if (!optionsOnError) {
        enqueueSnackbar(`CVE ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${safeError?.message}`, { variant: 'error' });
      }
      
      logger.error('useDeleteCVE', 'ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', { 
        error: safeError?.message,
        code: safeError?.code,
        status: safeError?.response?.status
      });
      
      // optionsì— onErrorê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ í˜¸ì¶œ
      if (optionsOnError) {
        optionsOnError(safeError, cveId, context);
      }
      
      throw safeError;
    },
    ...restOptions
  });
};

/**
 * CVE í•„ë“œ ë‹¨ìœ„ ì—…ë°ì´íŠ¸ Hook (ìƒíƒœ, PoC, ì½”ë©˜íŠ¸ ë“±)
 * @param options - React Query ì˜µì…˜
 * @param customService - ì„ íƒì ìœ¼ë¡œ ì£¼ì…í•  ì„œë¹„ìŠ¤ ê°ì²´
 * @returns useMutation í›…ì—ì„œ ë°˜í™˜ë˜ëŠ” ê²°ê³¼ ê°ì²´
 */
export const useUpdateCVEField = (
  options: UseMutationOptions<
    ApiResponse<CVEDetail>, 
    ApiError, 
    UpdateCVEFieldParams,
    UpdateCVEFieldContext
  > = {}, 
  customService = cveService
): UseMutationResult<
  ApiResponse<CVEDetail>, 
  ApiError, 
  UpdateCVEFieldParams,
  UpdateCVEFieldContext
> => {
  const queryClient = useQueryClient();
  const { enqueueSnackbar } = useSnackbar();
  
  // optionsì—ì„œ onSuccessì™€ onError ì¶”ì¶œ
  const { onSuccess: optionsOnSuccess, onError: optionsOnError, ...restOptions } = options;
  
  return useMutation<ApiResponse<CVEDetail>, ApiError, UpdateCVEFieldParams, UpdateCVEFieldContext>({
    mutationFn: ({ cveId, fieldName, fieldValue }) => {
      logger.info('useUpdateCVEField', 'í•„ë“œ ì—…ë°ì´íŠ¸ ìš”ì²­', { cveId, fieldName, fieldValue });
      
      // PoC í•„ë“œ ì—…ë°ì´íŠ¸ ì‹œ last_modified_atê³¼ last_modified_by í•„ë“œ ìë™ ì„¤ì •
      if (fieldName === 'poc' && isArray(fieldValue)) {
        // í˜„ì¬ ì‹œê°„ê³¼ ì‚¬ìš©ì ì •ë³´ ì„¤ì •
        const now = new Date().toISOString();
        const currentUser = localStorage.getItem('username') || 'unknown';
        
        // ê° PoC í•­ëª©ì— last_modified_atê³¼ last_modified_by í•„ë“œ ì„¤ì •
        const updatedPoc = fieldValue.map(poc => {
          // ìƒˆë¡œ ì¶”ê°€ëœ PoCì¸ ê²½ìš° (last_modified_atì´ ì—†ëŠ” ê²½ìš°)
          if (!poc.last_modified_at) {
            return {
              ...poc,
              last_modified_at: now,
              last_modified_by: currentUser
            };
          }
          return poc;
        });
        
        logger.info('useUpdateCVEField', 'PoC í•„ë“œ ìë™ ì—…ë°ì´íŠ¸', { 
          cveId, 
          pocCount: updatedPoc.length 
        });
        
        return customService.updateCVEField(cveId, fieldName, updatedPoc);
      }
      
      return customService.updateCVEField(cveId, fieldName, fieldValue);
    },
    onMutate: async ({ cveId, fieldName, fieldValue }): Promise<UpdateCVEFieldContext> => {
      // ì´ì „ ì¿¼ë¦¬ë¥¼ ì·¨ì†Œí•˜ì—¬ ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì¶©ëŒ ë°©ì§€
      await queryClient.cancelQueries({ queryKey: QUERY_KEYS.CVE.detail(cveId) });
      
      // ì´ì „ ìƒíƒœ ìŠ¤ëƒ…ìƒ· ì €ì¥
      const previousData = queryClient.getQueryData<ApiResponse<CVEDetail>>(QUERY_KEYS.CVE.detail(cveId));
      
      // ë‚™ê´€ì  ì—…ë°ì´íŠ¸
      if (previousData?.data) {
        logger.info('useUpdateCVEField', 'ë‚™ê´€ì  ì—…ë°ì´íŠ¸ ì ìš©', { cveId, fieldName });
        
        // PoC í•„ë“œ ì—…ë°ì´íŠ¸ ì‹œ ë‚™ê´€ì  ì—…ë°ì´íŠ¸ì—ë„ last_modified_atê³¼ last_modified_by í•„ë“œ ì„¤ì •
        let updatedFieldValue = fieldValue;
        if (fieldName === 'poc' && isArray(fieldValue)) {
          const now = new Date().toISOString();
          const currentUser = localStorage.getItem('username') || 'unknown';
          
          updatedFieldValue = fieldValue.map(poc => {
            if (!poc.last_modified_at) {
              return {
                ...poc,
                last_modified_at: now,
                last_modified_by: currentUser
              };
            }
            return poc;
          });
        }
        
        // lodashì˜ set í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¤‘ì²©ëœ í•„ë“œë„ ì•ˆì „í•˜ê²Œ ì—…ë°ì´íŠ¸
        const updatedData = { ...previousData };
        set(updatedData, `data.${fieldName}`, updatedFieldValue);
        
        queryClient.setQueryData<ApiResponse<CVEDetail>>(
          QUERY_KEYS.CVE.detail(cveId),
          updatedData
        );
      }
      
      return { previousData };
    },
    onError: (error, variables, context) => {
      const { cveId, fieldName } = variables;
      logger.error('useUpdateCVEField', 'í•„ë“œ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨', { cveId, fieldName, error: error?.message });
      
      // ê¸°ë³¸ ì—ëŸ¬ ë©”ì‹œì§€ (optionsì— onErrorê°€ ì—†ì„ ê²½ìš°ì—ë§Œ)
      if (!optionsOnError) {
        enqueueSnackbar(`CVE í•„ë“œ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error?.message}`, { variant: 'error' });
      }
      
      // ì˜¤ë¥˜ ì‹œ ì´ì „ ìƒíƒœë¡œ ë¡¤ë°±
      if (context?.previousData) {
        logger.info('useUpdateCVEField', 'ì´ì „ ìƒíƒœë¡œ ë¡¤ë°±', { cveId });
        queryClient.setQueryData(
          QUERY_KEYS.CVE.detail(cveId),
          context.previousData
        );
      }
      
      // optionsì— onErrorê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ í˜¸ì¶œ
      if (optionsOnError) {
        optionsOnError(error, variables, context);
      }
    },
    onSuccess: (data, variables, context) => {
      const { cveId, fieldName } = variables;
      logger.info('useUpdateCVEField', 'í•„ë“œ ì—…ë°ì´íŠ¸ ì„±ê³µ', { cveId, fieldName });
      
      // ê¸°ë³¸ ì„±ê³µ ë©”ì‹œì§€ (optionsì— onSuccessê°€ ì—†ì„ ê²½ìš°ì—ë§Œ)
      if (!optionsOnSuccess) {
        enqueueSnackbar(`CVE ${fieldName} í•„ë“œê°€ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.`, { variant: 'success' });
      }
      
      // ìƒì„¸ ì •ë³´ ìºì‹œ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(QUERY_KEYS.CVE.detail(cveId), data);
      
      // ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™” (í•„ìš”í•œ ê²½ìš°)
      if (['status', 'severity', 'title'].includes(fieldName)) {
        logger.info('useUpdateCVEField', 'ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”', { reason: 'ì¤‘ìš” í•„ë“œ ë³€ê²½' });
        queryClient.invalidateQueries({ 
          queryKey: QUERY_KEYS.CVE.lists(),
          refetchType: 'active'
        });
      }
      
      // optionsì— onSuccessê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ í˜¸ì¶œ
      if (optionsOnSuccess) {
        optionsOnSuccess(data, variables, context);
      }
    },
    ...restOptions
  });
};

/**
 * CVE ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ mutation í›…
 * @param options - React Query ì˜µì…˜
 * @param customService - ì„ íƒì ìœ¼ë¡œ ì£¼ì…í•  ì„œë¹„ìŠ¤ ê°ì²´
 * @returns useMutation í›…ì—ì„œ ë°˜í™˜ë˜ëŠ” ê²°ê³¼ ê°ì²´
 */
export const useUpdateCVEStatus = (
  options: UseMutationOptions<
    ApiResponse<CVEDetail>, 
    ApiError, 
    UpdateCVEStatusParams
  > = {}, 
  customService = cveService
): UseMutationResult<
  ApiResponse<CVEDetail>, 
  ApiError, 
  UpdateCVEStatusParams
> => {
  const queryClient = useQueryClient();
  const { enqueueSnackbar } = useSnackbar();
  
  // optionsì—ì„œ onSuccessì™€ onError ì¶”ì¶œ
  const { onSuccess: optionsOnSuccess, onError: optionsOnError, ...restOptions } = options;
  
  return useMutation<ApiResponse<CVEDetail>, ApiError, UpdateCVEStatusParams>({
    mutationFn: ({ cveId, status }) => {
      logger.info('useUpdateCVEStatus', 'ìƒíƒœ ì—…ë°ì´íŠ¸ ìš”ì²­', { cveId, status });
      return customService.updateCVEStatus(cveId, status);
    },
    onSuccess: (data, variables, context) => {
      const { cveId } = variables;
      // CVE ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ 
        queryKey: QUERY_KEYS.CVE.lists(),
        refetchType: 'active'
      });
      // í•´ë‹¹ CVE ìƒì„¸ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: QUERY_KEYS.CVE.detail(cveId), refetchType: 'active' });
      
      // ê¸°ë³¸ ì„±ê³µ ë©”ì‹œì§€ (optionsì— onSuccessê°€ ì—†ì„ ê²½ìš°ì—ë§Œ)
      if (!optionsOnSuccess) {
        enqueueSnackbar('CVE ìƒíƒœê°€ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.', { variant: 'success' });
      }
      
      logger.info('useUpdateCVEStatus', 'ìƒíƒœ ì—…ë°ì´íŠ¸ ì„±ê³µ', { cveId, status: data.data?.status });
      
      // optionsì— onSuccessê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ í˜¸ì¶œ
      if (optionsOnSuccess) {
        optionsOnSuccess(data, variables, context);
      }
      
      return data;
    },
    onError: (error, variables, context) => {
      // ê¸°ë³¸ ì—ëŸ¬ ë©”ì‹œì§€ (optionsì— onErrorê°€ ì—†ì„ ê²½ìš°ì—ë§Œ)
      if (!optionsOnError) {
        enqueueSnackbar(`CVE ìƒíƒœ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error?.message}`, { variant: 'error' });
      }
      
      logger.error('useUpdateCVEStatus', 'ìƒíƒœ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', { error: error?.message });
      
      // optionsì— onErrorê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ í˜¸ì¶œ
      if (optionsOnError) {
        optionsOnError(error, variables, context);
      }
      
      throw error;
    },
    ...restOptions
  });
};

/**
 * WebSocketì„ í†µí•œ ì‹¤ì‹œê°„ CVE ì—…ë°ì´íŠ¸ ì²˜ë¦¬ í•¨ìˆ˜
 * ì™¸ë¶€ì—ì„œ socketIO ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë¡œ ì‚¬ìš©
 * @param queryClient - QueryClient ì¸ìŠ¤í„´ìŠ¤
 * @returns ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ í•¨ìˆ˜
 */
export const handleRealtimeCVEUpdate = (queryClient: QueryClient) => {
  // ìì£¼ ë°œìƒí•  ìˆ˜ ìˆëŠ” ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”ë¥¼ ë””ë°”ìš´ìŠ¤ ì²˜ë¦¬
  const debouncedInvalidateLists = debounce(() => {
    queryClient.invalidateQueries({ 
      queryKey: QUERY_KEYS.CVE.lists(),
      refetchType: 'active'
    });
  }, 300, { leading: true, trailing: true });

  // íŠ¹ì • CVE ìƒì„¸ ì •ë³´ ì¿¼ë¦¬ ë¬´íš¨í™”ë¥¼ ë””ë°”ìš´ìŠ¤ ì²˜ë¦¬
  const debouncedInvalidateDetail = debounce((cveId: string) => {
    queryClient.invalidateQueries({ 
      queryKey: QUERY_KEYS.CVE.detail(cveId), 
      refetchType: 'active' 
    });
  }, 300, { leading: true, trailing: true });

  return (event: RealtimeCVEUpdateEvent): void => {
    const { type, cveId } = event;
    
    logger.info('handleRealtimeCVEUpdate', 'ì´ë²¤íŠ¸ ìˆ˜ì‹ ', { type, cveId });
    
    // ì´ë²¤íŠ¸ íƒ€ì…ì— ë”°ë¼ ì ì ˆí•œ ì¿¼ë¦¬ ë¬´íš¨í™”
    switch (type) {
      case SOCKET_EVENTS.CVE_CREATED:
        debouncedInvalidateLists();
        break;
      case SOCKET_EVENTS.CVE_UPDATED:
        debouncedInvalidateLists();
        if (cveId) {
          debouncedInvalidateDetail(cveId);
        }
        break;
      case SOCKET_EVENTS.CVE_DELETED:
        debouncedInvalidateLists();
        if (cveId) {
          queryClient.removeQueries({ queryKey: QUERY_KEYS.CVE.detail(cveId) });
        }
        break;
      case SOCKET_EVENTS.CACHE_INVALIDATED:
        // ìºì‹œ ë¬´íš¨í™” ì´ë²¤íŠ¸ ì²˜ë¦¬
        debouncedInvalidateLists();
        if (cveId) {
          debouncedInvalidateDetail(cveId);
        } else {
          // íŠ¹ì • CVE IDê°€ ì—†ëŠ” ê²½ìš° ì „ì²´ CVE ê´€ë ¨ ì¿¼ë¦¬ ë¬´íš¨í™”
          queryClient.invalidateQueries({ 
            predicate: (query) => 
              query.queryKey[0] === QUERY_KEYS.CVE.all
          });
        }
        break;
      default:
        logger.warn('handleRealtimeCVEUpdate', 'ì•Œ ìˆ˜ ì—†ëŠ” ì´ë²¤íŠ¸ íƒ€ì…', { type });
        break;
    }
  };
};

// ì´ì „ ë²„ì „ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ë³„ì¹­
export const useCreateCVEMutation = useCreateCVE;
export const useUpdateCVEMutation = useUpdateCVE;
export const useDeleteCVEMutation = useDeleteCVE;
export const useUpdateCVEFieldMutation = useUpdateCVEField;
export const useUpdateCVEStatusMutation = useUpdateCVEStatus;

// ëª¨ë“  CVE ê´€ë ¨ mutation í›…ì„ ê¸°ë³¸ ë‚´ë³´ë‚´ê¸°ë¡œ ë¬¶ì–´ì„œ ì œê³µ
export default {
  useCreateCVE,
  useUpdateCVE,
  useDeleteCVE,
  useUpdateCVEField,
  useUpdateCVEStatus,
  handleRealtimeCVEUpdate,
  // ì´ì „ ë²„ì „ê³¼ì˜ í˜¸í™˜ì„±ì„ ìœ„í•œ ë³„ì¹­
  useCreateCVEMutation,
  useUpdateCVEMutation,
  useDeleteCVEMutation,
  useUpdateCVEFieldMutation,
  useUpdateCVEStatusMutation
};

/**
 * ì•ˆì „í•œ ì—ëŸ¬ ê°ì²´ ìƒì„± í—¬í¼ í•¨ìˆ˜
 * @param error - ì›ë³¸ ì—ëŸ¬ ê°ì²´
 * @returns ì•ˆì „í•˜ê²Œ ì²˜ë¦¬ëœ ì—ëŸ¬ ê°ì²´
 */
const ensureSafeErrorObject = (error: any): ApiError => {
  // ì´ë¯¸ cveServiceì—ì„œ ì²˜ë¦¬ëœ ì—ëŸ¬ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
  if (get(error, 'isHandled', false)) {
    return error as ApiError;
  }
  
  // ê¸°ë³¸ ì—ëŸ¬ ì‘ë‹µ ê°ì²´
  const defaultErrorResponse = { 
    status: 500, 
    data: { 
      detail: 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
      errorCode: 'UNKNOWN_ERROR'
    } 
  };
  
  // lodashì˜ getì„ ì‚¬ìš©í•˜ì—¬ ì•ˆì „í•˜ê²Œ ì†ì„±ì— ì ‘ê·¼
  const errorMessage = 
    get(error, 'response.data.detail') || 
    get(error, 'response.data.message') || 
    (get(error, 'message') && !get(error, 'message', '').includes('status code')) 
      ? get(error, 'message') 
      : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤';
  
  // ì—ëŸ¬ ê°ì²´ ì•ˆì „í•˜ê²Œ êµ¬ì„± (lodashì˜ mergeì™€ defaultsDeep ì‚¬ìš©)
  const safeError: ApiError = merge({}, error, {
    name: get(error, 'name', 'Error'),
    code: get(error, 'response.status', get(error, 'code', 500)),
    message: errorMessage,
    response: defaultsDeep({}, get(error, 'response'), defaultErrorResponse)
  });
  
  // response.dataê°€ ì—†ëŠ” ê²½ìš° ìƒì„±
  if (!get(safeError, 'response.data')) {
    set(safeError, 'response.data', {
      detail: safeError.message,
      errorCode: `HTTP_${get(safeError, 'response.status', 500)}`
    });
  }
  
  // detail í•„ë“œê°€ ì—†ëŠ” ê²½ìš° ìƒì„±
  if (!get(safeError, 'response.data.detail')) {
    set(safeError, 'response.data.detail', safeError.message);
  }
  
  // errorCode í•„ë“œê°€ ì—†ëŠ” ê²½ìš° ìƒì„±
  if (!get(safeError, 'response.data.errorCode')) {
    set(safeError, 'response.data.errorCode', `HTTP_${get(safeError, 'response.status', 500)}`);
  }
  
  return safeError;
};



============================================================
File: /home/CVEHub/frontend/src/features/cve/CVEDetailHeader.tsx
------------------------------------------------------------
// CVEDetailHeader.tsx

import React, { memo } from 'react';
// PropTypesëŠ” ë” ì´ìƒ í•„ìš” ì—†ìœ¼ë¯€ë¡œ ì œê±°í•©ë‹ˆë‹¤.
// import PropTypes from 'prop-types';
import {
  Box,
  Typography,
  Tooltip,
  Chip,
  IconButton,
} from '@mui/material';
import HistoryIcon from '@mui/icons-material/History';
import RefreshIcon from '@mui/icons-material/Refresh';
import CloseIcon from '@mui/icons-material/Close';
// SubscriberCount ì»´í¬ë„ŒíŠ¸ import (í™•ì¥ì ì—†ì´ ë˜ëŠ” .tsx)
import SubscriberCount from './SubscriberCount';
// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ë° ìƒìˆ˜ import (íƒ€ì… ì •ì˜ê°€ ë˜ì–´ ìˆë‹¤ê³  ê°€ì •)
import { formatDateTime, DATE_FORMATS } from 'shared/utils/dateUtils';
// Subscriber íƒ€ì… import
import { Subscriber, CVEDetailHeaderProps } from './types/cve';

// Props ì¸í„°í˜ì´ìŠ¤ëŠ” types/cve.tsì—ì„œ import í–ˆìœ¼ë¯€ë¡œ ì¤‘ë³µ ì •ì˜ ì œê±°

// React.memoì™€ í•¨ê»˜ íƒ€ì… ì ìš© (React.FC ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ë°©ì‹ ì„ í˜¸)
const CVEDetailHeader = memo((props: CVEDetailHeaderProps) => {
  const {
    cveId,
    subscribers,
    createdAt,
    lastModifiedAt,
    isCached,
    isLoading,
    onRefresh,
    onClose,
  } = props;

  return (
    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
      {/* ì¢Œì¸¡: CVE ID, êµ¬ë…ì ìˆ˜ */}
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
        {/* cveIdê°€ ìˆì„ ë•Œë§Œ í‘œì‹œ (optionalì´ë¯€ë¡œ) */}
        <Typography variant="h6">{cveId ? `${cveId} ìƒì„¸ ì •ë³´` : 'ìƒì„¸ ì •ë³´'}</Typography>
        {/* SubscriberCountì—ëŠ” subscribersì™€ cveId ì „ë‹¬ */}
        {/* subscribersê°€ undefinedì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë¹ˆ ë°°ì—´([]) ì „ë‹¬ */}
        <SubscriberCount subscribers={subscribers || []} cveId={cveId} />
      </Box>

      {/* ìš°ì¸¡: ì‹œê°„ ì •ë³´, ìºì‹œ ìƒíƒœ, ë²„íŠ¼ */}
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
        {/* ìƒì„± ì‹œê°„ (createdAtì´ ìˆì„ ë•Œë§Œ ë Œë”ë§ ë˜ëŠ” formatDateTimeì´ null/undefined ì²˜ë¦¬ ê°€ëŠ¥í•´ì•¼ í•¨) */}
        {createdAt && (
          <Tooltip title="ìƒì„± ì‹œê°„">
            <Chip
              size="small"
              icon={<HistoryIcon fontSize="small" />}
              // formatDateTimeì´ null/undefinedë¥¼ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬í•œë‹¤ê³  ê°€ì •
              label={`ìƒì„±: ${formatDateTime(createdAt, DATE_FORMATS.DISPLAY.DEFAULT)}`}
              variant="outlined"
              sx={{ fontSize: '0.7rem', height: 24 }}
            />
          </Tooltip>
        )}

        {/* ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„ (lastModifiedAtì´ ìˆì„ ë•Œë§Œ ë Œë”ë§) */}
        {lastModifiedAt && (
          <Tooltip title="ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„">
            <Chip
              size="small"
              icon={<HistoryIcon fontSize="small" />}
              label={`ìˆ˜ì •: ${formatDateTime(lastModifiedAt, DATE_FORMATS.DISPLAY.DEFAULT)}`}
              variant="outlined"
              sx={{ fontSize: '0.7rem', height: 24 }}
            />
          </Tooltip>
        )}

        {/* ìºì‹œ ìƒíƒœ */}
        {isCached && (
          <Tooltip title="ìºì‹œëœ ë°ì´í„°ì…ë‹ˆë‹¤. ìƒˆë¡œê³ ì¹¨ì„ í´ë¦­í•˜ì—¬ ìµœì‹  ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.">
            <Chip
              size="small"
              label="ìºì‹œë¨"
              color="warning"
              variant="outlined"
              sx={{ fontSize: '0.7rem', height: 24 }}
            />
          </Tooltip>
        )}

        {/* ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ */}
        <Tooltip title="ìƒˆë¡œê³ ì¹¨">
          <span> {/* Tooltipê³¼ disabled ë²„íŠ¼ í˜¸í™˜ì„± ìœ„í•œ span */}
            <IconButton onClick={onRefresh} disabled={isLoading}>
              <RefreshIcon />
            </IconButton>
          </span>
        </Tooltip>

        {/* ë‹«ê¸° ë²„íŠ¼ */}
        <Tooltip title="ë‹«ê¸°">
          <span> {/* Tooltipê³¼ disabled ë²„íŠ¼ í˜¸í™˜ì„± ìœ„í•œ span */}
            <IconButton onClick={onClose} disabled={isLoading}>
              <CloseIcon />
            </IconButton>
          </span>
        </Tooltip>
      </Box>
    </Box>
  );
});

// DisplayName ì„¤ì • (React DevToolsì—ì„œ ì»´í¬ë„ŒíŠ¸ ì´ë¦„ ì‹ë³„ ìš©ì´)
CVEDetailHeader.displayName = 'CVEDetailHeader';

// PropTypes ì •ì˜ëŠ” ì œê±°í•©ë‹ˆë‹¤.

export default CVEDetailHeader;


============================================================
File: /home/CVEHub/frontend/src/features/cve/CVEDetailTabs.tsx
------------------------------------------------------------
// CVEDetailTabs.tsx

import React, { useState, useCallback, memo, ReactNode, ElementType, useMemo } from 'react';
// PropTypesëŠ” ë” ì´ìƒ í•„ìš” ì—†ìœ¼ë¯€ë¡œ ì œê±°
// import PropTypes from 'prop-types';
import { Box, Tabs, Tab, Typography } from '@mui/material';
import { SvgIconComponent } from '@mui/icons-material'; // MUI ì•„ì´ì½˜ íƒ€ì…
import ScienceIcon from '@mui/icons-material/Science';
import ShieldIcon from '@mui/icons-material/Shield';
import LinkIcon from '@mui/icons-material/Link';
import CommentIcon from '@mui/icons-material/Comment';
import HistoryIcon from '@mui/icons-material/History';

// í•„ìš”í•œ ì»´í¬ë„ŒíŠ¸ import
import GenericDataTab from './components/GenericDataTab';
import CommentsTab from './components/CommentsTab';
import HistoryTab from './components/HistoryTab';

// CVE ê´€ë ¨ íƒ€ì… import
import { CVEDetailData, TabCounts, RefreshTriggers, CVEDetailTabsProps } from './types/cve';
import {
  pocTabConfig, // ì‹¤ì œ íƒ€ì… ì •ì˜ í•„ìš” (e.g., PocTabConfigType)
  snortRuleTabConfig, // ì‹¤ì œ íƒ€ì… ì •ì˜ í•„ìš”
  referenceTabConfig // ì‹¤ì œ íƒ€ì… ì •ì˜ í•„ìš”
} from './components/tabConfigs';

// íƒ€ì… ì •ì˜ëŠ” types/cve.tsë¡œ ì´ë™

// TabPanelWrapperì˜ Props íƒ€ì…
interface TabPanelWrapperProps {
  children: ReactNode;
  active: boolean;
  index: number;
  // Box ì»´í¬ë„ŒíŠ¸ì— ì „ë‹¬ë  ìˆ˜ ìˆëŠ” ë‹¤ë¥¸ ì†ì„±ë“¤ í—ˆìš©
  [key: string]: any; 
}

// íƒ­ í‚¤ íƒ€ì… (TabCountsì˜ í‚¤)
type TabKey = keyof TabCounts;

// íƒ­ êµ¬ì„± í•­ëª© íƒ€ì…
interface TabItemConfig {
  label: string;
  iconComponent: SvgIconComponent | ElementType;
  color: string;
  hoverColor: string;
  description: string;
  countKey: TabKey | null;
  component: React.ComponentType<any>;
  config: object | null;
};


// --- ìƒìˆ˜ ì •ì˜ ---

// tabItemsConfig íƒ€ì… ëª…ì‹œ
const tabItemsConfig: TabItemConfig[] = [
  { label: 'PoC', iconComponent: ScienceIcon, color: '#2196f3', hoverColor: '#1976d2', description: 'ì¦ëª… ì½”ë“œ ë° ì·¨ì•½ì  ê²€ì¦', countKey: 'poc', component: GenericDataTab, config: pocTabConfig },
  { label: 'Snort Rule', iconComponent: ShieldIcon, color: '#4caf50', hoverColor: '#388e3c', description: 'íƒì§€ ê·œì¹™ ë° ë°©ì–´ ì •ì±…', countKey: 'snortRule', component: GenericDataTab, config: snortRuleTabConfig },
  { label: 'Reference', iconComponent: LinkIcon, color: '#ff9800', hoverColor: '#f57c00', description: 'ê´€ë ¨ ë¬¸ì„œ ë° ì°¸ê³  ìë£Œ', countKey: 'reference', component: GenericDataTab, config: referenceTabConfig },
  { label: 'Comments', iconComponent: CommentIcon, color: '#9c27b0', hoverColor: '#7b1fa2', description: 'í† ë¡  ë° ì˜ê²¬ ê³µìœ ', countKey: 'comments', component: CommentsTab, config: null },
  { label: 'History', iconComponent: HistoryIcon, color: '#757575', hoverColor: '#757575', description: 'ìˆ˜ì • ì´ë ¥', countKey: null, component: HistoryTab, config: null }
];

// --- ì»´í¬ë„ŒíŠ¸ êµ¬í˜„ ---

// íƒ­ íŒ¨ë„ Wrapper ì»´í¬ë„ŒíŠ¸
const TabPanelWrapper = memo(({ children, active, index, ...other }: TabPanelWrapperProps) => (
  <Box
    sx={{
      display: active ? 'block' : 'none',
      height: '100%',
      p: 3,
      overflowY: 'auto',
      '&::-webkit-scrollbar': { width: '8px', backgroundColor: 'transparent' },
      '&::-webkit-scrollbar-thumb': { backgroundColor: 'rgba(0, 0, 0, 0.1)', borderRadius: '4px', '&:hover': { backgroundColor: 'rgba(0, 0, 0, 0.2)' } }
    }}
    role="tabpanel"
    hidden={!active} // activeê°€ falseì¼ ë•Œ ìˆ¨ê¹€
    id={`tabpanel-${index}`}
    aria-labelledby={`tab-${index}`}
    {...other} // ë‹¤ë¥¸ props ì „ë‹¬ (ì˜ˆ: sx)
  >
    {/* activeì¼ ë•Œë§Œ childrenì„ ë Œë”ë§í•˜ë„ë¡ ìµœì í™” */}
    {active && children}
  </Box>
));
TabPanelWrapper.displayName = 'TabPanelWrapper'; // DevTools ì´ë¦„ ì„¤ì •

// ë©”ì¸ íƒ­ ì»´í¬ë„ŒíŠ¸
const CVEDetailTabs = memo((props: CVEDetailTabsProps) => {
  const {
    cveData,
    currentUser,
    refreshTriggers,
    tabCounts,
    onCountChange,
    parentSendMessage,
    highlightCommentId,
  } = props;

  const [activeTab, setActiveTab] = useState<number>(0);

  // íƒ­ ë³€ê²½ í•¸ë“¤ëŸ¬ - ì˜ì¡´ì„± ë°°ì—´ ìµœì í™”
  const handleTabChange = useCallback((_event: React.SyntheticEvent, newValue: number) => {
    setActiveTab(newValue);
  }, []);

  // íƒ­ ì¹´ìš´íŠ¸ ë³€ê²½ í•¸ë“¤ëŸ¬ - êµ¬ì²´ì ì¸ íƒ­ì— ëŒ€í•œ ë³€ê²½ì„ ì²˜ë¦¬í•˜ë„ë¡ ìµœì í™”
  const handleTabSpecificCountChange = useCallback((tabKey: TabKey) => {
    return (count: number) => {
      // ìƒìœ„ ì»´í¬ë„ŒíŠ¸ì— ì „ë‹¬ëœ ì½œë°±ì— ë³€ê²½ì‚¬í•­ í†µë³´
      if (onCountChange) {
        onCountChange(tabKey, count);
      }
    };
  }, [onCountChange]);

  // cveDataë¥¼ cveë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ë‚´ë¶€ ì»´í¬ë„ŒíŠ¸ì— ì „ë‹¬í•˜ë¯€ë¡œ, ì¼ê´€ì„±ì„ ìœ„í•´ ë³€ìˆ˜ ì¤€ë¹„
  const commonProps = useMemo(() => ({
    cve: cveData,
    currentUser: currentUser ?? undefined,
    parentSendMessage,
  }), [cveData, currentUser, parentSendMessage]);

  return (
    <Box sx={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden', bgcolor: 'background.paper' }}>
      {/* íƒ­ í—¤ë” */}
      <Tabs
        value={activeTab}
        onChange={handleTabChange}
        variant="fullWidth"
        sx={{
          borderBottom: 1,
          borderColor: 'divider',
          bgcolor: 'background.paper',
          flexShrink: 0,
        }}
        aria-label="CVE Detail Tabs"
      >
        {tabItemsConfig.map((tab, index) => {
          // countKeyê°€ nullì´ ì•„ë‹ˆê³ , tabCountsì— í•´ë‹¹ í‚¤ê°€ ìˆëŠ”ì§€ í™•ì¸
          const count = tab.countKey && tabCounts.hasOwnProperty(tab.countKey) ? tabCounts[tab.countKey] : undefined;
          const labelText = count !== undefined ? `${tab.label} (${count})` : tab.label;

          return (
            <Tab
              key={tab.label}
              label={
                <Box sx={{ textAlign: 'center', py: 1 }}>
                  <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 1, mb: 0.5 }}>
                    {/* ì•„ì´ì½˜ ì»´í¬ë„ŒíŠ¸ ìƒì„± */}
                    {React.createElement(tab.iconComponent, { sx: { fontSize: 20 } })}
                    <Typography component="span" sx={{ fontSize: '0.9rem' }}>
                      {labelText}
                    </Typography>
                  </Box>
                  <Typography variant="caption" color="text.secondary" sx={{ display: 'block' }}>
                    {tab.description}
                  </Typography>
                </Box>
              }
              sx={{
                minHeight: 72,
                textTransform: 'none',
                fontWeight: 500,
                color: activeTab === index ? tab.color : 'text.primary',
                opacity: 1,
                '&:hover': {
                  color: tab.hoverColor,
                  bgcolor: 'action.hover'
                },
                '&.Mui-selected': {
                  color: tab.color,
                  fontWeight: 600,
                },
                '&.Mui-focusVisible': {
                  backgroundColor: 'action.focus'
                }
              }}
              id={`tab-${index}`}
              aria-controls={`tabpanel-${index}`}
            />
          );
        })}
      </Tabs>

      {/* íƒ­ ì»¨í…ì¸  ì˜ì—­ */}
      <Box sx={{ flex: 1, overflow: 'hidden', bgcolor: 'background.paper' }}>
        {tabItemsConfig.map((tab, index) => {
          // ê° íƒ­ ì»´í¬ë„ŒíŠ¸ì— ì „ë‹¬ë  ê³µí†µ Props
          // currentUserê°€ nullì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ëª…ì‹œì  ì²˜ë¦¬
          let tabSpecificProps: Record<string, any> = {};

          if (tab.component === GenericDataTab && tab.countKey) {
            tabSpecificProps = {
              // refreshTriggersê°€ undefinedì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ optional chaining ë° ê¸°ë³¸ê°’ 0 ì‚¬ìš©
              refreshTrigger: refreshTriggers?.[tab.countKey] ?? 0,
              // íƒ­ì— í•´ë‹¹í•˜ëŠ” ì„¤ì • ê°ì²´ ì „ë‹¬
              tabConfig: tab.config,
              onCountChange: handleTabSpecificCountChange(tab.countKey),
            };
          } else if (tab.component === CommentsTab) {
            tabSpecificProps = {
              refreshTrigger: refreshTriggers?.comments ?? 0,
              onCountChange: handleTabSpecificCountChange('comments'),
              // highlightCommentIdê°€ nullì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ?? undefined ì‚¬ìš©
              highlightCommentId: highlightCommentId ?? undefined,
            };
          } else if (tab.component === HistoryTab) {
            tabSpecificProps = {
              // cveData.modificationHistoryê°€ ì—†ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë¹ˆ ë°°ì—´([]) ì „ë‹¬
              modificationHistory: cveData?.modificationHistory || [],
            };
          }

          // ìµœì¢… Props ê°ì²´ ê²°í•©
          const finalProps = { ...commonProps, ...tabSpecificProps };

          return (
            <TabPanelWrapper key={tab.label} active={activeTab === index} index={index}>
              {/* React.createElement ì‚¬ìš© ì‹œ íƒ€ì… ì£¼ì˜ */}
              {React.createElement(tab.component, finalProps)}
            </TabPanelWrapper>
          );
        })}
      </Box>
    </Box>
  );
});

CVEDetailTabs.displayName = 'CVEDetailTabs'; // DevTools ì´ë¦„ ì„¤ì •

// PropTypesëŠ” ì œê±°

export default CVEDetailTabs;


============================================================
File: /home/CVEHub/frontend/src/features/cve/SubscriberCount.tsx
------------------------------------------------------------
import React, { memo, useMemo, useEffect } from 'react';
import {
  Box,
  Typography,
  Tooltip,
  AvatarGroup,
  Avatar,
} from '@mui/material';
import VisibilityIcon from '@mui/icons-material/Visibility';
import { Subscriber, SubscriberCountProps } from './types/cve';

// SubscriberCount ì»´í¬ë„ŒíŠ¸ (ê¸°ì¡´ CVEDetailì—ì„œ ë¶„ë¦¬)
const SubscriberCount = memo(({ subscribers = [], cveId }: SubscriberCountProps) => {
  // ë””ë²„ê¹…ìš© ë¡œê·¸ ì¶”ê°€
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      console.debug('SubscriberCount ë Œë”ë§:', {
        cveId,
        subscribersCount: subscribers?.length || 0,
        subscribers
      });
    }
  }, [subscribers, cveId]);

  // ìœ íš¨í•œ êµ¬ë…ìë§Œ í•„í„°ë§ (ê°œì„ ëœ ë²„ì „)
  const validSubscribers = useMemo(() => {
    if (!Array.isArray(subscribers)) return [];
    
    return subscribers
      .filter(sub => sub && typeof sub === 'object')
      .map(sub => ({
        ...sub,
        id: sub.id || sub.userId || '',
        userId: sub.userId || sub.id || '',
        username: sub.username || 'User',
        displayName: sub.displayName || sub.username || 'User',
        profileImage: sub.profileImage || sub.profile_image || ''
      }))
      .filter(sub => sub.id || sub.userId); // IDê°€ ìˆëŠ” ê²½ìš°ë§Œ ìœ íš¨
  }, [subscribers]);
  
  const hasSubscribers = validSubscribers.length > 0;

  return (
    <Box
      sx={{
        display: 'flex',
        alignItems: 'center',
        gap: 1,
        bgcolor: 'action.hover',
        borderRadius: 2,
        py: 0.5,
        px: 1.5
      }}
    >
      <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
        <VisibilityIcon
          sx={{
            fontSize: 16,
            color: 'text.secondary'
          }}
        />
        <Typography variant="body2" color="text.secondary">
          {hasSubscribers ? `${validSubscribers.length}ëª…ì´ ë³´ëŠ” ì¤‘` : 'ë³´ëŠ” ì¤‘'}
        </Typography>
      </Box>
      {hasSubscribers && (
        <AvatarGroup
          max={5}
          sx={{
            '& .MuiAvatar-root': {
              width: 24,
              height: 24,
              fontSize: '0.75rem',
              border: '2px solid #fff',
              cursor: 'pointer',
              transition: 'all 0.2s ease-in-out',
              '&:hover': {
                transform: 'scale(1.1)',
                zIndex: 1
              }
            }
          }}
        >
          {validSubscribers.map((subscriber, index) => {
            // êµ¬ë…ì ì •ë³´ ì¶”ì¶œ ë° ê²€ì¦
            const key = subscriber.id || subscriber.userId || `subscriber-${index}`;
            const username = subscriber.displayName || subscriber.username || 'ì‚¬ìš©ì';
            const profileImage = subscriber.profileImage || subscriber.profile_image || '';
            const hasProfileImage = Boolean(profileImage && profileImage.length > 0);

            return (
              <Tooltip
                key={key}
                title={username}
                placement="bottom"
                arrow
                enterDelay={200}
                leaveDelay={0}
              >
                <Avatar
                  alt={username}
                  src={hasProfileImage ? profileImage : undefined}
                  sx={{
                    bgcolor: !hasProfileImage ?
                      `hsl(${(username.length * 30) % 360}, 70%, 50%)` : // ì´ë¦„ ê¸°ë°˜ ìƒ‰ìƒ
                      undefined
                  }}
                >
                  {/* í”„ë¡œí•„ ì´ë¯¸ì§€ ì—†ì„ ë•Œ ì²« ê¸€ì í‘œì‹œ */}
                  {!hasProfileImage && (username.charAt(0) || 'U').toUpperCase()}
                </Avatar>
              </Tooltip>
            );
          })}
        </AvatarGroup>
      )}
    </Box>
  );
});

// ì»´í¬ë„ŒíŠ¸ ì´ë¦„ ì§€ì • (ë””ë²„ê¹…ìš©)
SubscriberCount.displayName = 'SubscriberCount';

export default SubscriberCount;


============================================================
File: /home/CVEHub/frontend/src/features/activities/pages/ActivitiesPage.jsx
------------------------------------------------------------
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { 
  Container, 
  Typography, 
  Box, 
  Paper,
  Divider,
  Fade,
  Alert,
  Backdrop,
  CircularProgress
} from '@mui/material';
import { Helmet } from 'react-helmet-async';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { useActivityQuery } from '../hooks/useActivityQuery';
import ActivityList from '../components/ActivityList';
import ActivitiesFilter from '../components/ActivitiesFilter';
import useSocket from 'core/socket/hooks/useSocket';
import { useQueryClient } from '@tanstack/react-query';

/**
 * ê°œì„ ëœ ì‚¬ìš©ì í™œë™ ì´ë ¥ í˜ì´ì§€ ì»´í¬ë„ŒíŠ¸
 * - ì‘ë‹µí˜• ë””ìì¸ ê°œì„ 
 * - ë¡œë”© ìƒíƒœ ê°œì„ 
 * - ì„±ëŠ¥ ìµœì í™”
 * 
 * @returns {JSX.Element} ë Œë”ë§ëœ ì»´í¬ë„ŒíŠ¸
 */
const ActivitiesPage = () => {
  
  /** @type {Object} í˜„ì¬ ì¸ì¦ëœ ì‚¬ìš©ì ì •ë³´ */
  const { user } = useAuth();
  
  /** @type {string} í˜„ì¬ ì‚¬ìš©ìì˜ ì‚¬ìš©ìëª… */
  const username = user?.username || '';
  
  /**
   * í•„í„° ìƒíƒœ ê´€ë¦¬
   * @type {[Object, function]} í•„í„° ìƒíƒœì™€ ìƒíƒœ ë³€ê²½ í•¨ìˆ˜
   */
  const [filters, setFilters] = useState({
    username: username, // ê¸°ë³¸ê°’ìœ¼ë¡œ í˜„ì¬ ì‚¬ìš©ì ì„¤ì •
    page: 1,
    limit: 10,
    action: '',
    target_type: '',
    target_id: '',
    start_date: null,
    end_date: null
  });

  // ìƒíƒœ ë³€ê²½ ê°ì§€ìš© ì´ˆê¸° ë§ˆìš´íŠ¸ í”Œë˜ê·¸
  const [initialLoad, setInitialLoad] = useState(true);

  /**
   * í•„í„° ìƒíƒœ ë³€ê²½ ì‹œ í˜ì´ì§€ ë¦¬ì…‹
   * ì‚¬ìš©ìê°€ í•„í„°ë¥¼ ë³€ê²½í•  ë•Œë§ˆë‹¤ í˜ì´ì§€ë¥¼ 1ë¡œ ë¦¬ì…‹í•˜ì—¬
   * í•„í„°ë§ëœ ê²°ê³¼ì˜ ì²« í˜ì´ì§€ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.
   */
  useEffect(() => {
    if (initialLoad) {
      setInitialLoad(false);
      return;
    }
    
    // í˜ì´ì§€ ë³€ê²½ì´ ì•„ë‹Œ ë‹¤ë¥¸ í•„í„° ë³€ê²½ ì‹œì—ë§Œ í˜ì´ì§€ ë²ˆí˜¸ ì´ˆê¸°í™”
    // í•„í„° ë³€ê²½ ì‹œ í˜ì´ì§€ ë²ˆí˜¸ë¥¼ 1ë¡œ ë¦¬ì…‹
    setFilters(prev => ({ ...prev, page: 1 }));
  }, [filters.action, filters.target_type, filters.target_id, filters.username, filters.start_date, filters.end_date, initialLoad]);

  /**
   * ì‚¬ìš©ì ë³€ê²½ ì‹œ í•„í„° ì—…ë°ì´íŠ¸
   * ë¡œê·¸ì¸ ìƒíƒœê°€ ë³€ê²½ë˜ë©´ í•„í„°ì˜ ì‚¬ìš©ìëª…ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
   */
  useEffect(() => {
    if (username && initialLoad) {
      setFilters(prev => ({ ...prev, username }));
    }
  }, [username, initialLoad]);

  /**
   * í™œë™ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
   * useActivityQuery í›…ì„ ì‚¬ìš©í•˜ì—¬ ì„ íƒëœ í•„í„°ì— ë”°ë¼ í™œë™ ë°ì´í„°ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
   */
  const { 
    data, 
    isLoading, 
    isRefetching,
    error, 
    refetch 
  } = useActivityQuery(filters);

  // ë¡œë”© ì¤‘ ìƒíƒœ - ì²« ë¡œë”©ê³¼ ë¦¬í˜ì¹­ êµ¬ë¶„
  const isFullPageLoading = isLoading && !isRefetching;
  const isRefreshLoading = !isLoading && isRefetching;

  // queryClient ì„ ì–¸ì€ ìœ ì§€í•˜ì§€ë§Œ ë°°ê²½ì—ì„œ ìë™ìœ¼ë¡œ ë°ì´í„°ë¥¼ ê°±ì‹ í•˜ëŠ” ì½”ë“œëŠ” ì œê±°
  // ì‚¬ìš©ìê°€ ìˆ˜ë™ìœ¼ë¡œ ìƒˆë¡œê³ ì¹¨í•  ë•Œë§Œ ë°ì´í„°ê°€ ê°±ì‹ ë¨
  const queryClient = useQueryClient();

  /**
   * í•„í„° ë³€ê²½ í•¸ë“¤ëŸ¬
   * 
   * @param {Object} newFilters - ìƒˆë¡œìš´ í•„í„° ê°’
   */
  const handleFilterChange = (newFilters) => {
    setFilters(newFilters);
  };

  /**
   * í•„í„° ì ìš© í•¸ë“¤ëŸ¬
   */
  const handleFilterApply = () => {
    refetch();
  };

  /**
   * í•„í„° ì´ˆê¸°í™” í•¸ë“¤ëŸ¬
   */
  const handleFilterReset = () => {
    setFilters({
      username: username, // í˜„ì¬ ë¡œê·¸ì¸í•œ ì‚¬ìš©ìë¡œ ì„¤ì •
      page: 1,
      limit: 10,
      action: '',
      target_type: '',
      target_id: '',
      start_date: null,
      end_date: null
    });
    
    // ì´ˆê¸°í™” í›„ ë°”ë¡œ ë°ì´í„° ë‹¤ì‹œ ë¶ˆëŸ¬ì˜¤ê¸°
    setTimeout(() => refetch(), 0);
  };

  /**
   * í˜ì´ì§€ ë³€ê²½ í•¸ë“¤ëŸ¬
   * 
   * @param {number} newPage - ìƒˆë¡œìš´ í˜ì´ì§€ ë²ˆí˜¸
   */
  const handlePageChange = (newPage) => {
    setFilters(prev => ({ ...prev, page: newPage }));
  };

  /**
   * í˜ì´ì§€ë‹¹ í•­ëª© ìˆ˜ ë³€ê²½ í•¸ë“¤ëŸ¬
   * 
   * @param {number} newLimit - ìƒˆë¡œìš´ í˜ì´ì§€ë‹¹ í•­ëª© ìˆ˜
   */
  const handleLimitChange = (newLimit) => {
    setFilters(prev => ({ ...prev, limit: newLimit, page: 1 }));
  };
  
  // í˜„ì¬ ì ìš©ëœ í™œë™ íƒ€ì…ì— ë”°ë¥¸ ì œëª© í…ìŠ¤íŠ¸
  const titleText = useMemo(() => {
    if (filters.username === username) {
      return 'ë‚´ í™œë™';
    } else if (filters.username) {
      const selectedUser = data?.users?.find(u => u.username === filters.username);
      const displayName = selectedUser ? (selectedUser.display_name || selectedUser.username) : filters.username;
      return `${displayName}ë‹˜ì˜ í™œë™`;
    } else {
      return 'ëª¨ë“  í™œë™';
    }
  }, [filters.username, username, data?.users]);

  return (
    <>
      <Helmet>
        <title>í™œë™ ì´ë ¥ | CVEHub</title>
      </Helmet>
      
      {/* ì „ì²´ í˜ì´ì§€ ë¡œë”© ì¸ë””ì¼€ì´í„° */}
      <Backdrop
        sx={{ color: '#fff', zIndex: (theme) => theme.zIndex.drawer + 1 }}
        open={isFullPageLoading}
      >
        <CircularProgress color="inherit" />
      </Backdrop>
      
      <Container maxWidth="lg" sx={{ mt: { xs: 2, sm: 4 }, mb: 4 }}>
        {/* í˜ì´ì§€ íƒ€ì´í‹€ */}
        <Box sx={{ mb: { xs: 2, sm: 3 } }}>
          <Typography variant="h4" component="h1" gutterBottom>
            í™œë™ ì´ë ¥
          </Typography>
          <Typography variant="body1" color="text.secondary">
            CVEHubì—ì„œì˜ ì‚¬ìš©ì í™œë™ ë‚´ì—­ì„ í™•ì¸í•˜ì„¸ìš”. í•„í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ íŠ¹ì • ì‚¬ìš©ì, ê¸°ê°„, í™œë™ ìœ í˜• ë“±ìœ¼ë¡œ ê²€ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          </Typography>
        </Box>

        {/* í•„í„° ì˜ì—­ */}
        <Box sx={{ mb: { xs: 2, sm: 3 } }}>
          <ActivitiesFilter 
            filters={filters}
            onFilterChange={handleFilterChange}
            onFilterApply={handleFilterApply}
            onFilterReset={handleFilterReset}
          />
        </Box>

        {/* ë¦¬í”„ë ˆì‹œ ì¤‘ ì•Œë¦¼ */}
        {isRefreshLoading && (
          <Fade in={isRefreshLoading}>
            <Alert 
              severity="info" 
              sx={{ mb: 2 }}
              icon={<CircularProgress size={20} />}
            >
              ë°ì´í„°ë¥¼ ê°±ì‹  ì¤‘ì…ë‹ˆë‹¤...
            </Alert>
          </Fade>
        )}

        {/* í™œë™ ëª©ë¡ ì˜ì—­ */}
        <Paper sx={{ p: { xs: 2, sm: 3 } }}>
          <Box sx={{ mb: 2 }}>
            <Typography variant="h6" component="h2">
              {titleText}
            </Typography>
            <Divider sx={{ my: 1 }} />
          </Box>
          
          <ActivityList 
            activities={data?.items || []}
            total={data?.total || 0}
            page={filters.page}
            limit={filters.limit}
            isLoading={isLoading || isRefetching}
            error={error}
            onPageChange={handlePageChange}
            onLimitChange={handleLimitChange}
          />
        </Paper>
      </Container>
    </>
  );
};

export default React.memo(ActivitiesPage);


============================================================
File: /home/CVEHub/frontend/src/features/activities/components/ActivitiesFilter.jsx
------------------------------------------------------------
import React, { useState, useEffect, useMemo } from 'react';
import { 
  Box, 
  Grid, 
  TextField, 
  InputAdornment,
  FormControl, 
  InputLabel, 
  Select, 
  MenuItem, 
  Button,
  Chip,
  Stack,
  Typography,
  Paper,
  Divider,
  IconButton,
  Tooltip,
  useMediaQuery,
  useTheme,
  CircularProgress,
  Collapse,
  Autocomplete,
  Fade
} from '@mui/material';
import FilterListIcon from '@mui/icons-material/FilterList';
import ClearIcon from '@mui/icons-material/Clear';
import PersonIcon from '@mui/icons-material/Person';
import PublicIcon from '@mui/icons-material/Public';
import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import DateRangeIcon from '@mui/icons-material/DateRange';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import SearchIcon from '@mui/icons-material/Search';
import CategoryIcon from '@mui/icons-material/Category';
import TargetIcon from '@mui/icons-material/Adjust';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { ko } from 'date-fns/locale';
import { format, subDays, subMonths } from 'date-fns';
import { useAuth } from 'features/auth/contexts/AuthContext';
import { useUsers } from 'features/auth/hooks/useUsersQuery';

// ë™ì‘ ìœ í˜• ëª©ë¡ (ê°„ì†Œí™”ë¨)
const actionOptions = [
  { value: 'create', label: 'ìƒì„±' },
  { value: 'update', label: 'ìˆ˜ì •' },
  { value: 'add', label: 'ì¶”ê°€' },
  { value: 'delete', label: 'ì‚­ì œ' }
];

// ëŒ€ìƒ ìœ í˜• ëª©ë¡
const targetTypeOptions = [
  { value: 'cve', label: 'CVE' },
  { value: 'poc', label: 'PoC' },
  { value: 'snort_rule', label: 'Snort ê·œì¹™' },
  { value: 'reference', label: 'ì°¸ì¡°ë¬¸ì„œ' },
  { value: 'comment', label: 'ëŒ“ê¸€' },
  { value: 'user', label: 'ì‚¬ìš©ì' },
  { value: 'system', label: 'ì‹œìŠ¤í…œ' }
];

/**
 * ê°œì„ ëœ í™œë™ í•„í„°ë§ ì»´í¬ë„ŒíŠ¸
 * - ì§ê´€ì ì¸ UIë¡œ ê°„ì†Œí™”
 * - ëª¨ë°”ì¼ ëŒ€ì‘ ê°•í™”
 * - í†µí•© ê²€ìƒ‰ë°” ì¶”ê°€
 * 
 * @param {Object} props ì»´í¬ë„ŒíŠ¸ ì†ì„±
 * @param {Object} props.filters í˜„ì¬ í•„í„° ê°’
 * @param {Function} props.onFilterChange í•„í„° ë³€ê²½ í•¸ë“¤ëŸ¬
 * @param {Function} props.onFilterApply í•„í„° ì ìš© í•¸ë“¤ëŸ¬
 * @param {Function} props.onFilterReset í•„í„° ì´ˆê¸°í™” í•¸ë“¤ëŸ¬
 * @returns {JSX.Element} ë Œë”ë§ëœ ì»´í¬ë„ŒíŠ¸
 */
const ActivitiesFilter = ({ filters, onFilterChange, onFilterApply, onFilterReset }) => {
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const theme = useTheme();
  // PC í™˜ê²½ì— ìµœì í™”
  const isTablet = useMediaQuery(theme.breakpoints.down('md'));
  const { user } = useAuth();
  const currentUsername = user?.username || '';
  
  // ì‚¬ìš©ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
  const { data: usersData, isLoading: isLoadingUsers } = useUsers();
  const users = usersData?.items || [];
  
  // ì ìš©ëœ í•„í„° ê°œìˆ˜ ê³„ì‚°
  const appliedFiltersCount = useMemo(() => {
    let count = 0;
    if (filters.target_type && filters.target_type.length > 0) count += filters.target_type.length;
    if (filters.target_id) count++;
    if (filters.action && filters.action.length > 0) count += filters.action.length;
    if (filters.start_date) count++;
    if (filters.end_date) count++;
    if (filters.username && filters.username !== currentUsername) count++;
    return count;
  }, [filters, currentUsername]);

  // ê²€ìƒ‰ì–´ ì ìš© (target_idë‚˜ ëŒ€ìƒ ê²€ìƒ‰ì— í™œìš©)
  useEffect(() => {
    if (searchTerm.trim()) {
      // ê²€ìƒ‰ì–´ê°€ CVE í˜•ì‹ì¸ì§€ í™•ì¸ (CVE-YYYY-NNNNN)
      if (/^CVE-\d{4}-\d{4,}$/i.test(searchTerm.trim())) {
        onFilterChange({
          ...filters,
          target_type: 'cve',
          target_id: searchTerm.trim()
        });
      } else {
        onFilterChange({
          ...filters,
          target_id: searchTerm.trim()
        });
      }
    } else if (filters.target_id && !searchTerm) {
      // ê²€ìƒ‰ì–´ê°€ ì§€ì›Œì¡Œì„ ë•Œ target_id í•„í„° ì œê±°
      onFilterChange({
        ...filters,
        target_id: ''
      });
    }
  }, [searchTerm]);

  // í•„í„° ë³€ê²½ í•¸ë“¤ëŸ¬ (ì¦‰ì‹œ ì ìš©)
  const handleQuickFilterChange = (field, value) => {
    let newValue = value;
    
    // ë°°ì—´ í•„ë“œ ì²˜ë¦¬ (ë™ì‘ ìœ í˜•, ëŒ€ìƒ ìœ í˜•)
    if (field === 'action' || field === 'target_type') {
      if (Array.isArray(filters[field])) {
        // ì´ë¯¸ ê°’ì´ ìˆëŠ”ì§€ í™•ì¸
        const index = filters[field].indexOf(value);
        
        if (index === -1) {
          // ê°’ì´ ì—†ìœ¼ë©´ ì¶”ê°€
          newValue = [...filters[field], value];
        } else {
          // ê°’ì´ ìˆìœ¼ë©´ ì œê±°
          newValue = filters[field].filter(item => item !== value);
        }
      } else {
        // ë°°ì—´ì´ ì•„ë‹Œ ê²½ìš° ë°°ì—´ë¡œ ë³€í™˜
        newValue = [value];
      }
    }
    
    const newFilters = {
      ...filters,
      [field]: newValue
    };
    onFilterChange(newFilters);
    onFilterApply();
  };

  // í•„í„° ë³€ê²½ í•¸ë“¤ëŸ¬ (ì ìš© ë²„íŠ¼ í•„ìš”)
  const handleAdvancedFilterChange = (field, value) => {
    onFilterChange({
      ...filters,
      [field]: value
    });
  };

  // í¼ ì œì¶œ í•¸ë“¤ëŸ¬
  const handleSubmit = (e) => {
    e.preventDefault();
    onFilterApply();
  };

  // ë‚ ì§œ í˜•ì‹ í¬ë§·íŒ…
  const formatDateForDisplay = (date) => {
    if (!date) return '';
    return format(new Date(date), 'yyyy-MM-dd');
  };
  
  // í˜„ì¬ ë‚ ì§œ
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  // ê¸°ê°„ í…ìŠ¤íŠ¸ ê³„ì‚°
  const getPeriodText = () => {
    if (!filters.start_date || !filters.end_date) {
      return null;
    }
    
    const start = new Date(filters.start_date);
    const end = new Date(filters.end_date);
    
    // ì˜¤ëŠ˜ì¸ì§€ í™•ì¸
    const isToday = (date) => {
      const today = new Date();
      return date.getDate() === today.getDate() && 
             date.getMonth() === today.getMonth() && 
             date.getFullYear() === today.getFullYear();
    };
    
    // ì˜¤ëŠ˜ í•„í„° í™•ì¸
    if (start.getDate() === end.getDate() && 
        start.getMonth() === end.getMonth() && 
        start.getFullYear() === end.getFullYear() && 
        isToday(end)) {
      return "ì˜¤ëŠ˜";
    }
    
    // ìµœê·¼ 7ì¼ í•„í„° í™•ì¸
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    sevenDaysAgo.setHours(0, 0, 0, 0);
    
    if (Math.abs(start.getTime() - sevenDaysAgo.getTime()) < 86400000 && isToday(end)) {
      return "ìµœê·¼ 7ì¼";
    }
    
    // ìµœê·¼ 30ì¼ í•„í„° í™•ì¸
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    thirtyDaysAgo.setHours(0, 0, 0, 0);
    
    if (Math.abs(start.getTime() - thirtyDaysAgo.getTime()) < 86400000 && isToday(end)) {
      return "ìµœê·¼ 30ì¼";
    }
    
    // ì‚¬ìš©ì ì§€ì • ê¸°ê°„
    return `${formatDateForDisplay(start)} ~ ${formatDateForDisplay(end)}`;
  };

  // ë¹ ë¥¸ í•„í„° ì„¤ì • í•¨ìˆ˜ë“¤
  const handleSetToday = () => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const endOfDay = new Date();
    endOfDay.setHours(23, 59, 59, 999);
    
    // ë‘ í•„í„°ë¥¼ í•œë²ˆì— ë³€ê²½í•˜ê³  í•œë²ˆë§Œ API í˜¸ì¶œí•˜ë„ë¡
    onFilterChange({
      ...filters,
      start_date: today,
      end_date: endOfDay
    });
    onFilterApply();
  };

  const handleSetLastWeek = () => {
    const oneWeekAgo = subDays(new Date(), 7);
    oneWeekAgo.setHours(0, 0, 0, 0);
    const endOfDay = new Date();
    endOfDay.setHours(23, 59, 59, 999);
    
    onFilterChange({
      ...filters,
      start_date: oneWeekAgo,
      end_date: endOfDay
    });
    onFilterApply();
  };

  const handleSetLastMonth = () => {
    const oneMonthAgo = subMonths(new Date(), 1);
    oneMonthAgo.setHours(0, 0, 0, 0);
    const endOfDay = new Date();
    endOfDay.setHours(23, 59, 59, 999);
    
    onFilterChange({
      ...filters,
      start_date: oneMonthAgo,
      end_date: endOfDay
    });
    onFilterApply();
  };

  const handleSetMyActivities = () => {
    handleQuickFilterChange('username', currentUsername);
  };

  const handleSetAllActivities = () => {
    handleQuickFilterChange('username', null);
  };

  // í˜„ì¬ ì ìš©ëœ í•„í„° ì¹© ë Œë”ë§
  const renderFilterChips = () => {
    const chips = [];

    // ì‚¬ìš©ì í•„í„° ì¹© ì¶”ê°€
    if (filters.username) {
      let userLabel = "";
      if (filters.username === currentUsername) {
        userLabel = "ë‚´ í™œë™";
      } else if (filters.username === "system") {
        userLabel = "ì‹œìŠ¤í…œ";
      } else {
        const selectedUser = users.find(u => u.username === filters.username);
        userLabel = selectedUser ? (selectedUser.display_name || selectedUser.username) : filters.username;
      }
      
      chips.push(
        <Chip
          key="username"
          label={`ì‚¬ìš©ì: ${userLabel}`}
          onDelete={() => handleQuickFilterChange('username', null)}
          color="primary"
          size="small"
        />
      );
    }

    if (filters.action && filters.action.length > 0) {
      filters.action.forEach(actionValue => {
        const actionLabel = actionOptions.find(opt => opt.value === actionValue)?.label || actionValue;
        chips.push(
          <Chip
            key={`action-${actionValue}`}
            label={`ë™ì‘: ${actionLabel}`}
            onDelete={() => {
              const newActions = filters.action.filter(a => a !== actionValue);
              handleQuickFilterChange('action', actionValue); // í† ê¸€ ë°©ì‹ìœ¼ë¡œ ì œê±°
            }}
            color="primary"
            size="small"
          />
        );
      });
    }

    if (filters.target_type && filters.target_type.length > 0) {
      filters.target_type.forEach(typeValue => {
        const targetTypeLabel = targetTypeOptions.find(opt => opt.value === typeValue)?.label || typeValue;
        chips.push(
          <Chip
            key={`target_type-${typeValue}`}
            label={`ëŒ€ìƒ ìœ í˜•: ${targetTypeLabel}`}
            onDelete={() => {
              handleQuickFilterChange('target_type', typeValue); // í† ê¸€ ë°©ì‹ìœ¼ë¡œ ì œê±°
            }}
            color="primary"
            size="small"
          />
        );
      });
    }

    if (filters.target_id) {
      chips.push(
        <Chip
          key="target_id"
          label={`ëŒ€ìƒ ID: ${filters.target_id}`}
          onDelete={() => {
            handleQuickFilterChange('target_id', '');
            setSearchTerm('');
          }}
          color="primary"
          size="small"
        />
      );
    }

    // ì‹œì‘ì¼ê³¼ ì¢…ë£Œì¼ í•„í„° ì¹© (ê¸°ê°„ìœ¼ë¡œ í†µí•©)
    const periodText = getPeriodText();
    if (periodText) {
      chips.push(
        <Chip
          key="period"
          label={`ê¸°ê°„: ${periodText}`}
          onDelete={() => {
            handleQuickFilterChange('start_date', null);
            handleQuickFilterChange('end_date', null);
          }}
          color="primary"
          size="small"
        />
      );
    } else {
      // ì‹œì‘ì¼, ì¢…ë£Œì¼ì´ ê°œë³„ì ìœ¼ë¡œ ì„¤ì •ëœ ê²½ìš° (ê¸°ê°„ì´ ì•„ë‹Œ ê²½ìš°)
      if (filters.start_date) {
        chips.push(
          <Chip
            key="start_date"
            label={`ì‹œì‘ì¼: ${formatDateForDisplay(filters.start_date)}`}
            onDelete={() => handleQuickFilterChange('start_date', null)}
            color="primary"
            size="small"
          />
        );
      }

      if (filters.end_date) {
        chips.push(
          <Chip
            key="end_date"
            label={`ì¢…ë£Œì¼: ${formatDateForDisplay(filters.end_date)}`}
            onDelete={() => handleQuickFilterChange('end_date', null)}
            color="primary"
            size="small"
          />
        );
      }
    }

    return chips;
  };

  // ë²„íŠ¼ í™œì„±í™” ìƒíƒœ í™•ì¸
  const isMyActivitiesActive = filters.username === currentUsername;
  const isAllActivitiesActive = !filters.username;

  return (
    <Paper sx={{ p: { xs: 1.5, sm: 2 } }} elevation={1}>
      {/* í—¤ë” ì˜ì—­ */}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
        <Typography variant="h6" component="h2" sx={{ display: 'flex', alignItems: 'center' }}>
          <FilterListIcon sx={{ mr: 1 }} />
          í•„í„°
          {appliedFiltersCount > 0 && (
            <Chip
              label={appliedFiltersCount}
              color="primary"
              size="small"
              sx={{ ml: 1 }}
            />
          )}
        </Typography>
        
        {/* í•„í„° ì´ˆê¸°í™” ë²„íŠ¼ */}
        <Box>
          {appliedFiltersCount > 0 && (
            <Button
              variant="outlined"
              color="error"
              size="small"
              startIcon={<ClearIcon />}
              onClick={onFilterReset}
            >
              ì´ˆê¸°í™”
            </Button>
          )}
        </Box>
      </Box>

      {/* í†µí•© ê²€ìƒ‰ë°” */}
      <TextField
        fullWidth
        placeholder="CVE-2023-1234ì™€ ê°™ì€ ëŒ€ìƒ ID ë˜ëŠ” í‚¤ì›Œë“œ ê²€ìƒ‰"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        size="small"
        sx={{ mb: 2 }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <SearchIcon />
            </InputAdornment>
          ),
          endAdornment: searchTerm && (
            <InputAdornment position="end">
              <IconButton size="small" onClick={() => setSearchTerm('')}>
                <ClearIcon fontSize="small" />
              </IconButton>
            </InputAdornment>
          )
        }}
        onKeyPress={(e) => e.key === 'Enter' && onFilterApply()}
      />

      {/* ë¹ ë¥¸ í•„í„° ë²„íŠ¼ ê·¸ë£¹ */}
      <Box sx={{ mb: 2 }}>
        <Grid container spacing={1}>
          {/* ì‚¬ìš©ì í•„í„° ê·¸ë£¹ */}
          <Grid item xs={12} sm={6}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <PersonIcon fontSize="small" sx={{ mr: 0.5 }} />
              <Typography variant="body2" color="text.secondary">ì‚¬ìš©ì</Typography>
            </Box>
            <Stack 
              direction="row" 
              spacing={1} 
              sx={{ 
                flexWrap: 'wrap', 
                gap: 1,
                '& > button': { mb: 0 }
              }}
            >
              <Button 
                size="small" 
                variant={isMyActivitiesActive ? "contained" : "outlined"}
                onClick={handleSetMyActivities}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                ë‚´ í™œë™
              </Button>
              <Button 
                size="small" 
                variant={isAllActivitiesActive ? "contained" : "outlined"}
                onClick={handleSetAllActivities}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                ëª¨ë“  í™œë™
              </Button>
              <FormControl size="small" sx={{ minWidth: 120 }}>
                <Select
                  value={filters.username || ''}
                  onChange={(e) => handleQuickFilterChange('username', e.target.value)}
                  displayEmpty
                  renderValue={(selected) => {
                    if (!selected) return "ì‚¬ìš©ì ì„ íƒ";
                    
                    if (selected === currentUsername) {
                      return "ë‚´ í™œë™";
                    }
                    
                    if (selected === 'system') {
                      return "ì‹œìŠ¤í…œ";
                    }
                    
                    const selectedUser = users.find(u => u.username === selected);
                    return selectedUser ? (selectedUser.display_name || selectedUser.username) : selected;
                  }}
                  sx={{ height: 32 }}
                >
                  <MenuItem value={null}>ëª¨ë“  ì‚¬ìš©ì</MenuItem>
                  <MenuItem value={currentUsername}>ë‚´ í™œë™</MenuItem>
                  <MenuItem value="system">ì‹œìŠ¤í…œ</MenuItem>
                  {users
                    .filter(u => u.username !== currentUsername && u.username !== 'system')
                    .map((user) => (
                      <MenuItem key={user.id} value={user.username}>
                        {user.display_name || user.username}
                      </MenuItem>
                    ))
                  }
                </Select>
              </FormControl>
            </Stack>
          </Grid>

          {/* ê¸°ê°„ í•„í„° ê·¸ë£¹ */}
          <Grid item xs={12} sm={6}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <CalendarTodayIcon fontSize="small" sx={{ mr: 0.5 }} />
              <Typography variant="body2" color="text.secondary">ê¸°ê°„</Typography>
            </Box>
            <Stack 
              direction="row" 
              spacing={1} 
              sx={{ 
                flexWrap: 'wrap', 
                gap: 1,
                '& > button': { mb: 0 }
              }}
            >
              <Button 
                size="small" 
                variant="outlined"
                onClick={handleSetToday}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                ì˜¤ëŠ˜
              </Button>
              <Button 
                size="small" 
                variant="outlined"
                onClick={handleSetLastWeek}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                ìµœê·¼ 7ì¼
              </Button>
              <Button 
                size="small" 
                variant="outlined"
                onClick={handleSetLastMonth}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                ìµœê·¼ 30ì¼
              </Button>
            </Stack>
          </Grid>
        </Grid>
      </Box>
      
      {/* íƒ€ì… í•„í„° - ìœ„ì¹˜ ë³€ê²½ ë° ë™ì‘ ìœ í˜• ë²„íŠ¼ìœ¼ë¡œ ë³€ê²½ */}
      <Grid container spacing={2} sx={{ mb: 2 }}>
        <Grid item xs={12} sm={6}>
          <FormControl size="small" fullWidth>
            <InputLabel id="target-type-label">ëŒ€ìƒ ìœ í˜•</InputLabel>
            <Select
              labelId="target-type-label"
              multiple
              value={filters.target_type || []}
              onChange={(e) => onFilterChange({
                ...filters,
                target_type: e.target.value
              })}
              onClose={() => onFilterApply()}
              label="ëŒ€ìƒ ìœ í˜•"
              renderValue={(selected) => (
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                  {selected.map((value) => {
                    const label = targetTypeOptions.find(opt => opt.value === value)?.label || value;
                    return (
                      <Chip key={value} label={label} size="small" />
                    );
                  })}
                </Box>
              )}
            >
              {targetTypeOptions.map((option) => (
                <MenuItem key={option.value} value={option.value}>
                  {option.label}
                </MenuItem>
              ))}
            </Select>
          </FormControl>
        </Grid>
        <Grid item xs={12} sm={6}>
          <Box>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
              <Typography variant="body2" color="text.secondary">ë™ì‘ ìœ í˜•</Typography>
            </Box>
            <Stack direction="row" spacing={1} sx={{ flexWrap: 'wrap', gap: 1 }}>
              <Button 
                size="small" 
                variant={(filters.action.length === 0) ? "contained" : "outlined"}
                onClick={() => onFilterChange({
                  ...filters,
                  action: []
                })}
                sx={{ minWidth: 0, px: 1.5 }}
              >
                ì „ì²´
              </Button>
              {actionOptions.map((option) => (
                <Button 
                  key={option.value}
                  size="small" 
                  variant={filters.action.includes(option.value) ? "contained" : "outlined"}
                  onClick={() => handleQuickFilterChange('action', option.value)}
                  sx={{ minWidth: 0, px: 1.5 }}
                >
                  {option.label}
                </Button>
              ))}
            </Stack>
          </Box>
        </Grid>
      </Grid>

      {/* í˜„ì¬ ì ìš©ëœ í•„í„° ì¹© í‘œì‹œ */}
      {appliedFiltersCount > 0 && (
        <Fade in={appliedFiltersCount > 0}>
          <Box sx={{ mt: 2 }}>
            <Divider sx={{ mb: 1.5 }} />
            <Typography variant="body2" color="text.secondary" gutterBottom>
              ì ìš©ëœ í•„í„°
            </Typography>
            <Stack direction="row" spacing={1} flexWrap="wrap" sx={{ gap: 0.5 }}>
              {renderFilterChips()}
            </Stack>
          </Box>
        </Fade>
      )}

      {/* ê³ ê¸‰ í•„í„° í† ê¸€ ë²„íŠ¼ */}
      <Box sx={{ mt: 2, display: 'flex', justifyContent: 'center' }}>
        <Button
          size="small"
          onClick={() => setShowAdvanced(!showAdvanced)}
          endIcon={<ExpandMoreIcon sx={{ 
            transform: showAdvanced ? 'rotate(180deg)' : 'rotate(0deg)',
            transition: 'transform 0.3s'
          }} />}
          sx={{ textTransform: 'none' }}
        >
          {showAdvanced ? 'ê³ ê¸‰ í•„í„° ë‹«ê¸°' : 'ê³ ê¸‰ í•„í„° ì—´ê¸°'}
        </Button>
      </Box>

      {/* ê³ ê¸‰ í•„í„° íŒ¨ë„ */}
      <Collapse in={showAdvanced}>
        <Box sx={{ mt: 2, p: 2, bgcolor: 'background.default', borderRadius: 1 }}>
          <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ko}>
            <form onSubmit={handleSubmit}>
              <Grid container spacing={2}>
                {/* ë‚ ì§œ í•„í„° */}
                <Grid item xs={12} sm={6}>
                  <DatePicker
                    label="ì‹œì‘ì¼"
                    value={filters.start_date ? new Date(filters.start_date) : null}
                    onChange={(date) => handleAdvancedFilterChange('start_date', date)}
                    slotProps={{ textField: { size: 'small', fullWidth: true } }}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <DatePicker
                    label="ì¢…ë£Œì¼"
                    value={filters.end_date ? new Date(filters.end_date) : null}
                    onChange={(date) => handleAdvancedFilterChange('end_date', date)}
                    slotProps={{ textField: { size: 'small', fullWidth: true } }}
                  />
                </Grid>

                <Grid item xs={12}>
                  <Box display="flex" justifyContent="flex-end" gap={1}>
                    <Button
                      variant="text"
                      color="inherit"
                      onClick={onFilterReset}
                      size="small"
                    >
                      ì´ˆê¸°í™”
                    </Button>
                    <Button
                      variant="contained"
                      color="primary"
                      type="submit"
                      size="small"
                    >
                      í•„í„° ì ìš©
                    </Button>
                  </Box>
                </Grid>
              </Grid>
            </form>
          </LocalizationProvider>
        </Box>
      </Collapse>
    </Paper>
  );
};

export default React.memo(ActivitiesFilter);


============================================================
File: /home/CVEHub/frontend/src/features/activities/components/ActivityItem.jsx
------------------------------------------------------------
import React, { useState } from 'react';
import { TIME_ZONES, DATE_FORMATS, formatDateTime } from '../../../shared/utils/dateUtils';
import { 
  Box, 
  Typography, 
  Paper, 
  Chip, 
  Divider, 
  Collapse,
  Link,
  Card,
  CardContent,
  Avatar,
  Tooltip,
  IconButton,
  useTheme,
  useMediaQuery
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import KeyboardArrowDownIcon from '@mui/icons-material/KeyboardArrowDown';
import KeyboardArrowUpIcon from '@mui/icons-material/KeyboardArrowUp';
import CreateIcon from '@mui/icons-material/Create';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import AddIcon from '@mui/icons-material/Add';
import AssignmentIcon from '@mui/icons-material/Assignment';
import CommentIcon from '@mui/icons-material/Comment';
import PermIdentityIcon from '@mui/icons-material/PermIdentity';
import { Link as RouterLink } from 'react-router-dom';

// í™œë™ ë™ì‘ì— ë”°ë¥¸ ì•„ì´ì½˜ ë° ìƒ‰ìƒ ë§¤í•‘
const actionIcons = {
  create: <CreateIcon fontSize="small" />,
  update: <EditIcon fontSize="small" />,
  delete: <DeleteIcon fontSize="small" />,
  add: <AddIcon fontSize="small" />,
  assign: <AssignmentIcon fontSize="small" />,
  comment: <CommentIcon fontSize="small" />,
  comment_update: <EditIcon fontSize="small" />,
  comment_delete: <DeleteIcon fontSize="small" />
};

const actionColors = {
  create: 'success',
  update: 'primary',
  delete: 'error',
  add: 'success',
  assign: 'info',
  comment: 'secondary',
  comment_update: 'secondary',
  comment_delete: 'error'
};

// í™œë™ ëŒ€ìƒ ìœ í˜•ì— ë”°ë¥¸ ë¼ìš°íŒ… ê²½ë¡œ ë§¤í•‘
const getTargetRoute = (targetType, targetId) => {
  switch (targetType) {
    case 'cve':
      return `/cves/${targetId}`;
    case 'poc':
      return `/cves/${targetId.split('-poc-')[0]}/poc/${targetId}`;
    case 'snort_rule':
      return `/cves/${targetId.split('-snort-')[0]}/snort-rule/${targetId}`;
    case 'comment':
      // ëŒ“ê¸€ IDì—ì„œ ë¶€ëª¨ ë¦¬ì†ŒìŠ¤ IDë¥¼ ì¶”ì¶œ (ê°€ì •)
      const parentId = targetId.split('-comment-')[0];
      return `/cves/${parentId}#comment-${targetId}`;
    default:
      return '#';
  }
};

// í™œë™ ë™ì‘ì— ë”°ë¥¸ í‘œì‹œ í…ìŠ¤íŠ¸ ë§¤í•‘
const getActionText = (action) => {
  switch (action) {
    case 'create': return 'ìƒì„±';
    case 'update': return 'ìˆ˜ì •';
    case 'delete': return 'ì‚­ì œ';
    case 'add': return 'ì¶”ê°€';
    case 'assign': return 'í• ë‹¹';
    case 'comment': return 'ëŒ“ê¸€ ì‘ì„±';
    case 'comment_update': return 'ëŒ“ê¸€ ìˆ˜ì •';
    case 'comment_delete': return 'ëŒ“ê¸€ ì‚­ì œ';
    default: return action;
  }
};

// ëŒ€ìƒ ìœ í˜•ì— ë”°ë¥¸ í‘œì‹œ í…ìŠ¤íŠ¸ ë§¤í•‘
const getTargetTypeText = (targetType) => {
  switch (targetType) {
    case 'cve': return 'CVE';
    case 'poc': return 'PoC';
    case 'snort_rule': return 'Snort ê·œì¹™';
    case 'comment': return 'ëŒ“ê¸€';
    case 'reference': return 'ì°¸ì¡°ë¬¸ì„œ';
    case 'user': return 'ì‚¬ìš©ì';
    case 'system': return 'ì‹œìŠ¤í…œ';
    default: return targetType;
  }
};

/**
 * ê°œì„ ëœ ê°œë³„ í™œë™ í•­ëª© ì»´í¬ë„ŒíŠ¸
 * - ë””ìì¸ ê°œì„ 
 * - ë³€ê²½ ì‚¬í•­ í”„ë¦¬ë·° ê°œì„ 
 * - ì¸í„°ë™ì…˜ ê°œì„ 
 * 
 * @param {Object} props ì»´í¬ë„ŒíŠ¸ ì†ì„±
 * @param {Object} props.activity í™œë™ ë°ì´í„°
 * @returns {JSX.Element} ë Œë”ë§ëœ ì»´í¬ë„ŒíŠ¸
 */
const ActivityItem = ({ activity }) => {
  const [expanded, setExpanded] = useState(false);
  const theme = useTheme();
  // PC í™˜ê²½ì— ìµœì í™”
  
  const {
    username,
    timestamp,
    action,
    targetType,
    targetId,
    targetTitle,
    changes
  } = activity;

  // UTC ì‹œê°„ì„ KSTë¡œ ë³€í™˜í•˜ì—¬ í‘œì‹œ
  const dateTimeDisplay = formatDateTime(timestamp, DATE_FORMATS.DISPLAY.FULL, TIME_ZONES.KST);
  
  // íˆ´íŒìš© ìƒì„¸ í•œê¸€ í¬ë§· - ì´ë¯¸ KSTë¡œ ë³€í™˜ëœ ë‚ ì§œ ì‚¬ìš©
  const dateTimeDetail = formatDateTime(timestamp, 'yyyyë…„ MMì›” ddì¼ HHì‹œ mmë¶„ ssì´ˆ');
  
  // ë³€ê²½ ì‚¬í•­ì´ ìˆëŠ”ì§€ í™•ì¸
  const hasChanges = changes && changes.length > 0;
  
  // ìƒ‰ìƒ ê³„ì‚° - íˆ¬ëª…ë„ë¥¼ í¬í•¨í•œ ìƒ‰ìƒìœ¼ë¡œ ë³€í™˜
  const getBorderColor = () => {
    const color = actionColors[action] || 'grey';
    return theme.palette[color].main;
  };
  
  // ì•¡ì…˜ ë°°ê²½ìƒ‰ ê³„ì‚°
  const getActionBgColor = () => {
    const color = actionColors[action] || 'grey';
    return theme.palette[color].light;
  };

  // ì¶”ê°€ ì •ë³´ ìš”ì•½ ìƒì„± í•¨ìˆ˜ (PoC, Reference ë“±)
  const getAdditionalInfo = () => {
    if (!changes || changes.length === 0) return '';
    
    const additionalData = [];
    
    // PoC ì •ë³´ ì°¾ê¸°
    const pocChange = changes.find(c => c.field === 'poc' && c.action === 'add');
    if (pocChange && pocChange.items && pocChange.items.length > 0) {
      additionalData.push(`PoC ${pocChange.items.length}ê°œ`);
    }
    
    // ì°¸ì¡°ë¬¸ì„œ ì •ë³´ ì°¾ê¸°
    const refChange = changes.find(c => c.field === 'reference' && c.action === 'add');
    if (refChange && refChange.items && refChange.items.length > 0) {
      additionalData.push(`ì°¸ì¡°ë¬¸ì„œ ${refChange.items.length}ê°œ`);
    }
    
    // Snort ê·œì¹™ ì •ë³´ ì°¾ê¸°
    const ruleChange = changes.find(c => c.field === 'snort_rule' && c.action === 'add');
    if (ruleChange && ruleChange.items && ruleChange.items.length > 0) {
      additionalData.push(`Snort ê·œì¹™ ${ruleChange.items.length}ê°œ`);
    }
    
    // ì¶”ê°€ ì •ë³´ê°€ ìˆëŠ” ê²½ìš° ë¬¸ìì—´ë¡œ ê²°í•©í•˜ì—¬ ë°˜í™˜
    if (additionalData.length > 0) {
      return ` (${additionalData.join(', ')} í¬í•¨)`;
    }
    
    // ì¶”ê°€ ì •ë³´ê°€ ì—†ëŠ” ê²½ìš° ë¹ˆ ë¬¸ìì—´ ë°˜í™˜
    return '';
  };

  // ìš”ì•½ í…ìŠ¤íŠ¸ ìƒì„±
  const summaryText = () => {
    // íƒ€ì…ì´ CVEì¸ì§€ í™•ì¸
    const isCveActivity = targetType === 'cve';
    
    // í‘œì‹œí•  ID ê²°ì •
    let displayId = isCveActivity ? targetId : (targetTitle || targetId);
    
    // IDê°€ ì—†ëŠ” ê²½ìš° ì²˜ë¦¬
    if (!displayId) {
      displayId = targetId || '';
    }
    
    return (
      <>
        <Typography 
          component="span" 
          variant="body2" 
          fontWeight="medium"
          color="text.primary"
        >
          {username}
        </Typography>
        ë‹˜ì´ {' '}
        <Link
          component={RouterLink}
          to={getTargetRoute(targetType, targetId)}
          sx={{ fontWeight: 'medium' }}
          underline="hover"
        >
          {displayId}
        </Link>
        {/* CVEê°€ ì•„ë‹Œ íƒ€ì…ì—ë§Œ ê´„í˜¸ë¡œ íƒ€ì… í‘œì‹œ */}
        {!isCveActivity ? ` (${getTargetTypeText(targetType)})` : ''}
        {action && ` ${getActionText(action)}`}í•¨{getAdditionalInfo()}
      </>
    );
  };

  return (
    <Card 
      elevation={1} 
      sx={{ 
        mb: 2,
        overflow: 'visible',
        position: 'relative',
        border: `1px solid ${theme.palette.divider}`,
        borderLeft: `3px solid ${getBorderColor()}`,
        transition: 'all 0.2s ease-in-out',
        '&:hover': {
          transform: 'translateY(-2px)',
          boxShadow: theme.shadows[3],
        }
      }}
    >
      <CardContent sx={{ pt: 2, pb: 2, '&:last-child': { pb: 2 } }}>
        {/* ì•¡ì…˜ ì•„ì´ì½˜ */}
        <Box 
          sx={{ 
            position: 'absolute',
            top: -12,
            left: 12,
            width: 24,
            height: 24,
            borderRadius: '50%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            bgcolor: getActionBgColor(),
            color: getBorderColor(),
            border: `1px solid ${getBorderColor()}`,
            zIndex: 1
          }}
        >
          {actionIcons[action] || <CreateIcon fontSize="small" />}
        </Box>

        {/* í—¤ë” ì˜ì—­ */}
        <Box display="flex" flexDirection="row" 
          justifyContent="space-between" alignItems="center">
          <Box display="flex" alignItems="center" ml={4} mb={0}>
            <Avatar
              sx={{ 
                width: 24, 
                height: 24, 
                fontSize: '0.875rem',
                mr: 1,
                bgcolor: theme.palette.primary.main
              }}
            >
              {username ? username.charAt(0).toUpperCase() : <PermIdentityIcon fontSize="small" />}
            </Avatar>
            
            <Typography variant="body2" color="text.primary">
              {summaryText()}
            </Typography>
          </Box>

          <Box display="flex" alignItems="center" ml={0}>
            <Tooltip title={dateTimeDetail}>
              <Typography variant="caption" color="text.secondary">
                {dateTimeDisplay}
              </Typography>
            </Tooltip>
          </Box>
        </Box>

        {/* ë³€ê²½ ì‚¬í•­ì´ ìˆì„ ê²½ìš° í‘œì‹œ */}
        {hasChanges && (
          <>
            <Box 
              display="flex" 
              alignItems="center" 
              justifyContent="space-between"
              mt={1.5}
              sx={{ 
                cursor: 'pointer',
                '&:hover': { bgcolor: 'action.hover' },
                p: 1,
                mx: -1,
                borderRadius: 1
              }}
              onClick={() => setExpanded(!expanded)}
            >
              <Typography variant="caption" color="text.secondary">
                {changes.length}ê°œì˜ ë³€ê²½ ì‚¬í•­ {action === 'delete' ? 'ì‚­ì œë¨' : ''}
              </Typography>
              <IconButton size="small" onClick={(e) => {
                e.stopPropagation();
                setExpanded(!expanded);
              }}>
                {expanded ? <KeyboardArrowUpIcon /> : <KeyboardArrowDownIcon />}
              </IconButton>
            </Box>

            <Collapse in={expanded} timeout="auto">
              <Divider sx={{ my: 1 }} />
              <Box sx={{ mt: 1 }}>
                {changes.map((change, index) => (
                  <Box key={index} sx={{ mb: 1.5 }}>
                    <Typography variant="caption" fontWeight="bold" gutterBottom>
                      {change.field_name || change.field}:
                    </Typography>
                    
                    {change.action === 'edit' && (
                      <Box sx={{ display: 'flex', flexDirection: 'column', mt: 0.5 }}>
                        <Box sx={{ 
                          backgroundColor: 'rgba(244, 67, 54, 0.1)', 
                          p: 1, 
                          borderRadius: 1,
                          border: '1px solid rgba(244, 67, 54, 0.2)'
                        }}>
                          <Typography variant="caption">
                            - {String(change.before || '').substring(0, 100)}
                            {String(change.before || '').length > 100 ? '...' : ''}
                          </Typography>
                        </Box>
                        <Box sx={{ 
                          backgroundColor: 'rgba(76, 175, 80, 0.1)', 
                          p: 1, 
                          mt: 0.5, 
                          borderRadius: 1,
                          border: '1px solid rgba(76, 175, 80, 0.2)'
                        }}>
                          <Typography variant="caption">
                            + {String(change.after || '').substring(0, 100)}
                            {String(change.after || '').length > 100 ? '...' : ''}
                          </Typography>
                        </Box>
                      </Box>
                    )}
                    
                    {change.action === 'add' && change.items && change.items.length > 0 && (
                      <Box sx={{ mt: 0.5 }}>
                        {change.items.map((item, itemIndex) => (
                          <Box key={itemIndex} sx={{ 
                            backgroundColor: 'rgba(76, 175, 80, 0.1)', 
                            p: 1, 
                            mt: 0.5, 
                            borderRadius: 1,
                            border: '1px solid rgba(76, 175, 80, 0.2)'
                          }}>
                            <Typography variant="caption">
                              + {typeof item === 'object' ? JSON.stringify(item).substring(0, 100) : String(item).substring(0, 100)}
                              {(typeof item === 'object' ? JSON.stringify(item).length : String(item).length) > 100 ? '...' : ''}
                            </Typography>
                          </Box>
                        ))}
                      </Box>
                    )}
                    
                    {change.action === 'delete' && (
                      <Box sx={{ 
                        backgroundColor: 'rgba(244, 67, 54, 0.1)', 
                        p: 1, 
                        mt: 0.5, 
                        borderRadius: 1,
                        border: '1px solid rgba(244, 67, 54, 0.2)'
                      }}>
                        <Typography variant="caption">
                          ì‚­ì œë¨
                        </Typography>
                      </Box>
                    )}
                    
                    {change.summary && (
                      <Typography variant="caption" display="block" sx={{ mt: 0.5, color: 'text.secondary' }}>
                        {change.summary}
                      </Typography>
                    )}
                  </Box>
                ))}
              </Box>
            </Collapse>
          </>
        )}
      </CardContent>
    </Card>
  );
};

export default React.memo(ActivityItem);


============================================================
File: /home/CVEHub/frontend/src/features/activities/components/ActivityList.jsx
------------------------------------------------------------
import React from 'react';
import { 
  Box, 
  Typography, 
  CircularProgress, 
  Pagination, 
  Alert,
  Skeleton,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Stack,
  useMediaQuery,
  useTheme
} from '@mui/material';
import ActivityItem from './ActivityItem';

/**
 * ìŠ¤ì¼ˆë ˆí†¤ ë¡œë”© ì»´í¬ë„ŒíŠ¸
 * 
 * @returns {JSX.Element} ìŠ¤ì¼ˆë ˆí†¤ UI
 */
const ActivitySkeleton = () => {
  const theme = useTheme();
  // PC í™˜ê²½ì— ìµœì í™”
  
  return (
    <Box sx={{ 
      mb: 2, 
      p: 2, 
      borderRadius: 1, 
      border: `1px solid ${theme.palette.divider}`,
      borderLeft: `3px solid ${theme.palette.grey[400]}`
    }}>
      <Box display="flex" flexDirection="row" justifyContent="space-between" alignItems="center">
        <Box display="flex" alignItems="center" width="100%">
          <Skeleton variant="circular" width={24} height={24} sx={{ mr: 1 }} />
          <Skeleton variant="text" width="40%" height={24} />
        </Box>
        <Skeleton variant="text" width={100} />
      </Box>
      
      {/* PC í™˜ê²½ì—ì„œëŠ” í•„ìš” ì—†ëŠ” ëª¨ë°”ì¼ ì½”ë“œ ì œê±° */}
      
      <Box mt={2}>
        <Skeleton variant="rectangular" width="100%" height={40} sx={{ borderRadius: 1 }} />
      </Box>
    </Box>
  );
};

/**
 * ê°œì„ ëœ í™œë™ ëª©ë¡ ì»´í¬ë„ŒíŠ¸
 * - ìŠ¤ì¼ˆë ˆí†¤ ë¡œë”© UI ì ìš©
 * - í˜ì´ì§€ë„¤ì´ì…˜ ë° í‘œì‹œ ê°œìˆ˜ ì»¨íŠ¸ë¡¤ ê°œì„ 
 * - ì„±ëŠ¥ ìµœì í™”
 * 
 * @param {Object} props ì»´í¬ë„ŒíŠ¸ ì†ì„±
 * @param {Array} props.activities í™œë™ ëª©ë¡ ë°ì´í„°
 * @param {number} props.total ì „ì²´ í•­ëª© ìˆ˜
 * @param {boolean} props.isLoading ë¡œë”© ìƒíƒœ
 * @param {Object} props.error ì—ëŸ¬ ê°ì²´
 * @param {number} props.page í˜„ì¬ í˜ì´ì§€
 * @param {number} props.limit í˜ì´ì§€ë‹¹ í•­ëª© ìˆ˜
 * @param {Function} props.onPageChange í˜ì´ì§€ ë³€ê²½ í•¸ë“¤ëŸ¬
 * @param {Function} props.onLimitChange í‘œì‹œ ê°œìˆ˜ ë³€ê²½ í•¸ë“¤ëŸ¬
 * @returns {JSX.Element} ë Œë”ë§ëœ ì»´í¬ë„ŒíŠ¸
 */
const ActivityList = ({ 
  activities = [], 
  total = 0,
  isLoading = false, 
  error = null, 
  page = 1, 
  limit = 10, 
  onPageChange,
  onLimitChange
}) => {
  const theme = useTheme();
  // PC í™˜ê²½ì— ìµœì í™”
  
  // ì´ í˜ì´ì§€ ìˆ˜ ê³„ì‚°
  const totalPages = Math.max(1, Math.ceil(total / limit));
  
  // ì—ëŸ¬ í‘œì‹œ
  if (error) {
    // ì—ëŸ¬ ë©”ì‹œì§€ ì¶”ì¶œ (ê°ì²´ì¸ ê²½ìš° message ì†ì„± ì‚¬ìš©, ì•„ë‹ˆë©´ ë¬¸ìì—´ë¡œ ë³€í™˜)
    const errorMessage = typeof error === 'object' ? 
      (error.message || JSON.stringify(error)) : 
      String(error);
      
    return (
      <Alert 
        severity="error" 
        sx={{ 
          mb: 2,
          borderRadius: 1,
          '& .MuiAlert-message': { width: '100%' }
        }}
      >
        <Typography variant="body2">
          í™œë™ ë‚´ì—­ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤
        </Typography>
        <Typography variant="caption" component="pre" sx={{ 
          mt: 1, 
          p: 1, 
          bgcolor: 'rgba(0, 0, 0, 0.04)', 
          borderRadius: 1,
          overflow: 'auto',
          maxHeight: '100px',
          whiteSpace: 'pre-wrap',
          wordBreak: 'break-word'
        }}>
          {errorMessage}
        </Typography>
      </Alert>
    );
  }

  // ë¡œë”© ì¤‘ ìŠ¤ì¼ˆë ˆí†¤ UI í‘œì‹œ
  if (isLoading) {
    return (
      <>
        {[...Array(Math.min(limit, 5))].map((_, index) => (
          <ActivitySkeleton key={index} />
        ))}
      </>
    );
  }

  // ë°ì´í„°ê°€ ì—†ì„ ê²½ìš°
  if (!activities || activities.length === 0) {
    return (
      <Box 
        display="flex" 
        flexDirection="column"
        justifyContent="center" 
        alignItems="center" 
        height="200px"
        bgcolor="background.paper"
        borderRadius={1}
        p={3}
        border={`1px dashed ${theme.palette.divider}`}
      >
        <Typography variant="body1" color="text.secondary" gutterBottom>
          í‘œì‹œí•  í™œë™ ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤
        </Typography>
        <Typography variant="caption" color="text.secondary">
          ë‹¤ë¥¸ í•„í„° ì¡°ê±´ì„ ì ìš©í•´ë³´ì„¸ìš”
        </Typography>
      </Box>
    );
  }

  return (
    <Box>
      {/* í™œë™ ëª©ë¡ - í•­ìƒ ê³ ìœ í•œ í‚¤ ë³´ì¥ (ì¸ë±ìŠ¤ë¥¼ í•­ìƒ í¬í•¨) */}
      {activities.map((activity, index) => (
        <ActivityItem 
          key={activity?.id ? `item-${activity.id}-${index}` : `activity-${index}`} 
          activity={activity} 
        />
      ))}

      {/* í˜ì´ì§€ë„¤ì´ì…˜ ë° í‘œì‹œ ê°œìˆ˜ ì»¨íŠ¸ë¡¤ */}
      {total > 0 && (
        <Box 
          sx={{ 
            mt: 3, 
            display: 'flex', 
            flexDirection: 'row',
            alignItems: 'center',
            justifyContent: 'space-between',
            gap: 2
          }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center', order: 1 }}>
            <Typography variant="body2" color="text.secondary" mr={2}>
              ì´ {total}ê°œ í•­ëª©
            </Typography>
            
            <FormControl size="small" sx={{ minWidth: 100 }}>
              <Select
                value={limit}
                onChange={(e) => onLimitChange(e.target.value)}
                displayEmpty
                variant="outlined"
              >
                <MenuItem value={5}>5ê°œì”©</MenuItem>
                <MenuItem value={10}>10ê°œì”©</MenuItem>
                <MenuItem value={20}>20ê°œì”©</MenuItem>
                <MenuItem value={50}>50ê°œì”©</MenuItem>
              </Select>
            </FormControl>
          </Box>

          {totalPages > 1 && (
            <Stack 
              direction="row" 
              spacing={2} 
              justifyContent="center"
              order={2}
              width="auto"
            >
              <Pagination 
                count={totalPages} 
                page={page} 
                onChange={(event, value) => onPageChange(value)}
                color="primary"
                size="medium"
                showFirstButton={true}
                showLastButton={true}
                siblingCount={1}
              />
            </Stack>
          )}
        </Box>
      )}
    </Box>
  );
};

export default React.memo(ActivityList);


============================================================
File: /home/CVEHub/frontend/src/features/activities/hooks/useActivityQuery.js
------------------------------------------------------------
import { useQuery } from "@tanstack/react-query";
import axios from "../../../shared/api/config/axios";

/**
 * ìºì‹œ í‚¤ ìƒì„± ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
 * 
 * @param {Object} options í•„í„° ì˜µì…˜
 * @returns {Array} ì¿¼ë¦¬ í‚¤ ë°°ì—´
 */
const createActivitiesQueryKey = (options) => {
  const {
    username,
    target_type,
    target_id,
    action,
    start_date,
    end_date,
    page,
    limit,
  } = options;

  return [
    "activities",
    username,
    target_type,
    target_id,
    action,
    start_date ? start_date.toISOString() : null,
    end_date ? end_date.toISOString() : null,
    page,
    limit,
  ];
};

/**
 * ê°œì„ ëœ í™œë™ ì´ë ¥ ì¡°íšŒë¥¼ ìœ„í•œ ì¿¼ë¦¬ í›…
 * - ì¿¼ë¦¬ í‚¤ ê´€ë¦¬ ìµœì í™”
 * - ì„±ëŠ¥ í–¥ìƒì„ ìœ„í•œ ì˜µì…˜ ì¡°ì •
 * - ë°ì´í„° ê°€ê³µ í†µí•©
 * 
 * @param {Object} options í•„í„° ë° í˜ì´ì§€ë„¤ì´ì…˜ ì˜µì…˜
 * @param {string} options.username ì‚¬ìš©ìëª… í•„í„°
 * @param {string} options.target_type ëŒ€ìƒ ìœ í˜• í•„í„°
 * @param {string} options.target_id ëŒ€ìƒ ID í•„í„°
 * @param {string} options.action ë™ì‘ í•„í„°
 * @param {Date} options.start_date ì‹œì‘ ë‚ ì§œ
 * @param {Date} options.end_date ì¢…ë£Œ ë‚ ì§œ
 * @param {number} options.page í˜ì´ì§€ ë²ˆí˜¸
 * @param {number} options.limit í˜ì´ì§€ë‹¹ í•­ëª© ìˆ˜
 * @returns {Object} ì¿¼ë¦¬ ê²°ê³¼
 */
export const useActivityQuery = (options = {}) => {
  const {
    username,
    target_type,
    target_id,
    action,
    start_date,
    end_date,
    page = 1,
    limit = 10,
  } = options;

  return useQuery({
    queryKey: createActivitiesQueryKey(options),
    queryFn: async () => {
      try {
        let url = "/activities";
        const params = {
          page,
          limit,
        };

        // ì‚¬ìš©ìëª…ìœ¼ë¡œ í•„í„°ë§í•˜ëŠ” ê²½ìš° í•´ë‹¹ ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš©
        if (username) {
          url = `/activities/users/${username}`;
        } 
        // ëŒ€ìƒ ìœ í˜•ê³¼ IDë¡œ í•„í„°ë§í•˜ëŠ” ê²½ìš° í•´ë‹¹ ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš©
        else if (target_type && target_id) {
          url = `/activities/targets/${target_type}/${target_id}`;
        } else {
          // ê¸°ë³¸ ì—”ë“œí¬ì¸íŠ¸ì—ì„œ í•„í„° ì ìš©
          if (action) {
            // actionì´ ë°°ì—´ì¸ ê²½ìš°, ì‰¼í‘œë¡œ êµ¬ë¶„ëœ ë¬¸ìì—´ë¡œ ë³€í™˜
            if (Array.isArray(action) && action.length > 0) {
              params.action = action.join(',');
            } else if (typeof action === 'string') {
              params.action = action;
            }
          }
          if (target_type) {
            // target_typeì´ ë°°ì—´ì¸ ê²½ìš°, ì‰¼í‘œë¡œ êµ¬ë¶„ëœ ë¬¸ìì—´ë¡œ ë³€í™˜
            if (Array.isArray(target_type) && target_type.length > 0) {
              params.target_type = target_type.join(',');
            } else if (typeof target_type === 'string') {
              params.target_type = target_type;
            }
          }
          if (start_date) params.start_date = start_date.toISOString();
          if (end_date) params.end_date = end_date.toISOString();
        }

        // ë””ë²„ê¹… ë¡œê·¸ëŠ” ê°œë°œ ëª¨ë“œì—ì„œë§Œ ì¶œë ¥
        if (process.env.NODE_ENV === 'development') {
          console.log(`í™œë™ ì´ë ¥ API ìš”ì²­: ${url}`, params);
        }
        
        const { data } = await axios.get(url, { params });
        
        // ë‚ ì§œ í•„ë“œëŠ” ì´ë¯¸ axios ì¸í„°ì…‰í„°ì—ì„œ normalizeDateFieldsFromApië¥¼ í†µí•´ ì²˜ë¦¬ë¨
        // ë””ë²„ê¹…: í™œë™ ë‚´ì—­ ì¡°íšŒ ê²°ê³¼ ì¶œë ¥
        console.log(`[í™œë™ ë‚´ì—­ ë””ë²„ê·¸] ë°ì´í„° ì¡°íšŒ ê²°ê³¼:`, {
          url,
          params,
          ì´ê±´ìˆ˜: data.total,
          í˜„ì¬í˜ì´ì§€: params.page,
          í˜ì´ì§€ë‹¹í•­ëª©ìˆ˜: params.limit,
          í•„í„°: {
            ì‚¬ìš©ì: username || 'ëª¨ë“  ì‚¬ìš©ì',
            ëŒ€ìƒìœ í˜•: target_type || 'ì „ì²´',
            ëŒ€ìƒID: target_id || 'ì „ì²´',
            ì•¡ì…˜: action || 'ì „ì²´',
            ì‹œì‘ì¼: start_date ? new Date(start_date).toLocaleDateString() : 'ì „ì²´',
            ì¢…ë£Œì¼: end_date ? new Date(end_date).toLocaleDateString() : 'ì „ì²´'
          }
        });
        
        // ì¡°íšŒëœ ì²« 5ê°œ í•­ëª© ìƒ˜í”Œ ì¶œë ¥ (í•­ëª©ì´ ë§ì„ ê²½ìš°)
        if (Array.isArray(data.items) && data.items.length > 0) {
          console.log(`[í™œë™ ë‚´ì—­ ë””ë²„ê·¸] ì¡°íšŒëœ í•­ëª© ìƒ˜í”Œ (ìµœëŒ€ 5ê°œ):`, 
            data.items.slice(0, 5).map(item => ({
              ID: item.id,
              ì‚¬ìš©ì: item.username,
              ì•¡ì…˜: item.action,
              ëŒ€ìƒ: `${item.target_type}${item.target_id ? ` (${item.target_id})` : ''}`,
              ì‹œê°„: item.timestamp.toLocaleString(),
              ìƒì„¸: item.details
            }))
          );
        }
        
        return data;
      } catch (error) {
        console.error('í™œë™ ì´ë ¥ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        throw error;
      }
    },
    keepPreviousData: true,
    staleTime: 30000, // 30ì´ˆ
    refetchOnWindowFocus: false,
    retry: 1, // ìš”ì²­ ì‹¤íŒ¨ ì‹œ 1ë²ˆë§Œ ì¬ì‹œë„
  });
};

/**
 * íŠ¹ì • ëŒ€ìƒì˜ í™œë™ ì´ë ¥ ì¡°íšŒë¥¼ ìœ„í•œ ì¿¼ë¦¬ í›…
 * 
 * @param {string} target_type ëŒ€ìƒ ìœ í˜•
 * @param {string} target_id ëŒ€ìƒ ID
 * @param {Object} options í˜ì´ì§€ë„¤ì´ì…˜ ì˜µì…˜
 * @returns {Object} ì¿¼ë¦¬ ê²°ê³¼
 */
export const useTargetActivities = (target_type, target_id, options = {}) => {
  const { page = 1, limit = 10 } = options;

  return useQuery({
    queryKey: ["targetActivities", target_type, target_id, page, limit],
    queryFn: async () => {
      try {
        const params = {
          page,
          limit,
        };

        const { data } = await axios.get(`/activities/targets/${target_type}/${target_id}`, { params });
        
        // ë‚ ì§œ í•„ë“œëŠ” ì´ë¯¸ axios ì¸í„°ì…‰í„°ì—ì„œ ì²˜ë¦¬ë¨
        return data;
      } catch (error) {
        console.error(`${target_type} ${target_id}ì˜ í™œë™ ì´ë ¥ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:`, error);
        throw error;
      }
    },
    keepPreviousData: true,
    enabled: Boolean(target_type && target_id),
    staleTime: 30000,
    refetchOnWindowFocus: false,
    retry: 1,
  });
};

/**
 * í˜„ì¬ ì‚¬ìš©ìì˜ í™œë™ ì´ë ¥ ì¡°íšŒë¥¼ ìœ„í•œ ì¿¼ë¦¬ í›…
 * 
 * @param {string} username ì‚¬ìš©ìëª…
 * @param {Object} options í˜ì´ì§€ë„¤ì´ì…˜ ì˜µì…˜
 * @returns {Object} ì¿¼ë¦¬ ê²°ê³¼
 */
export const useUserActivities = (username, options = {}) => {
  const { page = 1, limit = 10 } = options;

  return useQuery({
    queryKey: ["userActivities", username, page, limit],
    queryFn: async () => {
      try {
        const params = {
          page,
          limit,
        };

        const { data } = await axios.get(`/activities/users/${username}`, { params });
        
        // ë‚ ì§œ í•„ë“œëŠ” ì´ë¯¸ axios ì¸í„°ì…‰í„°ì—ì„œ ì²˜ë¦¬ë¨
        return data;
      } catch (error) {
        console.error(`ì‚¬ìš©ì ${username}ì˜ í™œë™ ì´ë ¥ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:`, error);
        throw error;
      }
    },
    keepPreviousData: true,
    enabled: Boolean(username),
    staleTime: 30000,
    refetchOnWindowFocus: false,
    retry: 1,
  });
};


============================================================
File: /home/CVEHub/frontend/src/features/crawler/types/index.ts
------------------------------------------------------------
/**
 * í¬ë¡¤ëŸ¬ ê´€ë ¨ íƒ€ì… ì •ì˜ íŒŒì¼
 */
import { CVEBase } from 'features/cve/types/cve';

/** 
 * ë‹¨ì¼ í¬ë¡¤ëŸ¬ ì •ë³´ 
 */
export interface Crawler {
  id: string;
  name: string;
  type: string;
}

/** 
 * ì§„í–‰ ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ 
 */
export interface ProgressState {
  stage: string;
  percent: number;
  message: string;
}

/** 
 * ì—…ë°ì´íŠ¸ëœ CVEs êµ¬ì¡° 
 */
export interface UpdatedCVEs {
  count: number;
  items: CVEBase[];
}

/**
 * í¬ë¡¤ëŸ¬ ì—…ë°ì´íŠ¸ ì†Œì¼“ ì´ë²¤íŠ¸ ë°ì´í„°
 */
export interface CrawlerUpdateData {
  stage?: string;
  stage_label?: string;
  percent?: number;
  message?: string;
  isRunning?: boolean;
  hasError?: boolean;
  updatedCves?: string[];
}

/** 
 * í¬ë¡¤ëŸ¬ ìƒíƒœ APIì—ì„œ ê°€ì ¸ì˜¨ êµ¬ì¡°
 */
export interface CrawlerStatusResponse {
  isRunning: boolean;
  lastUpdate: unknown;
  currentStatus?: {
    stage: string;
    stage_label?: string;
    percent?: number;
    message?: string;
  };
  results?: Record<string, any>;
}

/** 
 * ë‹¨ê³„ ì •ì˜ 
 */
export interface StageInfo {
  key: string;
  label: string;
  description: string;
  icon: React.ReactNode;
  color: string;
  backendValues: string[];
}

/**
 * ì›¹ì†Œì¼“ ì—°ê²° ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸ ë°ì´í„°
 */
export interface ConnectionStateChangeData {
  state: string;
  timestamp?: string;
  message?: string;
}



============================================================
File: /home/CVEHub/frontend/src/features/crawler/services/crawlerService.js
------------------------------------------------------------
import api from 'shared/api/config/axios';

const CRAWLER = {
  RUN: (type) => `/crawler/run/${type}`,
  STATUS: '/crawler/status'
};

export const crawlerService = {
  // íŠ¹ì • í¬ë¡¤ëŸ¬ ì‹¤í–‰
  runCrawler: async (type) => {
    try {
      const response = await api.post(CRAWLER.RUN(type));
      return response.data;
    } catch (error) {
      console.error('Error running crawler:', error.response?.data || error);
      throw error;
    }
  },

  // í¬ë¡¤ëŸ¬ ìƒíƒœ ë° ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ ì¡°íšŒ
  getCrawlerStatus: async () => {
    try {
      const response = await api.get(CRAWLER.STATUS);
      return response.data;
    } catch (error) {
      console.error('Error getting crawler status:', error.response?.data || error);
      throw error;
    }
  },

  // DB ìƒíƒœ í™•ì¸ í•¨ìˆ˜ ì¶”ê°€
  getDBStatus: async () => {
    try {
      const response = await api.get('/crawler/db-status');
      return response.data;
    } catch (error) {
      console.error('Error checking DB status:', error.response?.data || error);
      throw error;
    }
  }
};

export default crawlerService; 


